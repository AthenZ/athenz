//
// Code generated by rdl 1.5.2 DO NOT EDIT.
//

package zms

import (
	"encoding/json"
	"fmt"
	rdl "github.com/ardielle/ardielle-go/rdl"
)

var _ = rdl.Version
var _ = json.Marshal
var _ = fmt.Printf

//
// SimpleName - Copyright 2016 Yahoo Inc. Licensed under the terms of the
// Apache version 2.0 license. See LICENSE file for terms. Common name types
// used by several API definitions A simple identifier, an element of compound
// name.
//
type SimpleName string

//
// CompoundName - A compound name. Most names in this API are compound names.
//
type CompoundName string

//
// DomainName - A domain name is the general qualifier prefix, as its
// uniqueness is managed.
//
type DomainName string

//
// EntityName - An entity name is a short form of a resource name, including
// only the domain and entity.
//
type EntityName string

//
// ServiceName - A service name will generally be a unique subdomain.
//
type ServiceName string

//
// LocationName - A location name is not yet defined, but will be a dotted name
// like everything else.
//
type LocationName string

//
// ActionName - An action (operation) name.
//
type ActionName string

//
// ResourceName - A resource name Note that the EntityName part is optional,
// that is, a domain name followed by a colon is valid resource name.
//
type ResourceName string

//
// ResourceNames - A comma separated list of resource names
//
type ResourceNames string

//
// YBase64 - The Y-specific URL-safe Base64 variant.
//
type YBase64 string

//
// YEncoded - YEncoded includes ybase64 chars, as well as = and %. This can
// represent a user cookie and URL-encoded values.
//
type YEncoded string

//
// AuthorityName - Used as the prefix in a signed assertion. This uniquely
// identifies a signing authority.
//
type AuthorityName string

//
// SignedToken - A signed assertion if identity. i.e. the user cookie value.
// This token will only make sense to the authority that generated it, so it is
// beneficial to have something in the value that is cheaply recognized to
// quickly reject if it belongs to another authority. In addition to the
// YEncoded set our token includes ; to separate components and , to separate
// roles and : for IPv6 addresses
//
type SignedToken string

//
// GroupName - A group name
//
type GroupName string

//
// GroupMemberName - A group member name
//
type GroupMemberName string

//
// MemberName - Role Member name - could be one of four values: *, DomainName.*
// or ServiceName[*], or GroupNames
//
type MemberName string

//
// AuthorityKeyword - A comma separated list of authority keywords
//
type AuthorityKeyword string

//
// AuthorityKeywords -
//
type AuthorityKeywords string

//
// TagValue - TagValue to contain generic string patterns
//
type TagValue string

//
// TagCompoundValue - A compound value of TagValue
//
type TagCompoundValue string

//
// TagValueList -
//
type TagValueList struct {

	//
	// list of tag values
	//
	List []TagCompoundValue `json:"list"`
}

//
// NewTagValueList - creates an initialized TagValueList instance, returns a pointer to it
//
func NewTagValueList(init ...*TagValueList) *TagValueList {
	var o *TagValueList
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(TagValueList)
	}
	return o.Init()
}

//
// Init - sets up the instance according to its default field values, if any
//
func (self *TagValueList) Init() *TagValueList {
	if self.List == nil {
		self.List = make([]TagCompoundValue, 0)
	}
	return self
}

type rawTagValueList TagValueList

//
// UnmarshalJSON is defined for proper JSON decoding of a TagValueList
//
func (self *TagValueList) UnmarshalJSON(b []byte) error {
	var m rawTagValueList
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := TagValueList(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (self *TagValueList) Validate() error {
	if self.List == nil {
		return fmt.Errorf("TagValueList: Missing required field: list")
	}
	return nil
}

//
// AssertionConditionKeyPattern -
//
type AssertionConditionKeyPattern string

//
// AssertionConditionKey -
//
type AssertionConditionKey string

//
// AssertionConditionValuePattern -
//
type AssertionConditionValuePattern string

//
// AssertionConditionValue -
//
type AssertionConditionValue string

//
// DomainMeta - Set of metadata attributes that all domains may have and can be
// changed.
//
type DomainMeta struct {

	//
	// a description of the domain
	//
	Description string `json:"description" rdl:"optional" yaml:",omitempty"`

	//
	// a reference to an audit organization defined in athenz
	//
	Org ResourceName `json:"org,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// Future use only, currently not used
	//
	Enabled *bool `json:"enabled,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// Flag indicates whether or not domain modifications should be logged for
	// SOX+Auditing. If true, the auditRef parameter must be supplied(not empty) for
	// any API defining it.
	//
	AuditEnabled *bool `json:"auditEnabled,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// associated aws account id (system attribute - uniqueness check)
	//
	Account string `json:"account" rdl:"optional" yaml:",omitempty"`

	//
	// associated product id (system attribute - uniqueness check)
	//
	YpmId *int32 `json:"ypmId,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// associated application id
	//
	ApplicationId string `json:"applicationId" rdl:"optional" yaml:",omitempty"`

	//
	// domain certificate dns domain (system attribute)
	//
	CertDnsDomain string `json:"certDnsDomain" rdl:"optional" yaml:",omitempty"`

	//
	// all user members in the domain will have specified max expiry days
	//
	MemberExpiryDays *int32 `json:"memberExpiryDays,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// tokens issued for this domain will have specified max timeout in mins
	//
	TokenExpiryMins *int32 `json:"tokenExpiryMins,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// service identity certs issued for this domain will have specified max
	// timeout in mins
	//
	ServiceCertExpiryMins *int32 `json:"serviceCertExpiryMins,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// role certs issued for this domain will have specified max timeout in mins
	//
	RoleCertExpiryMins *int32 `json:"roleCertExpiryMins,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// rsa or ec signing algorithm to be used for tokens
	//
	SignAlgorithm SimpleName `json:"signAlgorithm,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// all services in the domain roles will have specified max expiry days
	//
	ServiceExpiryDays *int32 `json:"serviceExpiryDays,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// all groups in the domain roles will have specified max expiry days
	//
	GroupExpiryDays *int32 `json:"groupExpiryDays,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// membership filtered based on user authority configured attributes
	//
	UserAuthorityFilter string `json:"userAuthorityFilter" rdl:"optional" yaml:",omitempty"`

	//
	// associated azure subscription id (system attribute - uniqueness check)
	//
	AzureSubscription string `json:"azureSubscription" rdl:"optional" yaml:",omitempty"`

	//
	// key-value pair tags, tag might contain multiple values
	//
	Tags map[CompoundName]*TagValueList `json:"tags,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// associated business service with domain
	//
	BusinessService string `json:"businessService" rdl:"optional" yaml:",omitempty"`
}

//
// NewDomainMeta - creates an initialized DomainMeta instance, returns a pointer to it
//
func NewDomainMeta(init ...*DomainMeta) *DomainMeta {
	var o *DomainMeta
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(DomainMeta)
	}
	return o.Init()
}

//
// Init - sets up the instance according to its default field values, if any
//
func (self *DomainMeta) Init() *DomainMeta {
	if self.Enabled == nil {
		d := true
		self.Enabled = &d
	}
	if self.AuditEnabled == nil {
		d := false
		self.AuditEnabled = &d
	}
	return self
}

type rawDomainMeta DomainMeta

//
// UnmarshalJSON is defined for proper JSON decoding of a DomainMeta
//
func (self *DomainMeta) UnmarshalJSON(b []byte) error {
	var m rawDomainMeta
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := DomainMeta(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (self *DomainMeta) Validate() error {
	if self.Description != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.Description)
		if !val.Valid {
			return fmt.Errorf("DomainMeta.description does not contain a valid String (%v)", val.Error)
		}
	}
	if self.Org != "" {
		val := rdl.Validate(ZMSSchema(), "ResourceName", self.Org)
		if !val.Valid {
			return fmt.Errorf("DomainMeta.org does not contain a valid ResourceName (%v)", val.Error)
		}
	}
	if self.Account != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.Account)
		if !val.Valid {
			return fmt.Errorf("DomainMeta.account does not contain a valid String (%v)", val.Error)
		}
	}
	if self.ApplicationId != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.ApplicationId)
		if !val.Valid {
			return fmt.Errorf("DomainMeta.applicationId does not contain a valid String (%v)", val.Error)
		}
	}
	if self.CertDnsDomain != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.CertDnsDomain)
		if !val.Valid {
			return fmt.Errorf("DomainMeta.certDnsDomain does not contain a valid String (%v)", val.Error)
		}
	}
	if self.SignAlgorithm != "" {
		val := rdl.Validate(ZMSSchema(), "SimpleName", self.SignAlgorithm)
		if !val.Valid {
			return fmt.Errorf("DomainMeta.signAlgorithm does not contain a valid SimpleName (%v)", val.Error)
		}
	}
	if self.UserAuthorityFilter != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.UserAuthorityFilter)
		if !val.Valid {
			return fmt.Errorf("DomainMeta.userAuthorityFilter does not contain a valid String (%v)", val.Error)
		}
	}
	if self.AzureSubscription != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.AzureSubscription)
		if !val.Valid {
			return fmt.Errorf("DomainMeta.azureSubscription does not contain a valid String (%v)", val.Error)
		}
	}
	if self.BusinessService != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.BusinessService)
		if !val.Valid {
			return fmt.Errorf("DomainMeta.businessService does not contain a valid String (%v)", val.Error)
		}
	}
	return nil
}

//
// Domain - A domain is an independent partition of users, roles, and
// resources. Its name represents the definition of a namespace; the only way a
// new namespace can be created, from the top, is by creating Domains.
// Administration of a domain is governed by the parent domain (using
// reverse-DNS namespaces). The top level domains are governed by the special
// "sys.auth" domain.
//
type Domain struct {

	//
	// a description of the domain
	//
	Description string `json:"description" rdl:"optional" yaml:",omitempty"`

	//
	// a reference to an audit organization defined in athenz
	//
	Org ResourceName `json:"org,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// Future use only, currently not used
	//
	Enabled *bool `json:"enabled,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// Flag indicates whether or not domain modifications should be logged for
	// SOX+Auditing. If true, the auditRef parameter must be supplied(not empty) for
	// any API defining it.
	//
	AuditEnabled *bool `json:"auditEnabled,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// associated aws account id (system attribute - uniqueness check)
	//
	Account string `json:"account" rdl:"optional" yaml:",omitempty"`

	//
	// associated product id (system attribute - uniqueness check)
	//
	YpmId *int32 `json:"ypmId,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// associated application id
	//
	ApplicationId string `json:"applicationId" rdl:"optional" yaml:",omitempty"`

	//
	// domain certificate dns domain (system attribute)
	//
	CertDnsDomain string `json:"certDnsDomain" rdl:"optional" yaml:",omitempty"`

	//
	// all user members in the domain will have specified max expiry days
	//
	MemberExpiryDays *int32 `json:"memberExpiryDays,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// tokens issued for this domain will have specified max timeout in mins
	//
	TokenExpiryMins *int32 `json:"tokenExpiryMins,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// service identity certs issued for this domain will have specified max
	// timeout in mins
	//
	ServiceCertExpiryMins *int32 `json:"serviceCertExpiryMins,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// role certs issued for this domain will have specified max timeout in mins
	//
	RoleCertExpiryMins *int32 `json:"roleCertExpiryMins,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// rsa or ec signing algorithm to be used for tokens
	//
	SignAlgorithm SimpleName `json:"signAlgorithm,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// all services in the domain roles will have specified max expiry days
	//
	ServiceExpiryDays *int32 `json:"serviceExpiryDays,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// all groups in the domain roles will have specified max expiry days
	//
	GroupExpiryDays *int32 `json:"groupExpiryDays,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// membership filtered based on user authority configured attributes
	//
	UserAuthorityFilter string `json:"userAuthorityFilter" rdl:"optional" yaml:",omitempty"`

	//
	// associated azure subscription id (system attribute - uniqueness check)
	//
	AzureSubscription string `json:"azureSubscription" rdl:"optional" yaml:",omitempty"`

	//
	// key-value pair tags, tag might contain multiple values
	//
	Tags map[CompoundName]*TagValueList `json:"tags,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// associated business service with domain
	//
	BusinessService string `json:"businessService" rdl:"optional" yaml:",omitempty"`

	//
	// the common name to be referred to, the symbolic id. It is immutable
	//
	Name DomainName `json:"name"`

	//
	// the last modification timestamp of any object or attribute in this domain
	//
	Modified *rdl.Timestamp `json:"modified,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// unique identifier of the domain. generated on create, never reused
	//
	Id *rdl.UUID `json:"id,omitempty" rdl:"optional" yaml:",omitempty"`
}

//
// NewDomain - creates an initialized Domain instance, returns a pointer to it
//
func NewDomain(init ...*Domain) *Domain {
	var o *Domain
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(Domain)
	}
	return o.Init()
}

//
// Init - sets up the instance according to its default field values, if any
//
func (self *Domain) Init() *Domain {
	if self.Enabled == nil {
		d := true
		self.Enabled = &d
	}
	if self.AuditEnabled == nil {
		d := false
		self.AuditEnabled = &d
	}
	return self
}

type rawDomain Domain

//
// UnmarshalJSON is defined for proper JSON decoding of a Domain
//
func (self *Domain) UnmarshalJSON(b []byte) error {
	var m rawDomain
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := Domain(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (self *Domain) Validate() error {
	if self.Description != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.Description)
		if !val.Valid {
			return fmt.Errorf("Domain.description does not contain a valid String (%v)", val.Error)
		}
	}
	if self.Org != "" {
		val := rdl.Validate(ZMSSchema(), "ResourceName", self.Org)
		if !val.Valid {
			return fmt.Errorf("Domain.org does not contain a valid ResourceName (%v)", val.Error)
		}
	}
	if self.Account != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.Account)
		if !val.Valid {
			return fmt.Errorf("Domain.account does not contain a valid String (%v)", val.Error)
		}
	}
	if self.ApplicationId != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.ApplicationId)
		if !val.Valid {
			return fmt.Errorf("Domain.applicationId does not contain a valid String (%v)", val.Error)
		}
	}
	if self.CertDnsDomain != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.CertDnsDomain)
		if !val.Valid {
			return fmt.Errorf("Domain.certDnsDomain does not contain a valid String (%v)", val.Error)
		}
	}
	if self.SignAlgorithm != "" {
		val := rdl.Validate(ZMSSchema(), "SimpleName", self.SignAlgorithm)
		if !val.Valid {
			return fmt.Errorf("Domain.signAlgorithm does not contain a valid SimpleName (%v)", val.Error)
		}
	}
	if self.UserAuthorityFilter != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.UserAuthorityFilter)
		if !val.Valid {
			return fmt.Errorf("Domain.userAuthorityFilter does not contain a valid String (%v)", val.Error)
		}
	}
	if self.AzureSubscription != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.AzureSubscription)
		if !val.Valid {
			return fmt.Errorf("Domain.azureSubscription does not contain a valid String (%v)", val.Error)
		}
	}
	if self.BusinessService != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.BusinessService)
		if !val.Valid {
			return fmt.Errorf("Domain.businessService does not contain a valid String (%v)", val.Error)
		}
	}
	if self.Name == "" {
		return fmt.Errorf("Domain.name is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "DomainName", self.Name)
		if !val.Valid {
			return fmt.Errorf("Domain.name does not contain a valid DomainName (%v)", val.Error)
		}
	}
	return nil
}

//
// DomainMetaList - A list of domain objects with their meta attributes.
//
type DomainMetaList struct {

	//
	// list of domain objects
	//
	Domains []*Domain `json:"domains"`
}

//
// NewDomainMetaList - creates an initialized DomainMetaList instance, returns a pointer to it
//
func NewDomainMetaList(init ...*DomainMetaList) *DomainMetaList {
	var o *DomainMetaList
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(DomainMetaList)
	}
	return o.Init()
}

//
// Init - sets up the instance according to its default field values, if any
//
func (self *DomainMetaList) Init() *DomainMetaList {
	if self.Domains == nil {
		self.Domains = make([]*Domain, 0)
	}
	return self
}

type rawDomainMetaList DomainMetaList

//
// UnmarshalJSON is defined for proper JSON decoding of a DomainMetaList
//
func (self *DomainMetaList) UnmarshalJSON(b []byte) error {
	var m rawDomainMetaList
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := DomainMetaList(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (self *DomainMetaList) Validate() error {
	if self.Domains == nil {
		return fmt.Errorf("DomainMetaList: Missing required field: domains")
	}
	return nil
}

//
// RoleList - The representation for an enumeration of roles in the namespace,
// with pagination.
//
type RoleList struct {

	//
	// list of role names
	//
	Names []EntityName `json:"names"`

	//
	// if the response is a paginated list, this attribute specifies the value to
	// be used in the next role list request as the value for the skip query
	// parameter.
	//
	Next string `json:"next" rdl:"optional" yaml:",omitempty"`
}

//
// NewRoleList - creates an initialized RoleList instance, returns a pointer to it
//
func NewRoleList(init ...*RoleList) *RoleList {
	var o *RoleList
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(RoleList)
	}
	return o.Init()
}

//
// Init - sets up the instance according to its default field values, if any
//
func (self *RoleList) Init() *RoleList {
	if self.Names == nil {
		self.Names = make([]EntityName, 0)
	}
	return self
}

type rawRoleList RoleList

//
// UnmarshalJSON is defined for proper JSON decoding of a RoleList
//
func (self *RoleList) UnmarshalJSON(b []byte) error {
	var m rawRoleList
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := RoleList(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (self *RoleList) Validate() error {
	if self.Names == nil {
		return fmt.Errorf("RoleList: Missing required field: names")
	}
	if self.Next != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.Next)
		if !val.Valid {
			return fmt.Errorf("RoleList.next does not contain a valid String (%v)", val.Error)
		}
	}
	return nil
}

//
// RoleAuditLog - An audit log entry for role membership change.
//
type RoleAuditLog struct {

	//
	// name of the role member
	//
	Member MemberName `json:"member"`

	//
	// name of the principal executing the change
	//
	Admin ResourceName `json:"admin"`

	//
	// timestamp of the entry
	//
	Created rdl.Timestamp `json:"created"`

	//
	// log action - e.g. add, delete, approve, etc
	//
	Action string `json:"action"`

	//
	// audit reference string for the change as supplied by admin
	//
	AuditRef string `json:"auditRef" rdl:"optional" yaml:",omitempty"`
}

//
// NewRoleAuditLog - creates an initialized RoleAuditLog instance, returns a pointer to it
//
func NewRoleAuditLog(init ...*RoleAuditLog) *RoleAuditLog {
	var o *RoleAuditLog
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(RoleAuditLog)
	}
	return o
}

type rawRoleAuditLog RoleAuditLog

//
// UnmarshalJSON is defined for proper JSON decoding of a RoleAuditLog
//
func (self *RoleAuditLog) UnmarshalJSON(b []byte) error {
	var m rawRoleAuditLog
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := RoleAuditLog(m)
		*self = o
		err = self.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (self *RoleAuditLog) Validate() error {
	if self.Member == "" {
		return fmt.Errorf("RoleAuditLog.member is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "MemberName", self.Member)
		if !val.Valid {
			return fmt.Errorf("RoleAuditLog.member does not contain a valid MemberName (%v)", val.Error)
		}
	}
	if self.Admin == "" {
		return fmt.Errorf("RoleAuditLog.admin is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "ResourceName", self.Admin)
		if !val.Valid {
			return fmt.Errorf("RoleAuditLog.admin does not contain a valid ResourceName (%v)", val.Error)
		}
	}
	if self.Created.IsZero() {
		return fmt.Errorf("RoleAuditLog: Missing required field: created")
	}
	if self.Action == "" {
		return fmt.Errorf("RoleAuditLog.action is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "String", self.Action)
		if !val.Valid {
			return fmt.Errorf("RoleAuditLog.action does not contain a valid String (%v)", val.Error)
		}
	}
	if self.AuditRef != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.AuditRef)
		if !val.Valid {
			return fmt.Errorf("RoleAuditLog.auditRef does not contain a valid String (%v)", val.Error)
		}
	}
	return nil
}

//
// RoleMember -
//
type RoleMember struct {

	//
	// name of the member
	//
	MemberName MemberName `json:"memberName"`

	//
	// the expiration timestamp
	//
	Expiration *rdl.Timestamp `json:"expiration,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// the review reminder timestamp
	//
	ReviewReminder *rdl.Timestamp `json:"reviewReminder,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// Flag to indicate whether membership is active
	//
	Active *bool `json:"active,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// Flag to indicate whether membership is approved either by delegates ( in
	// case of auditEnabled roles ) or by domain admins ( in case of selfserve roles
	// )
	//
	Approved *bool `json:"approved,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// audit reference string for the change as supplied by admin
	//
	AuditRef string `json:"auditRef" rdl:"optional" yaml:",omitempty"`

	//
	// for pending membership requests, the request time
	//
	RequestTime *rdl.Timestamp `json:"requestTime,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// for pending membership requests, time when last notification was sent
	//
	LastNotifiedTime *rdl.Timestamp `json:"lastNotifiedTime,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// pending members only - name of the principal requesting the change
	//
	RequestPrincipal ResourceName `json:"requestPrincipal,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// for pending membership requests, time when last notification was sent (for
	// file store)
	//
	ReviewLastNotifiedTime *rdl.Timestamp `json:"reviewLastNotifiedTime,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// user disabled by system based on configured role setting
	//
	SystemDisabled *int32 `json:"systemDisabled,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// server use only - principal type: unknown(0), user(1), service(2), or
	// group(3)
	//
	PrincipalType *int32 `json:"principalType,omitempty" rdl:"optional" yaml:",omitempty"`
}

//
// NewRoleMember - creates an initialized RoleMember instance, returns a pointer to it
//
func NewRoleMember(init ...*RoleMember) *RoleMember {
	var o *RoleMember
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(RoleMember)
	}
	return o.Init()
}

//
// Init - sets up the instance according to its default field values, if any
//
func (self *RoleMember) Init() *RoleMember {
	if self.Active == nil {
		d := true
		self.Active = &d
	}
	if self.Approved == nil {
		d := true
		self.Approved = &d
	}
	return self
}

type rawRoleMember RoleMember

//
// UnmarshalJSON is defined for proper JSON decoding of a RoleMember
//
func (self *RoleMember) UnmarshalJSON(b []byte) error {
	var m rawRoleMember
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := RoleMember(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (self *RoleMember) Validate() error {
	if self.MemberName == "" {
		return fmt.Errorf("RoleMember.memberName is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "MemberName", self.MemberName)
		if !val.Valid {
			return fmt.Errorf("RoleMember.memberName does not contain a valid MemberName (%v)", val.Error)
		}
	}
	if self.AuditRef != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.AuditRef)
		if !val.Valid {
			return fmt.Errorf("RoleMember.auditRef does not contain a valid String (%v)", val.Error)
		}
	}
	if self.RequestPrincipal != "" {
		val := rdl.Validate(ZMSSchema(), "ResourceName", self.RequestPrincipal)
		if !val.Valid {
			return fmt.Errorf("RoleMember.requestPrincipal does not contain a valid ResourceName (%v)", val.Error)
		}
	}
	return nil
}

//
// RoleMeta - Set of metadata attributes that all roles may have and can be
// changed by domain admins.
//
type RoleMeta struct {

	//
	// Flag indicates whether or not role allows self service. Users can add
	// themselves in the role, but it has to be approved by domain admins to be
	// effective.
	//
	SelfServe *bool `json:"selfServe,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// all user members in the role will have specified max expiry days
	//
	MemberExpiryDays *int32 `json:"memberExpiryDays,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// tokens issued for this role will have specified max timeout in mins
	//
	TokenExpiryMins *int32 `json:"tokenExpiryMins,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// certs issued for this role will have specified max timeout in mins
	//
	CertExpiryMins *int32 `json:"certExpiryMins,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// rsa or ec signing algorithm to be used for tokens
	//
	SignAlgorithm SimpleName `json:"signAlgorithm,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// all services in the role will have specified max expiry days
	//
	ServiceExpiryDays *int32 `json:"serviceExpiryDays,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// all user members in the role will have specified max review days
	//
	MemberReviewDays *int32 `json:"memberReviewDays,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// all services in the role will have specified max review days
	//
	ServiceReviewDays *int32 `json:"serviceReviewDays,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// Flag indicates whether or not role updates require another review and
	// approval
	//
	ReviewEnabled *bool `json:"reviewEnabled,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// list of roles whose members should be notified for member review/approval
	//
	NotifyRoles string `json:"notifyRoles" rdl:"optional" yaml:",omitempty"`

	//
	// membership filtered based on user authority configured attributes
	//
	UserAuthorityFilter string `json:"userAuthorityFilter" rdl:"optional" yaml:",omitempty"`

	//
	// expiration enforced by a user authority configured attribute
	//
	UserAuthorityExpiration string `json:"userAuthorityExpiration" rdl:"optional" yaml:",omitempty"`

	//
	// all groups in the domain roles will have specified max expiry days
	//
	GroupExpiryDays *int32 `json:"groupExpiryDays,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// all groups in the domain roles will have specified max review days
	//
	GroupReviewDays *int32 `json:"groupReviewDays,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// key-value pair tags, tag might contain multiple values
	//
	Tags map[CompoundName]*TagValueList `json:"tags,omitempty" rdl:"optional" yaml:",omitempty"`
}

//
// NewRoleMeta - creates an initialized RoleMeta instance, returns a pointer to it
//
func NewRoleMeta(init ...*RoleMeta) *RoleMeta {
	var o *RoleMeta
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(RoleMeta)
	}
	return o
}

type rawRoleMeta RoleMeta

//
// UnmarshalJSON is defined for proper JSON decoding of a RoleMeta
//
func (self *RoleMeta) UnmarshalJSON(b []byte) error {
	var m rawRoleMeta
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := RoleMeta(m)
		*self = o
		err = self.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (self *RoleMeta) Validate() error {
	if self.SignAlgorithm != "" {
		val := rdl.Validate(ZMSSchema(), "SimpleName", self.SignAlgorithm)
		if !val.Valid {
			return fmt.Errorf("RoleMeta.signAlgorithm does not contain a valid SimpleName (%v)", val.Error)
		}
	}
	if self.NotifyRoles != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.NotifyRoles)
		if !val.Valid {
			return fmt.Errorf("RoleMeta.notifyRoles does not contain a valid String (%v)", val.Error)
		}
	}
	if self.UserAuthorityFilter != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.UserAuthorityFilter)
		if !val.Valid {
			return fmt.Errorf("RoleMeta.userAuthorityFilter does not contain a valid String (%v)", val.Error)
		}
	}
	if self.UserAuthorityExpiration != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.UserAuthorityExpiration)
		if !val.Valid {
			return fmt.Errorf("RoleMeta.userAuthorityExpiration does not contain a valid String (%v)", val.Error)
		}
	}
	return nil
}

//
// Role - The representation for a Role with set of members.
//
type Role struct {

	//
	// Flag indicates whether or not role allows self service. Users can add
	// themselves in the role, but it has to be approved by domain admins to be
	// effective.
	//
	SelfServe *bool `json:"selfServe,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// all user members in the role will have specified max expiry days
	//
	MemberExpiryDays *int32 `json:"memberExpiryDays,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// tokens issued for this role will have specified max timeout in mins
	//
	TokenExpiryMins *int32 `json:"tokenExpiryMins,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// certs issued for this role will have specified max timeout in mins
	//
	CertExpiryMins *int32 `json:"certExpiryMins,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// rsa or ec signing algorithm to be used for tokens
	//
	SignAlgorithm SimpleName `json:"signAlgorithm,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// all services in the role will have specified max expiry days
	//
	ServiceExpiryDays *int32 `json:"serviceExpiryDays,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// all user members in the role will have specified max review days
	//
	MemberReviewDays *int32 `json:"memberReviewDays,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// all services in the role will have specified max review days
	//
	ServiceReviewDays *int32 `json:"serviceReviewDays,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// Flag indicates whether or not role updates require another review and
	// approval
	//
	ReviewEnabled *bool `json:"reviewEnabled,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// list of roles whose members should be notified for member review/approval
	//
	NotifyRoles string `json:"notifyRoles" rdl:"optional" yaml:",omitempty"`

	//
	// membership filtered based on user authority configured attributes
	//
	UserAuthorityFilter string `json:"userAuthorityFilter" rdl:"optional" yaml:",omitempty"`

	//
	// expiration enforced by a user authority configured attribute
	//
	UserAuthorityExpiration string `json:"userAuthorityExpiration" rdl:"optional" yaml:",omitempty"`

	//
	// all groups in the domain roles will have specified max expiry days
	//
	GroupExpiryDays *int32 `json:"groupExpiryDays,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// all groups in the domain roles will have specified max review days
	//
	GroupReviewDays *int32 `json:"groupReviewDays,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// key-value pair tags, tag might contain multiple values
	//
	Tags map[CompoundName]*TagValueList `json:"tags,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// name of the role
	//
	Name ResourceName `json:"name"`

	//
	// last modification timestamp of the role
	//
	Modified *rdl.Timestamp `json:"modified,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// an explicit list of members. Might be empty or null, if trust is set
	//
	Members []MemberName `json:"members,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// members with expiration
	//
	RoleMembers []*RoleMember `json:"roleMembers,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// a trusted domain to delegate membership decisions to
	//
	Trust DomainName `json:"trust,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// an audit log for role membership changes
	//
	AuditLog []*RoleAuditLog `json:"auditLog,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// Flag indicates whether or not role updates should require GRC approval. If
	// true, the auditRef parameter must be supplied(not empty) for any API defining
	// it
	//
	AuditEnabled *bool `json:"auditEnabled,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// last review timestamp of the role
	//
	LastReviewedDate *rdl.Timestamp `json:"lastReviewedDate,omitempty" rdl:"optional" yaml:",omitempty"`
}

//
// NewRole - creates an initialized Role instance, returns a pointer to it
//
func NewRole(init ...*Role) *Role {
	var o *Role
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(Role)
	}
	return o
}

type rawRole Role

//
// UnmarshalJSON is defined for proper JSON decoding of a Role
//
func (self *Role) UnmarshalJSON(b []byte) error {
	var m rawRole
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := Role(m)
		*self = o
		err = self.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (self *Role) Validate() error {
	if self.SignAlgorithm != "" {
		val := rdl.Validate(ZMSSchema(), "SimpleName", self.SignAlgorithm)
		if !val.Valid {
			return fmt.Errorf("Role.signAlgorithm does not contain a valid SimpleName (%v)", val.Error)
		}
	}
	if self.NotifyRoles != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.NotifyRoles)
		if !val.Valid {
			return fmt.Errorf("Role.notifyRoles does not contain a valid String (%v)", val.Error)
		}
	}
	if self.UserAuthorityFilter != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.UserAuthorityFilter)
		if !val.Valid {
			return fmt.Errorf("Role.userAuthorityFilter does not contain a valid String (%v)", val.Error)
		}
	}
	if self.UserAuthorityExpiration != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.UserAuthorityExpiration)
		if !val.Valid {
			return fmt.Errorf("Role.userAuthorityExpiration does not contain a valid String (%v)", val.Error)
		}
	}
	if self.Name == "" {
		return fmt.Errorf("Role.name is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "ResourceName", self.Name)
		if !val.Valid {
			return fmt.Errorf("Role.name does not contain a valid ResourceName (%v)", val.Error)
		}
	}
	if self.Trust != "" {
		val := rdl.Validate(ZMSSchema(), "DomainName", self.Trust)
		if !val.Valid {
			return fmt.Errorf("Role.trust does not contain a valid DomainName (%v)", val.Error)
		}
	}
	return nil
}

//
// Roles - The representation for a list of roles with full details
//
type Roles struct {

	//
	// list of role objects
	//
	List []*Role `json:"list"`
}

//
// NewRoles - creates an initialized Roles instance, returns a pointer to it
//
func NewRoles(init ...*Roles) *Roles {
	var o *Roles
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(Roles)
	}
	return o.Init()
}

//
// Init - sets up the instance according to its default field values, if any
//
func (self *Roles) Init() *Roles {
	if self.List == nil {
		self.List = make([]*Role, 0)
	}
	return self
}

type rawRoles Roles

//
// UnmarshalJSON is defined for proper JSON decoding of a Roles
//
func (self *Roles) UnmarshalJSON(b []byte) error {
	var m rawRoles
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := Roles(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (self *Roles) Validate() error {
	if self.List == nil {
		return fmt.Errorf("Roles: Missing required field: list")
	}
	return nil
}

//
// Membership - The representation for a role membership.
//
type Membership struct {

	//
	// name of the member
	//
	MemberName MemberName `json:"memberName"`

	//
	// flag to indicate whether or the user is a member or not
	//
	IsMember *bool `json:"isMember,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// name of the role
	//
	RoleName ResourceName `json:"roleName,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// the expiration timestamp
	//
	Expiration *rdl.Timestamp `json:"expiration,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// the review reminder timestamp
	//
	ReviewReminder *rdl.Timestamp `json:"reviewReminder,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// Flag to indicate whether membership is active
	//
	Active *bool `json:"active,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// Flag to indicate whether membership is approved either by delegates ( in
	// case of auditEnabled roles ) or by domain admins ( in case of selfserve roles
	// )
	//
	Approved *bool `json:"approved,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// audit reference string for the change as supplied by admin
	//
	AuditRef string `json:"auditRef" rdl:"optional" yaml:",omitempty"`

	//
	// pending members only - name of the principal requesting the change
	//
	RequestPrincipal ResourceName `json:"requestPrincipal,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// user disabled by system based on configured role setting
	//
	SystemDisabled *int32 `json:"systemDisabled,omitempty" rdl:"optional" yaml:",omitempty"`
}

//
// NewMembership - creates an initialized Membership instance, returns a pointer to it
//
func NewMembership(init ...*Membership) *Membership {
	var o *Membership
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(Membership)
	}
	return o.Init()
}

//
// Init - sets up the instance according to its default field values, if any
//
func (self *Membership) Init() *Membership {
	if self.IsMember == nil {
		d := true
		self.IsMember = &d
	}
	if self.Active == nil {
		d := true
		self.Active = &d
	}
	if self.Approved == nil {
		d := true
		self.Approved = &d
	}
	return self
}

type rawMembership Membership

//
// UnmarshalJSON is defined for proper JSON decoding of a Membership
//
func (self *Membership) UnmarshalJSON(b []byte) error {
	var m rawMembership
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := Membership(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (self *Membership) Validate() error {
	if self.MemberName == "" {
		return fmt.Errorf("Membership.memberName is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "MemberName", self.MemberName)
		if !val.Valid {
			return fmt.Errorf("Membership.memberName does not contain a valid MemberName (%v)", val.Error)
		}
	}
	if self.RoleName != "" {
		val := rdl.Validate(ZMSSchema(), "ResourceName", self.RoleName)
		if !val.Valid {
			return fmt.Errorf("Membership.roleName does not contain a valid ResourceName (%v)", val.Error)
		}
	}
	if self.AuditRef != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.AuditRef)
		if !val.Valid {
			return fmt.Errorf("Membership.auditRef does not contain a valid String (%v)", val.Error)
		}
	}
	if self.RequestPrincipal != "" {
		val := rdl.Validate(ZMSSchema(), "ResourceName", self.RequestPrincipal)
		if !val.Valid {
			return fmt.Errorf("Membership.requestPrincipal does not contain a valid ResourceName (%v)", val.Error)
		}
	}
	return nil
}

//
// DefaultAdmins - The list of domain administrators.
//
type DefaultAdmins struct {

	//
	// list of domain administrators
	//
	Admins []ResourceName `json:"admins"`
}

//
// NewDefaultAdmins - creates an initialized DefaultAdmins instance, returns a pointer to it
//
func NewDefaultAdmins(init ...*DefaultAdmins) *DefaultAdmins {
	var o *DefaultAdmins
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(DefaultAdmins)
	}
	return o.Init()
}

//
// Init - sets up the instance according to its default field values, if any
//
func (self *DefaultAdmins) Init() *DefaultAdmins {
	if self.Admins == nil {
		self.Admins = make([]ResourceName, 0)
	}
	return self
}

type rawDefaultAdmins DefaultAdmins

//
// UnmarshalJSON is defined for proper JSON decoding of a DefaultAdmins
//
func (self *DefaultAdmins) UnmarshalJSON(b []byte) error {
	var m rawDefaultAdmins
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := DefaultAdmins(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (self *DefaultAdmins) Validate() error {
	if self.Admins == nil {
		return fmt.Errorf("DefaultAdmins: Missing required field: admins")
	}
	return nil
}

//
// MemberRole -
//
type MemberRole struct {

	//
	// name of the role
	//
	RoleName ResourceName `json:"roleName"`

	//
	// name of the domain
	//
	DomainName DomainName `json:"domainName,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// name of the member
	//
	MemberName MemberName `json:"memberName,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// the expiration timestamp
	//
	Expiration *rdl.Timestamp `json:"expiration,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// the review reminder timestamp
	//
	ReviewReminder *rdl.Timestamp `json:"reviewReminder,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// Flag to indicate whether membership is active
	//
	Active *bool `json:"active,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// audit reference string for the change as supplied by admin
	//
	AuditRef string `json:"auditRef" rdl:"optional" yaml:",omitempty"`

	//
	// pending members only - name of the principal requesting the change
	//
	RequestPrincipal EntityName `json:"requestPrincipal,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// for pending membership requests, the request time
	//
	RequestTime *rdl.Timestamp `json:"requestTime,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// user disabled by system based on configured role setting
	//
	SystemDisabled *int32 `json:"systemDisabled,omitempty" rdl:"optional" yaml:",omitempty"`
}

//
// NewMemberRole - creates an initialized MemberRole instance, returns a pointer to it
//
func NewMemberRole(init ...*MemberRole) *MemberRole {
	var o *MemberRole
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(MemberRole)
	}
	return o.Init()
}

//
// Init - sets up the instance according to its default field values, if any
//
func (self *MemberRole) Init() *MemberRole {
	if self.Active == nil {
		d := true
		self.Active = &d
	}
	return self
}

type rawMemberRole MemberRole

//
// UnmarshalJSON is defined for proper JSON decoding of a MemberRole
//
func (self *MemberRole) UnmarshalJSON(b []byte) error {
	var m rawMemberRole
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := MemberRole(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (self *MemberRole) Validate() error {
	if self.RoleName == "" {
		return fmt.Errorf("MemberRole.roleName is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "ResourceName", self.RoleName)
		if !val.Valid {
			return fmt.Errorf("MemberRole.roleName does not contain a valid ResourceName (%v)", val.Error)
		}
	}
	if self.DomainName != "" {
		val := rdl.Validate(ZMSSchema(), "DomainName", self.DomainName)
		if !val.Valid {
			return fmt.Errorf("MemberRole.domainName does not contain a valid DomainName (%v)", val.Error)
		}
	}
	if self.MemberName != "" {
		val := rdl.Validate(ZMSSchema(), "MemberName", self.MemberName)
		if !val.Valid {
			return fmt.Errorf("MemberRole.memberName does not contain a valid MemberName (%v)", val.Error)
		}
	}
	if self.AuditRef != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.AuditRef)
		if !val.Valid {
			return fmt.Errorf("MemberRole.auditRef does not contain a valid String (%v)", val.Error)
		}
	}
	if self.RequestPrincipal != "" {
		val := rdl.Validate(ZMSSchema(), "EntityName", self.RequestPrincipal)
		if !val.Valid {
			return fmt.Errorf("MemberRole.requestPrincipal does not contain a valid EntityName (%v)", val.Error)
		}
	}
	return nil
}

//
// DomainRoleMember -
//
type DomainRoleMember struct {

	//
	// name of the member
	//
	MemberName MemberName `json:"memberName"`

	//
	// roles for this member
	//
	MemberRoles []*MemberRole `json:"memberRoles"`
}

//
// NewDomainRoleMember - creates an initialized DomainRoleMember instance, returns a pointer to it
//
func NewDomainRoleMember(init ...*DomainRoleMember) *DomainRoleMember {
	var o *DomainRoleMember
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(DomainRoleMember)
	}
	return o.Init()
}

//
// Init - sets up the instance according to its default field values, if any
//
func (self *DomainRoleMember) Init() *DomainRoleMember {
	if self.MemberRoles == nil {
		self.MemberRoles = make([]*MemberRole, 0)
	}
	return self
}

type rawDomainRoleMember DomainRoleMember

//
// UnmarshalJSON is defined for proper JSON decoding of a DomainRoleMember
//
func (self *DomainRoleMember) UnmarshalJSON(b []byte) error {
	var m rawDomainRoleMember
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := DomainRoleMember(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (self *DomainRoleMember) Validate() error {
	if self.MemberName == "" {
		return fmt.Errorf("DomainRoleMember.memberName is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "MemberName", self.MemberName)
		if !val.Valid {
			return fmt.Errorf("DomainRoleMember.memberName does not contain a valid MemberName (%v)", val.Error)
		}
	}
	if self.MemberRoles == nil {
		return fmt.Errorf("DomainRoleMember: Missing required field: memberRoles")
	}
	return nil
}

//
// DomainRoleMembers -
//
type DomainRoleMembers struct {

	//
	// name of the domain
	//
	DomainName DomainName `json:"domainName"`

	//
	// role members
	//
	Members []*DomainRoleMember `json:"members"`
}

//
// NewDomainRoleMembers - creates an initialized DomainRoleMembers instance, returns a pointer to it
//
func NewDomainRoleMembers(init ...*DomainRoleMembers) *DomainRoleMembers {
	var o *DomainRoleMembers
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(DomainRoleMembers)
	}
	return o.Init()
}

//
// Init - sets up the instance according to its default field values, if any
//
func (self *DomainRoleMembers) Init() *DomainRoleMembers {
	if self.Members == nil {
		self.Members = make([]*DomainRoleMember, 0)
	}
	return self
}

type rawDomainRoleMembers DomainRoleMembers

//
// UnmarshalJSON is defined for proper JSON decoding of a DomainRoleMembers
//
func (self *DomainRoleMembers) UnmarshalJSON(b []byte) error {
	var m rawDomainRoleMembers
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := DomainRoleMembers(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (self *DomainRoleMembers) Validate() error {
	if self.DomainName == "" {
		return fmt.Errorf("DomainRoleMembers.domainName is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "DomainName", self.DomainName)
		if !val.Valid {
			return fmt.Errorf("DomainRoleMembers.domainName does not contain a valid DomainName (%v)", val.Error)
		}
	}
	if self.Members == nil {
		return fmt.Errorf("DomainRoleMembers: Missing required field: members")
	}
	return nil
}

//
// RoleSystemMeta - Set of system metadata attributes that all roles may have
// and can be changed by system admins.
//
type RoleSystemMeta struct {

	//
	// Flag indicates whether or not role updates should be approved by GRC. If
	// true, the auditRef parameter must be supplied(not empty) for any API defining
	// it.
	//
	AuditEnabled *bool `json:"auditEnabled,omitempty" rdl:"optional" yaml:",omitempty"`
}

//
// NewRoleSystemMeta - creates an initialized RoleSystemMeta instance, returns a pointer to it
//
func NewRoleSystemMeta(init ...*RoleSystemMeta) *RoleSystemMeta {
	var o *RoleSystemMeta
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(RoleSystemMeta)
	}
	return o
}

type rawRoleSystemMeta RoleSystemMeta

//
// UnmarshalJSON is defined for proper JSON decoding of a RoleSystemMeta
//
func (self *RoleSystemMeta) UnmarshalJSON(b []byte) error {
	var m rawRoleSystemMeta
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := RoleSystemMeta(m)
		*self = o
		err = self.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (self *RoleSystemMeta) Validate() error {
	return nil
}

//
// AssertionEffect - Every assertion can have the effect of ALLOW or DENY.
//
type AssertionEffect int

//
// AssertionEffect constants
//
const (
	_ AssertionEffect = iota
	ALLOW
	DENY
)

var namesAssertionEffect = []string{
	ALLOW: "ALLOW",
	DENY:  "DENY",
}

//
// NewAssertionEffect - return a string representation of the enum
//
func NewAssertionEffect(init ...interface{}) AssertionEffect {
	if len(init) == 1 {
		switch v := init[0].(type) {
		case AssertionEffect:
			return v
		case int:
			return AssertionEffect(v)
		case int32:
			return AssertionEffect(v)
		case string:
			for i, s := range namesAssertionEffect {
				if s == v {
					return AssertionEffect(i)
				}
			}
		default:
			panic("Bad init value for AssertionEffect enum")
		}
	}
	return AssertionEffect(0) //default to the first enum value
}

//
// String - return a string representation of the enum
//
func (e AssertionEffect) String() string {
	return namesAssertionEffect[e]
}

//
// SymbolSet - return an array of all valid string representations (symbols) of the enum
//
func (e AssertionEffect) SymbolSet() []string {
	return namesAssertionEffect
}

//
// MarshalJSON is defined for proper JSON encoding of a AssertionEffect
//
func (e AssertionEffect) MarshalJSON() ([]byte, error) {
	return json.Marshal(e.String())
}

//
// UnmarshalJSON is defined for proper JSON decoding of a AssertionEffect
//
func (e *AssertionEffect) UnmarshalJSON(b []byte) error {
	var j string
	err := json.Unmarshal(b, &j)
	if err == nil {
		s := string(j)
		for v, s2 := range namesAssertionEffect {
			if s == s2 {
				*e = AssertionEffect(v)
				return nil
			}
		}
		err = fmt.Errorf("Bad enum symbol for type AssertionEffect: %s", s)
	}
	return err
}

//
// AssertionConditionOperator - Allowed operators for assertion conditions
//
type AssertionConditionOperator int

//
// AssertionConditionOperator constants
//
const (
	_ AssertionConditionOperator = iota
	EQUALS
)

var namesAssertionConditionOperator = []string{
	EQUALS: "EQUALS",
}

//
// NewAssertionConditionOperator - return a string representation of the enum
//
func NewAssertionConditionOperator(init ...interface{}) AssertionConditionOperator {
	if len(init) == 1 {
		switch v := init[0].(type) {
		case AssertionConditionOperator:
			return v
		case int:
			return AssertionConditionOperator(v)
		case int32:
			return AssertionConditionOperator(v)
		case string:
			for i, s := range namesAssertionConditionOperator {
				if s == v {
					return AssertionConditionOperator(i)
				}
			}
		default:
			panic("Bad init value for AssertionConditionOperator enum")
		}
	}
	return AssertionConditionOperator(0) //default to the first enum value
}

//
// String - return a string representation of the enum
//
func (e AssertionConditionOperator) String() string {
	return namesAssertionConditionOperator[e]
}

//
// SymbolSet - return an array of all valid string representations (symbols) of the enum
//
func (e AssertionConditionOperator) SymbolSet() []string {
	return namesAssertionConditionOperator
}

//
// MarshalJSON is defined for proper JSON encoding of a AssertionConditionOperator
//
func (e AssertionConditionOperator) MarshalJSON() ([]byte, error) {
	return json.Marshal(e.String())
}

//
// UnmarshalJSON is defined for proper JSON decoding of a AssertionConditionOperator
//
func (e *AssertionConditionOperator) UnmarshalJSON(b []byte) error {
	var j string
	err := json.Unmarshal(b, &j)
	if err == nil {
		s := string(j)
		for v, s2 := range namesAssertionConditionOperator {
			if s == s2 {
				*e = AssertionConditionOperator(v)
				return nil
			}
		}
		err = fmt.Errorf("Bad enum symbol for type AssertionConditionOperator: %s", s)
	}
	return err
}

//
// AssertionConditionData - A representation of details associated with an
// assertion condition key
//
type AssertionConditionData struct {

	//
	// Operator for the assertion condition
	//
	Operator AssertionConditionOperator `json:"operator"`

	//
	// Value of the assertion condition
	//
	Value AssertionConditionValue `json:"value"`
}

//
// NewAssertionConditionData - creates an initialized AssertionConditionData instance, returns a pointer to it
//
func NewAssertionConditionData(init ...*AssertionConditionData) *AssertionConditionData {
	var o *AssertionConditionData
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(AssertionConditionData)
	}
	return o
}

type rawAssertionConditionData AssertionConditionData

//
// UnmarshalJSON is defined for proper JSON decoding of a AssertionConditionData
//
func (self *AssertionConditionData) UnmarshalJSON(b []byte) error {
	var m rawAssertionConditionData
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := AssertionConditionData(m)
		*self = o
		err = self.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (self *AssertionConditionData) Validate() error {
	if self.Value == "" {
		return fmt.Errorf("AssertionConditionData.value is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "AssertionConditionValue", self.Value)
		if !val.Valid {
			return fmt.Errorf("AssertionConditionData.value does not contain a valid AssertionConditionValue (%v)", val.Error)
		}
	}
	return nil
}

//
// AssertionCondition - A representation of condition associated with an
// assertion
//
type AssertionCondition struct {

	//
	// condition id - auto generated by server. Not required during put
	// operations.
	//
	Id *int32 `json:"id,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// each key in the map represents a unique condition. All the keys present in
	// the map form a logical condition with AND operation.
	//
	ConditionsMap map[AssertionConditionKey]*AssertionConditionData `json:"conditionsMap"`
}

//
// NewAssertionCondition - creates an initialized AssertionCondition instance, returns a pointer to it
//
func NewAssertionCondition(init ...*AssertionCondition) *AssertionCondition {
	var o *AssertionCondition
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(AssertionCondition)
	}
	return o.Init()
}

//
// Init - sets up the instance according to its default field values, if any
//
func (self *AssertionCondition) Init() *AssertionCondition {
	if self.ConditionsMap == nil {
		self.ConditionsMap = make(map[AssertionConditionKey]*AssertionConditionData)
	}
	return self
}

type rawAssertionCondition AssertionCondition

//
// UnmarshalJSON is defined for proper JSON decoding of a AssertionCondition
//
func (self *AssertionCondition) UnmarshalJSON(b []byte) error {
	var m rawAssertionCondition
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := AssertionCondition(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (self *AssertionCondition) Validate() error {
	if self.ConditionsMap == nil {
		return fmt.Errorf("AssertionCondition: Missing required field: conditionsMap")
	}
	return nil
}

//
// AssertionConditions - The representation of list of assertion conditions
//
type AssertionConditions struct {

	//
	// list of assertion conditions.
	//
	ConditionsList []*AssertionCondition `json:"conditionsList"`
}

//
// NewAssertionConditions - creates an initialized AssertionConditions instance, returns a pointer to it
//
func NewAssertionConditions(init ...*AssertionConditions) *AssertionConditions {
	var o *AssertionConditions
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(AssertionConditions)
	}
	return o.Init()
}

//
// Init - sets up the instance according to its default field values, if any
//
func (self *AssertionConditions) Init() *AssertionConditions {
	if self.ConditionsList == nil {
		self.ConditionsList = make([]*AssertionCondition, 0)
	}
	return self
}

type rawAssertionConditions AssertionConditions

//
// UnmarshalJSON is defined for proper JSON decoding of a AssertionConditions
//
func (self *AssertionConditions) UnmarshalJSON(b []byte) error {
	var m rawAssertionConditions
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := AssertionConditions(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (self *AssertionConditions) Validate() error {
	if self.ConditionsList == nil {
		return fmt.Errorf("AssertionConditions: Missing required field: conditionsList")
	}
	return nil
}

//
// Assertion - A representation for the encapsulation of an action to be
// performed on a resource by a principal.
//
type Assertion struct {

	//
	// the subject of the assertion - a role
	//
	Role string `json:"role"`

	//
	// the object of the assertion. Must be in the local namespace. Can contain
	// wildcards
	//
	Resource string `json:"resource"`

	//
	// the predicate of the assertion. Can contain wildcards
	//
	Action string `json:"action"`

	//
	// the effect of the assertion in the policy language
	//
	Effect *AssertionEffect `json:"effect,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// assertion id - auto generated by server. Not required during put
	// operations.
	//
	Id *int64 `json:"id,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// If true, we should store action and resource in their original case
	//
	CaseSensitive *bool `json:"caseSensitive,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// optional list of assertion conditions associated with given assertion
	//
	Conditions *AssertionConditions `json:"conditions,omitempty" rdl:"optional" yaml:",omitempty"`
}

//
// NewAssertion - creates an initialized Assertion instance, returns a pointer to it
//
func NewAssertion(init ...*Assertion) *Assertion {
	var o *Assertion
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(Assertion)
	}
	return o
}

type rawAssertion Assertion

//
// UnmarshalJSON is defined for proper JSON decoding of a Assertion
//
func (self *Assertion) UnmarshalJSON(b []byte) error {
	var m rawAssertion
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := Assertion(m)
		*self = o
		err = self.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (self *Assertion) Validate() error {
	if self.Role == "" {
		return fmt.Errorf("Assertion.role is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "String", self.Role)
		if !val.Valid {
			return fmt.Errorf("Assertion.role does not contain a valid String (%v)", val.Error)
		}
	}
	if self.Resource == "" {
		return fmt.Errorf("Assertion.resource is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "String", self.Resource)
		if !val.Valid {
			return fmt.Errorf("Assertion.resource does not contain a valid String (%v)", val.Error)
		}
	}
	if self.Action == "" {
		return fmt.Errorf("Assertion.action is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "String", self.Action)
		if !val.Valid {
			return fmt.Errorf("Assertion.action does not contain a valid String (%v)", val.Error)
		}
	}
	return nil
}

//
// Policy - The representation for a Policy with set of assertions.
//
type Policy struct {

	//
	// name of the policy
	//
	Name ResourceName `json:"name"`

	//
	// last modification timestamp of this policy
	//
	Modified *rdl.Timestamp `json:"modified,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// list of defined assertions for this policy
	//
	Assertions []*Assertion `json:"assertions"`

	//
	// If true, we should store action and resource in their original case
	//
	CaseSensitive *bool `json:"caseSensitive,omitempty" rdl:"optional" yaml:",omitempty"`
}

//
// NewPolicy - creates an initialized Policy instance, returns a pointer to it
//
func NewPolicy(init ...*Policy) *Policy {
	var o *Policy
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(Policy)
	}
	return o.Init()
}

//
// Init - sets up the instance according to its default field values, if any
//
func (self *Policy) Init() *Policy {
	if self.Assertions == nil {
		self.Assertions = make([]*Assertion, 0)
	}
	return self
}

type rawPolicy Policy

//
// UnmarshalJSON is defined for proper JSON decoding of a Policy
//
func (self *Policy) UnmarshalJSON(b []byte) error {
	var m rawPolicy
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := Policy(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (self *Policy) Validate() error {
	if self.Name == "" {
		return fmt.Errorf("Policy.name is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "ResourceName", self.Name)
		if !val.Valid {
			return fmt.Errorf("Policy.name does not contain a valid ResourceName (%v)", val.Error)
		}
	}
	if self.Assertions == nil {
		return fmt.Errorf("Policy: Missing required field: assertions")
	}
	return nil
}

//
// Policies - The representation of list of policy objects
//
type Policies struct {

	//
	// list of policy objects
	//
	List []*Policy `json:"list"`
}

//
// NewPolicies - creates an initialized Policies instance, returns a pointer to it
//
func NewPolicies(init ...*Policies) *Policies {
	var o *Policies
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(Policies)
	}
	return o.Init()
}

//
// Init - sets up the instance according to its default field values, if any
//
func (self *Policies) Init() *Policies {
	if self.List == nil {
		self.List = make([]*Policy, 0)
	}
	return self
}

type rawPolicies Policies

//
// UnmarshalJSON is defined for proper JSON decoding of a Policies
//
func (self *Policies) UnmarshalJSON(b []byte) error {
	var m rawPolicies
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := Policies(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (self *Policies) Validate() error {
	if self.List == nil {
		return fmt.Errorf("Policies: Missing required field: list")
	}
	return nil
}

//
// PublicKeyEntry - The representation of the public key in a service identity
// object.
//
type PublicKeyEntry struct {

	//
	// the public key for the service
	//
	Key string `json:"key"`

	//
	// the key identifier (version or zone name)
	//
	Id string `json:"id"`
}

//
// NewPublicKeyEntry - creates an initialized PublicKeyEntry instance, returns a pointer to it
//
func NewPublicKeyEntry(init ...*PublicKeyEntry) *PublicKeyEntry {
	var o *PublicKeyEntry
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(PublicKeyEntry)
	}
	return o
}

type rawPublicKeyEntry PublicKeyEntry

//
// UnmarshalJSON is defined for proper JSON decoding of a PublicKeyEntry
//
func (self *PublicKeyEntry) UnmarshalJSON(b []byte) error {
	var m rawPublicKeyEntry
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := PublicKeyEntry(m)
		*self = o
		err = self.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (self *PublicKeyEntry) Validate() error {
	if self.Key == "" {
		return fmt.Errorf("PublicKeyEntry.key is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "String", self.Key)
		if !val.Valid {
			return fmt.Errorf("PublicKeyEntry.key does not contain a valid String (%v)", val.Error)
		}
	}
	if self.Id == "" {
		return fmt.Errorf("PublicKeyEntry.id is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "String", self.Id)
		if !val.Valid {
			return fmt.Errorf("PublicKeyEntry.id does not contain a valid String (%v)", val.Error)
		}
	}
	return nil
}

//
// ServiceIdentity - The representation of the service identity object.
//
type ServiceIdentity struct {

	//
	// the full name of the service, i.e. "sports.storage"
	//
	Name ServiceName `json:"name"`

	//
	// description of the service
	//
	Description string `json:"description" rdl:"optional" yaml:",omitempty"`

	//
	// array of public keys for key rotation
	//
	PublicKeys []*PublicKeyEntry `json:"publicKeys,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// if present, then this service can provision tenants via this endpoint.
	//
	ProviderEndpoint string `json:"providerEndpoint" rdl:"optional" yaml:",omitempty"`

	//
	// the timestamp when this entry was last modified
	//
	Modified *rdl.Timestamp `json:"modified,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// the path of the executable that runs the service
	//
	Executable string `json:"executable" rdl:"optional" yaml:",omitempty"`

	//
	// list of host names that this service can run on
	//
	Hosts []string `json:"hosts,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// local (unix) user name this service can run as
	//
	User string `json:"user" rdl:"optional" yaml:",omitempty"`

	//
	// local (unix) group name this service can run as
	//
	Group string `json:"group" rdl:"optional" yaml:",omitempty"`
}

//
// NewServiceIdentity - creates an initialized ServiceIdentity instance, returns a pointer to it
//
func NewServiceIdentity(init ...*ServiceIdentity) *ServiceIdentity {
	var o *ServiceIdentity
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(ServiceIdentity)
	}
	return o
}

type rawServiceIdentity ServiceIdentity

//
// UnmarshalJSON is defined for proper JSON decoding of a ServiceIdentity
//
func (self *ServiceIdentity) UnmarshalJSON(b []byte) error {
	var m rawServiceIdentity
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := ServiceIdentity(m)
		*self = o
		err = self.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (self *ServiceIdentity) Validate() error {
	if self.Name == "" {
		return fmt.Errorf("ServiceIdentity.name is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "ServiceName", self.Name)
		if !val.Valid {
			return fmt.Errorf("ServiceIdentity.name does not contain a valid ServiceName (%v)", val.Error)
		}
	}
	if self.Description != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.Description)
		if !val.Valid {
			return fmt.Errorf("ServiceIdentity.description does not contain a valid String (%v)", val.Error)
		}
	}
	if self.ProviderEndpoint != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.ProviderEndpoint)
		if !val.Valid {
			return fmt.Errorf("ServiceIdentity.providerEndpoint does not contain a valid String (%v)", val.Error)
		}
	}
	if self.Executable != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.Executable)
		if !val.Valid {
			return fmt.Errorf("ServiceIdentity.executable does not contain a valid String (%v)", val.Error)
		}
	}
	if self.User != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.User)
		if !val.Valid {
			return fmt.Errorf("ServiceIdentity.user does not contain a valid String (%v)", val.Error)
		}
	}
	if self.Group != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.Group)
		if !val.Valid {
			return fmt.Errorf("ServiceIdentity.group does not contain a valid String (%v)", val.Error)
		}
	}
	return nil
}

//
// ServiceIdentities - The representation of list of services
//
type ServiceIdentities struct {

	//
	// list of services
	//
	List []*ServiceIdentity `json:"list"`
}

//
// NewServiceIdentities - creates an initialized ServiceIdentities instance, returns a pointer to it
//
func NewServiceIdentities(init ...*ServiceIdentities) *ServiceIdentities {
	var o *ServiceIdentities
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(ServiceIdentities)
	}
	return o.Init()
}

//
// Init - sets up the instance according to its default field values, if any
//
func (self *ServiceIdentities) Init() *ServiceIdentities {
	if self.List == nil {
		self.List = make([]*ServiceIdentity, 0)
	}
	return self
}

type rawServiceIdentities ServiceIdentities

//
// UnmarshalJSON is defined for proper JSON decoding of a ServiceIdentities
//
func (self *ServiceIdentities) UnmarshalJSON(b []byte) error {
	var m rawServiceIdentities
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := ServiceIdentities(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (self *ServiceIdentities) Validate() error {
	if self.List == nil {
		return fmt.Errorf("ServiceIdentities: Missing required field: list")
	}
	return nil
}

//
// ServiceIdentityList - The representation for an enumeration of services in
// the namespace, with pagination.
//
type ServiceIdentityList struct {

	//
	// list of service names
	//
	Names []EntityName `json:"names"`

	//
	// if the response is a paginated list, this attribute specifies the value to
	// be used in the next service list request as the value for the skip query
	// parameter.
	//
	Next string `json:"next" rdl:"optional" yaml:",omitempty"`
}

//
// NewServiceIdentityList - creates an initialized ServiceIdentityList instance, returns a pointer to it
//
func NewServiceIdentityList(init ...*ServiceIdentityList) *ServiceIdentityList {
	var o *ServiceIdentityList
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(ServiceIdentityList)
	}
	return o.Init()
}

//
// Init - sets up the instance according to its default field values, if any
//
func (self *ServiceIdentityList) Init() *ServiceIdentityList {
	if self.Names == nil {
		self.Names = make([]EntityName, 0)
	}
	return self
}

type rawServiceIdentityList ServiceIdentityList

//
// UnmarshalJSON is defined for proper JSON decoding of a ServiceIdentityList
//
func (self *ServiceIdentityList) UnmarshalJSON(b []byte) error {
	var m rawServiceIdentityList
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := ServiceIdentityList(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (self *ServiceIdentityList) Validate() error {
	if self.Names == nil {
		return fmt.Errorf("ServiceIdentityList: Missing required field: names")
	}
	if self.Next != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.Next)
		if !val.Valid {
			return fmt.Errorf("ServiceIdentityList.next does not contain a valid String (%v)", val.Error)
		}
	}
	return nil
}

//
// ServiceIdentitySystemMeta - Set of system metadata attributes that all
// services may have and can be changed by system admins.
//
type ServiceIdentitySystemMeta struct {

	//
	// provider callback endpoint
	//
	ProviderEndpoint string `json:"providerEndpoint" rdl:"optional" yaml:",omitempty"`
}

//
// NewServiceIdentitySystemMeta - creates an initialized ServiceIdentitySystemMeta instance, returns a pointer to it
//
func NewServiceIdentitySystemMeta(init ...*ServiceIdentitySystemMeta) *ServiceIdentitySystemMeta {
	var o *ServiceIdentitySystemMeta
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(ServiceIdentitySystemMeta)
	}
	return o
}

type rawServiceIdentitySystemMeta ServiceIdentitySystemMeta

//
// UnmarshalJSON is defined for proper JSON decoding of a ServiceIdentitySystemMeta
//
func (self *ServiceIdentitySystemMeta) UnmarshalJSON(b []byte) error {
	var m rawServiceIdentitySystemMeta
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := ServiceIdentitySystemMeta(m)
		*self = o
		err = self.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (self *ServiceIdentitySystemMeta) Validate() error {
	if self.ProviderEndpoint != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.ProviderEndpoint)
		if !val.Valid {
			return fmt.Errorf("ServiceIdentitySystemMeta.providerEndpoint does not contain a valid String (%v)", val.Error)
		}
	}
	return nil
}

//
// TemplateMetaData - MetaData for template.
//
type TemplateMetaData struct {

	//
	// name of the template
	//
	TemplateName string `json:"templateName" rdl:"optional" yaml:",omitempty"`

	//
	// description of the template
	//
	Description string `json:"description" rdl:"optional" yaml:",omitempty"`

	//
	// Version from DB(zms_store->domain_template->version)
	//
	CurrentVersion *int32 `json:"currentVersion,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// Bumped up version from solutions-template.json when there is a change
	//
	LatestVersion *int32 `json:"latestVersion,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// placeholders in the template roles/policies to replace (ex:_service_)
	//
	KeywordsToReplace string `json:"keywordsToReplace" rdl:"optional" yaml:",omitempty"`

	//
	// the updated timestamp of the template(solution_templates.json)
	//
	Timestamp *rdl.Timestamp `json:"timestamp,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// flag to automatically update the roles/policies that belongs to the
	// template
	//
	AutoUpdate *bool `json:"autoUpdate,omitempty" rdl:"optional" yaml:",omitempty"`
}

//
// NewTemplateMetaData - creates an initialized TemplateMetaData instance, returns a pointer to it
//
func NewTemplateMetaData(init ...*TemplateMetaData) *TemplateMetaData {
	var o *TemplateMetaData
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(TemplateMetaData)
	}
	return o
}

type rawTemplateMetaData TemplateMetaData

//
// UnmarshalJSON is defined for proper JSON decoding of a TemplateMetaData
//
func (self *TemplateMetaData) UnmarshalJSON(b []byte) error {
	var m rawTemplateMetaData
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := TemplateMetaData(m)
		*self = o
		err = self.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (self *TemplateMetaData) Validate() error {
	if self.TemplateName != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.TemplateName)
		if !val.Valid {
			return fmt.Errorf("TemplateMetaData.templateName does not contain a valid String (%v)", val.Error)
		}
	}
	if self.Description != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.Description)
		if !val.Valid {
			return fmt.Errorf("TemplateMetaData.description does not contain a valid String (%v)", val.Error)
		}
	}
	if self.KeywordsToReplace != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.KeywordsToReplace)
		if !val.Valid {
			return fmt.Errorf("TemplateMetaData.keywordsToReplace does not contain a valid String (%v)", val.Error)
		}
	}
	return nil
}

//
// Template - Solution Template object defined on the server
//
type Template struct {

	//
	// list of roles in the template
	//
	Roles []*Role `json:"roles"`

	//
	// list of policies defined in this template
	//
	Policies []*Policy `json:"policies"`

	//
	// list of services defined in this template
	//
	Services []*ServiceIdentity `json:"services,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// list of services defined in this template
	//
	Metadata *TemplateMetaData `json:"metadata,omitempty" rdl:"optional" yaml:",omitempty"`
}

//
// NewTemplate - creates an initialized Template instance, returns a pointer to it
//
func NewTemplate(init ...*Template) *Template {
	var o *Template
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(Template)
	}
	return o.Init()
}

//
// Init - sets up the instance according to its default field values, if any
//
func (self *Template) Init() *Template {
	if self.Roles == nil {
		self.Roles = make([]*Role, 0)
	}
	if self.Policies == nil {
		self.Policies = make([]*Policy, 0)
	}
	return self
}

type rawTemplate Template

//
// UnmarshalJSON is defined for proper JSON decoding of a Template
//
func (self *Template) UnmarshalJSON(b []byte) error {
	var m rawTemplate
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := Template(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (self *Template) Validate() error {
	if self.Roles == nil {
		return fmt.Errorf("Template: Missing required field: roles")
	}
	if self.Policies == nil {
		return fmt.Errorf("Template: Missing required field: policies")
	}
	return nil
}

//
// TemplateList - List of template names that is the base struct for server and
// domain templates
//
type TemplateList struct {

	//
	// list of template names
	//
	TemplateNames []SimpleName `json:"templateNames"`
}

//
// NewTemplateList - creates an initialized TemplateList instance, returns a pointer to it
//
func NewTemplateList(init ...*TemplateList) *TemplateList {
	var o *TemplateList
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(TemplateList)
	}
	return o.Init()
}

//
// Init - sets up the instance according to its default field values, if any
//
func (self *TemplateList) Init() *TemplateList {
	if self.TemplateNames == nil {
		self.TemplateNames = make([]SimpleName, 0)
	}
	return self
}

type rawTemplateList TemplateList

//
// UnmarshalJSON is defined for proper JSON decoding of a TemplateList
//
func (self *TemplateList) UnmarshalJSON(b []byte) error {
	var m rawTemplateList
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := TemplateList(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (self *TemplateList) Validate() error {
	if self.TemplateNames == nil {
		return fmt.Errorf("TemplateList: Missing required field: templateNames")
	}
	return nil
}

//
// TemplateParam -
//
type TemplateParam struct {

	//
	// name of the parameter
	//
	Name SimpleName `json:"name"`

	//
	// value of the parameter
	//
	Value CompoundName `json:"value"`
}

//
// NewTemplateParam - creates an initialized TemplateParam instance, returns a pointer to it
//
func NewTemplateParam(init ...*TemplateParam) *TemplateParam {
	var o *TemplateParam
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(TemplateParam)
	}
	return o
}

type rawTemplateParam TemplateParam

//
// UnmarshalJSON is defined for proper JSON decoding of a TemplateParam
//
func (self *TemplateParam) UnmarshalJSON(b []byte) error {
	var m rawTemplateParam
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := TemplateParam(m)
		*self = o
		err = self.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (self *TemplateParam) Validate() error {
	if self.Name == "" {
		return fmt.Errorf("TemplateParam.name is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "SimpleName", self.Name)
		if !val.Valid {
			return fmt.Errorf("TemplateParam.name does not contain a valid SimpleName (%v)", val.Error)
		}
	}
	if self.Value == "" {
		return fmt.Errorf("TemplateParam.value is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "CompoundName", self.Value)
		if !val.Valid {
			return fmt.Errorf("TemplateParam.value does not contain a valid CompoundName (%v)", val.Error)
		}
	}
	return nil
}

//
// DomainTemplate - solution template(s) to be applied to a domain
//
type DomainTemplate struct {

	//
	// list of template names
	//
	TemplateNames []SimpleName `json:"templateNames"`

	//
	// optional template parameters
	//
	Params []*TemplateParam `json:"params,omitempty" rdl:"optional" yaml:",omitempty"`
}

//
// NewDomainTemplate - creates an initialized DomainTemplate instance, returns a pointer to it
//
func NewDomainTemplate(init ...*DomainTemplate) *DomainTemplate {
	var o *DomainTemplate
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(DomainTemplate)
	}
	return o.Init()
}

//
// Init - sets up the instance according to its default field values, if any
//
func (self *DomainTemplate) Init() *DomainTemplate {
	if self.TemplateNames == nil {
		self.TemplateNames = make([]SimpleName, 0)
	}
	return self
}

type rawDomainTemplate DomainTemplate

//
// UnmarshalJSON is defined for proper JSON decoding of a DomainTemplate
//
func (self *DomainTemplate) UnmarshalJSON(b []byte) error {
	var m rawDomainTemplate
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := DomainTemplate(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (self *DomainTemplate) Validate() error {
	if self.TemplateNames == nil {
		return fmt.Errorf("DomainTemplate: Missing required field: templateNames")
	}
	return nil
}

//
// DomainTemplateList - List of solution templates to be applied to a domain
//
type DomainTemplateList struct {

	//
	// list of template names
	//
	TemplateNames []SimpleName `json:"templateNames"`
}

//
// NewDomainTemplateList - creates an initialized DomainTemplateList instance, returns a pointer to it
//
func NewDomainTemplateList(init ...*DomainTemplateList) *DomainTemplateList {
	var o *DomainTemplateList
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(DomainTemplateList)
	}
	return o.Init()
}

//
// Init - sets up the instance according to its default field values, if any
//
func (self *DomainTemplateList) Init() *DomainTemplateList {
	if self.TemplateNames == nil {
		self.TemplateNames = make([]SimpleName, 0)
	}
	return self
}

type rawDomainTemplateList DomainTemplateList

//
// UnmarshalJSON is defined for proper JSON decoding of a DomainTemplateList
//
func (self *DomainTemplateList) UnmarshalJSON(b []byte) error {
	var m rawDomainTemplateList
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := DomainTemplateList(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (self *DomainTemplateList) Validate() error {
	if self.TemplateNames == nil {
		return fmt.Errorf("DomainTemplateList: Missing required field: templateNames")
	}
	return nil
}

//
// ServerTemplateList - List of solution templates available in the server
//
type ServerTemplateList struct {

	//
	// list of template names
	//
	TemplateNames []SimpleName `json:"templateNames"`
}

//
// NewServerTemplateList - creates an initialized ServerTemplateList instance, returns a pointer to it
//
func NewServerTemplateList(init ...*ServerTemplateList) *ServerTemplateList {
	var o *ServerTemplateList
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(ServerTemplateList)
	}
	return o.Init()
}

//
// Init - sets up the instance according to its default field values, if any
//
func (self *ServerTemplateList) Init() *ServerTemplateList {
	if self.TemplateNames == nil {
		self.TemplateNames = make([]SimpleName, 0)
	}
	return self
}

type rawServerTemplateList ServerTemplateList

//
// UnmarshalJSON is defined for proper JSON decoding of a ServerTemplateList
//
func (self *ServerTemplateList) UnmarshalJSON(b []byte) error {
	var m rawServerTemplateList
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := ServerTemplateList(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (self *ServerTemplateList) Validate() error {
	if self.TemplateNames == nil {
		return fmt.Errorf("ServerTemplateList: Missing required field: templateNames")
	}
	return nil
}

//
// DomainTemplateDetailsList - List of templates with metadata details given a
// domain
//
type DomainTemplateDetailsList struct {

	//
	// list of template metadata
	//
	MetaData []*TemplateMetaData `json:"metaData"`
}

//
// NewDomainTemplateDetailsList - creates an initialized DomainTemplateDetailsList instance, returns a pointer to it
//
func NewDomainTemplateDetailsList(init ...*DomainTemplateDetailsList) *DomainTemplateDetailsList {
	var o *DomainTemplateDetailsList
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(DomainTemplateDetailsList)
	}
	return o.Init()
}

//
// Init - sets up the instance according to its default field values, if any
//
func (self *DomainTemplateDetailsList) Init() *DomainTemplateDetailsList {
	if self.MetaData == nil {
		self.MetaData = make([]*TemplateMetaData, 0)
	}
	return self
}

type rawDomainTemplateDetailsList DomainTemplateDetailsList

//
// UnmarshalJSON is defined for proper JSON decoding of a DomainTemplateDetailsList
//
func (self *DomainTemplateDetailsList) UnmarshalJSON(b []byte) error {
	var m rawDomainTemplateDetailsList
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := DomainTemplateDetailsList(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (self *DomainTemplateDetailsList) Validate() error {
	if self.MetaData == nil {
		return fmt.Errorf("DomainTemplateDetailsList: Missing required field: metaData")
	}
	return nil
}

//
// DomainList - A paginated list of domains.
//
type DomainList struct {

	//
	// list of domain names
	//
	Names []DomainName `json:"names"`

	//
	// if the response is a paginated list, this attribute specifies the value to
	// be used in the next domain list request as the value for the skip query
	// parameter.
	//
	Next string `json:"next" rdl:"optional" yaml:",omitempty"`
}

//
// NewDomainList - creates an initialized DomainList instance, returns a pointer to it
//
func NewDomainList(init ...*DomainList) *DomainList {
	var o *DomainList
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(DomainList)
	}
	return o.Init()
}

//
// Init - sets up the instance according to its default field values, if any
//
func (self *DomainList) Init() *DomainList {
	if self.Names == nil {
		self.Names = make([]DomainName, 0)
	}
	return self
}

type rawDomainList DomainList

//
// UnmarshalJSON is defined for proper JSON decoding of a DomainList
//
func (self *DomainList) UnmarshalJSON(b []byte) error {
	var m rawDomainList
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := DomainList(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (self *DomainList) Validate() error {
	if self.Names == nil {
		return fmt.Errorf("DomainList: Missing required field: names")
	}
	if self.Next != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.Next)
		if !val.Valid {
			return fmt.Errorf("DomainList.next does not contain a valid String (%v)", val.Error)
		}
	}
	return nil
}

//
// TopLevelDomain - Top Level Domain object. The required attributes include
// the name of the domain and list of domain administrators.
//
type TopLevelDomain struct {

	//
	// a description of the domain
	//
	Description string `json:"description" rdl:"optional" yaml:",omitempty"`

	//
	// a reference to an audit organization defined in athenz
	//
	Org ResourceName `json:"org,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// Future use only, currently not used
	//
	Enabled *bool `json:"enabled,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// Flag indicates whether or not domain modifications should be logged for
	// SOX+Auditing. If true, the auditRef parameter must be supplied(not empty) for
	// any API defining it.
	//
	AuditEnabled *bool `json:"auditEnabled,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// associated aws account id (system attribute - uniqueness check)
	//
	Account string `json:"account" rdl:"optional" yaml:",omitempty"`

	//
	// associated product id (system attribute - uniqueness check)
	//
	YpmId *int32 `json:"ypmId,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// associated application id
	//
	ApplicationId string `json:"applicationId" rdl:"optional" yaml:",omitempty"`

	//
	// domain certificate dns domain (system attribute)
	//
	CertDnsDomain string `json:"certDnsDomain" rdl:"optional" yaml:",omitempty"`

	//
	// all user members in the domain will have specified max expiry days
	//
	MemberExpiryDays *int32 `json:"memberExpiryDays,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// tokens issued for this domain will have specified max timeout in mins
	//
	TokenExpiryMins *int32 `json:"tokenExpiryMins,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// service identity certs issued for this domain will have specified max
	// timeout in mins
	//
	ServiceCertExpiryMins *int32 `json:"serviceCertExpiryMins,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// role certs issued for this domain will have specified max timeout in mins
	//
	RoleCertExpiryMins *int32 `json:"roleCertExpiryMins,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// rsa or ec signing algorithm to be used for tokens
	//
	SignAlgorithm SimpleName `json:"signAlgorithm,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// all services in the domain roles will have specified max expiry days
	//
	ServiceExpiryDays *int32 `json:"serviceExpiryDays,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// all groups in the domain roles will have specified max expiry days
	//
	GroupExpiryDays *int32 `json:"groupExpiryDays,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// membership filtered based on user authority configured attributes
	//
	UserAuthorityFilter string `json:"userAuthorityFilter" rdl:"optional" yaml:",omitempty"`

	//
	// associated azure subscription id (system attribute - uniqueness check)
	//
	AzureSubscription string `json:"azureSubscription" rdl:"optional" yaml:",omitempty"`

	//
	// key-value pair tags, tag might contain multiple values
	//
	Tags map[CompoundName]*TagValueList `json:"tags,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// associated business service with domain
	//
	BusinessService string `json:"businessService" rdl:"optional" yaml:",omitempty"`

	//
	// name of the domain
	//
	Name SimpleName `json:"name"`

	//
	// list of domain administrators
	//
	AdminUsers []ResourceName `json:"adminUsers"`

	//
	// list of solution template names
	//
	Templates *DomainTemplateList `json:"templates,omitempty" rdl:"optional" yaml:",omitempty"`
}

//
// NewTopLevelDomain - creates an initialized TopLevelDomain instance, returns a pointer to it
//
func NewTopLevelDomain(init ...*TopLevelDomain) *TopLevelDomain {
	var o *TopLevelDomain
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(TopLevelDomain)
	}
	return o.Init()
}

//
// Init - sets up the instance according to its default field values, if any
//
func (self *TopLevelDomain) Init() *TopLevelDomain {
	if self.Enabled == nil {
		d := true
		self.Enabled = &d
	}
	if self.AuditEnabled == nil {
		d := false
		self.AuditEnabled = &d
	}
	if self.AdminUsers == nil {
		self.AdminUsers = make([]ResourceName, 0)
	}
	return self
}

type rawTopLevelDomain TopLevelDomain

//
// UnmarshalJSON is defined for proper JSON decoding of a TopLevelDomain
//
func (self *TopLevelDomain) UnmarshalJSON(b []byte) error {
	var m rawTopLevelDomain
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := TopLevelDomain(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (self *TopLevelDomain) Validate() error {
	if self.Description != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.Description)
		if !val.Valid {
			return fmt.Errorf("TopLevelDomain.description does not contain a valid String (%v)", val.Error)
		}
	}
	if self.Org != "" {
		val := rdl.Validate(ZMSSchema(), "ResourceName", self.Org)
		if !val.Valid {
			return fmt.Errorf("TopLevelDomain.org does not contain a valid ResourceName (%v)", val.Error)
		}
	}
	if self.Account != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.Account)
		if !val.Valid {
			return fmt.Errorf("TopLevelDomain.account does not contain a valid String (%v)", val.Error)
		}
	}
	if self.ApplicationId != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.ApplicationId)
		if !val.Valid {
			return fmt.Errorf("TopLevelDomain.applicationId does not contain a valid String (%v)", val.Error)
		}
	}
	if self.CertDnsDomain != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.CertDnsDomain)
		if !val.Valid {
			return fmt.Errorf("TopLevelDomain.certDnsDomain does not contain a valid String (%v)", val.Error)
		}
	}
	if self.SignAlgorithm != "" {
		val := rdl.Validate(ZMSSchema(), "SimpleName", self.SignAlgorithm)
		if !val.Valid {
			return fmt.Errorf("TopLevelDomain.signAlgorithm does not contain a valid SimpleName (%v)", val.Error)
		}
	}
	if self.UserAuthorityFilter != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.UserAuthorityFilter)
		if !val.Valid {
			return fmt.Errorf("TopLevelDomain.userAuthorityFilter does not contain a valid String (%v)", val.Error)
		}
	}
	if self.AzureSubscription != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.AzureSubscription)
		if !val.Valid {
			return fmt.Errorf("TopLevelDomain.azureSubscription does not contain a valid String (%v)", val.Error)
		}
	}
	if self.BusinessService != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.BusinessService)
		if !val.Valid {
			return fmt.Errorf("TopLevelDomain.businessService does not contain a valid String (%v)", val.Error)
		}
	}
	if self.Name == "" {
		return fmt.Errorf("TopLevelDomain.name is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "SimpleName", self.Name)
		if !val.Valid {
			return fmt.Errorf("TopLevelDomain.name does not contain a valid SimpleName (%v)", val.Error)
		}
	}
	if self.AdminUsers == nil {
		return fmt.Errorf("TopLevelDomain: Missing required field: adminUsers")
	}
	return nil
}

//
// SubDomain - A Subdomain is a TopLevelDomain, except it has a parent.
//
type SubDomain struct {

	//
	// a description of the domain
	//
	Description string `json:"description" rdl:"optional" yaml:",omitempty"`

	//
	// a reference to an audit organization defined in athenz
	//
	Org ResourceName `json:"org,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// Future use only, currently not used
	//
	Enabled *bool `json:"enabled,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// Flag indicates whether or not domain modifications should be logged for
	// SOX+Auditing. If true, the auditRef parameter must be supplied(not empty) for
	// any API defining it.
	//
	AuditEnabled *bool `json:"auditEnabled,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// associated aws account id (system attribute - uniqueness check)
	//
	Account string `json:"account" rdl:"optional" yaml:",omitempty"`

	//
	// associated product id (system attribute - uniqueness check)
	//
	YpmId *int32 `json:"ypmId,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// associated application id
	//
	ApplicationId string `json:"applicationId" rdl:"optional" yaml:",omitempty"`

	//
	// domain certificate dns domain (system attribute)
	//
	CertDnsDomain string `json:"certDnsDomain" rdl:"optional" yaml:",omitempty"`

	//
	// all user members in the domain will have specified max expiry days
	//
	MemberExpiryDays *int32 `json:"memberExpiryDays,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// tokens issued for this domain will have specified max timeout in mins
	//
	TokenExpiryMins *int32 `json:"tokenExpiryMins,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// service identity certs issued for this domain will have specified max
	// timeout in mins
	//
	ServiceCertExpiryMins *int32 `json:"serviceCertExpiryMins,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// role certs issued for this domain will have specified max timeout in mins
	//
	RoleCertExpiryMins *int32 `json:"roleCertExpiryMins,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// rsa or ec signing algorithm to be used for tokens
	//
	SignAlgorithm SimpleName `json:"signAlgorithm,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// all services in the domain roles will have specified max expiry days
	//
	ServiceExpiryDays *int32 `json:"serviceExpiryDays,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// all groups in the domain roles will have specified max expiry days
	//
	GroupExpiryDays *int32 `json:"groupExpiryDays,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// membership filtered based on user authority configured attributes
	//
	UserAuthorityFilter string `json:"userAuthorityFilter" rdl:"optional" yaml:",omitempty"`

	//
	// associated azure subscription id (system attribute - uniqueness check)
	//
	AzureSubscription string `json:"azureSubscription" rdl:"optional" yaml:",omitempty"`

	//
	// key-value pair tags, tag might contain multiple values
	//
	Tags map[CompoundName]*TagValueList `json:"tags,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// associated business service with domain
	//
	BusinessService string `json:"businessService" rdl:"optional" yaml:",omitempty"`

	//
	// name of the domain
	//
	Name SimpleName `json:"name"`

	//
	// list of domain administrators
	//
	AdminUsers []ResourceName `json:"adminUsers"`

	//
	// list of solution template names
	//
	Templates *DomainTemplateList `json:"templates,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// name of the parent domain
	//
	Parent DomainName `json:"parent"`
}

//
// NewSubDomain - creates an initialized SubDomain instance, returns a pointer to it
//
func NewSubDomain(init ...*SubDomain) *SubDomain {
	var o *SubDomain
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(SubDomain)
	}
	return o.Init()
}

//
// Init - sets up the instance according to its default field values, if any
//
func (self *SubDomain) Init() *SubDomain {
	if self.Enabled == nil {
		d := true
		self.Enabled = &d
	}
	if self.AuditEnabled == nil {
		d := false
		self.AuditEnabled = &d
	}
	if self.AdminUsers == nil {
		self.AdminUsers = make([]ResourceName, 0)
	}
	return self
}

type rawSubDomain SubDomain

//
// UnmarshalJSON is defined for proper JSON decoding of a SubDomain
//
func (self *SubDomain) UnmarshalJSON(b []byte) error {
	var m rawSubDomain
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := SubDomain(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (self *SubDomain) Validate() error {
	if self.Description != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.Description)
		if !val.Valid {
			return fmt.Errorf("SubDomain.description does not contain a valid String (%v)", val.Error)
		}
	}
	if self.Org != "" {
		val := rdl.Validate(ZMSSchema(), "ResourceName", self.Org)
		if !val.Valid {
			return fmt.Errorf("SubDomain.org does not contain a valid ResourceName (%v)", val.Error)
		}
	}
	if self.Account != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.Account)
		if !val.Valid {
			return fmt.Errorf("SubDomain.account does not contain a valid String (%v)", val.Error)
		}
	}
	if self.ApplicationId != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.ApplicationId)
		if !val.Valid {
			return fmt.Errorf("SubDomain.applicationId does not contain a valid String (%v)", val.Error)
		}
	}
	if self.CertDnsDomain != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.CertDnsDomain)
		if !val.Valid {
			return fmt.Errorf("SubDomain.certDnsDomain does not contain a valid String (%v)", val.Error)
		}
	}
	if self.SignAlgorithm != "" {
		val := rdl.Validate(ZMSSchema(), "SimpleName", self.SignAlgorithm)
		if !val.Valid {
			return fmt.Errorf("SubDomain.signAlgorithm does not contain a valid SimpleName (%v)", val.Error)
		}
	}
	if self.UserAuthorityFilter != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.UserAuthorityFilter)
		if !val.Valid {
			return fmt.Errorf("SubDomain.userAuthorityFilter does not contain a valid String (%v)", val.Error)
		}
	}
	if self.AzureSubscription != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.AzureSubscription)
		if !val.Valid {
			return fmt.Errorf("SubDomain.azureSubscription does not contain a valid String (%v)", val.Error)
		}
	}
	if self.BusinessService != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.BusinessService)
		if !val.Valid {
			return fmt.Errorf("SubDomain.businessService does not contain a valid String (%v)", val.Error)
		}
	}
	if self.Name == "" {
		return fmt.Errorf("SubDomain.name is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "SimpleName", self.Name)
		if !val.Valid {
			return fmt.Errorf("SubDomain.name does not contain a valid SimpleName (%v)", val.Error)
		}
	}
	if self.AdminUsers == nil {
		return fmt.Errorf("SubDomain: Missing required field: adminUsers")
	}
	if self.Parent == "" {
		return fmt.Errorf("SubDomain.parent is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "DomainName", self.Parent)
		if !val.Valid {
			return fmt.Errorf("SubDomain.parent does not contain a valid DomainName (%v)", val.Error)
		}
	}
	return nil
}

//
// UserDomain - A UserDomain is the user's own top level domain in user - e.g.
// user.hga
//
type UserDomain struct {

	//
	// a description of the domain
	//
	Description string `json:"description" rdl:"optional" yaml:",omitempty"`

	//
	// a reference to an audit organization defined in athenz
	//
	Org ResourceName `json:"org,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// Future use only, currently not used
	//
	Enabled *bool `json:"enabled,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// Flag indicates whether or not domain modifications should be logged for
	// SOX+Auditing. If true, the auditRef parameter must be supplied(not empty) for
	// any API defining it.
	//
	AuditEnabled *bool `json:"auditEnabled,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// associated aws account id (system attribute - uniqueness check)
	//
	Account string `json:"account" rdl:"optional" yaml:",omitempty"`

	//
	// associated product id (system attribute - uniqueness check)
	//
	YpmId *int32 `json:"ypmId,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// associated application id
	//
	ApplicationId string `json:"applicationId" rdl:"optional" yaml:",omitempty"`

	//
	// domain certificate dns domain (system attribute)
	//
	CertDnsDomain string `json:"certDnsDomain" rdl:"optional" yaml:",omitempty"`

	//
	// all user members in the domain will have specified max expiry days
	//
	MemberExpiryDays *int32 `json:"memberExpiryDays,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// tokens issued for this domain will have specified max timeout in mins
	//
	TokenExpiryMins *int32 `json:"tokenExpiryMins,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// service identity certs issued for this domain will have specified max
	// timeout in mins
	//
	ServiceCertExpiryMins *int32 `json:"serviceCertExpiryMins,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// role certs issued for this domain will have specified max timeout in mins
	//
	RoleCertExpiryMins *int32 `json:"roleCertExpiryMins,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// rsa or ec signing algorithm to be used for tokens
	//
	SignAlgorithm SimpleName `json:"signAlgorithm,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// all services in the domain roles will have specified max expiry days
	//
	ServiceExpiryDays *int32 `json:"serviceExpiryDays,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// all groups in the domain roles will have specified max expiry days
	//
	GroupExpiryDays *int32 `json:"groupExpiryDays,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// membership filtered based on user authority configured attributes
	//
	UserAuthorityFilter string `json:"userAuthorityFilter" rdl:"optional" yaml:",omitempty"`

	//
	// associated azure subscription id (system attribute - uniqueness check)
	//
	AzureSubscription string `json:"azureSubscription" rdl:"optional" yaml:",omitempty"`

	//
	// key-value pair tags, tag might contain multiple values
	//
	Tags map[CompoundName]*TagValueList `json:"tags,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// associated business service with domain
	//
	BusinessService string `json:"businessService" rdl:"optional" yaml:",omitempty"`

	//
	// user id which will be the domain name
	//
	Name SimpleName `json:"name"`

	//
	// list of solution template names
	//
	Templates *DomainTemplateList `json:"templates,omitempty" rdl:"optional" yaml:",omitempty"`
}

//
// NewUserDomain - creates an initialized UserDomain instance, returns a pointer to it
//
func NewUserDomain(init ...*UserDomain) *UserDomain {
	var o *UserDomain
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(UserDomain)
	}
	return o.Init()
}

//
// Init - sets up the instance according to its default field values, if any
//
func (self *UserDomain) Init() *UserDomain {
	if self.Enabled == nil {
		d := true
		self.Enabled = &d
	}
	if self.AuditEnabled == nil {
		d := false
		self.AuditEnabled = &d
	}
	return self
}

type rawUserDomain UserDomain

//
// UnmarshalJSON is defined for proper JSON decoding of a UserDomain
//
func (self *UserDomain) UnmarshalJSON(b []byte) error {
	var m rawUserDomain
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := UserDomain(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (self *UserDomain) Validate() error {
	if self.Description != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.Description)
		if !val.Valid {
			return fmt.Errorf("UserDomain.description does not contain a valid String (%v)", val.Error)
		}
	}
	if self.Org != "" {
		val := rdl.Validate(ZMSSchema(), "ResourceName", self.Org)
		if !val.Valid {
			return fmt.Errorf("UserDomain.org does not contain a valid ResourceName (%v)", val.Error)
		}
	}
	if self.Account != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.Account)
		if !val.Valid {
			return fmt.Errorf("UserDomain.account does not contain a valid String (%v)", val.Error)
		}
	}
	if self.ApplicationId != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.ApplicationId)
		if !val.Valid {
			return fmt.Errorf("UserDomain.applicationId does not contain a valid String (%v)", val.Error)
		}
	}
	if self.CertDnsDomain != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.CertDnsDomain)
		if !val.Valid {
			return fmt.Errorf("UserDomain.certDnsDomain does not contain a valid String (%v)", val.Error)
		}
	}
	if self.SignAlgorithm != "" {
		val := rdl.Validate(ZMSSchema(), "SimpleName", self.SignAlgorithm)
		if !val.Valid {
			return fmt.Errorf("UserDomain.signAlgorithm does not contain a valid SimpleName (%v)", val.Error)
		}
	}
	if self.UserAuthorityFilter != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.UserAuthorityFilter)
		if !val.Valid {
			return fmt.Errorf("UserDomain.userAuthorityFilter does not contain a valid String (%v)", val.Error)
		}
	}
	if self.AzureSubscription != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.AzureSubscription)
		if !val.Valid {
			return fmt.Errorf("UserDomain.azureSubscription does not contain a valid String (%v)", val.Error)
		}
	}
	if self.BusinessService != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.BusinessService)
		if !val.Valid {
			return fmt.Errorf("UserDomain.businessService does not contain a valid String (%v)", val.Error)
		}
	}
	if self.Name == "" {
		return fmt.Errorf("UserDomain.name is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "SimpleName", self.Name)
		if !val.Valid {
			return fmt.Errorf("UserDomain.name does not contain a valid SimpleName (%v)", val.Error)
		}
	}
	return nil
}

//
// DomainMetaStoreValidValuesList - List of valid domain meta attribute values
//
type DomainMetaStoreValidValuesList struct {

	//
	// list of valid values for attribute
	//
	ValidValues []string `json:"validValues"`
}

//
// NewDomainMetaStoreValidValuesList - creates an initialized DomainMetaStoreValidValuesList instance, returns a pointer to it
//
func NewDomainMetaStoreValidValuesList(init ...*DomainMetaStoreValidValuesList) *DomainMetaStoreValidValuesList {
	var o *DomainMetaStoreValidValuesList
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(DomainMetaStoreValidValuesList)
	}
	return o.Init()
}

//
// Init - sets up the instance according to its default field values, if any
//
func (self *DomainMetaStoreValidValuesList) Init() *DomainMetaStoreValidValuesList {
	if self.ValidValues == nil {
		self.ValidValues = make([]string, 0)
	}
	return self
}

type rawDomainMetaStoreValidValuesList DomainMetaStoreValidValuesList

//
// UnmarshalJSON is defined for proper JSON decoding of a DomainMetaStoreValidValuesList
//
func (self *DomainMetaStoreValidValuesList) UnmarshalJSON(b []byte) error {
	var m rawDomainMetaStoreValidValuesList
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := DomainMetaStoreValidValuesList(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (self *DomainMetaStoreValidValuesList) Validate() error {
	if self.ValidValues == nil {
		return fmt.Errorf("DomainMetaStoreValidValuesList: Missing required field: validValues")
	}
	return nil
}

//
// DanglingPolicy - A dangling policy where the assertion is referencing a role
// name that doesn't exist in the domain
//
type DanglingPolicy struct {
	PolicyName EntityName `json:"policyName"`
	RoleName   EntityName `json:"roleName"`
}

//
// NewDanglingPolicy - creates an initialized DanglingPolicy instance, returns a pointer to it
//
func NewDanglingPolicy(init ...*DanglingPolicy) *DanglingPolicy {
	var o *DanglingPolicy
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(DanglingPolicy)
	}
	return o
}

type rawDanglingPolicy DanglingPolicy

//
// UnmarshalJSON is defined for proper JSON decoding of a DanglingPolicy
//
func (self *DanglingPolicy) UnmarshalJSON(b []byte) error {
	var m rawDanglingPolicy
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := DanglingPolicy(m)
		*self = o
		err = self.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (self *DanglingPolicy) Validate() error {
	if self.PolicyName == "" {
		return fmt.Errorf("DanglingPolicy.policyName is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "EntityName", self.PolicyName)
		if !val.Valid {
			return fmt.Errorf("DanglingPolicy.policyName does not contain a valid EntityName (%v)", val.Error)
		}
	}
	if self.RoleName == "" {
		return fmt.Errorf("DanglingPolicy.roleName is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "EntityName", self.RoleName)
		if !val.Valid {
			return fmt.Errorf("DanglingPolicy.roleName does not contain a valid EntityName (%v)", val.Error)
		}
	}
	return nil
}

//
// DomainDataCheck - Domain data object representing the results of a check
// operation looking for dangling roles, policies and trust relationships that
// are set either on tenant or provider side only
//
type DomainDataCheck struct {

	//
	// Names of roles not specified in any assertion. Might be empty or null if no
	// dangling roles.
	//
	DanglingRoles []EntityName `json:"danglingRoles,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// Policy+role tuples where role doesnt exist. Might be empty or null if no
	// dangling policies.
	//
	DanglingPolicies []*DanglingPolicy `json:"danglingPolicies,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// total number of policies
	//
	PolicyCount int32 `json:"policyCount"`

	//
	// total number of assertions
	//
	AssertionCount int32 `json:"assertionCount"`

	//
	// total number of assertions containing roles as wildcards
	//
	RoleWildCardCount int32 `json:"roleWildCardCount"`

	//
	// Service names (domain.service) that dont contain trust role if this is a
	// tenant domain. Might be empty or null, if not a tenant or if all providers
	// support this tenant.
	//
	ProvidersWithoutTrust []ServiceName `json:"providersWithoutTrust,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// Names of Tenant domains that dont contain assume role assertions if this is
	// a provider domain. Might be empty or null, if not a provider or if all
	// tenants support use this provider.
	//
	TenantsWithoutAssumeRole []DomainName `json:"tenantsWithoutAssumeRole,omitempty" rdl:"optional" yaml:",omitempty"`
}

//
// NewDomainDataCheck - creates an initialized DomainDataCheck instance, returns a pointer to it
//
func NewDomainDataCheck(init ...*DomainDataCheck) *DomainDataCheck {
	var o *DomainDataCheck
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(DomainDataCheck)
	}
	return o
}

type rawDomainDataCheck DomainDataCheck

//
// UnmarshalJSON is defined for proper JSON decoding of a DomainDataCheck
//
func (self *DomainDataCheck) UnmarshalJSON(b []byte) error {
	var m rawDomainDataCheck
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := DomainDataCheck(m)
		*self = o
		err = self.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (self *DomainDataCheck) Validate() error {
	return nil
}

//
// Entity - An entity is a name and a structured value. some entity
// names/prefixes are reserved (i.e. "role",  "policy", "meta", "domain",
// "service")
//
type Entity struct {

	//
	// name of the entity object
	//
	Name ResourceName `json:"name"`

	//
	// value of the entity
	//
	Value rdl.Struct `json:"value"`
}

//
// NewEntity - creates an initialized Entity instance, returns a pointer to it
//
func NewEntity(init ...*Entity) *Entity {
	var o *Entity
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(Entity)
	}
	return o.Init()
}

//
// Init - sets up the instance according to its default field values, if any
//
func (self *Entity) Init() *Entity {
	if self.Value == nil {
		self.Value = make(rdl.Struct)
	}
	return self
}

type rawEntity Entity

//
// UnmarshalJSON is defined for proper JSON decoding of a Entity
//
func (self *Entity) UnmarshalJSON(b []byte) error {
	var m rawEntity
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := Entity(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (self *Entity) Validate() error {
	if self.Name == "" {
		return fmt.Errorf("Entity.name is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "ResourceName", self.Name)
		if !val.Valid {
			return fmt.Errorf("Entity.name does not contain a valid ResourceName (%v)", val.Error)
		}
	}
	if self.Value == nil {
		return fmt.Errorf("Entity: Missing required field: value")
	}
	return nil
}

//
// EntityList - The representation for an enumeration of entities in the
// namespace
//
type EntityList struct {

	//
	// list of entity names
	//
	Names []EntityName `json:"names"`
}

//
// NewEntityList - creates an initialized EntityList instance, returns a pointer to it
//
func NewEntityList(init ...*EntityList) *EntityList {
	var o *EntityList
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(EntityList)
	}
	return o.Init()
}

//
// Init - sets up the instance according to its default field values, if any
//
func (self *EntityList) Init() *EntityList {
	if self.Names == nil {
		self.Names = make([]EntityName, 0)
	}
	return self
}

type rawEntityList EntityList

//
// UnmarshalJSON is defined for proper JSON decoding of a EntityList
//
func (self *EntityList) UnmarshalJSON(b []byte) error {
	var m rawEntityList
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := EntityList(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (self *EntityList) Validate() error {
	if self.Names == nil {
		return fmt.Errorf("EntityList: Missing required field: names")
	}
	return nil
}

//
// GroupAuditLog - An audit log entry for group membership change.
//
type GroupAuditLog struct {

	//
	// name of the group member
	//
	Member GroupMemberName `json:"member"`

	//
	// name of the principal executing the change
	//
	Admin ResourceName `json:"admin"`

	//
	// timestamp of the entry
	//
	Created rdl.Timestamp `json:"created"`

	//
	// log action - e.g. add, delete, approve, etc
	//
	Action string `json:"action"`

	//
	// audit reference string for the change as supplied by admin
	//
	AuditRef string `json:"auditRef" rdl:"optional" yaml:",omitempty"`
}

//
// NewGroupAuditLog - creates an initialized GroupAuditLog instance, returns a pointer to it
//
func NewGroupAuditLog(init ...*GroupAuditLog) *GroupAuditLog {
	var o *GroupAuditLog
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(GroupAuditLog)
	}
	return o
}

type rawGroupAuditLog GroupAuditLog

//
// UnmarshalJSON is defined for proper JSON decoding of a GroupAuditLog
//
func (self *GroupAuditLog) UnmarshalJSON(b []byte) error {
	var m rawGroupAuditLog
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := GroupAuditLog(m)
		*self = o
		err = self.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (self *GroupAuditLog) Validate() error {
	if self.Member == "" {
		return fmt.Errorf("GroupAuditLog.member is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "GroupMemberName", self.Member)
		if !val.Valid {
			return fmt.Errorf("GroupAuditLog.member does not contain a valid GroupMemberName (%v)", val.Error)
		}
	}
	if self.Admin == "" {
		return fmt.Errorf("GroupAuditLog.admin is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "ResourceName", self.Admin)
		if !val.Valid {
			return fmt.Errorf("GroupAuditLog.admin does not contain a valid ResourceName (%v)", val.Error)
		}
	}
	if self.Created.IsZero() {
		return fmt.Errorf("GroupAuditLog: Missing required field: created")
	}
	if self.Action == "" {
		return fmt.Errorf("GroupAuditLog.action is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "String", self.Action)
		if !val.Valid {
			return fmt.Errorf("GroupAuditLog.action does not contain a valid String (%v)", val.Error)
		}
	}
	if self.AuditRef != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.AuditRef)
		if !val.Valid {
			return fmt.Errorf("GroupAuditLog.auditRef does not contain a valid String (%v)", val.Error)
		}
	}
	return nil
}

//
// GroupMember -
//
type GroupMember struct {

	//
	// name of the member
	//
	MemberName GroupMemberName `json:"memberName,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// name of the group
	//
	GroupName ResourceName `json:"groupName,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// name of the domain
	//
	DomainName DomainName `json:"domainName,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// the expiration timestamp
	//
	Expiration *rdl.Timestamp `json:"expiration,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// Flag to indicate whether membership is active
	//
	Active *bool `json:"active,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// Flag to indicate whether membership is approved either by delegates ( in
	// case of auditEnabled groups ) or by domain admins ( in case of selfserve
	// groups )
	//
	Approved *bool `json:"approved,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// audit reference string for the change as supplied by admin
	//
	AuditRef string `json:"auditRef" rdl:"optional" yaml:",omitempty"`

	//
	// for pending membership requests, the request time
	//
	RequestTime *rdl.Timestamp `json:"requestTime,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// for pending membership requests, time when last notification was sent
	//
	LastNotifiedTime *rdl.Timestamp `json:"lastNotifiedTime,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// pending members only - name of the principal requesting the change
	//
	RequestPrincipal ResourceName `json:"requestPrincipal,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// for pending membership requests, time when last notification was sent (for
	// file store)
	//
	ReviewLastNotifiedTime *rdl.Timestamp `json:"reviewLastNotifiedTime,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// user disabled by system based on configured group setting
	//
	SystemDisabled *int32 `json:"systemDisabled,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// server use only - principal type: unknown(0), user(1) or service(2)
	//
	PrincipalType *int32 `json:"principalType,omitempty" rdl:"optional" yaml:",omitempty"`
}

//
// NewGroupMember - creates an initialized GroupMember instance, returns a pointer to it
//
func NewGroupMember(init ...*GroupMember) *GroupMember {
	var o *GroupMember
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(GroupMember)
	}
	return o.Init()
}

//
// Init - sets up the instance according to its default field values, if any
//
func (self *GroupMember) Init() *GroupMember {
	if self.Active == nil {
		d := true
		self.Active = &d
	}
	if self.Approved == nil {
		d := true
		self.Approved = &d
	}
	return self
}

type rawGroupMember GroupMember

//
// UnmarshalJSON is defined for proper JSON decoding of a GroupMember
//
func (self *GroupMember) UnmarshalJSON(b []byte) error {
	var m rawGroupMember
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := GroupMember(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (self *GroupMember) Validate() error {
	if self.MemberName != "" {
		val := rdl.Validate(ZMSSchema(), "GroupMemberName", self.MemberName)
		if !val.Valid {
			return fmt.Errorf("GroupMember.memberName does not contain a valid GroupMemberName (%v)", val.Error)
		}
	}
	if self.GroupName != "" {
		val := rdl.Validate(ZMSSchema(), "ResourceName", self.GroupName)
		if !val.Valid {
			return fmt.Errorf("GroupMember.groupName does not contain a valid ResourceName (%v)", val.Error)
		}
	}
	if self.DomainName != "" {
		val := rdl.Validate(ZMSSchema(), "DomainName", self.DomainName)
		if !val.Valid {
			return fmt.Errorf("GroupMember.domainName does not contain a valid DomainName (%v)", val.Error)
		}
	}
	if self.AuditRef != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.AuditRef)
		if !val.Valid {
			return fmt.Errorf("GroupMember.auditRef does not contain a valid String (%v)", val.Error)
		}
	}
	if self.RequestPrincipal != "" {
		val := rdl.Validate(ZMSSchema(), "ResourceName", self.RequestPrincipal)
		if !val.Valid {
			return fmt.Errorf("GroupMember.requestPrincipal does not contain a valid ResourceName (%v)", val.Error)
		}
	}
	return nil
}

//
// GroupMembership - The representation for a group membership.
//
type GroupMembership struct {

	//
	// name of the member
	//
	MemberName GroupMemberName `json:"memberName"`

	//
	// flag to indicate whether or the user is a member or not
	//
	IsMember *bool `json:"isMember,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// name of the group
	//
	GroupName ResourceName `json:"groupName,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// the expiration timestamp
	//
	Expiration *rdl.Timestamp `json:"expiration,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// Flag to indicate whether membership is active
	//
	Active *bool `json:"active,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// Flag to indicate whether membership is approved either by delegates ( in
	// case of auditEnabled groups ) or by domain admins ( in case of selfserve
	// groups )
	//
	Approved *bool `json:"approved,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// audit reference string for the change as supplied by admin
	//
	AuditRef string `json:"auditRef" rdl:"optional" yaml:",omitempty"`

	//
	// pending members only - name of the principal requesting the change
	//
	RequestPrincipal ResourceName `json:"requestPrincipal,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// user disabled by system based on configured group setting
	//
	SystemDisabled *int32 `json:"systemDisabled,omitempty" rdl:"optional" yaml:",omitempty"`
}

//
// NewGroupMembership - creates an initialized GroupMembership instance, returns a pointer to it
//
func NewGroupMembership(init ...*GroupMembership) *GroupMembership {
	var o *GroupMembership
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(GroupMembership)
	}
	return o.Init()
}

//
// Init - sets up the instance according to its default field values, if any
//
func (self *GroupMembership) Init() *GroupMembership {
	if self.IsMember == nil {
		d := true
		self.IsMember = &d
	}
	if self.Active == nil {
		d := true
		self.Active = &d
	}
	if self.Approved == nil {
		d := true
		self.Approved = &d
	}
	return self
}

type rawGroupMembership GroupMembership

//
// UnmarshalJSON is defined for proper JSON decoding of a GroupMembership
//
func (self *GroupMembership) UnmarshalJSON(b []byte) error {
	var m rawGroupMembership
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := GroupMembership(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (self *GroupMembership) Validate() error {
	if self.MemberName == "" {
		return fmt.Errorf("GroupMembership.memberName is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "GroupMemberName", self.MemberName)
		if !val.Valid {
			return fmt.Errorf("GroupMembership.memberName does not contain a valid GroupMemberName (%v)", val.Error)
		}
	}
	if self.GroupName != "" {
		val := rdl.Validate(ZMSSchema(), "ResourceName", self.GroupName)
		if !val.Valid {
			return fmt.Errorf("GroupMembership.groupName does not contain a valid ResourceName (%v)", val.Error)
		}
	}
	if self.AuditRef != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.AuditRef)
		if !val.Valid {
			return fmt.Errorf("GroupMembership.auditRef does not contain a valid String (%v)", val.Error)
		}
	}
	if self.RequestPrincipal != "" {
		val := rdl.Validate(ZMSSchema(), "ResourceName", self.RequestPrincipal)
		if !val.Valid {
			return fmt.Errorf("GroupMembership.requestPrincipal does not contain a valid ResourceName (%v)", val.Error)
		}
	}
	return nil
}

//
// GroupMeta - Set of metadata attributes that all groups may have and can be
// changed by domain admins.
//
type GroupMeta struct {

	//
	// Flag indicates whether or not group allows self service. Users can add
	// themselves in the group, but it has to be approved by domain admins to be
	// effective.
	//
	SelfServe *bool `json:"selfServe,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// Flag indicates whether or not group updates require another review and
	// approval
	//
	ReviewEnabled *bool `json:"reviewEnabled,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// list of roles whose members should be notified for member review/approval
	//
	NotifyRoles string `json:"notifyRoles" rdl:"optional" yaml:",omitempty"`

	//
	// membership filtered based on user authority configured attributes
	//
	UserAuthorityFilter string `json:"userAuthorityFilter" rdl:"optional" yaml:",omitempty"`

	//
	// expiration enforced by a user authority configured attribute
	//
	UserAuthorityExpiration string `json:"userAuthorityExpiration" rdl:"optional" yaml:",omitempty"`

	//
	// all user members in the group will have specified max expiry days
	//
	MemberExpiryDays *int32 `json:"memberExpiryDays,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// all services in the group will have specified max expiry days
	//
	ServiceExpiryDays *int32 `json:"serviceExpiryDays,omitempty" rdl:"optional" yaml:",omitempty"`
}

//
// NewGroupMeta - creates an initialized GroupMeta instance, returns a pointer to it
//
func NewGroupMeta(init ...*GroupMeta) *GroupMeta {
	var o *GroupMeta
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(GroupMeta)
	}
	return o
}

type rawGroupMeta GroupMeta

//
// UnmarshalJSON is defined for proper JSON decoding of a GroupMeta
//
func (self *GroupMeta) UnmarshalJSON(b []byte) error {
	var m rawGroupMeta
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := GroupMeta(m)
		*self = o
		err = self.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (self *GroupMeta) Validate() error {
	if self.NotifyRoles != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.NotifyRoles)
		if !val.Valid {
			return fmt.Errorf("GroupMeta.notifyRoles does not contain a valid String (%v)", val.Error)
		}
	}
	if self.UserAuthorityFilter != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.UserAuthorityFilter)
		if !val.Valid {
			return fmt.Errorf("GroupMeta.userAuthorityFilter does not contain a valid String (%v)", val.Error)
		}
	}
	if self.UserAuthorityExpiration != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.UserAuthorityExpiration)
		if !val.Valid {
			return fmt.Errorf("GroupMeta.userAuthorityExpiration does not contain a valid String (%v)", val.Error)
		}
	}
	return nil
}

//
// Group - The representation for a Group with set of members.
//
type Group struct {

	//
	// Flag indicates whether or not group allows self service. Users can add
	// themselves in the group, but it has to be approved by domain admins to be
	// effective.
	//
	SelfServe *bool `json:"selfServe,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// Flag indicates whether or not group updates require another review and
	// approval
	//
	ReviewEnabled *bool `json:"reviewEnabled,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// list of roles whose members should be notified for member review/approval
	//
	NotifyRoles string `json:"notifyRoles" rdl:"optional" yaml:",omitempty"`

	//
	// membership filtered based on user authority configured attributes
	//
	UserAuthorityFilter string `json:"userAuthorityFilter" rdl:"optional" yaml:",omitempty"`

	//
	// expiration enforced by a user authority configured attribute
	//
	UserAuthorityExpiration string `json:"userAuthorityExpiration" rdl:"optional" yaml:",omitempty"`

	//
	// all user members in the group will have specified max expiry days
	//
	MemberExpiryDays *int32 `json:"memberExpiryDays,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// all services in the group will have specified max expiry days
	//
	ServiceExpiryDays *int32 `json:"serviceExpiryDays,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// name of the group
	//
	Name ResourceName `json:"name"`

	//
	// last modification timestamp of the group
	//
	Modified *rdl.Timestamp `json:"modified,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// members with expiration
	//
	GroupMembers []*GroupMember `json:"groupMembers,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// an audit log for group membership changes
	//
	AuditLog []*GroupAuditLog `json:"auditLog,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// Flag indicates whether or not group updates should require GRC approval. If
	// true, the auditRef parameter must be supplied(not empty) for any API defining
	// it
	//
	AuditEnabled *bool `json:"auditEnabled,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// last review timestamp of the group
	//
	LastReviewedDate *rdl.Timestamp `json:"lastReviewedDate,omitempty" rdl:"optional" yaml:",omitempty"`
}

//
// NewGroup - creates an initialized Group instance, returns a pointer to it
//
func NewGroup(init ...*Group) *Group {
	var o *Group
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(Group)
	}
	return o
}

type rawGroup Group

//
// UnmarshalJSON is defined for proper JSON decoding of a Group
//
func (self *Group) UnmarshalJSON(b []byte) error {
	var m rawGroup
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := Group(m)
		*self = o
		err = self.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (self *Group) Validate() error {
	if self.NotifyRoles != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.NotifyRoles)
		if !val.Valid {
			return fmt.Errorf("Group.notifyRoles does not contain a valid String (%v)", val.Error)
		}
	}
	if self.UserAuthorityFilter != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.UserAuthorityFilter)
		if !val.Valid {
			return fmt.Errorf("Group.userAuthorityFilter does not contain a valid String (%v)", val.Error)
		}
	}
	if self.UserAuthorityExpiration != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.UserAuthorityExpiration)
		if !val.Valid {
			return fmt.Errorf("Group.userAuthorityExpiration does not contain a valid String (%v)", val.Error)
		}
	}
	if self.Name == "" {
		return fmt.Errorf("Group.name is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "ResourceName", self.Name)
		if !val.Valid {
			return fmt.Errorf("Group.name does not contain a valid ResourceName (%v)", val.Error)
		}
	}
	return nil
}

//
// Groups - The representation for a list of groups with full details
//
type Groups struct {

	//
	// list of group objects
	//
	List []*Group `json:"list"`
}

//
// NewGroups - creates an initialized Groups instance, returns a pointer to it
//
func NewGroups(init ...*Groups) *Groups {
	var o *Groups
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(Groups)
	}
	return o.Init()
}

//
// Init - sets up the instance according to its default field values, if any
//
func (self *Groups) Init() *Groups {
	if self.List == nil {
		self.List = make([]*Group, 0)
	}
	return self
}

type rawGroups Groups

//
// UnmarshalJSON is defined for proper JSON decoding of a Groups
//
func (self *Groups) UnmarshalJSON(b []byte) error {
	var m rawGroups
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := Groups(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (self *Groups) Validate() error {
	if self.List == nil {
		return fmt.Errorf("Groups: Missing required field: list")
	}
	return nil
}

//
// DomainGroupMember -
//
type DomainGroupMember struct {

	//
	// name of the member
	//
	MemberName GroupMemberName `json:"memberName"`

	//
	// groups for this member
	//
	MemberGroups []*GroupMember `json:"memberGroups"`
}

//
// NewDomainGroupMember - creates an initialized DomainGroupMember instance, returns a pointer to it
//
func NewDomainGroupMember(init ...*DomainGroupMember) *DomainGroupMember {
	var o *DomainGroupMember
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(DomainGroupMember)
	}
	return o.Init()
}

//
// Init - sets up the instance according to its default field values, if any
//
func (self *DomainGroupMember) Init() *DomainGroupMember {
	if self.MemberGroups == nil {
		self.MemberGroups = make([]*GroupMember, 0)
	}
	return self
}

type rawDomainGroupMember DomainGroupMember

//
// UnmarshalJSON is defined for proper JSON decoding of a DomainGroupMember
//
func (self *DomainGroupMember) UnmarshalJSON(b []byte) error {
	var m rawDomainGroupMember
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := DomainGroupMember(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (self *DomainGroupMember) Validate() error {
	if self.MemberName == "" {
		return fmt.Errorf("DomainGroupMember.memberName is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "GroupMemberName", self.MemberName)
		if !val.Valid {
			return fmt.Errorf("DomainGroupMember.memberName does not contain a valid GroupMemberName (%v)", val.Error)
		}
	}
	if self.MemberGroups == nil {
		return fmt.Errorf("DomainGroupMember: Missing required field: memberGroups")
	}
	return nil
}

//
// DomainGroupMembers -
//
type DomainGroupMembers struct {

	//
	// name of the domain
	//
	DomainName DomainName `json:"domainName"`

	//
	// group members
	//
	Members []*DomainGroupMember `json:"members"`
}

//
// NewDomainGroupMembers - creates an initialized DomainGroupMembers instance, returns a pointer to it
//
func NewDomainGroupMembers(init ...*DomainGroupMembers) *DomainGroupMembers {
	var o *DomainGroupMembers
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(DomainGroupMembers)
	}
	return o.Init()
}

//
// Init - sets up the instance according to its default field values, if any
//
func (self *DomainGroupMembers) Init() *DomainGroupMembers {
	if self.Members == nil {
		self.Members = make([]*DomainGroupMember, 0)
	}
	return self
}

type rawDomainGroupMembers DomainGroupMembers

//
// UnmarshalJSON is defined for proper JSON decoding of a DomainGroupMembers
//
func (self *DomainGroupMembers) UnmarshalJSON(b []byte) error {
	var m rawDomainGroupMembers
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := DomainGroupMembers(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (self *DomainGroupMembers) Validate() error {
	if self.DomainName == "" {
		return fmt.Errorf("DomainGroupMembers.domainName is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "DomainName", self.DomainName)
		if !val.Valid {
			return fmt.Errorf("DomainGroupMembers.domainName does not contain a valid DomainName (%v)", val.Error)
		}
	}
	if self.Members == nil {
		return fmt.Errorf("DomainGroupMembers: Missing required field: members")
	}
	return nil
}

//
// DomainGroupMembership -
//
type DomainGroupMembership struct {
	DomainGroupMembersList []*DomainGroupMembers `json:"domainGroupMembersList"`
}

//
// NewDomainGroupMembership - creates an initialized DomainGroupMembership instance, returns a pointer to it
//
func NewDomainGroupMembership(init ...*DomainGroupMembership) *DomainGroupMembership {
	var o *DomainGroupMembership
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(DomainGroupMembership)
	}
	return o.Init()
}

//
// Init - sets up the instance according to its default field values, if any
//
func (self *DomainGroupMembership) Init() *DomainGroupMembership {
	if self.DomainGroupMembersList == nil {
		self.DomainGroupMembersList = make([]*DomainGroupMembers, 0)
	}
	return self
}

type rawDomainGroupMembership DomainGroupMembership

//
// UnmarshalJSON is defined for proper JSON decoding of a DomainGroupMembership
//
func (self *DomainGroupMembership) UnmarshalJSON(b []byte) error {
	var m rawDomainGroupMembership
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := DomainGroupMembership(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (self *DomainGroupMembership) Validate() error {
	if self.DomainGroupMembersList == nil {
		return fmt.Errorf("DomainGroupMembership: Missing required field: domainGroupMembersList")
	}
	return nil
}

//
// GroupSystemMeta - Set of system metadata attributes that all groups may have
// and can be changed by system admins.
//
type GroupSystemMeta struct {

	//
	// Flag indicates whether or not group updates should be approved by GRC. If
	// true, the auditRef parameter must be supplied(not empty) for any API defining
	// it.
	//
	AuditEnabled *bool `json:"auditEnabled,omitempty" rdl:"optional" yaml:",omitempty"`
}

//
// NewGroupSystemMeta - creates an initialized GroupSystemMeta instance, returns a pointer to it
//
func NewGroupSystemMeta(init ...*GroupSystemMeta) *GroupSystemMeta {
	var o *GroupSystemMeta
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(GroupSystemMeta)
	}
	return o
}

type rawGroupSystemMeta GroupSystemMeta

//
// UnmarshalJSON is defined for proper JSON decoding of a GroupSystemMeta
//
func (self *GroupSystemMeta) UnmarshalJSON(b []byte) error {
	var m rawGroupSystemMeta
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := GroupSystemMeta(m)
		*self = o
		err = self.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (self *GroupSystemMeta) Validate() error {
	return nil
}

//
// PolicyList - The representation for an enumeration of policies in the
// namespace, with pagination.
//
type PolicyList struct {

	//
	// list of policy names
	//
	Names []EntityName `json:"names"`

	//
	// if the response is a paginated list, this attribute specifies the value to
	// be used in the next policy list request as the value for the skip query
	// parameter.
	//
	Next string `json:"next" rdl:"optional" yaml:",omitempty"`
}

//
// NewPolicyList - creates an initialized PolicyList instance, returns a pointer to it
//
func NewPolicyList(init ...*PolicyList) *PolicyList {
	var o *PolicyList
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(PolicyList)
	}
	return o.Init()
}

//
// Init - sets up the instance according to its default field values, if any
//
func (self *PolicyList) Init() *PolicyList {
	if self.Names == nil {
		self.Names = make([]EntityName, 0)
	}
	return self
}

type rawPolicyList PolicyList

//
// UnmarshalJSON is defined for proper JSON decoding of a PolicyList
//
func (self *PolicyList) UnmarshalJSON(b []byte) error {
	var m rawPolicyList
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := PolicyList(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (self *PolicyList) Validate() error {
	if self.Names == nil {
		return fmt.Errorf("PolicyList: Missing required field: names")
	}
	if self.Next != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.Next)
		if !val.Valid {
			return fmt.Errorf("PolicyList.next does not contain a valid String (%v)", val.Error)
		}
	}
	return nil
}

//
// Tenancy - A representation of tenant.
//
type Tenancy struct {

	//
	// the domain that is to get a tenancy
	//
	Domain DomainName `json:"domain"`

	//
	// the provider service on which the tenancy is to reside
	//
	Service ServiceName `json:"service"`

	//
	// registered resource groups for this tenant
	//
	ResourceGroups []EntityName `json:"resourceGroups,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// optional flag indicating whether to create a default tenancy admin role
	//
	CreateAdminRole *bool `json:"createAdminRole,omitempty" rdl:"optional" yaml:",omitempty"`
}

//
// NewTenancy - creates an initialized Tenancy instance, returns a pointer to it
//
func NewTenancy(init ...*Tenancy) *Tenancy {
	var o *Tenancy
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(Tenancy)
	}
	return o.Init()
}

//
// Init - sets up the instance according to its default field values, if any
//
func (self *Tenancy) Init() *Tenancy {
	if self.CreateAdminRole == nil {
		d := true
		self.CreateAdminRole = &d
	}
	return self
}

type rawTenancy Tenancy

//
// UnmarshalJSON is defined for proper JSON decoding of a Tenancy
//
func (self *Tenancy) UnmarshalJSON(b []byte) error {
	var m rawTenancy
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := Tenancy(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (self *Tenancy) Validate() error {
	if self.Domain == "" {
		return fmt.Errorf("Tenancy.domain is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "DomainName", self.Domain)
		if !val.Valid {
			return fmt.Errorf("Tenancy.domain does not contain a valid DomainName (%v)", val.Error)
		}
	}
	if self.Service == "" {
		return fmt.Errorf("Tenancy.service is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "ServiceName", self.Service)
		if !val.Valid {
			return fmt.Errorf("Tenancy.service does not contain a valid ServiceName (%v)", val.Error)
		}
	}
	return nil
}

//
// TenantRoleAction - A representation of tenant role action.
//
type TenantRoleAction struct {

	//
	// name of the role
	//
	Role SimpleName `json:"role"`

	//
	// action value for the generated policy assertion
	//
	Action string `json:"action"`
}

//
// NewTenantRoleAction - creates an initialized TenantRoleAction instance, returns a pointer to it
//
func NewTenantRoleAction(init ...*TenantRoleAction) *TenantRoleAction {
	var o *TenantRoleAction
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(TenantRoleAction)
	}
	return o
}

type rawTenantRoleAction TenantRoleAction

//
// UnmarshalJSON is defined for proper JSON decoding of a TenantRoleAction
//
func (self *TenantRoleAction) UnmarshalJSON(b []byte) error {
	var m rawTenantRoleAction
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := TenantRoleAction(m)
		*self = o
		err = self.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (self *TenantRoleAction) Validate() error {
	if self.Role == "" {
		return fmt.Errorf("TenantRoleAction.role is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "SimpleName", self.Role)
		if !val.Valid {
			return fmt.Errorf("TenantRoleAction.role does not contain a valid SimpleName (%v)", val.Error)
		}
	}
	if self.Action == "" {
		return fmt.Errorf("TenantRoleAction.action is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "String", self.Action)
		if !val.Valid {
			return fmt.Errorf("TenantRoleAction.action does not contain a valid String (%v)", val.Error)
		}
	}
	return nil
}

//
// TenantResourceGroupRoles - A representation of tenant roles for resource
// groups to be provisioned.
//
type TenantResourceGroupRoles struct {

	//
	// name of the provider domain
	//
	Domain DomainName `json:"domain"`

	//
	// name of the provider service
	//
	Service SimpleName `json:"service"`

	//
	// name of the tenant domain
	//
	Tenant DomainName `json:"tenant"`

	//
	// the role/action pairs to provision
	//
	Roles []*TenantRoleAction `json:"roles"`

	//
	// tenant resource group
	//
	ResourceGroup EntityName `json:"resourceGroup"`
}

//
// NewTenantResourceGroupRoles - creates an initialized TenantResourceGroupRoles instance, returns a pointer to it
//
func NewTenantResourceGroupRoles(init ...*TenantResourceGroupRoles) *TenantResourceGroupRoles {
	var o *TenantResourceGroupRoles
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(TenantResourceGroupRoles)
	}
	return o.Init()
}

//
// Init - sets up the instance according to its default field values, if any
//
func (self *TenantResourceGroupRoles) Init() *TenantResourceGroupRoles {
	if self.Roles == nil {
		self.Roles = make([]*TenantRoleAction, 0)
	}
	return self
}

type rawTenantResourceGroupRoles TenantResourceGroupRoles

//
// UnmarshalJSON is defined for proper JSON decoding of a TenantResourceGroupRoles
//
func (self *TenantResourceGroupRoles) UnmarshalJSON(b []byte) error {
	var m rawTenantResourceGroupRoles
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := TenantResourceGroupRoles(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (self *TenantResourceGroupRoles) Validate() error {
	if self.Domain == "" {
		return fmt.Errorf("TenantResourceGroupRoles.domain is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "DomainName", self.Domain)
		if !val.Valid {
			return fmt.Errorf("TenantResourceGroupRoles.domain does not contain a valid DomainName (%v)", val.Error)
		}
	}
	if self.Service == "" {
		return fmt.Errorf("TenantResourceGroupRoles.service is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "SimpleName", self.Service)
		if !val.Valid {
			return fmt.Errorf("TenantResourceGroupRoles.service does not contain a valid SimpleName (%v)", val.Error)
		}
	}
	if self.Tenant == "" {
		return fmt.Errorf("TenantResourceGroupRoles.tenant is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "DomainName", self.Tenant)
		if !val.Valid {
			return fmt.Errorf("TenantResourceGroupRoles.tenant does not contain a valid DomainName (%v)", val.Error)
		}
	}
	if self.Roles == nil {
		return fmt.Errorf("TenantResourceGroupRoles: Missing required field: roles")
	}
	if self.ResourceGroup == "" {
		return fmt.Errorf("TenantResourceGroupRoles.resourceGroup is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "EntityName", self.ResourceGroup)
		if !val.Valid {
			return fmt.Errorf("TenantResourceGroupRoles.resourceGroup does not contain a valid EntityName (%v)", val.Error)
		}
	}
	return nil
}

//
// ProviderResourceGroupRoles - A representation of provider roles to be
// provisioned.
//
type ProviderResourceGroupRoles struct {

	//
	// name of the provider domain
	//
	Domain DomainName `json:"domain"`

	//
	// name of the provider service
	//
	Service SimpleName `json:"service"`

	//
	// name of the tenant domain
	//
	Tenant DomainName `json:"tenant"`

	//
	// the role/action pairs to provision
	//
	Roles []*TenantRoleAction `json:"roles"`

	//
	// tenant resource group
	//
	ResourceGroup EntityName `json:"resourceGroup"`

	//
	// optional flag indicating whether to create a default tenancy admin role
	//
	CreateAdminRole *bool `json:"createAdminRole,omitempty" rdl:"optional" yaml:",omitempty"`
}

//
// NewProviderResourceGroupRoles - creates an initialized ProviderResourceGroupRoles instance, returns a pointer to it
//
func NewProviderResourceGroupRoles(init ...*ProviderResourceGroupRoles) *ProviderResourceGroupRoles {
	var o *ProviderResourceGroupRoles
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(ProviderResourceGroupRoles)
	}
	return o.Init()
}

//
// Init - sets up the instance according to its default field values, if any
//
func (self *ProviderResourceGroupRoles) Init() *ProviderResourceGroupRoles {
	if self.Roles == nil {
		self.Roles = make([]*TenantRoleAction, 0)
	}
	if self.CreateAdminRole == nil {
		d := true
		self.CreateAdminRole = &d
	}
	return self
}

type rawProviderResourceGroupRoles ProviderResourceGroupRoles

//
// UnmarshalJSON is defined for proper JSON decoding of a ProviderResourceGroupRoles
//
func (self *ProviderResourceGroupRoles) UnmarshalJSON(b []byte) error {
	var m rawProviderResourceGroupRoles
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := ProviderResourceGroupRoles(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (self *ProviderResourceGroupRoles) Validate() error {
	if self.Domain == "" {
		return fmt.Errorf("ProviderResourceGroupRoles.domain is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "DomainName", self.Domain)
		if !val.Valid {
			return fmt.Errorf("ProviderResourceGroupRoles.domain does not contain a valid DomainName (%v)", val.Error)
		}
	}
	if self.Service == "" {
		return fmt.Errorf("ProviderResourceGroupRoles.service is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "SimpleName", self.Service)
		if !val.Valid {
			return fmt.Errorf("ProviderResourceGroupRoles.service does not contain a valid SimpleName (%v)", val.Error)
		}
	}
	if self.Tenant == "" {
		return fmt.Errorf("ProviderResourceGroupRoles.tenant is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "DomainName", self.Tenant)
		if !val.Valid {
			return fmt.Errorf("ProviderResourceGroupRoles.tenant does not contain a valid DomainName (%v)", val.Error)
		}
	}
	if self.Roles == nil {
		return fmt.Errorf("ProviderResourceGroupRoles: Missing required field: roles")
	}
	if self.ResourceGroup == "" {
		return fmt.Errorf("ProviderResourceGroupRoles.resourceGroup is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "EntityName", self.ResourceGroup)
		if !val.Valid {
			return fmt.Errorf("ProviderResourceGroupRoles.resourceGroup does not contain a valid EntityName (%v)", val.Error)
		}
	}
	return nil
}

//
// Access - Access can be checked and returned as this resource.
//
type Access struct {

	//
	// true (allowed) or false (denied)
	//
	Granted bool `json:"granted"`
}

//
// NewAccess - creates an initialized Access instance, returns a pointer to it
//
func NewAccess(init ...*Access) *Access {
	var o *Access
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(Access)
	}
	return o
}

type rawAccess Access

//
// UnmarshalJSON is defined for proper JSON decoding of a Access
//
func (self *Access) UnmarshalJSON(b []byte) error {
	var m rawAccess
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := Access(m)
		*self = o
		err = self.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (self *Access) Validate() error {
	return nil
}

//
// ResourceAccess -
//
type ResourceAccess struct {
	Principal  ResourceName `json:"principal"`
	Assertions []*Assertion `json:"assertions"`
}

//
// NewResourceAccess - creates an initialized ResourceAccess instance, returns a pointer to it
//
func NewResourceAccess(init ...*ResourceAccess) *ResourceAccess {
	var o *ResourceAccess
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(ResourceAccess)
	}
	return o.Init()
}

//
// Init - sets up the instance according to its default field values, if any
//
func (self *ResourceAccess) Init() *ResourceAccess {
	if self.Assertions == nil {
		self.Assertions = make([]*Assertion, 0)
	}
	return self
}

type rawResourceAccess ResourceAccess

//
// UnmarshalJSON is defined for proper JSON decoding of a ResourceAccess
//
func (self *ResourceAccess) UnmarshalJSON(b []byte) error {
	var m rawResourceAccess
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := ResourceAccess(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (self *ResourceAccess) Validate() error {
	if self.Principal == "" {
		return fmt.Errorf("ResourceAccess.principal is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "ResourceName", self.Principal)
		if !val.Valid {
			return fmt.Errorf("ResourceAccess.principal does not contain a valid ResourceName (%v)", val.Error)
		}
	}
	if self.Assertions == nil {
		return fmt.Errorf("ResourceAccess: Missing required field: assertions")
	}
	return nil
}

//
// ResourceAccessList -
//
type ResourceAccessList struct {
	Resources []*ResourceAccess `json:"resources"`
}

//
// NewResourceAccessList - creates an initialized ResourceAccessList instance, returns a pointer to it
//
func NewResourceAccessList(init ...*ResourceAccessList) *ResourceAccessList {
	var o *ResourceAccessList
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(ResourceAccessList)
	}
	return o.Init()
}

//
// Init - sets up the instance according to its default field values, if any
//
func (self *ResourceAccessList) Init() *ResourceAccessList {
	if self.Resources == nil {
		self.Resources = make([]*ResourceAccess, 0)
	}
	return self
}

type rawResourceAccessList ResourceAccessList

//
// UnmarshalJSON is defined for proper JSON decoding of a ResourceAccessList
//
func (self *ResourceAccessList) UnmarshalJSON(b []byte) error {
	var m rawResourceAccessList
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := ResourceAccessList(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (self *ResourceAccessList) Validate() error {
	if self.Resources == nil {
		return fmt.Errorf("ResourceAccessList: Missing required field: resources")
	}
	return nil
}

//
// DomainPolicies - We need to include the name of the domain in this struct
// since this data will be passed back to ZPU through ZTS so we need to sign not
// only the list of policies but also the corresponding domain name that the
// policies belong to.
//
type DomainPolicies struct {

	//
	// name of the domain
	//
	Domain DomainName `json:"domain"`

	//
	// list of policies defined in this server
	//
	Policies []*Policy `json:"policies"`
}

//
// NewDomainPolicies - creates an initialized DomainPolicies instance, returns a pointer to it
//
func NewDomainPolicies(init ...*DomainPolicies) *DomainPolicies {
	var o *DomainPolicies
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(DomainPolicies)
	}
	return o.Init()
}

//
// Init - sets up the instance according to its default field values, if any
//
func (self *DomainPolicies) Init() *DomainPolicies {
	if self.Policies == nil {
		self.Policies = make([]*Policy, 0)
	}
	return self
}

type rawDomainPolicies DomainPolicies

//
// UnmarshalJSON is defined for proper JSON decoding of a DomainPolicies
//
func (self *DomainPolicies) UnmarshalJSON(b []byte) error {
	var m rawDomainPolicies
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := DomainPolicies(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (self *DomainPolicies) Validate() error {
	if self.Domain == "" {
		return fmt.Errorf("DomainPolicies.domain is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "DomainName", self.Domain)
		if !val.Valid {
			return fmt.Errorf("DomainPolicies.domain does not contain a valid DomainName (%v)", val.Error)
		}
	}
	if self.Policies == nil {
		return fmt.Errorf("DomainPolicies: Missing required field: policies")
	}
	return nil
}

//
// SignedPolicies - A signed bulk transfer of policies. The data is signed with
// server's private key.
//
type SignedPolicies struct {

	//
	// list of policies defined in a domain
	//
	Contents *DomainPolicies `json:"contents"`

	//
	// signature generated based on the domain policies object
	//
	Signature string `json:"signature"`

	//
	// the identifier of the key used to generate the signature
	//
	KeyId string `json:"keyId"`
}

//
// NewSignedPolicies - creates an initialized SignedPolicies instance, returns a pointer to it
//
func NewSignedPolicies(init ...*SignedPolicies) *SignedPolicies {
	var o *SignedPolicies
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(SignedPolicies)
	}
	return o.Init()
}

//
// Init - sets up the instance according to its default field values, if any
//
func (self *SignedPolicies) Init() *SignedPolicies {
	if self.Contents == nil {
		self.Contents = NewDomainPolicies()
	}
	return self
}

type rawSignedPolicies SignedPolicies

//
// UnmarshalJSON is defined for proper JSON decoding of a SignedPolicies
//
func (self *SignedPolicies) UnmarshalJSON(b []byte) error {
	var m rawSignedPolicies
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := SignedPolicies(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (self *SignedPolicies) Validate() error {
	if self.Contents == nil {
		return fmt.Errorf("SignedPolicies: Missing required field: contents")
	}
	if self.Signature == "" {
		return fmt.Errorf("SignedPolicies.signature is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "String", self.Signature)
		if !val.Valid {
			return fmt.Errorf("SignedPolicies.signature does not contain a valid String (%v)", val.Error)
		}
	}
	if self.KeyId == "" {
		return fmt.Errorf("SignedPolicies.keyId is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "String", self.KeyId)
		if !val.Valid {
			return fmt.Errorf("SignedPolicies.keyId does not contain a valid String (%v)", val.Error)
		}
	}
	return nil
}

//
// DomainData - A domain object that includes its roles, policies and services.
//
type DomainData struct {

	//
	// a description of the domain
	//
	Description string `json:"description" rdl:"optional" yaml:",omitempty"`

	//
	// a reference to an audit organization defined in athenz
	//
	Org ResourceName `json:"org,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// Future use only, currently not used
	//
	Enabled *bool `json:"enabled,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// Flag indicates whether or not domain modifications should be logged for
	// SOX+Auditing. If true, the auditRef parameter must be supplied(not empty) for
	// any API defining it.
	//
	AuditEnabled *bool `json:"auditEnabled,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// associated aws account id (system attribute - uniqueness check)
	//
	Account string `json:"account" rdl:"optional" yaml:",omitempty"`

	//
	// associated product id (system attribute - uniqueness check)
	//
	YpmId *int32 `json:"ypmId,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// associated application id
	//
	ApplicationId string `json:"applicationId" rdl:"optional" yaml:",omitempty"`

	//
	// domain certificate dns domain (system attribute)
	//
	CertDnsDomain string `json:"certDnsDomain" rdl:"optional" yaml:",omitempty"`

	//
	// all user members in the domain will have specified max expiry days
	//
	MemberExpiryDays *int32 `json:"memberExpiryDays,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// tokens issued for this domain will have specified max timeout in mins
	//
	TokenExpiryMins *int32 `json:"tokenExpiryMins,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// service identity certs issued for this domain will have specified max
	// timeout in mins
	//
	ServiceCertExpiryMins *int32 `json:"serviceCertExpiryMins,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// role certs issued for this domain will have specified max timeout in mins
	//
	RoleCertExpiryMins *int32 `json:"roleCertExpiryMins,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// rsa or ec signing algorithm to be used for tokens
	//
	SignAlgorithm SimpleName `json:"signAlgorithm,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// all services in the domain roles will have specified max expiry days
	//
	ServiceExpiryDays *int32 `json:"serviceExpiryDays,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// all groups in the domain roles will have specified max expiry days
	//
	GroupExpiryDays *int32 `json:"groupExpiryDays,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// membership filtered based on user authority configured attributes
	//
	UserAuthorityFilter string `json:"userAuthorityFilter" rdl:"optional" yaml:",omitempty"`

	//
	// associated azure subscription id (system attribute - uniqueness check)
	//
	AzureSubscription string `json:"azureSubscription" rdl:"optional" yaml:",omitempty"`

	//
	// key-value pair tags, tag might contain multiple values
	//
	Tags map[CompoundName]*TagValueList `json:"tags,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// associated business service with domain
	//
	BusinessService string `json:"businessService" rdl:"optional" yaml:",omitempty"`

	//
	// name of the domain
	//
	Name DomainName `json:"name"`

	//
	// list of roles in the domain
	//
	Roles []*Role `json:"roles"`

	//
	// list of policies in the domain signed with ZMS private key
	//
	Policies *SignedPolicies `json:"policies"`

	//
	// list of services in the domain
	//
	Services []*ServiceIdentity `json:"services"`

	//
	// list of entities in the domain
	//
	Entities []*Entity `json:"entities"`

	//
	// list of groups in the domain
	//
	Groups []*Group `json:"groups"`

	//
	// last modification timestamp
	//
	Modified rdl.Timestamp `json:"modified"`
}

//
// NewDomainData - creates an initialized DomainData instance, returns a pointer to it
//
func NewDomainData(init ...*DomainData) *DomainData {
	var o *DomainData
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(DomainData)
	}
	return o.Init()
}

//
// Init - sets up the instance according to its default field values, if any
//
func (self *DomainData) Init() *DomainData {
	if self.Enabled == nil {
		d := true
		self.Enabled = &d
	}
	if self.AuditEnabled == nil {
		d := false
		self.AuditEnabled = &d
	}
	if self.Roles == nil {
		self.Roles = make([]*Role, 0)
	}
	if self.Policies == nil {
		self.Policies = NewSignedPolicies()
	}
	if self.Services == nil {
		self.Services = make([]*ServiceIdentity, 0)
	}
	if self.Entities == nil {
		self.Entities = make([]*Entity, 0)
	}
	if self.Groups == nil {
		self.Groups = make([]*Group, 0)
	}
	return self
}

type rawDomainData DomainData

//
// UnmarshalJSON is defined for proper JSON decoding of a DomainData
//
func (self *DomainData) UnmarshalJSON(b []byte) error {
	var m rawDomainData
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := DomainData(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (self *DomainData) Validate() error {
	if self.Description != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.Description)
		if !val.Valid {
			return fmt.Errorf("DomainData.description does not contain a valid String (%v)", val.Error)
		}
	}
	if self.Org != "" {
		val := rdl.Validate(ZMSSchema(), "ResourceName", self.Org)
		if !val.Valid {
			return fmt.Errorf("DomainData.org does not contain a valid ResourceName (%v)", val.Error)
		}
	}
	if self.Account != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.Account)
		if !val.Valid {
			return fmt.Errorf("DomainData.account does not contain a valid String (%v)", val.Error)
		}
	}
	if self.ApplicationId != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.ApplicationId)
		if !val.Valid {
			return fmt.Errorf("DomainData.applicationId does not contain a valid String (%v)", val.Error)
		}
	}
	if self.CertDnsDomain != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.CertDnsDomain)
		if !val.Valid {
			return fmt.Errorf("DomainData.certDnsDomain does not contain a valid String (%v)", val.Error)
		}
	}
	if self.SignAlgorithm != "" {
		val := rdl.Validate(ZMSSchema(), "SimpleName", self.SignAlgorithm)
		if !val.Valid {
			return fmt.Errorf("DomainData.signAlgorithm does not contain a valid SimpleName (%v)", val.Error)
		}
	}
	if self.UserAuthorityFilter != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.UserAuthorityFilter)
		if !val.Valid {
			return fmt.Errorf("DomainData.userAuthorityFilter does not contain a valid String (%v)", val.Error)
		}
	}
	if self.AzureSubscription != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.AzureSubscription)
		if !val.Valid {
			return fmt.Errorf("DomainData.azureSubscription does not contain a valid String (%v)", val.Error)
		}
	}
	if self.BusinessService != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.BusinessService)
		if !val.Valid {
			return fmt.Errorf("DomainData.businessService does not contain a valid String (%v)", val.Error)
		}
	}
	if self.Name == "" {
		return fmt.Errorf("DomainData.name is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "DomainName", self.Name)
		if !val.Valid {
			return fmt.Errorf("DomainData.name does not contain a valid DomainName (%v)", val.Error)
		}
	}
	if self.Roles == nil {
		return fmt.Errorf("DomainData: Missing required field: roles")
	}
	if self.Policies == nil {
		return fmt.Errorf("DomainData: Missing required field: policies")
	}
	if self.Services == nil {
		return fmt.Errorf("DomainData: Missing required field: services")
	}
	if self.Entities == nil {
		return fmt.Errorf("DomainData: Missing required field: entities")
	}
	if self.Groups == nil {
		return fmt.Errorf("DomainData: Missing required field: groups")
	}
	if self.Modified.IsZero() {
		return fmt.Errorf("DomainData: Missing required field: modified")
	}
	return nil
}

//
// SignedDomain - A domain object signed with server's private key. The
// signature and keyid are optional if the metaonly flag is set to true in the
// getSignedDomains api call
//
type SignedDomain struct {

	//
	// domain object with its roles, policies and services
	//
	Domain *DomainData `json:"domain"`

	//
	// signature generated based on the domain object
	//
	Signature string `json:"signature" rdl:"optional" yaml:",omitempty"`

	//
	// the identifier of the key used to generate the signature
	//
	KeyId string `json:"keyId" rdl:"optional" yaml:",omitempty"`
}

//
// NewSignedDomain - creates an initialized SignedDomain instance, returns a pointer to it
//
func NewSignedDomain(init ...*SignedDomain) *SignedDomain {
	var o *SignedDomain
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(SignedDomain)
	}
	return o.Init()
}

//
// Init - sets up the instance according to its default field values, if any
//
func (self *SignedDomain) Init() *SignedDomain {
	if self.Domain == nil {
		self.Domain = NewDomainData()
	}
	return self
}

type rawSignedDomain SignedDomain

//
// UnmarshalJSON is defined for proper JSON decoding of a SignedDomain
//
func (self *SignedDomain) UnmarshalJSON(b []byte) error {
	var m rawSignedDomain
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := SignedDomain(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (self *SignedDomain) Validate() error {
	if self.Domain == nil {
		return fmt.Errorf("SignedDomain: Missing required field: domain")
	}
	if self.Signature != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.Signature)
		if !val.Valid {
			return fmt.Errorf("SignedDomain.signature does not contain a valid String (%v)", val.Error)
		}
	}
	if self.KeyId != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.KeyId)
		if !val.Valid {
			return fmt.Errorf("SignedDomain.keyId does not contain a valid String (%v)", val.Error)
		}
	}
	return nil
}

//
// SignedDomains - A list of signed domain objects
//
type SignedDomains struct {
	Domains []*SignedDomain `json:"domains"`
}

//
// NewSignedDomains - creates an initialized SignedDomains instance, returns a pointer to it
//
func NewSignedDomains(init ...*SignedDomains) *SignedDomains {
	var o *SignedDomains
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(SignedDomains)
	}
	return o.Init()
}

//
// Init - sets up the instance according to its default field values, if any
//
func (self *SignedDomains) Init() *SignedDomains {
	if self.Domains == nil {
		self.Domains = make([]*SignedDomain, 0)
	}
	return self
}

type rawSignedDomains SignedDomains

//
// UnmarshalJSON is defined for proper JSON decoding of a SignedDomains
//
func (self *SignedDomains) UnmarshalJSON(b []byte) error {
	var m rawSignedDomains
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := SignedDomains(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (self *SignedDomains) Validate() error {
	if self.Domains == nil {
		return fmt.Errorf("SignedDomains: Missing required field: domains")
	}
	return nil
}

//
// JWSDomain - SignedDomain using flattened JWS JSON Serialization syntax.
// https://tools.ietf.org/html/rfc7515#section-7.2.2
//
type JWSDomain struct {
	Payload   string            `json:"payload"`
	Protected string            `json:"protected"`
	Header    map[string]string `json:"header"`
	Signature string            `json:"signature"`
}

//
// NewJWSDomain - creates an initialized JWSDomain instance, returns a pointer to it
//
func NewJWSDomain(init ...*JWSDomain) *JWSDomain {
	var o *JWSDomain
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(JWSDomain)
	}
	return o.Init()
}

//
// Init - sets up the instance according to its default field values, if any
//
func (self *JWSDomain) Init() *JWSDomain {
	if self.Header == nil {
		self.Header = make(map[string]string)
	}
	return self
}

type rawJWSDomain JWSDomain

//
// UnmarshalJSON is defined for proper JSON decoding of a JWSDomain
//
func (self *JWSDomain) UnmarshalJSON(b []byte) error {
	var m rawJWSDomain
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := JWSDomain(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (self *JWSDomain) Validate() error {
	if self.Payload == "" {
		return fmt.Errorf("JWSDomain.payload is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "String", self.Payload)
		if !val.Valid {
			return fmt.Errorf("JWSDomain.payload does not contain a valid String (%v)", val.Error)
		}
	}
	if self.Protected == "" {
		return fmt.Errorf("JWSDomain.protected is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "String", self.Protected)
		if !val.Valid {
			return fmt.Errorf("JWSDomain.protected does not contain a valid String (%v)", val.Error)
		}
	}
	if self.Header == nil {
		return fmt.Errorf("JWSDomain: Missing required field: header")
	}
	if self.Signature == "" {
		return fmt.Errorf("JWSDomain.signature is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "String", self.Signature)
		if !val.Valid {
			return fmt.Errorf("JWSDomain.signature does not contain a valid String (%v)", val.Error)
		}
	}
	return nil
}

//
// UserToken - A user token generated based on user's credentials
//
type UserToken struct {

	//
	// Signed user token identifying a specific authenticated user
	//
	Token SignedToken `json:"token"`

	//
	// Authorization header name for the token
	//
	Header string `json:"header" rdl:"optional" yaml:",omitempty"`
}

//
// NewUserToken - creates an initialized UserToken instance, returns a pointer to it
//
func NewUserToken(init ...*UserToken) *UserToken {
	var o *UserToken
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(UserToken)
	}
	return o
}

type rawUserToken UserToken

//
// UnmarshalJSON is defined for proper JSON decoding of a UserToken
//
func (self *UserToken) UnmarshalJSON(b []byte) error {
	var m rawUserToken
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := UserToken(m)
		*self = o
		err = self.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (self *UserToken) Validate() error {
	if self.Token == "" {
		return fmt.Errorf("UserToken.token is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "SignedToken", self.Token)
		if !val.Valid {
			return fmt.Errorf("UserToken.token does not contain a valid SignedToken (%v)", val.Error)
		}
	}
	if self.Header != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.Header)
		if !val.Valid {
			return fmt.Errorf("UserToken.header does not contain a valid String (%v)", val.Error)
		}
	}
	return nil
}

//
// ServicePrincipal - A service principal object identifying a given service.
//
type ServicePrincipal struct {

	//
	// name of the domain
	//
	Domain DomainName `json:"domain"`

	//
	// name of the service
	//
	Service EntityName `json:"service"`

	//
	// service's signed token
	//
	Token SignedToken `json:"token"`
}

//
// NewServicePrincipal - creates an initialized ServicePrincipal instance, returns a pointer to it
//
func NewServicePrincipal(init ...*ServicePrincipal) *ServicePrincipal {
	var o *ServicePrincipal
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(ServicePrincipal)
	}
	return o
}

type rawServicePrincipal ServicePrincipal

//
// UnmarshalJSON is defined for proper JSON decoding of a ServicePrincipal
//
func (self *ServicePrincipal) UnmarshalJSON(b []byte) error {
	var m rawServicePrincipal
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := ServicePrincipal(m)
		*self = o
		err = self.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (self *ServicePrincipal) Validate() error {
	if self.Domain == "" {
		return fmt.Errorf("ServicePrincipal.domain is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "DomainName", self.Domain)
		if !val.Valid {
			return fmt.Errorf("ServicePrincipal.domain does not contain a valid DomainName (%v)", val.Error)
		}
	}
	if self.Service == "" {
		return fmt.Errorf("ServicePrincipal.service is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "EntityName", self.Service)
		if !val.Valid {
			return fmt.Errorf("ServicePrincipal.service does not contain a valid EntityName (%v)", val.Error)
		}
	}
	if self.Token == "" {
		return fmt.Errorf("ServicePrincipal.token is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "SignedToken", self.Token)
		if !val.Valid {
			return fmt.Errorf("ServicePrincipal.token does not contain a valid SignedToken (%v)", val.Error)
		}
	}
	return nil
}

//
// User - The representation for a user
//
type User struct {

	//
	// name of the user
	//
	Name SimpleName `json:"name"`
}

//
// NewUser - creates an initialized User instance, returns a pointer to it
//
func NewUser(init ...*User) *User {
	var o *User
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(User)
	}
	return o
}

type rawUser User

//
// UnmarshalJSON is defined for proper JSON decoding of a User
//
func (self *User) UnmarshalJSON(b []byte) error {
	var m rawUser
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := User(m)
		*self = o
		err = self.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (self *User) Validate() error {
	if self.Name == "" {
		return fmt.Errorf("User.name is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "SimpleName", self.Name)
		if !val.Valid {
			return fmt.Errorf("User.name does not contain a valid SimpleName (%v)", val.Error)
		}
	}
	return nil
}

//
// UserList -
//
type UserList struct {

	//
	// list of user names
	//
	Names []SimpleName `json:"names"`
}

//
// NewUserList - creates an initialized UserList instance, returns a pointer to it
//
func NewUserList(init ...*UserList) *UserList {
	var o *UserList
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(UserList)
	}
	return o.Init()
}

//
// Init - sets up the instance according to its default field values, if any
//
func (self *UserList) Init() *UserList {
	if self.Names == nil {
		self.Names = make([]SimpleName, 0)
	}
	return self
}

type rawUserList UserList

//
// UnmarshalJSON is defined for proper JSON decoding of a UserList
//
func (self *UserList) UnmarshalJSON(b []byte) error {
	var m rawUserList
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := UserList(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (self *UserList) Validate() error {
	if self.Names == nil {
		return fmt.Errorf("UserList: Missing required field: names")
	}
	return nil
}

//
// Quota - The representation for a quota object
//
type Quota struct {

	//
	// name of the domain object
	//
	Name DomainName `json:"name"`

	//
	// number of subdomains allowed (applied at top level domain level)
	//
	Subdomain int32 `json:"subdomain"`

	//
	// number of roles allowed
	//
	Role int32 `json:"role"`

	//
	// number of members a role may have
	//
	RoleMember int32 `json:"roleMember"`

	//
	// number of policies allowed
	//
	Policy int32 `json:"policy"`

	//
	// total number of assertions a policy may have
	//
	Assertion int32 `json:"assertion"`

	//
	// total number of entity objects
	//
	Entity int32 `json:"entity"`

	//
	// number of services allowed
	//
	Service int32 `json:"service"`

	//
	// number of hosts allowed per service
	//
	ServiceHost int32 `json:"serviceHost"`

	//
	// number of public keys per service
	//
	PublicKey int32 `json:"publicKey"`

	//
	// number of groups per domain
	//
	Group int32 `json:"group"`

	//
	// number of members a group may have
	//
	GroupMember int32 `json:"groupMember"`

	//
	// the last modification timestamp of the quota object
	//
	Modified *rdl.Timestamp `json:"modified,omitempty" rdl:"optional" yaml:",omitempty"`
}

//
// NewQuota - creates an initialized Quota instance, returns a pointer to it
//
func NewQuota(init ...*Quota) *Quota {
	var o *Quota
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(Quota)
	}
	return o
}

type rawQuota Quota

//
// UnmarshalJSON is defined for proper JSON decoding of a Quota
//
func (self *Quota) UnmarshalJSON(b []byte) error {
	var m rawQuota
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := Quota(m)
		*self = o
		err = self.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (self *Quota) Validate() error {
	if self.Name == "" {
		return fmt.Errorf("Quota.name is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "DomainName", self.Name)
		if !val.Valid {
			return fmt.Errorf("Quota.name does not contain a valid DomainName (%v)", val.Error)
		}
	}
	return nil
}

//
// Status - The representation for a status object
//
type Status struct {

	//
	// status message code
	//
	Code int32 `json:"code"`

	//
	// status message of the server
	//
	Message string `json:"message"`
}

//
// NewStatus - creates an initialized Status instance, returns a pointer to it
//
func NewStatus(init ...*Status) *Status {
	var o *Status
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(Status)
	}
	return o
}

type rawStatus Status

//
// UnmarshalJSON is defined for proper JSON decoding of a Status
//
func (self *Status) UnmarshalJSON(b []byte) error {
	var m rawStatus
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := Status(m)
		*self = o
		err = self.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (self *Status) Validate() error {
	if self.Message == "" {
		return fmt.Errorf("Status.message is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "String", self.Message)
		if !val.Valid {
			return fmt.Errorf("Status.message does not contain a valid String (%v)", val.Error)
		}
	}
	return nil
}

//
// DomainRoleMembership -
//
type DomainRoleMembership struct {
	DomainRoleMembersList []*DomainRoleMembers `json:"domainRoleMembersList"`
}

//
// NewDomainRoleMembership - creates an initialized DomainRoleMembership instance, returns a pointer to it
//
func NewDomainRoleMembership(init ...*DomainRoleMembership) *DomainRoleMembership {
	var o *DomainRoleMembership
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(DomainRoleMembership)
	}
	return o.Init()
}

//
// Init - sets up the instance according to its default field values, if any
//
func (self *DomainRoleMembership) Init() *DomainRoleMembership {
	if self.DomainRoleMembersList == nil {
		self.DomainRoleMembersList = make([]*DomainRoleMembers, 0)
	}
	return self
}

type rawDomainRoleMembership DomainRoleMembership

//
// UnmarshalJSON is defined for proper JSON decoding of a DomainRoleMembership
//
func (self *DomainRoleMembership) UnmarshalJSON(b []byte) error {
	var m rawDomainRoleMembership
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := DomainRoleMembership(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (self *DomainRoleMembership) Validate() error {
	if self.DomainRoleMembersList == nil {
		return fmt.Errorf("DomainRoleMembership: Missing required field: domainRoleMembersList")
	}
	return nil
}

//
// UserAuthorityAttributes - Copyright Athenz Authors Licensed under the terms
// of the Apache version 2.0 license. See LICENSE file for terms.
//
type UserAuthorityAttributes struct {
	Values []string `json:"values"`
}

//
// NewUserAuthorityAttributes - creates an initialized UserAuthorityAttributes instance, returns a pointer to it
//
func NewUserAuthorityAttributes(init ...*UserAuthorityAttributes) *UserAuthorityAttributes {
	var o *UserAuthorityAttributes
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(UserAuthorityAttributes)
	}
	return o.Init()
}

//
// Init - sets up the instance according to its default field values, if any
//
func (self *UserAuthorityAttributes) Init() *UserAuthorityAttributes {
	if self.Values == nil {
		self.Values = make([]string, 0)
	}
	return self
}

type rawUserAuthorityAttributes UserAuthorityAttributes

//
// UnmarshalJSON is defined for proper JSON decoding of a UserAuthorityAttributes
//
func (self *UserAuthorityAttributes) UnmarshalJSON(b []byte) error {
	var m rawUserAuthorityAttributes
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := UserAuthorityAttributes(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (self *UserAuthorityAttributes) Validate() error {
	if self.Values == nil {
		return fmt.Errorf("UserAuthorityAttributes: Missing required field: values")
	}
	return nil
}

//
// UserAuthorityAttributeMap - Map of user authority attributes
//
type UserAuthorityAttributeMap struct {

	//
	// map of type to attribute values
	//
	Attributes map[SimpleName]*UserAuthorityAttributes `json:"attributes"`
}

//
// NewUserAuthorityAttributeMap - creates an initialized UserAuthorityAttributeMap instance, returns a pointer to it
//
func NewUserAuthorityAttributeMap(init ...*UserAuthorityAttributeMap) *UserAuthorityAttributeMap {
	var o *UserAuthorityAttributeMap
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(UserAuthorityAttributeMap)
	}
	return o.Init()
}

//
// Init - sets up the instance according to its default field values, if any
//
func (self *UserAuthorityAttributeMap) Init() *UserAuthorityAttributeMap {
	if self.Attributes == nil {
		self.Attributes = make(map[SimpleName]*UserAuthorityAttributes)
	}
	return self
}

type rawUserAuthorityAttributeMap UserAuthorityAttributeMap

//
// UnmarshalJSON is defined for proper JSON decoding of a UserAuthorityAttributeMap
//
func (self *UserAuthorityAttributeMap) UnmarshalJSON(b []byte) error {
	var m rawUserAuthorityAttributeMap
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := UserAuthorityAttributeMap(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (self *UserAuthorityAttributeMap) Validate() error {
	if self.Attributes == nil {
		return fmt.Errorf("UserAuthorityAttributeMap: Missing required field: attributes")
	}
	return nil
}
