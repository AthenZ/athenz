//
// This file generated by rdl 1.4.10
//

package zms

import (
	"encoding/json"
	"fmt"
	rdl "github.com/ardielle/ardielle-go/rdl"
)

var _ = rdl.Version
var _ = json.Marshal
var _ = fmt.Printf

//
// SimpleName - Copyright 2016 Yahoo Inc. Licensed under the terms of the
// Apache version 2.0 license. See LICENSE file for terms. Common name types
// used by several API definitions A simple identifier, an element of compound
// name.
//
type SimpleName string

//
// CompoundName - A compound name. Most names in this API are compound names.
//
type CompoundName string

//
// DomainName - A domain name is the general qualifier prefix, as its
// uniqueness is managed.
//
type DomainName string

//
// EntityName - An entity name is a short form of a resource name, including
// only the domain and entity.
//
type EntityName string

//
// ServiceName - A service name will generally be a unique subdomain.
//
type ServiceName string

//
// LocationName - A location name is not yet defined, but will be a dotted name
// like everything else.
//
type LocationName string

//
// ActionName - An action (operation) name.
//
type ActionName string

//
// ResourceName - A shorthand for a YRN with no service or location. The 'tail'
// of a YRN, just the domain:entity. Note that the EntityName part is optional,
// that is, a domain name followed by a colon is valid resource name.
//
type ResourceName string

//
// YRN - A full Yahoo Resource name (YRN).
//
type YRN string

//
// YBase64 - The Y-specific URL-safe Base64 variant.
//
type YBase64 string

//
// YEncoded - YEncoded includes ybase64 chars, as well as = and %. This can
// represent a user cookie and URL-encoded values.
//
type YEncoded string

//
// AuthorityName - Used as the prefix in a signed assertion. This uniquely
// identifies a signing authority. i.e. "user"
//
type AuthorityName string

//
// SignedToken - A signed assertion if identity. i.e. the user cookie value.
// This token will only make sense to the authority that generated it, so it is
// beneficial to have something in the value that is cheaply recognized to
// quickly reject if it belongs to another authority. In addition to the
// YEncoded set our token includes ; to separate components and , to separate
// roles and : for IPv6 addresses
//
type SignedToken string

//
// Domain - A domain is an independent partition of users, roles, and
// resources. Its name represents the definition of a namespace; the only way a
// new namespace can be created, from the top, is by creating Domains.
// Administration of a domain is governed by the parent domain (using
// reverse-DNS namespaces). The top level domains are governed by the special
// "sys.auth" domain.
//
type Domain struct {

	//
	// the common name to be referred to, the symbolic id. It is immutable
	//
	Name DomainName `json:"name"`

	//
	// the last modification timestamp of any object or attribute in this domain
	//
	Modified *rdl.Timestamp `json:"modified,omitempty" rdl:"optional"`

	//
	// unique identifier of the domain. generated on create, never reused
	//
	Id *rdl.UUID `json:"id,omitempty" rdl:"optional"`

	//
	// description of the domain
	//
	Description string `json:"description,omitempty" rdl:"optional"`

	//
	// a reference to an Organization
	//
	Org ResourceName `json:"org,omitempty" rdl:"optional"`

	//
	// Future use only, currently not used
	//
	Enabled *bool `json:"enabled,omitempty" rdl:"optional"`

	//
	// Flag indicates whether or not domain modifications should be logged for
	// SOX+Auditing. If true, the auditRef parameter must be supplied(not empty) for
	// any API defining it.
	//
	AuditEnabled *bool `json:"auditEnabled,omitempty" rdl:"optional"`

	//
	// associated cloud (i.e. aws) account id
	//
	Account string `json:"account,omitempty" rdl:"optional"`

	//
	// associated product id
	//
	YpmId *int32 `json:"ypmId,omitempty" rdl:"optional"`
}

//
// NewDomain - creates an initialized Domain instance, returns a pointer to it
//
func NewDomain(init ...*Domain) *Domain {
	var o *Domain
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(Domain)
	}
	return o.Init()
}

//
// Init - sets up the instance according to its default field values, if any
//
func (pTypeDef *Domain) Init() *Domain {
	if pTypeDef.Enabled == nil {
		d := true
		pTypeDef.Enabled = &d
	}
	if pTypeDef.AuditEnabled == nil {
		d := false
		pTypeDef.AuditEnabled = &d
	}
	return pTypeDef
}

type rawDomain Domain

//
// UnmarshalJSON is defined for proper JSON decoding of a Domain
//
func (pTypeDef *Domain) UnmarshalJSON(b []byte) error {
	var r rawDomain
	err := json.Unmarshal(b, &r)
	if err == nil {
		o := Domain(r)
		*pTypeDef = *((&o).Init())
		err = pTypeDef.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (pTypeDef *Domain) Validate() error {
	if pTypeDef.Name == "" {
		return fmt.Errorf("Domain.name is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "DomainName", pTypeDef.Name)
		if !val.Valid {
			return fmt.Errorf("Domain.name does not contain a valid DomainName (%v)", val.Error)
		}
	}
	return nil
}

//
// RoleList - The representation for an enumeration of roles in the namespace,
// with pagination.
//
type RoleList struct {

	//
	// list of role names
	//
	Names []EntityName `json:"names"`

	//
	// if the response is a paginated list, this attribute specifies the value to
	// be used in the next role list request as the value for the skip query
	// parameter.
	//
	Next string `json:"next,omitempty" rdl:"optional"`
}

//
// NewRoleList - creates an initialized RoleList instance, returns a pointer to it
//
func NewRoleList(init ...*RoleList) *RoleList {
	var o *RoleList
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(RoleList)
	}
	return o.Init()
}

//
// Init - sets up the instance according to its default field values, if any
//
func (pTypeDef *RoleList) Init() *RoleList {
	if pTypeDef.Names == nil {
		pTypeDef.Names = make([]EntityName, 0)
	}
	return pTypeDef
}

type rawRoleList RoleList

//
// UnmarshalJSON is defined for proper JSON decoding of a RoleList
//
func (pTypeDef *RoleList) UnmarshalJSON(b []byte) error {
	var r rawRoleList
	err := json.Unmarshal(b, &r)
	if err == nil {
		o := RoleList(r)
		*pTypeDef = *((&o).Init())
		err = pTypeDef.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (pTypeDef *RoleList) Validate() error {
	if pTypeDef.Names == nil {
		return fmt.Errorf("RoleList: Missing required field: names")
	}
	return nil
}

//
// RoleAuditLog - An audit log entry for role membership change.
//
type RoleAuditLog struct {

	//
	// name of the role member
	//
	Member ResourceName `json:"member"`

	//
	// name of the principal executing the change
	//
	Admin ResourceName `json:"admin"`

	//
	// timestamp of the entry
	//
	Created rdl.Timestamp `json:"created"`

	//
	// log action - either add or delete
	//
	Action string `json:"action"`

	//
	// audit reference string for the change as supplied by admin
	//
	AuditRef string `json:"auditRef,omitempty" rdl:"optional"`
}

//
// NewRoleAuditLog - creates an initialized RoleAuditLog instance, returns a pointer to it
//
func NewRoleAuditLog(init ...*RoleAuditLog) *RoleAuditLog {
	var o *RoleAuditLog
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(RoleAuditLog)
	}
	return o
}

type rawRoleAuditLog RoleAuditLog

//
// UnmarshalJSON is defined for proper JSON decoding of a RoleAuditLog
//
func (pTypeDef *RoleAuditLog) UnmarshalJSON(b []byte) error {
	var r rawRoleAuditLog
	err := json.Unmarshal(b, &r)
	if err == nil {
		o := RoleAuditLog(r)
		*pTypeDef = o
		err = pTypeDef.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (pTypeDef *RoleAuditLog) Validate() error {
	if pTypeDef.Member == "" {
		return fmt.Errorf("RoleAuditLog.member is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "ResourceName", pTypeDef.Member)
		if !val.Valid {
			return fmt.Errorf("RoleAuditLog.member does not contain a valid ResourceName (%v)", val.Error)
		}
	}
	if pTypeDef.Admin == "" {
		return fmt.Errorf("RoleAuditLog.admin is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "ResourceName", pTypeDef.Admin)
		if !val.Valid {
			return fmt.Errorf("RoleAuditLog.admin does not contain a valid ResourceName (%v)", val.Error)
		}
	}
	if pTypeDef.Created.IsZero() {
		return fmt.Errorf("RoleAuditLog: Missing required field: created")
	}
	if pTypeDef.Action == "" {
		return fmt.Errorf("RoleAuditLog.action is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "String", pTypeDef.Action)
		if !val.Valid {
			return fmt.Errorf("RoleAuditLog.action does not contain a valid String (%v)", val.Error)
		}
	}
	return nil
}

//
// RoleMember -
//
type RoleMember struct {

	//
	// name of the member
	//
	MemberName ResourceName `json:"memberName"`

	//
	// the expiration timestamp
	//
	Expiration *rdl.Timestamp `json:"expiration,omitempty" rdl:"optional"`
}

//
// NewRoleMember - creates an initialized RoleMember instance, returns a pointer to it
//
func NewRoleMember(init ...*RoleMember) *RoleMember {
	var o *RoleMember
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(RoleMember)
	}
	return o
}

type rawRoleMember RoleMember

//
// UnmarshalJSON is defined for proper JSON decoding of a RoleMember
//
func (pTypeDef *RoleMember) UnmarshalJSON(b []byte) error {
	var r rawRoleMember
	err := json.Unmarshal(b, &r)
	if err == nil {
		o := RoleMember(r)
		*pTypeDef = o
		err = pTypeDef.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (pTypeDef *RoleMember) Validate() error {
	if pTypeDef.MemberName == "" {
		return fmt.Errorf("RoleMember.memberName is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "ResourceName", pTypeDef.MemberName)
		if !val.Valid {
			return fmt.Errorf("RoleMember.memberName does not contain a valid ResourceName (%v)", val.Error)
		}
	}
	return nil
}

//
// Role - The representation for a Role with set of members.
//
type Role struct {

	//
	// name of the role
	//
	Name ResourceName `json:"name"`

	//
	// last modification timestamp of the role
	//
	Modified *rdl.Timestamp `json:"modified,omitempty" rdl:"optional"`

	//
	// an explicit list of members. Might be empty or null, if trust is set
	//
	Members []ResourceName `json:"members,omitempty" rdl:"optional"`

	//
	// members with expiration
	//
	RoleMembers []*RoleMember `json:"roleMembers,omitempty" rdl:"optional"`

	//
	// a trusted domain to delegate membership decisions to
	//
	Trust DomainName `json:"trust,omitempty" rdl:"optional"`

	//
	// an audit log for role membership changes
	//
	AuditLog []*RoleAuditLog `json:"auditLog,omitempty" rdl:"optional"`
}

//
// NewRole - creates an initialized Role instance, returns a pointer to it
//
func NewRole(init ...*Role) *Role {
	var o *Role
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(Role)
	}
	return o
}

type rawRole Role

//
// UnmarshalJSON is defined for proper JSON decoding of a Role
//
func (pTypeDef *Role) UnmarshalJSON(b []byte) error {
	var r rawRole
	err := json.Unmarshal(b, &r)
	if err == nil {
		o := Role(r)
		*pTypeDef = o
		err = pTypeDef.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (pTypeDef *Role) Validate() error {
	if pTypeDef.Name == "" {
		return fmt.Errorf("Role.name is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "ResourceName", pTypeDef.Name)
		if !val.Valid {
			return fmt.Errorf("Role.name does not contain a valid ResourceName (%v)", val.Error)
		}
	}
	return nil
}

//
// Roles - The representation for a list of roles with full details
//
type Roles struct {

	//
	// list of role objects
	//
	List []*Role `json:"list"`
}

//
// NewRoles - creates an initialized Roles instance, returns a pointer to it
//
func NewRoles(init ...*Roles) *Roles {
	var o *Roles
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(Roles)
	}
	return o.Init()
}

//
// Init - sets up the instance according to its default field values, if any
//
func (pTypeDef *Roles) Init() *Roles {
	if pTypeDef.List == nil {
		pTypeDef.List = make([]*Role, 0)
	}
	return pTypeDef
}

type rawRoles Roles

//
// UnmarshalJSON is defined for proper JSON decoding of a Roles
//
func (pTypeDef *Roles) UnmarshalJSON(b []byte) error {
	var r rawRoles
	err := json.Unmarshal(b, &r)
	if err == nil {
		o := Roles(r)
		*pTypeDef = *((&o).Init())
		err = pTypeDef.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (pTypeDef *Roles) Validate() error {
	if pTypeDef.List == nil {
		return fmt.Errorf("Roles: Missing required field: list")
	}
	return nil
}

//
// Membership - The representation for a role membership.
//
type Membership struct {

	//
	// name of the member
	//
	MemberName ResourceName `json:"memberName"`

	//
	// flag to indicate whether or the user is a member or not
	//
	IsMember *bool `json:"isMember,omitempty" rdl:"optional"`

	//
	// name of the role
	//
	RoleName ResourceName `json:"roleName,omitempty" rdl:"optional"`

	//
	// the expiration timestamp
	//
	Expiration *rdl.Timestamp `json:"expiration,omitempty" rdl:"optional"`
}

//
// NewMembership - creates an initialized Membership instance, returns a pointer to it
//
func NewMembership(init ...*Membership) *Membership {
	var o *Membership
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(Membership)
	}
	return o.Init()
}

//
// Init - sets up the instance according to its default field values, if any
//
func (pTypeDef *Membership) Init() *Membership {
	if pTypeDef.IsMember == nil {
		d := true
		pTypeDef.IsMember = &d
	}
	return pTypeDef
}

type rawMembership Membership

//
// UnmarshalJSON is defined for proper JSON decoding of a Membership
//
func (pTypeDef *Membership) UnmarshalJSON(b []byte) error {
	var r rawMembership
	err := json.Unmarshal(b, &r)
	if err == nil {
		o := Membership(r)
		*pTypeDef = *((&o).Init())
		err = pTypeDef.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (pTypeDef *Membership) Validate() error {
	if pTypeDef.MemberName == "" {
		return fmt.Errorf("Membership.memberName is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "ResourceName", pTypeDef.MemberName)
		if !val.Valid {
			return fmt.Errorf("Membership.memberName does not contain a valid ResourceName (%v)", val.Error)
		}
	}
	return nil
}

//
// DefaultAdmins - The list of domain administrators.
//
type DefaultAdmins struct {

	//
	// list of domain administrators
	//
	Admins []ResourceName `json:"admins"`
}

//
// NewDefaultAdmins - creates an initialized DefaultAdmins instance, returns a pointer to it
//
func NewDefaultAdmins(init ...*DefaultAdmins) *DefaultAdmins {
	var o *DefaultAdmins
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(DefaultAdmins)
	}
	return o.Init()
}

//
// Init - sets up the instance according to its default field values, if any
//
func (pTypeDef *DefaultAdmins) Init() *DefaultAdmins {
	if pTypeDef.Admins == nil {
		pTypeDef.Admins = make([]ResourceName, 0)
	}
	return pTypeDef
}

type rawDefaultAdmins DefaultAdmins

//
// UnmarshalJSON is defined for proper JSON decoding of a DefaultAdmins
//
func (pTypeDef *DefaultAdmins) UnmarshalJSON(b []byte) error {
	var r rawDefaultAdmins
	err := json.Unmarshal(b, &r)
	if err == nil {
		o := DefaultAdmins(r)
		*pTypeDef = *((&o).Init())
		err = pTypeDef.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (pTypeDef *DefaultAdmins) Validate() error {
	if pTypeDef.Admins == nil {
		return fmt.Errorf("DefaultAdmins: Missing required field: admins")
	}
	return nil
}

//
// AssertionEffect - Every assertion can have the effect of ALLOW or DENY.
//
type AssertionEffect int

//
// AssertionEffect constants
//
const (
	_ AssertionEffect = iota
	ALLOW
	DENY
)

var namesAssertionEffect = []string{
	ALLOW: "ALLOW",
	DENY:  "DENY",
}

//
// NewAssertionEffect - return a string representation of the enum
//
func NewAssertionEffect(init ...interface{}) AssertionEffect {
	if len(init) == 1 {
		switch v := init[0].(type) {
		case AssertionEffect:
			return v
		case int:
			return AssertionEffect(v)
		case int32:
			return AssertionEffect(v)
		case string:
			for i, s := range namesAssertionEffect {
				if s == v {
					return AssertionEffect(i)
				}
			}
		default:
			panic("Bad init value for AssertionEffect enum")
		}
	}
	return AssertionEffect(0) //default to the first enum value
}

//
// String - return a string representation of the enum
//
func (e AssertionEffect) String() string {
	return namesAssertionEffect[e]
}

//
// SymbolSet - return an array of all valid string representations (symbols) of the enum
//
func (e AssertionEffect) SymbolSet() []string {
	return namesAssertionEffect
}

//
// MarshalJSON is defined for proper JSON encoding of a AssertionEffect
//
func (e AssertionEffect) MarshalJSON() ([]byte, error) {
	return json.Marshal(e.String())
}

//
// UnmarshalJSON is defined for proper JSON decoding of a AssertionEffect
//
func (e *AssertionEffect) UnmarshalJSON(b []byte) error {
	var j string
	err := json.Unmarshal(b, &j)
	if err == nil {
		s := string(j)
		for v, s2 := range namesAssertionEffect {
			if s == s2 {
				*e = AssertionEffect(v)
				return nil
			}
		}
		err = fmt.Errorf("Bad enum symbol for type AssertionEffect: %s", s)
	}
	return err
}

//
// Assertion - A representation for the encapsulation of an action to be
// performed on a resource by a principal.
//
type Assertion struct {

	//
	// the subject of the assertion - a role
	//
	Role string `json:"role"`

	//
	// the object of the assertion. Must be in the local namespace. Can contain
	// wildcards
	//
	Resource string `json:"resource"`

	//
	// the predicate of the assertion. Can contain wildcards
	//
	Action string `json:"action"`

	//
	// the effect of the assertion in the policy language
	//
	Effect *AssertionEffect `json:"effect,omitempty" rdl:"optional"`

	//
	// assertion id - auto generated by server. Not required during put
	// operations.
	//
	Id *int64 `json:"id,omitempty" rdl:"optional"`
}

//
// NewAssertion - creates an initialized Assertion instance, returns a pointer to it
//
func NewAssertion(init ...*Assertion) *Assertion {
	var o *Assertion
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(Assertion)
	}
	return o
}

type rawAssertion Assertion

//
// UnmarshalJSON is defined for proper JSON decoding of a Assertion
//
func (pTypeDef *Assertion) UnmarshalJSON(b []byte) error {
	var r rawAssertion
	err := json.Unmarshal(b, &r)
	if err == nil {
		o := Assertion(r)
		*pTypeDef = o
		err = pTypeDef.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (pTypeDef *Assertion) Validate() error {
	if pTypeDef.Role == "" {
		return fmt.Errorf("Assertion.role is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "String", pTypeDef.Role)
		if !val.Valid {
			return fmt.Errorf("Assertion.role does not contain a valid String (%v)", val.Error)
		}
	}
	if pTypeDef.Resource == "" {
		return fmt.Errorf("Assertion.resource is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "String", pTypeDef.Resource)
		if !val.Valid {
			return fmt.Errorf("Assertion.resource does not contain a valid String (%v)", val.Error)
		}
	}
	if pTypeDef.Action == "" {
		return fmt.Errorf("Assertion.action is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "String", pTypeDef.Action)
		if !val.Valid {
			return fmt.Errorf("Assertion.action does not contain a valid String (%v)", val.Error)
		}
	}
	return nil
}

//
// Policy - The representation for a Policy with set of assertions.
//
type Policy struct {

	//
	// name of the policy
	//
	Name ResourceName `json:"name"`

	//
	// last modification timestamp of this policy
	//
	Modified *rdl.Timestamp `json:"modified,omitempty" rdl:"optional"`

	//
	// list of defined assertions for this policy
	//
	Assertions []*Assertion `json:"assertions"`
}

//
// NewPolicy - creates an initialized Policy instance, returns a pointer to it
//
func NewPolicy(init ...*Policy) *Policy {
	var o *Policy
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(Policy)
	}
	return o.Init()
}

//
// Init - sets up the instance according to its default field values, if any
//
func (pTypeDef *Policy) Init() *Policy {
	if pTypeDef.Assertions == nil {
		pTypeDef.Assertions = make([]*Assertion, 0)
	}
	return pTypeDef
}

type rawPolicy Policy

//
// UnmarshalJSON is defined for proper JSON decoding of a Policy
//
func (pTypeDef *Policy) UnmarshalJSON(b []byte) error {
	var r rawPolicy
	err := json.Unmarshal(b, &r)
	if err == nil {
		o := Policy(r)
		*pTypeDef = *((&o).Init())
		err = pTypeDef.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (pTypeDef *Policy) Validate() error {
	if pTypeDef.Name == "" {
		return fmt.Errorf("Policy.name is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "ResourceName", pTypeDef.Name)
		if !val.Valid {
			return fmt.Errorf("Policy.name does not contain a valid ResourceName (%v)", val.Error)
		}
	}
	if pTypeDef.Assertions == nil {
		return fmt.Errorf("Policy: Missing required field: assertions")
	}
	return nil
}

//
// Policies - The representation of list of policy objects
//
type Policies struct {

	//
	// list of policy objects
	//
	List []*Policy `json:"list"`
}

//
// NewPolicies - creates an initialized Policies instance, returns a pointer to it
//
func NewPolicies(init ...*Policies) *Policies {
	var o *Policies
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(Policies)
	}
	return o.Init()
}

//
// Init - sets up the instance according to its default field values, if any
//
func (pTypeDef *Policies) Init() *Policies {
	if pTypeDef.List == nil {
		pTypeDef.List = make([]*Policy, 0)
	}
	return pTypeDef
}

type rawPolicies Policies

//
// UnmarshalJSON is defined for proper JSON decoding of a Policies
//
func (pTypeDef *Policies) UnmarshalJSON(b []byte) error {
	var r rawPolicies
	err := json.Unmarshal(b, &r)
	if err == nil {
		o := Policies(r)
		*pTypeDef = *((&o).Init())
		err = pTypeDef.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (pTypeDef *Policies) Validate() error {
	if pTypeDef.List == nil {
		return fmt.Errorf("Policies: Missing required field: list")
	}
	return nil
}

//
// Template - Solution Template object defined on the server
//
type Template struct {

	//
	// list of roles in the template
	//
	Roles []*Role `json:"roles"`

	//
	// list of policies defined in this template
	//
	Policies []*Policy `json:"policies"`
}

//
// NewTemplate - creates an initialized Template instance, returns a pointer to it
//
func NewTemplate(init ...*Template) *Template {
	var o *Template
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(Template)
	}
	return o.Init()
}

//
// Init - sets up the instance according to its default field values, if any
//
func (pTypeDef *Template) Init() *Template {
	if pTypeDef.Roles == nil {
		pTypeDef.Roles = make([]*Role, 0)
	}
	if pTypeDef.Policies == nil {
		pTypeDef.Policies = make([]*Policy, 0)
	}
	return pTypeDef
}

type rawTemplate Template

//
// UnmarshalJSON is defined for proper JSON decoding of a Template
//
func (pTypeDef *Template) UnmarshalJSON(b []byte) error {
	var r rawTemplate
	err := json.Unmarshal(b, &r)
	if err == nil {
		o := Template(r)
		*pTypeDef = *((&o).Init())
		err = pTypeDef.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (pTypeDef *Template) Validate() error {
	if pTypeDef.Roles == nil {
		return fmt.Errorf("Template: Missing required field: roles")
	}
	if pTypeDef.Policies == nil {
		return fmt.Errorf("Template: Missing required field: policies")
	}
	return nil
}

//
// TemplateList - List of template names that is the base struct for server and
// domain templates
//
type TemplateList struct {

	//
	// list of template names
	//
	TemplateNames []SimpleName `json:"templateNames"`
}

//
// NewTemplateList - creates an initialized TemplateList instance, returns a pointer to it
//
func NewTemplateList(init ...*TemplateList) *TemplateList {
	var o *TemplateList
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(TemplateList)
	}
	return o.Init()
}

//
// Init - sets up the instance according to its default field values, if any
//
func (pTypeDef *TemplateList) Init() *TemplateList {
	if pTypeDef.TemplateNames == nil {
		pTypeDef.TemplateNames = make([]SimpleName, 0)
	}
	return pTypeDef
}

type rawTemplateList TemplateList

//
// UnmarshalJSON is defined for proper JSON decoding of a TemplateList
//
func (pTypeDef *TemplateList) UnmarshalJSON(b []byte) error {
	var r rawTemplateList
	err := json.Unmarshal(b, &r)
	if err == nil {
		o := TemplateList(r)
		*pTypeDef = *((&o).Init())
		err = pTypeDef.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (pTypeDef *TemplateList) Validate() error {
	if pTypeDef.TemplateNames == nil {
		return fmt.Errorf("TemplateList: Missing required field: templateNames")
	}
	return nil
}

//
// DomainTemplate - solution template(s) to be applied to a domain
//
type DomainTemplate struct {

	//
	// list of template names
	//
	TemplateNames []SimpleName `json:"templateNames"`
}

//
// NewDomainTemplate - creates an initialized DomainTemplate instance, returns a pointer to it
//
func NewDomainTemplate(init ...*DomainTemplate) *DomainTemplate {
	var o *DomainTemplate
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(DomainTemplate)
	}
	return o.Init()
}

//
// Init - sets up the instance according to its default field values, if any
//
func (pTypeDef *DomainTemplate) Init() *DomainTemplate {
	if pTypeDef.TemplateNames == nil {
		pTypeDef.TemplateNames = make([]SimpleName, 0)
	}
	return pTypeDef
}

type rawDomainTemplate DomainTemplate

//
// UnmarshalJSON is defined for proper JSON decoding of a DomainTemplate
//
func (pTypeDef *DomainTemplate) UnmarshalJSON(b []byte) error {
	var r rawDomainTemplate
	err := json.Unmarshal(b, &r)
	if err == nil {
		o := DomainTemplate(r)
		*pTypeDef = *((&o).Init())
		err = pTypeDef.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (pTypeDef *DomainTemplate) Validate() error {
	if pTypeDef.TemplateNames == nil {
		return fmt.Errorf("DomainTemplate: Missing required field: templateNames")
	}
	return nil
}

//
// DomainTemplateList - List of solution templates to be applied to a domain
//
type DomainTemplateList struct {

	//
	// list of template names
	//
	TemplateNames []SimpleName `json:"templateNames"`
}

//
// NewDomainTemplateList - creates an initialized DomainTemplateList instance, returns a pointer to it
//
func NewDomainTemplateList(init ...*DomainTemplateList) *DomainTemplateList {
	var o *DomainTemplateList
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(DomainTemplateList)
	}
	return o.Init()
}

//
// Init - sets up the instance according to its default field values, if any
//
func (pTypeDef *DomainTemplateList) Init() *DomainTemplateList {
	if pTypeDef.TemplateNames == nil {
		pTypeDef.TemplateNames = make([]SimpleName, 0)
	}
	return pTypeDef
}

type rawDomainTemplateList DomainTemplateList

//
// UnmarshalJSON is defined for proper JSON decoding of a DomainTemplateList
//
func (pTypeDef *DomainTemplateList) UnmarshalJSON(b []byte) error {
	var r rawDomainTemplateList
	err := json.Unmarshal(b, &r)
	if err == nil {
		o := DomainTemplateList(r)
		*pTypeDef = *((&o).Init())
		err = pTypeDef.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (pTypeDef *DomainTemplateList) Validate() error {
	if pTypeDef.TemplateNames == nil {
		return fmt.Errorf("DomainTemplateList: Missing required field: templateNames")
	}
	return nil
}

//
// ServerTemplateList - List of solution templates available in the server
//
type ServerTemplateList struct {

	//
	// list of template names
	//
	TemplateNames []SimpleName `json:"templateNames"`
}

//
// NewServerTemplateList - creates an initialized ServerTemplateList instance, returns a pointer to it
//
func NewServerTemplateList(init ...*ServerTemplateList) *ServerTemplateList {
	var o *ServerTemplateList
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(ServerTemplateList)
	}
	return o.Init()
}

//
// Init - sets up the instance according to its default field values, if any
//
func (pTypeDef *ServerTemplateList) Init() *ServerTemplateList {
	if pTypeDef.TemplateNames == nil {
		pTypeDef.TemplateNames = make([]SimpleName, 0)
	}
	return pTypeDef
}

type rawServerTemplateList ServerTemplateList

//
// UnmarshalJSON is defined for proper JSON decoding of a ServerTemplateList
//
func (pTypeDef *ServerTemplateList) UnmarshalJSON(b []byte) error {
	var r rawServerTemplateList
	err := json.Unmarshal(b, &r)
	if err == nil {
		o := ServerTemplateList(r)
		*pTypeDef = *((&o).Init())
		err = pTypeDef.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (pTypeDef *ServerTemplateList) Validate() error {
	if pTypeDef.TemplateNames == nil {
		return fmt.Errorf("ServerTemplateList: Missing required field: templateNames")
	}
	return nil
}

//
// DomainList - A paginated list of domains.
//
type DomainList struct {

	//
	// list of domain names
	//
	Names []DomainName `json:"names"`

	//
	// if the response is a paginated list, this attribute specifies the value to
	// be used in the next domain list request as the value for the skip query
	// parameter.
	//
	Next string `json:"next,omitempty" rdl:"optional"`
}

//
// NewDomainList - creates an initialized DomainList instance, returns a pointer to it
//
func NewDomainList(init ...*DomainList) *DomainList {
	var o *DomainList
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(DomainList)
	}
	return o.Init()
}

//
// Init - sets up the instance according to its default field values, if any
//
func (pTypeDef *DomainList) Init() *DomainList {
	if pTypeDef.Names == nil {
		pTypeDef.Names = make([]DomainName, 0)
	}
	return pTypeDef
}

type rawDomainList DomainList

//
// UnmarshalJSON is defined for proper JSON decoding of a DomainList
//
func (pTypeDef *DomainList) UnmarshalJSON(b []byte) error {
	var r rawDomainList
	err := json.Unmarshal(b, &r)
	if err == nil {
		o := DomainList(r)
		*pTypeDef = *((&o).Init())
		err = pTypeDef.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (pTypeDef *DomainList) Validate() error {
	if pTypeDef.Names == nil {
		return fmt.Errorf("DomainList: Missing required field: names")
	}
	return nil
}

//
// DomainMeta - Set of metadata attributes that all domains may have and can be
// changed.
//
type DomainMeta struct {

	//
	// a description of the domain
	//
	Description string `json:"description,omitempty" rdl:"optional"`

	//
	// a reference to an Organization. (i.e. org:media)
	//
	Org ResourceName `json:"org,omitempty" rdl:"optional"`

	//
	// Future use only, currently not used
	//
	Enabled *bool `json:"enabled,omitempty" rdl:"optional"`

	//
	// Flag indicates whether or not domain modifications should be logged for
	// SOX+Auditing. If true, the auditRef parameter must be supplied(not empty) for
	// any API defining it.
	//
	AuditEnabled *bool `json:"auditEnabled,omitempty" rdl:"optional"`

	//
	// associated cloud (i.e. aws) account id
	//
	Account string `json:"account,omitempty" rdl:"optional"`

	//
	// associated product id
	//
	YpmId *int32 `json:"ypmId,omitempty" rdl:"optional"`
}

//
// NewDomainMeta - creates an initialized DomainMeta instance, returns a pointer to it
//
func NewDomainMeta(init ...*DomainMeta) *DomainMeta {
	var o *DomainMeta
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(DomainMeta)
	}
	return o.Init()
}

//
// Init - sets up the instance according to its default field values, if any
//
func (pTypeDef *DomainMeta) Init() *DomainMeta {
	if pTypeDef.Enabled == nil {
		d := true
		pTypeDef.Enabled = &d
	}
	if pTypeDef.AuditEnabled == nil {
		d := false
		pTypeDef.AuditEnabled = &d
	}
	return pTypeDef
}

type rawDomainMeta DomainMeta

//
// UnmarshalJSON is defined for proper JSON decoding of a DomainMeta
//
func (pTypeDef *DomainMeta) UnmarshalJSON(b []byte) error {
	var r rawDomainMeta
	err := json.Unmarshal(b, &r)
	if err == nil {
		o := DomainMeta(r)
		*pTypeDef = *((&o).Init())
		err = pTypeDef.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (pTypeDef *DomainMeta) Validate() error {
	return nil
}

//
// TopLevelDomain - Top Level Domain object. The required attributes include
// the name of the domain and list of domain administrators.
//
type TopLevelDomain struct {

	//
	// a description of the domain
	//
	Description string `json:"description,omitempty" rdl:"optional"`

	//
	// a reference to an Organization. (i.e. org:media)
	//
	Org ResourceName `json:"org,omitempty" rdl:"optional"`

	//
	// Future use only, currently not used
	//
	Enabled *bool `json:"enabled,omitempty" rdl:"optional"`

	//
	// Flag indicates whether or not domain modifications should be logged for
	// SOX+Auditing. If true, the auditRef parameter must be supplied(not empty) for
	// any API defining it.
	//
	AuditEnabled *bool `json:"auditEnabled,omitempty" rdl:"optional"`

	//
	// associated cloud (i.e. aws) account id
	//
	Account string `json:"account,omitempty" rdl:"optional"`

	//
	// associated product id
	//
	YpmId *int32 `json:"ypmId,omitempty" rdl:"optional"`

	//
	// name of the domain
	//
	Name SimpleName `json:"name"`

	//
	// list of domain administrators
	//
	AdminUsers []ResourceName `json:"adminUsers"`

	//
	// list of solution template names
	//
	Templates *DomainTemplateList `json:"templates,omitempty" rdl:"optional"`
}

//
// NewTopLevelDomain - creates an initialized TopLevelDomain instance, returns a pointer to it
//
func NewTopLevelDomain(init ...*TopLevelDomain) *TopLevelDomain {
	var o *TopLevelDomain
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(TopLevelDomain)
	}
	return o.Init()
}

//
// Init - sets up the instance according to its default field values, if any
//
func (pTypeDef *TopLevelDomain) Init() *TopLevelDomain {
	if pTypeDef.Enabled == nil {
		d := true
		pTypeDef.Enabled = &d
	}
	if pTypeDef.AuditEnabled == nil {
		d := false
		pTypeDef.AuditEnabled = &d
	}
	if pTypeDef.AdminUsers == nil {
		pTypeDef.AdminUsers = make([]ResourceName, 0)
	}
	return pTypeDef
}

type rawTopLevelDomain TopLevelDomain

//
// UnmarshalJSON is defined for proper JSON decoding of a TopLevelDomain
//
func (pTypeDef *TopLevelDomain) UnmarshalJSON(b []byte) error {
	var r rawTopLevelDomain
	err := json.Unmarshal(b, &r)
	if err == nil {
		o := TopLevelDomain(r)
		*pTypeDef = *((&o).Init())
		err = pTypeDef.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (pTypeDef *TopLevelDomain) Validate() error {
	if pTypeDef.Name == "" {
		return fmt.Errorf("TopLevelDomain.name is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "SimpleName", pTypeDef.Name)
		if !val.Valid {
			return fmt.Errorf("TopLevelDomain.name does not contain a valid SimpleName (%v)", val.Error)
		}
	}
	if pTypeDef.AdminUsers == nil {
		return fmt.Errorf("TopLevelDomain: Missing required field: adminUsers")
	}
	return nil
}

//
// SubDomain - A Subdomain is a TopLevelDomain, except it has a parent.
//
type SubDomain struct {

	//
	// a description of the domain
	//
	Description string `json:"description,omitempty" rdl:"optional"`

	//
	// a reference to an Organization. (i.e. org:media)
	//
	Org ResourceName `json:"org,omitempty" rdl:"optional"`

	//
	// Future use only, currently not used
	//
	Enabled *bool `json:"enabled,omitempty" rdl:"optional"`

	//
	// Flag indicates whether or not domain modifications should be logged for
	// SOX+Auditing. If true, the auditRef parameter must be supplied(not empty) for
	// any API defining it.
	//
	AuditEnabled *bool `json:"auditEnabled,omitempty" rdl:"optional"`

	//
	// associated cloud (i.e. aws) account id
	//
	Account string `json:"account,omitempty" rdl:"optional"`

	//
	// associated product id
	//
	YpmId *int32 `json:"ypmId,omitempty" rdl:"optional"`

	//
	// name of the domain
	//
	Name SimpleName `json:"name"`

	//
	// list of domain administrators
	//
	AdminUsers []ResourceName `json:"adminUsers"`

	//
	// list of solution template names
	//
	Templates *DomainTemplateList `json:"templates,omitempty" rdl:"optional"`

	//
	// name of the parent domain
	//
	Parent DomainName `json:"parent"`
}

//
// NewSubDomain - creates an initialized SubDomain instance, returns a pointer to it
//
func NewSubDomain(init ...*SubDomain) *SubDomain {
	var o *SubDomain
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(SubDomain)
	}
	return o.Init()
}

//
// Init - sets up the instance according to its default field values, if any
//
func (pTypeDef *SubDomain) Init() *SubDomain {
	if pTypeDef.Enabled == nil {
		d := true
		pTypeDef.Enabled = &d
	}
	if pTypeDef.AuditEnabled == nil {
		d := false
		pTypeDef.AuditEnabled = &d
	}
	if pTypeDef.AdminUsers == nil {
		pTypeDef.AdminUsers = make([]ResourceName, 0)
	}
	return pTypeDef
}

type rawSubDomain SubDomain

//
// UnmarshalJSON is defined for proper JSON decoding of a SubDomain
//
func (pTypeDef *SubDomain) UnmarshalJSON(b []byte) error {
	var r rawSubDomain
	err := json.Unmarshal(b, &r)
	if err == nil {
		o := SubDomain(r)
		*pTypeDef = *((&o).Init())
		err = pTypeDef.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (pTypeDef *SubDomain) Validate() error {
	if pTypeDef.Name == "" {
		return fmt.Errorf("SubDomain.name is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "SimpleName", pTypeDef.Name)
		if !val.Valid {
			return fmt.Errorf("SubDomain.name does not contain a valid SimpleName (%v)", val.Error)
		}
	}
	if pTypeDef.AdminUsers == nil {
		return fmt.Errorf("SubDomain: Missing required field: adminUsers")
	}
	if pTypeDef.Parent == "" {
		return fmt.Errorf("SubDomain.parent is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "DomainName", pTypeDef.Parent)
		if !val.Valid {
			return fmt.Errorf("SubDomain.parent does not contain a valid DomainName (%v)", val.Error)
		}
	}
	return nil
}

//
// UserDomain - A UserDomain is the user's own top level domain in user - e.g.
// user.hga
//
type UserDomain struct {

	//
	// a description of the domain
	//
	Description string `json:"description,omitempty" rdl:"optional"`

	//
	// a reference to an Organization. (i.e. org:media)
	//
	Org ResourceName `json:"org,omitempty" rdl:"optional"`

	//
	// Future use only, currently not used
	//
	Enabled *bool `json:"enabled,omitempty" rdl:"optional"`

	//
	// Flag indicates whether or not domain modifications should be logged for
	// SOX+Auditing. If true, the auditRef parameter must be supplied(not empty) for
	// any API defining it.
	//
	AuditEnabled *bool `json:"auditEnabled,omitempty" rdl:"optional"`

	//
	// associated cloud (i.e. aws) account id
	//
	Account string `json:"account,omitempty" rdl:"optional"`

	//
	// associated product id
	//
	YpmId *int32 `json:"ypmId,omitempty" rdl:"optional"`

	//
	// user id which will be the domain name
	//
	Name SimpleName `json:"name"`

	//
	// list of solution template names
	//
	Templates *DomainTemplateList `json:"templates,omitempty" rdl:"optional"`
}

//
// NewUserDomain - creates an initialized UserDomain instance, returns a pointer to it
//
func NewUserDomain(init ...*UserDomain) *UserDomain {
	var o *UserDomain
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(UserDomain)
	}
	return o.Init()
}

//
// Init - sets up the instance according to its default field values, if any
//
func (pTypeDef *UserDomain) Init() *UserDomain {
	if pTypeDef.Enabled == nil {
		d := true
		pTypeDef.Enabled = &d
	}
	if pTypeDef.AuditEnabled == nil {
		d := false
		pTypeDef.AuditEnabled = &d
	}
	return pTypeDef
}

type rawUserDomain UserDomain

//
// UnmarshalJSON is defined for proper JSON decoding of a UserDomain
//
func (pTypeDef *UserDomain) UnmarshalJSON(b []byte) error {
	var r rawUserDomain
	err := json.Unmarshal(b, &r)
	if err == nil {
		o := UserDomain(r)
		*pTypeDef = *((&o).Init())
		err = pTypeDef.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (pTypeDef *UserDomain) Validate() error {
	if pTypeDef.Name == "" {
		return fmt.Errorf("UserDomain.name is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "SimpleName", pTypeDef.Name)
		if !val.Valid {
			return fmt.Errorf("UserDomain.name does not contain a valid SimpleName (%v)", val.Error)
		}
	}
	return nil
}

//
// DanglingPolicy - A dangling policy where the assertion is referencing a role
// name that doesn't exist in the domain
//
type DanglingPolicy struct {
	PolicyName EntityName `json:"policyName"`
	RoleName   EntityName `json:"roleName"`
}

//
// NewDanglingPolicy - creates an initialized DanglingPolicy instance, returns a pointer to it
//
func NewDanglingPolicy(init ...*DanglingPolicy) *DanglingPolicy {
	var o *DanglingPolicy
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(DanglingPolicy)
	}
	return o
}

type rawDanglingPolicy DanglingPolicy

//
// UnmarshalJSON is defined for proper JSON decoding of a DanglingPolicy
//
func (pTypeDef *DanglingPolicy) UnmarshalJSON(b []byte) error {
	var r rawDanglingPolicy
	err := json.Unmarshal(b, &r)
	if err == nil {
		o := DanglingPolicy(r)
		*pTypeDef = o
		err = pTypeDef.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (pTypeDef *DanglingPolicy) Validate() error {
	if pTypeDef.PolicyName == "" {
		return fmt.Errorf("DanglingPolicy.policyName is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "EntityName", pTypeDef.PolicyName)
		if !val.Valid {
			return fmt.Errorf("DanglingPolicy.policyName does not contain a valid EntityName (%v)", val.Error)
		}
	}
	if pTypeDef.RoleName == "" {
		return fmt.Errorf("DanglingPolicy.roleName is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "EntityName", pTypeDef.RoleName)
		if !val.Valid {
			return fmt.Errorf("DanglingPolicy.roleName does not contain a valid EntityName (%v)", val.Error)
		}
	}
	return nil
}

//
// DomainDataCheck - Domain data object representing the results of a check
// operation looking for dangling roles, policies and trust relationships that
// are set either on tenant or provider side only
//
type DomainDataCheck struct {

	//
	// Names of roles not specified in any assertion. Might be empty or null if no
	// dangling roles.
	//
	DanglingRoles []EntityName `json:"danglingRoles,omitempty" rdl:"optional"`

	//
	// Policy+role tuples where role doesnt exist. Might be empty or null if no
	// dangling policies.
	//
	DanglingPolicies []*DanglingPolicy `json:"danglingPolicies,omitempty" rdl:"optional"`

	//
	// total number of policies
	//
	PolicyCount int32 `json:"policyCount"`

	//
	// total number of assertions
	//
	AssertionCount int32 `json:"assertionCount"`

	//
	// total number of assertions containing roles as wildcards
	//
	RoleWildCardCount int32 `json:"roleWildCardCount"`

	//
	// Service names (domain.service) that dont contain trust role if this is a
	// tenant domain. Might be empty or null, if not a tenant or if all providers
	// support this tenant.
	//
	ProvidersWithoutTrust []ServiceName `json:"providersWithoutTrust,omitempty" rdl:"optional"`

	//
	// Names of Tenant domains that dont contain assume role assertions if this is
	// a provider domain. Might be empty or null, if not a provider or if all
	// tenants support use this provider.
	//
	TenantsWithoutAssumeRole []DomainName `json:"tenantsWithoutAssumeRole,omitempty" rdl:"optional"`
}

//
// NewDomainDataCheck - creates an initialized DomainDataCheck instance, returns a pointer to it
//
func NewDomainDataCheck(init ...*DomainDataCheck) *DomainDataCheck {
	var o *DomainDataCheck
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(DomainDataCheck)
	}
	return o
}

type rawDomainDataCheck DomainDataCheck

//
// UnmarshalJSON is defined for proper JSON decoding of a DomainDataCheck
//
func (pTypeDef *DomainDataCheck) UnmarshalJSON(b []byte) error {
	var r rawDomainDataCheck
	err := json.Unmarshal(b, &r)
	if err == nil {
		o := DomainDataCheck(r)
		*pTypeDef = o
		err = pTypeDef.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (pTypeDef *DomainDataCheck) Validate() error {
	return nil
}

//
// Entity - An entity is a name and a structured value. some entity
// names/prefixes are reserved (i.e. "role",  "policy", "meta", "domain",
// "service")
//
type Entity struct {

	//
	// name of the entity object
	//
	Name EntityName `json:"name"`

	//
	// value of the entity
	//
	Value rdl.Struct `json:"value"`
}

//
// NewEntity - creates an initialized Entity instance, returns a pointer to it
//
func NewEntity(init ...*Entity) *Entity {
	var o *Entity
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(Entity)
	}
	return o.Init()
}

//
// Init - sets up the instance according to its default field values, if any
//
func (pTypeDef *Entity) Init() *Entity {
	if pTypeDef.Value == nil {
		pTypeDef.Value = make(rdl.Struct)
	}
	return pTypeDef
}

type rawEntity Entity

//
// UnmarshalJSON is defined for proper JSON decoding of a Entity
//
func (pTypeDef *Entity) UnmarshalJSON(b []byte) error {
	var r rawEntity
	err := json.Unmarshal(b, &r)
	if err == nil {
		o := Entity(r)
		*pTypeDef = *((&o).Init())
		err = pTypeDef.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (pTypeDef *Entity) Validate() error {
	if pTypeDef.Name == "" {
		return fmt.Errorf("Entity.name is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "EntityName", pTypeDef.Name)
		if !val.Valid {
			return fmt.Errorf("Entity.name does not contain a valid EntityName (%v)", val.Error)
		}
	}
	if pTypeDef.Value == nil {
		return fmt.Errorf("Entity: Missing required field: value")
	}
	return nil
}

//
// EntityList - The representation for an enumeration of entities in the
// namespace
//
type EntityList struct {

	//
	// list of entity names
	//
	Names []EntityName `json:"names"`
}

//
// NewEntityList - creates an initialized EntityList instance, returns a pointer to it
//
func NewEntityList(init ...*EntityList) *EntityList {
	var o *EntityList
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(EntityList)
	}
	return o.Init()
}

//
// Init - sets up the instance according to its default field values, if any
//
func (pTypeDef *EntityList) Init() *EntityList {
	if pTypeDef.Names == nil {
		pTypeDef.Names = make([]EntityName, 0)
	}
	return pTypeDef
}

type rawEntityList EntityList

//
// UnmarshalJSON is defined for proper JSON decoding of a EntityList
//
func (pTypeDef *EntityList) UnmarshalJSON(b []byte) error {
	var r rawEntityList
	err := json.Unmarshal(b, &r)
	if err == nil {
		o := EntityList(r)
		*pTypeDef = *((&o).Init())
		err = pTypeDef.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (pTypeDef *EntityList) Validate() error {
	if pTypeDef.Names == nil {
		return fmt.Errorf("EntityList: Missing required field: names")
	}
	return nil
}

//
// PolicyList - The representation for an enumeration of policies in the
// namespace, with pagination.
//
type PolicyList struct {

	//
	// list of policy names
	//
	Names []EntityName `json:"names"`

	//
	// if the response is a paginated list, this attribute specifies the value to
	// be used in the next policy list request as the value for the skip query
	// parameter.
	//
	Next string `json:"next,omitempty" rdl:"optional"`
}

//
// NewPolicyList - creates an initialized PolicyList instance, returns a pointer to it
//
func NewPolicyList(init ...*PolicyList) *PolicyList {
	var o *PolicyList
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(PolicyList)
	}
	return o.Init()
}

//
// Init - sets up the instance according to its default field values, if any
//
func (pTypeDef *PolicyList) Init() *PolicyList {
	if pTypeDef.Names == nil {
		pTypeDef.Names = make([]EntityName, 0)
	}
	return pTypeDef
}

type rawPolicyList PolicyList

//
// UnmarshalJSON is defined for proper JSON decoding of a PolicyList
//
func (pTypeDef *PolicyList) UnmarshalJSON(b []byte) error {
	var r rawPolicyList
	err := json.Unmarshal(b, &r)
	if err == nil {
		o := PolicyList(r)
		*pTypeDef = *((&o).Init())
		err = pTypeDef.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (pTypeDef *PolicyList) Validate() error {
	if pTypeDef.Names == nil {
		return fmt.Errorf("PolicyList: Missing required field: names")
	}
	return nil
}

//
// PublicKeyEntry - The representation of the public key in a service identity
// object.
//
type PublicKeyEntry struct {

	//
	// the public key for the service
	//
	Key string `json:"key"`

	//
	// the key identifier (version or zone name)
	//
	Id string `json:"id"`
}

//
// NewPublicKeyEntry - creates an initialized PublicKeyEntry instance, returns a pointer to it
//
func NewPublicKeyEntry(init ...*PublicKeyEntry) *PublicKeyEntry {
	var o *PublicKeyEntry
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(PublicKeyEntry)
	}
	return o
}

type rawPublicKeyEntry PublicKeyEntry

//
// UnmarshalJSON is defined for proper JSON decoding of a PublicKeyEntry
//
func (pTypeDef *PublicKeyEntry) UnmarshalJSON(b []byte) error {
	var r rawPublicKeyEntry
	err := json.Unmarshal(b, &r)
	if err == nil {
		o := PublicKeyEntry(r)
		*pTypeDef = o
		err = pTypeDef.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (pTypeDef *PublicKeyEntry) Validate() error {
	if pTypeDef.Key == "" {
		return fmt.Errorf("PublicKeyEntry.key is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "String", pTypeDef.Key)
		if !val.Valid {
			return fmt.Errorf("PublicKeyEntry.key does not contain a valid String (%v)", val.Error)
		}
	}
	if pTypeDef.Id == "" {
		return fmt.Errorf("PublicKeyEntry.id is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "String", pTypeDef.Id)
		if !val.Valid {
			return fmt.Errorf("PublicKeyEntry.id does not contain a valid String (%v)", val.Error)
		}
	}
	return nil
}

//
// ServiceIdentity - The representation of the service identity object.
//
type ServiceIdentity struct {

	//
	// the full name of the service, i.e. "sports.storage"
	//
	Name ServiceName `json:"name"`

	//
	// array of public keys for key rotation
	//
	PublicKeys []*PublicKeyEntry `json:"publicKeys,omitempty" rdl:"optional"`

	//
	// if present, then this service can provision tenants via this endpoint.
	//
	ProviderEndpoint string `json:"providerEndpoint,omitempty" rdl:"optional"`

	//
	// the timestamp when this entry was last modified
	//
	Modified *rdl.Timestamp `json:"modified,omitempty" rdl:"optional"`

	//
	// the path of the executable that runs the service
	//
	Executable string `json:"executable,omitempty" rdl:"optional"`

	//
	// list of host names that this service can run on
	//
	Hosts []string `json:"hosts,omitempty" rdl:"optional"`

	//
	// local (unix) user name this service can run as
	//
	User string `json:"user,omitempty" rdl:"optional"`

	//
	// local (unix) group name this service can run as
	//
	Group string `json:"group,omitempty" rdl:"optional"`
}

//
// NewServiceIdentity - creates an initialized ServiceIdentity instance, returns a pointer to it
//
func NewServiceIdentity(init ...*ServiceIdentity) *ServiceIdentity {
	var o *ServiceIdentity
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(ServiceIdentity)
	}
	return o
}

type rawServiceIdentity ServiceIdentity

//
// UnmarshalJSON is defined for proper JSON decoding of a ServiceIdentity
//
func (pTypeDef *ServiceIdentity) UnmarshalJSON(b []byte) error {
	var r rawServiceIdentity
	err := json.Unmarshal(b, &r)
	if err == nil {
		o := ServiceIdentity(r)
		*pTypeDef = o
		err = pTypeDef.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (pTypeDef *ServiceIdentity) Validate() error {
	if pTypeDef.Name == "" {
		return fmt.Errorf("ServiceIdentity.name is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "ServiceName", pTypeDef.Name)
		if !val.Valid {
			return fmt.Errorf("ServiceIdentity.name does not contain a valid ServiceName (%v)", val.Error)
		}
	}
	return nil
}

//
// ServiceIdentities - The representation of list of services
//
type ServiceIdentities struct {

	//
	// list of services
	//
	List []*ServiceIdentity `json:"list"`
}

//
// NewServiceIdentities - creates an initialized ServiceIdentities instance, returns a pointer to it
//
func NewServiceIdentities(init ...*ServiceIdentities) *ServiceIdentities {
	var o *ServiceIdentities
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(ServiceIdentities)
	}
	return o.Init()
}

//
// Init - sets up the instance according to its default field values, if any
//
func (pTypeDef *ServiceIdentities) Init() *ServiceIdentities {
	if pTypeDef.List == nil {
		pTypeDef.List = make([]*ServiceIdentity, 0)
	}
	return pTypeDef
}

type rawServiceIdentities ServiceIdentities

//
// UnmarshalJSON is defined for proper JSON decoding of a ServiceIdentities
//
func (pTypeDef *ServiceIdentities) UnmarshalJSON(b []byte) error {
	var r rawServiceIdentities
	err := json.Unmarshal(b, &r)
	if err == nil {
		o := ServiceIdentities(r)
		*pTypeDef = *((&o).Init())
		err = pTypeDef.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (pTypeDef *ServiceIdentities) Validate() error {
	if pTypeDef.List == nil {
		return fmt.Errorf("ServiceIdentities: Missing required field: list")
	}
	return nil
}

//
// ServiceIdentityList - The representation for an enumeration of services in
// the namespace, with pagination.
//
type ServiceIdentityList struct {

	//
	// list of service names
	//
	Names []EntityName `json:"names"`

	//
	// if the response is a paginated list, this attribute specifies the value to
	// be used in the next service list request as the value for the skip query
	// parameter.
	//
	Next string `json:"next,omitempty" rdl:"optional"`
}

//
// NewServiceIdentityList - creates an initialized ServiceIdentityList instance, returns a pointer to it
//
func NewServiceIdentityList(init ...*ServiceIdentityList) *ServiceIdentityList {
	var o *ServiceIdentityList
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(ServiceIdentityList)
	}
	return o.Init()
}

//
// Init - sets up the instance according to its default field values, if any
//
func (pTypeDef *ServiceIdentityList) Init() *ServiceIdentityList {
	if pTypeDef.Names == nil {
		pTypeDef.Names = make([]EntityName, 0)
	}
	return pTypeDef
}

type rawServiceIdentityList ServiceIdentityList

//
// UnmarshalJSON is defined for proper JSON decoding of a ServiceIdentityList
//
func (pTypeDef *ServiceIdentityList) UnmarshalJSON(b []byte) error {
	var r rawServiceIdentityList
	err := json.Unmarshal(b, &r)
	if err == nil {
		o := ServiceIdentityList(r)
		*pTypeDef = *((&o).Init())
		err = pTypeDef.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (pTypeDef *ServiceIdentityList) Validate() error {
	if pTypeDef.Names == nil {
		return fmt.Errorf("ServiceIdentityList: Missing required field: names")
	}
	return nil
}

//
// Tenancy - A representation of tenant.
//
type Tenancy struct {

	//
	// the domain that is to get a tenancy
	//
	Domain DomainName `json:"domain"`

	//
	// the provider service on which the tenancy is to reside
	//
	Service ServiceName `json:"service"`

	//
	// registered resource groups for this tenant
	//
	ResourceGroups []EntityName `json:"resourceGroups,omitempty" rdl:"optional"`
}

//
// NewTenancy - creates an initialized Tenancy instance, returns a pointer to it
//
func NewTenancy(init ...*Tenancy) *Tenancy {
	var o *Tenancy
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(Tenancy)
	}
	return o
}

type rawTenancy Tenancy

//
// UnmarshalJSON is defined for proper JSON decoding of a Tenancy
//
func (pTypeDef *Tenancy) UnmarshalJSON(b []byte) error {
	var r rawTenancy
	err := json.Unmarshal(b, &r)
	if err == nil {
		o := Tenancy(r)
		*pTypeDef = o
		err = pTypeDef.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (pTypeDef *Tenancy) Validate() error {
	if pTypeDef.Domain == "" {
		return fmt.Errorf("Tenancy.domain is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "DomainName", pTypeDef.Domain)
		if !val.Valid {
			return fmt.Errorf("Tenancy.domain does not contain a valid DomainName (%v)", val.Error)
		}
	}
	if pTypeDef.Service == "" {
		return fmt.Errorf("Tenancy.service is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "ServiceName", pTypeDef.Service)
		if !val.Valid {
			return fmt.Errorf("Tenancy.service does not contain a valid ServiceName (%v)", val.Error)
		}
	}
	return nil
}

//
// TenancyResourceGroup -
//
type TenancyResourceGroup struct {

	//
	// the domain that is to get a tenancy
	//
	Domain DomainName `json:"domain"`

	//
	// the provider service on which the tenancy is to reside
	//
	Service ServiceName `json:"service"`

	//
	// registered resource group for this tenant
	//
	ResourceGroup EntityName `json:"resourceGroup"`
}

//
// NewTenancyResourceGroup - creates an initialized TenancyResourceGroup instance, returns a pointer to it
//
func NewTenancyResourceGroup(init ...*TenancyResourceGroup) *TenancyResourceGroup {
	var o *TenancyResourceGroup
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(TenancyResourceGroup)
	}
	return o
}

type rawTenancyResourceGroup TenancyResourceGroup

//
// UnmarshalJSON is defined for proper JSON decoding of a TenancyResourceGroup
//
func (pTypeDef *TenancyResourceGroup) UnmarshalJSON(b []byte) error {
	var r rawTenancyResourceGroup
	err := json.Unmarshal(b, &r)
	if err == nil {
		o := TenancyResourceGroup(r)
		*pTypeDef = o
		err = pTypeDef.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (pTypeDef *TenancyResourceGroup) Validate() error {
	if pTypeDef.Domain == "" {
		return fmt.Errorf("TenancyResourceGroup.domain is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "DomainName", pTypeDef.Domain)
		if !val.Valid {
			return fmt.Errorf("TenancyResourceGroup.domain does not contain a valid DomainName (%v)", val.Error)
		}
	}
	if pTypeDef.Service == "" {
		return fmt.Errorf("TenancyResourceGroup.service is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "ServiceName", pTypeDef.Service)
		if !val.Valid {
			return fmt.Errorf("TenancyResourceGroup.service does not contain a valid ServiceName (%v)", val.Error)
		}
	}
	if pTypeDef.ResourceGroup == "" {
		return fmt.Errorf("TenancyResourceGroup.resourceGroup is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "EntityName", pTypeDef.ResourceGroup)
		if !val.Valid {
			return fmt.Errorf("TenancyResourceGroup.resourceGroup does not contain a valid EntityName (%v)", val.Error)
		}
	}
	return nil
}

//
// TenantRoleAction - A representation of tenant role action.
//
type TenantRoleAction struct {

	//
	// name of the role
	//
	Role SimpleName `json:"role"`

	//
	// action value for the generated policy assertion
	//
	Action string `json:"action"`
}

//
// NewTenantRoleAction - creates an initialized TenantRoleAction instance, returns a pointer to it
//
func NewTenantRoleAction(init ...*TenantRoleAction) *TenantRoleAction {
	var o *TenantRoleAction
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(TenantRoleAction)
	}
	return o
}

type rawTenantRoleAction TenantRoleAction

//
// UnmarshalJSON is defined for proper JSON decoding of a TenantRoleAction
//
func (pTypeDef *TenantRoleAction) UnmarshalJSON(b []byte) error {
	var r rawTenantRoleAction
	err := json.Unmarshal(b, &r)
	if err == nil {
		o := TenantRoleAction(r)
		*pTypeDef = o
		err = pTypeDef.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (pTypeDef *TenantRoleAction) Validate() error {
	if pTypeDef.Role == "" {
		return fmt.Errorf("TenantRoleAction.role is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "SimpleName", pTypeDef.Role)
		if !val.Valid {
			return fmt.Errorf("TenantRoleAction.role does not contain a valid SimpleName (%v)", val.Error)
		}
	}
	if pTypeDef.Action == "" {
		return fmt.Errorf("TenantRoleAction.action is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "String", pTypeDef.Action)
		if !val.Valid {
			return fmt.Errorf("TenantRoleAction.action does not contain a valid String (%v)", val.Error)
		}
	}
	return nil
}

//
// TenantRoles - A representation of tenant roles to be provisioned.
//
type TenantRoles struct {

	//
	// name of the provider domain
	//
	Domain DomainName `json:"domain"`

	//
	// name of the provider service
	//
	Service SimpleName `json:"service"`

	//
	// name of the tenant domain
	//
	Tenant DomainName `json:"tenant"`

	//
	// the role/action pairs to provision
	//
	Roles []*TenantRoleAction `json:"roles"`
}

//
// NewTenantRoles - creates an initialized TenantRoles instance, returns a pointer to it
//
func NewTenantRoles(init ...*TenantRoles) *TenantRoles {
	var o *TenantRoles
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(TenantRoles)
	}
	return o.Init()
}

//
// Init - sets up the instance according to its default field values, if any
//
func (pTypeDef *TenantRoles) Init() *TenantRoles {
	if pTypeDef.Roles == nil {
		pTypeDef.Roles = make([]*TenantRoleAction, 0)
	}
	return pTypeDef
}

type rawTenantRoles TenantRoles

//
// UnmarshalJSON is defined for proper JSON decoding of a TenantRoles
//
func (pTypeDef *TenantRoles) UnmarshalJSON(b []byte) error {
	var r rawTenantRoles
	err := json.Unmarshal(b, &r)
	if err == nil {
		o := TenantRoles(r)
		*pTypeDef = *((&o).Init())
		err = pTypeDef.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (pTypeDef *TenantRoles) Validate() error {
	if pTypeDef.Domain == "" {
		return fmt.Errorf("TenantRoles.domain is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "DomainName", pTypeDef.Domain)
		if !val.Valid {
			return fmt.Errorf("TenantRoles.domain does not contain a valid DomainName (%v)", val.Error)
		}
	}
	if pTypeDef.Service == "" {
		return fmt.Errorf("TenantRoles.service is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "SimpleName", pTypeDef.Service)
		if !val.Valid {
			return fmt.Errorf("TenantRoles.service does not contain a valid SimpleName (%v)", val.Error)
		}
	}
	if pTypeDef.Tenant == "" {
		return fmt.Errorf("TenantRoles.tenant is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "DomainName", pTypeDef.Tenant)
		if !val.Valid {
			return fmt.Errorf("TenantRoles.tenant does not contain a valid DomainName (%v)", val.Error)
		}
	}
	if pTypeDef.Roles == nil {
		return fmt.Errorf("TenantRoles: Missing required field: roles")
	}
	return nil
}

//
// TenantResourceGroupRoles - A representation of tenant roles for resource
// groups to be provisioned.
//
type TenantResourceGroupRoles struct {

	//
	// name of the provider domain
	//
	Domain DomainName `json:"domain"`

	//
	// name of the provider service
	//
	Service SimpleName `json:"service"`

	//
	// name of the tenant domain
	//
	Tenant DomainName `json:"tenant"`

	//
	// the role/action pairs to provision
	//
	Roles []*TenantRoleAction `json:"roles"`

	//
	// tenant resource group
	//
	ResourceGroup EntityName `json:"resourceGroup"`
}

//
// NewTenantResourceGroupRoles - creates an initialized TenantResourceGroupRoles instance, returns a pointer to it
//
func NewTenantResourceGroupRoles(init ...*TenantResourceGroupRoles) *TenantResourceGroupRoles {
	var o *TenantResourceGroupRoles
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(TenantResourceGroupRoles)
	}
	return o.Init()
}

//
// Init - sets up the instance according to its default field values, if any
//
func (pTypeDef *TenantResourceGroupRoles) Init() *TenantResourceGroupRoles {
	if pTypeDef.Roles == nil {
		pTypeDef.Roles = make([]*TenantRoleAction, 0)
	}
	return pTypeDef
}

type rawTenantResourceGroupRoles TenantResourceGroupRoles

//
// UnmarshalJSON is defined for proper JSON decoding of a TenantResourceGroupRoles
//
func (pTypeDef *TenantResourceGroupRoles) UnmarshalJSON(b []byte) error {
	var r rawTenantResourceGroupRoles
	err := json.Unmarshal(b, &r)
	if err == nil {
		o := TenantResourceGroupRoles(r)
		*pTypeDef = *((&o).Init())
		err = pTypeDef.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (pTypeDef *TenantResourceGroupRoles) Validate() error {
	if pTypeDef.Domain == "" {
		return fmt.Errorf("TenantResourceGroupRoles.domain is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "DomainName", pTypeDef.Domain)
		if !val.Valid {
			return fmt.Errorf("TenantResourceGroupRoles.domain does not contain a valid DomainName (%v)", val.Error)
		}
	}
	if pTypeDef.Service == "" {
		return fmt.Errorf("TenantResourceGroupRoles.service is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "SimpleName", pTypeDef.Service)
		if !val.Valid {
			return fmt.Errorf("TenantResourceGroupRoles.service does not contain a valid SimpleName (%v)", val.Error)
		}
	}
	if pTypeDef.Tenant == "" {
		return fmt.Errorf("TenantResourceGroupRoles.tenant is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "DomainName", pTypeDef.Tenant)
		if !val.Valid {
			return fmt.Errorf("TenantResourceGroupRoles.tenant does not contain a valid DomainName (%v)", val.Error)
		}
	}
	if pTypeDef.Roles == nil {
		return fmt.Errorf("TenantResourceGroupRoles: Missing required field: roles")
	}
	if pTypeDef.ResourceGroup == "" {
		return fmt.Errorf("TenantResourceGroupRoles.resourceGroup is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "EntityName", pTypeDef.ResourceGroup)
		if !val.Valid {
			return fmt.Errorf("TenantResourceGroupRoles.resourceGroup does not contain a valid EntityName (%v)", val.Error)
		}
	}
	return nil
}

//
// ProviderResourceGroupRoles - A representation of provider roles to be
// provisioned.
//
type ProviderResourceGroupRoles struct {

	//
	// name of the provider domain
	//
	Domain DomainName `json:"domain"`

	//
	// name of the provider service
	//
	Service SimpleName `json:"service"`

	//
	// name of the tenant domain
	//
	Tenant DomainName `json:"tenant"`

	//
	// the role/action pairs to provision
	//
	Roles []*TenantRoleAction `json:"roles"`

	//
	// tenant resource group
	//
	ResourceGroup EntityName `json:"resourceGroup"`
}

//
// NewProviderResourceGroupRoles - creates an initialized ProviderResourceGroupRoles instance, returns a pointer to it
//
func NewProviderResourceGroupRoles(init ...*ProviderResourceGroupRoles) *ProviderResourceGroupRoles {
	var o *ProviderResourceGroupRoles
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(ProviderResourceGroupRoles)
	}
	return o.Init()
}

//
// Init - sets up the instance according to its default field values, if any
//
func (pTypeDef *ProviderResourceGroupRoles) Init() *ProviderResourceGroupRoles {
	if pTypeDef.Roles == nil {
		pTypeDef.Roles = make([]*TenantRoleAction, 0)
	}
	return pTypeDef
}

type rawProviderResourceGroupRoles ProviderResourceGroupRoles

//
// UnmarshalJSON is defined for proper JSON decoding of a ProviderResourceGroupRoles
//
func (pTypeDef *ProviderResourceGroupRoles) UnmarshalJSON(b []byte) error {
	var r rawProviderResourceGroupRoles
	err := json.Unmarshal(b, &r)
	if err == nil {
		o := ProviderResourceGroupRoles(r)
		*pTypeDef = *((&o).Init())
		err = pTypeDef.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (pTypeDef *ProviderResourceGroupRoles) Validate() error {
	if pTypeDef.Domain == "" {
		return fmt.Errorf("ProviderResourceGroupRoles.domain is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "DomainName", pTypeDef.Domain)
		if !val.Valid {
			return fmt.Errorf("ProviderResourceGroupRoles.domain does not contain a valid DomainName (%v)", val.Error)
		}
	}
	if pTypeDef.Service == "" {
		return fmt.Errorf("ProviderResourceGroupRoles.service is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "SimpleName", pTypeDef.Service)
		if !val.Valid {
			return fmt.Errorf("ProviderResourceGroupRoles.service does not contain a valid SimpleName (%v)", val.Error)
		}
	}
	if pTypeDef.Tenant == "" {
		return fmt.Errorf("ProviderResourceGroupRoles.tenant is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "DomainName", pTypeDef.Tenant)
		if !val.Valid {
			return fmt.Errorf("ProviderResourceGroupRoles.tenant does not contain a valid DomainName (%v)", val.Error)
		}
	}
	if pTypeDef.Roles == nil {
		return fmt.Errorf("ProviderResourceGroupRoles: Missing required field: roles")
	}
	if pTypeDef.ResourceGroup == "" {
		return fmt.Errorf("ProviderResourceGroupRoles.resourceGroup is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "EntityName", pTypeDef.ResourceGroup)
		if !val.Valid {
			return fmt.Errorf("ProviderResourceGroupRoles.resourceGroup does not contain a valid EntityName (%v)", val.Error)
		}
	}
	return nil
}

//
// Access - Access can be checked and returned as this resource.
//
type Access struct {

	//
	// true (allowed) or false (denied)
	//
	Granted bool `json:"granted"`
}

//
// NewAccess - creates an initialized Access instance, returns a pointer to it
//
func NewAccess(init ...*Access) *Access {
	var o *Access
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(Access)
	}
	return o
}

type rawAccess Access

//
// UnmarshalJSON is defined for proper JSON decoding of a Access
//
func (pTypeDef *Access) UnmarshalJSON(b []byte) error {
	var r rawAccess
	err := json.Unmarshal(b, &r)
	if err == nil {
		o := Access(r)
		*pTypeDef = o
		err = pTypeDef.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (pTypeDef *Access) Validate() error {
	return nil
}

//
// ResourceAccess -
//
type ResourceAccess struct {
	Principal  EntityName   `json:"principal"`
	Assertions []*Assertion `json:"assertions"`
}

//
// NewResourceAccess - creates an initialized ResourceAccess instance, returns a pointer to it
//
func NewResourceAccess(init ...*ResourceAccess) *ResourceAccess {
	var o *ResourceAccess
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(ResourceAccess)
	}
	return o.Init()
}

//
// Init - sets up the instance according to its default field values, if any
//
func (pTypeDef *ResourceAccess) Init() *ResourceAccess {
	if pTypeDef.Assertions == nil {
		pTypeDef.Assertions = make([]*Assertion, 0)
	}
	return pTypeDef
}

type rawResourceAccess ResourceAccess

//
// UnmarshalJSON is defined for proper JSON decoding of a ResourceAccess
//
func (pTypeDef *ResourceAccess) UnmarshalJSON(b []byte) error {
	var r rawResourceAccess
	err := json.Unmarshal(b, &r)
	if err == nil {
		o := ResourceAccess(r)
		*pTypeDef = *((&o).Init())
		err = pTypeDef.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (pTypeDef *ResourceAccess) Validate() error {
	if pTypeDef.Principal == "" {
		return fmt.Errorf("ResourceAccess.principal is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "EntityName", pTypeDef.Principal)
		if !val.Valid {
			return fmt.Errorf("ResourceAccess.principal does not contain a valid EntityName (%v)", val.Error)
		}
	}
	if pTypeDef.Assertions == nil {
		return fmt.Errorf("ResourceAccess: Missing required field: assertions")
	}
	return nil
}

//
// ResourceAccessList -
//
type ResourceAccessList struct {
	Resources []*ResourceAccess `json:"resources"`
}

//
// NewResourceAccessList - creates an initialized ResourceAccessList instance, returns a pointer to it
//
func NewResourceAccessList(init ...*ResourceAccessList) *ResourceAccessList {
	var o *ResourceAccessList
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(ResourceAccessList)
	}
	return o.Init()
}

//
// Init - sets up the instance according to its default field values, if any
//
func (pTypeDef *ResourceAccessList) Init() *ResourceAccessList {
	if pTypeDef.Resources == nil {
		pTypeDef.Resources = make([]*ResourceAccess, 0)
	}
	return pTypeDef
}

type rawResourceAccessList ResourceAccessList

//
// UnmarshalJSON is defined for proper JSON decoding of a ResourceAccessList
//
func (pTypeDef *ResourceAccessList) UnmarshalJSON(b []byte) error {
	var r rawResourceAccessList
	err := json.Unmarshal(b, &r)
	if err == nil {
		o := ResourceAccessList(r)
		*pTypeDef = *((&o).Init())
		err = pTypeDef.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (pTypeDef *ResourceAccessList) Validate() error {
	if pTypeDef.Resources == nil {
		return fmt.Errorf("ResourceAccessList: Missing required field: resources")
	}
	return nil
}

//
// DomainModified - Tuple of domain-name and modification time-stamps. This
// object is returned when the caller has requested list of domains modified
// since a specific timestamp.
//
type DomainModified struct {

	//
	// name of the domain
	//
	Name DomainName `json:"name"`

	//
	// last modified timestamp of the domain
	//
	Modified int64 `json:"modified"`
}

//
// NewDomainModified - creates an initialized DomainModified instance, returns a pointer to it
//
func NewDomainModified(init ...*DomainModified) *DomainModified {
	var o *DomainModified
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(DomainModified)
	}
	return o
}

type rawDomainModified DomainModified

//
// UnmarshalJSON is defined for proper JSON decoding of a DomainModified
//
func (pTypeDef *DomainModified) UnmarshalJSON(b []byte) error {
	var r rawDomainModified
	err := json.Unmarshal(b, &r)
	if err == nil {
		o := DomainModified(r)
		*pTypeDef = o
		err = pTypeDef.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (pTypeDef *DomainModified) Validate() error {
	if pTypeDef.Name == "" {
		return fmt.Errorf("DomainModified.name is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "DomainName", pTypeDef.Name)
		if !val.Valid {
			return fmt.Errorf("DomainModified.name does not contain a valid DomainName (%v)", val.Error)
		}
	}
	return nil
}

//
// DomainModifiedList - A list of {domain, modified-timestamp} tuples.
//
type DomainModifiedList struct {

	//
	// list of modified domains
	//
	NameModList []*DomainModified `json:"nameModList"`
}

//
// NewDomainModifiedList - creates an initialized DomainModifiedList instance, returns a pointer to it
//
func NewDomainModifiedList(init ...*DomainModifiedList) *DomainModifiedList {
	var o *DomainModifiedList
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(DomainModifiedList)
	}
	return o.Init()
}

//
// Init - sets up the instance according to its default field values, if any
//
func (pTypeDef *DomainModifiedList) Init() *DomainModifiedList {
	if pTypeDef.NameModList == nil {
		pTypeDef.NameModList = make([]*DomainModified, 0)
	}
	return pTypeDef
}

type rawDomainModifiedList DomainModifiedList

//
// UnmarshalJSON is defined for proper JSON decoding of a DomainModifiedList
//
func (pTypeDef *DomainModifiedList) UnmarshalJSON(b []byte) error {
	var r rawDomainModifiedList
	err := json.Unmarshal(b, &r)
	if err == nil {
		o := DomainModifiedList(r)
		*pTypeDef = *((&o).Init())
		err = pTypeDef.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (pTypeDef *DomainModifiedList) Validate() error {
	if pTypeDef.NameModList == nil {
		return fmt.Errorf("DomainModifiedList: Missing required field: nameModList")
	}
	return nil
}

//
// DomainPolicies - We need to include the name of the domain in this struct
// since this data will be passed back to ZPU through ZTS so we need to sign not
// only the list of policies but also the corresponding domain name that the
// policies belong to.
//
type DomainPolicies struct {

	//
	// name of the domain
	//
	Domain DomainName `json:"domain"`

	//
	// list of policies defined in this server
	//
	Policies []*Policy `json:"policies"`
}

//
// NewDomainPolicies - creates an initialized DomainPolicies instance, returns a pointer to it
//
func NewDomainPolicies(init ...*DomainPolicies) *DomainPolicies {
	var o *DomainPolicies
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(DomainPolicies)
	}
	return o.Init()
}

//
// Init - sets up the instance according to its default field values, if any
//
func (pTypeDef *DomainPolicies) Init() *DomainPolicies {
	if pTypeDef.Policies == nil {
		pTypeDef.Policies = make([]*Policy, 0)
	}
	return pTypeDef
}

type rawDomainPolicies DomainPolicies

//
// UnmarshalJSON is defined for proper JSON decoding of a DomainPolicies
//
func (pTypeDef *DomainPolicies) UnmarshalJSON(b []byte) error {
	var r rawDomainPolicies
	err := json.Unmarshal(b, &r)
	if err == nil {
		o := DomainPolicies(r)
		*pTypeDef = *((&o).Init())
		err = pTypeDef.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (pTypeDef *DomainPolicies) Validate() error {
	if pTypeDef.Domain == "" {
		return fmt.Errorf("DomainPolicies.domain is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "DomainName", pTypeDef.Domain)
		if !val.Valid {
			return fmt.Errorf("DomainPolicies.domain does not contain a valid DomainName (%v)", val.Error)
		}
	}
	if pTypeDef.Policies == nil {
		return fmt.Errorf("DomainPolicies: Missing required field: policies")
	}
	return nil
}

//
// SignedPolicies - A signed bulk transfer of policies. The data is signed with
// server's private key.
//
type SignedPolicies struct {

	//
	// list of policies defined in a domain
	//
	Contents *DomainPolicies `json:"contents"`

	//
	// signature generated based on the domain policies object
	//
	Signature string `json:"signature"`

	//
	// the identifier of the key used to generate the signature
	//
	KeyId string `json:"keyId"`
}

//
// NewSignedPolicies - creates an initialized SignedPolicies instance, returns a pointer to it
//
func NewSignedPolicies(init ...*SignedPolicies) *SignedPolicies {
	var o *SignedPolicies
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(SignedPolicies)
	}
	return o.Init()
}

//
// Init - sets up the instance according to its default field values, if any
//
func (pTypeDef *SignedPolicies) Init() *SignedPolicies {
	if pTypeDef.Contents == nil {
		pTypeDef.Contents = NewDomainPolicies()
	}
	return pTypeDef
}

type rawSignedPolicies SignedPolicies

//
// UnmarshalJSON is defined for proper JSON decoding of a SignedPolicies
//
func (pTypeDef *SignedPolicies) UnmarshalJSON(b []byte) error {
	var r rawSignedPolicies
	err := json.Unmarshal(b, &r)
	if err == nil {
		o := SignedPolicies(r)
		*pTypeDef = *((&o).Init())
		err = pTypeDef.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (pTypeDef *SignedPolicies) Validate() error {
	if pTypeDef.Contents == nil {
		return fmt.Errorf("SignedPolicies: Missing required field: contents")
	}
	if pTypeDef.Signature == "" {
		return fmt.Errorf("SignedPolicies.signature is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "String", pTypeDef.Signature)
		if !val.Valid {
			return fmt.Errorf("SignedPolicies.signature does not contain a valid String (%v)", val.Error)
		}
	}
	if pTypeDef.KeyId == "" {
		return fmt.Errorf("SignedPolicies.keyId is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "String", pTypeDef.KeyId)
		if !val.Valid {
			return fmt.Errorf("SignedPolicies.keyId does not contain a valid String (%v)", val.Error)
		}
	}
	return nil
}

//
// DomainData - A domain object that includes its roles, policies and services.
//
type DomainData struct {

	//
	// name of the domain
	//
	Name DomainName `json:"name"`

	//
	// associated cloud (i.e. aws) account id
	//
	Account string `json:"account,omitempty" rdl:"optional"`

	//
	// associated product id
	//
	YpmId *int32 `json:"ypmId,omitempty" rdl:"optional"`

	//
	// list of roles in the domain
	//
	Roles []*Role `json:"roles"`

	//
	// list of policies in the domain signed with ZMS private key
	//
	Policies *SignedPolicies `json:"policies"`

	//
	// list of services in the domain
	//
	Services []*ServiceIdentity `json:"services"`

	//
	// list of entities in the domain
	//
	Entities []*Entity `json:"entities"`

	//
	// last modification timestamp
	//
	Modified rdl.Timestamp `json:"modified"`
}

//
// NewDomainData - creates an initialized DomainData instance, returns a pointer to it
//
func NewDomainData(init ...*DomainData) *DomainData {
	var o *DomainData
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(DomainData)
	}
	return o.Init()
}

//
// Init - sets up the instance according to its default field values, if any
//
func (pTypeDef *DomainData) Init() *DomainData {
	if pTypeDef.Roles == nil {
		pTypeDef.Roles = make([]*Role, 0)
	}
	if pTypeDef.Policies == nil {
		pTypeDef.Policies = NewSignedPolicies()
	}
	if pTypeDef.Services == nil {
		pTypeDef.Services = make([]*ServiceIdentity, 0)
	}
	if pTypeDef.Entities == nil {
		pTypeDef.Entities = make([]*Entity, 0)
	}
	return pTypeDef
}

type rawDomainData DomainData

//
// UnmarshalJSON is defined for proper JSON decoding of a DomainData
//
func (pTypeDef *DomainData) UnmarshalJSON(b []byte) error {
	var r rawDomainData
	err := json.Unmarshal(b, &r)
	if err == nil {
		o := DomainData(r)
		*pTypeDef = *((&o).Init())
		err = pTypeDef.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (pTypeDef *DomainData) Validate() error {
	if pTypeDef.Name == "" {
		return fmt.Errorf("DomainData.name is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "DomainName", pTypeDef.Name)
		if !val.Valid {
			return fmt.Errorf("DomainData.name does not contain a valid DomainName (%v)", val.Error)
		}
	}
	if pTypeDef.Roles == nil {
		return fmt.Errorf("DomainData: Missing required field: roles")
	}
	if pTypeDef.Policies == nil {
		return fmt.Errorf("DomainData: Missing required field: policies")
	}
	if pTypeDef.Services == nil {
		return fmt.Errorf("DomainData: Missing required field: services")
	}
	if pTypeDef.Entities == nil {
		return fmt.Errorf("DomainData: Missing required field: entities")
	}
	if pTypeDef.Modified.IsZero() {
		return fmt.Errorf("DomainData: Missing required field: modified")
	}
	return nil
}

//
// SignedDomain - A domain object signed with server's private key
//
type SignedDomain struct {

	//
	// domain object with its roles, policies and services
	//
	Domain *DomainData `json:"domain"`

	//
	// signature generated based on the domain object
	//
	Signature string `json:"signature"`

	//
	// the identifier of the key used to generate the signature
	//
	KeyId string `json:"keyId"`
}

//
// NewSignedDomain - creates an initialized SignedDomain instance, returns a pointer to it
//
func NewSignedDomain(init ...*SignedDomain) *SignedDomain {
	var o *SignedDomain
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(SignedDomain)
	}
	return o.Init()
}

//
// Init - sets up the instance according to its default field values, if any
//
func (pTypeDef *SignedDomain) Init() *SignedDomain {
	if pTypeDef.Domain == nil {
		pTypeDef.Domain = NewDomainData()
	}
	return pTypeDef
}

type rawSignedDomain SignedDomain

//
// UnmarshalJSON is defined for proper JSON decoding of a SignedDomain
//
func (pTypeDef *SignedDomain) UnmarshalJSON(b []byte) error {
	var r rawSignedDomain
	err := json.Unmarshal(b, &r)
	if err == nil {
		o := SignedDomain(r)
		*pTypeDef = *((&o).Init())
		err = pTypeDef.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (pTypeDef *SignedDomain) Validate() error {
	if pTypeDef.Domain == nil {
		return fmt.Errorf("SignedDomain: Missing required field: domain")
	}
	if pTypeDef.Signature == "" {
		return fmt.Errorf("SignedDomain.signature is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "String", pTypeDef.Signature)
		if !val.Valid {
			return fmt.Errorf("SignedDomain.signature does not contain a valid String (%v)", val.Error)
		}
	}
	if pTypeDef.KeyId == "" {
		return fmt.Errorf("SignedDomain.keyId is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "String", pTypeDef.KeyId)
		if !val.Valid {
			return fmt.Errorf("SignedDomain.keyId does not contain a valid String (%v)", val.Error)
		}
	}
	return nil
}

//
// SignedDomains - A list of signed domain objects
//
type SignedDomains struct {
	Domains []*SignedDomain `json:"domains"`
}

//
// NewSignedDomains - creates an initialized SignedDomains instance, returns a pointer to it
//
func NewSignedDomains(init ...*SignedDomains) *SignedDomains {
	var o *SignedDomains
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(SignedDomains)
	}
	return o.Init()
}

//
// Init - sets up the instance according to its default field values, if any
//
func (pTypeDef *SignedDomains) Init() *SignedDomains {
	if pTypeDef.Domains == nil {
		pTypeDef.Domains = make([]*SignedDomain, 0)
	}
	return pTypeDef
}

type rawSignedDomains SignedDomains

//
// UnmarshalJSON is defined for proper JSON decoding of a SignedDomains
//
func (pTypeDef *SignedDomains) UnmarshalJSON(b []byte) error {
	var r rawSignedDomains
	err := json.Unmarshal(b, &r)
	if err == nil {
		o := SignedDomains(r)
		*pTypeDef = *((&o).Init())
		err = pTypeDef.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (pTypeDef *SignedDomains) Validate() error {
	if pTypeDef.Domains == nil {
		return fmt.Errorf("SignedDomains: Missing required field: domains")
	}
	return nil
}

//
// UserToken - A user token generated based on user's credentials
//
type UserToken struct {

	//
	// Signed user token identifying a specific authenticated user
	//
	Token SignedToken `json:"token"`
}

//
// NewUserToken - creates an initialized UserToken instance, returns a pointer to it
//
func NewUserToken(init ...*UserToken) *UserToken {
	var o *UserToken
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(UserToken)
	}
	return o
}

type rawUserToken UserToken

//
// UnmarshalJSON is defined for proper JSON decoding of a UserToken
//
func (pTypeDef *UserToken) UnmarshalJSON(b []byte) error {
	var r rawUserToken
	err := json.Unmarshal(b, &r)
	if err == nil {
		o := UserToken(r)
		*pTypeDef = o
		err = pTypeDef.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (pTypeDef *UserToken) Validate() error {
	if pTypeDef.Token == "" {
		return fmt.Errorf("UserToken.token is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "SignedToken", pTypeDef.Token)
		if !val.Valid {
			return fmt.Errorf("UserToken.token does not contain a valid SignedToken (%v)", val.Error)
		}
	}
	return nil
}

//
// ServicePrincipal - A service principal object identifying a given service.
//
type ServicePrincipal struct {

	//
	// name of the domain
	//
	Domain DomainName `json:"domain"`

	//
	// name of the service
	//
	Service EntityName `json:"service"`

	//
	// service's signed token
	//
	Token SignedToken `json:"token"`
}

//
// NewServicePrincipal - creates an initialized ServicePrincipal instance, returns a pointer to it
//
func NewServicePrincipal(init ...*ServicePrincipal) *ServicePrincipal {
	var o *ServicePrincipal
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(ServicePrincipal)
	}
	return o
}

type rawServicePrincipal ServicePrincipal

//
// UnmarshalJSON is defined for proper JSON decoding of a ServicePrincipal
//
func (pTypeDef *ServicePrincipal) UnmarshalJSON(b []byte) error {
	var r rawServicePrincipal
	err := json.Unmarshal(b, &r)
	if err == nil {
		o := ServicePrincipal(r)
		*pTypeDef = o
		err = pTypeDef.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (pTypeDef *ServicePrincipal) Validate() error {
	if pTypeDef.Domain == "" {
		return fmt.Errorf("ServicePrincipal.domain is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "DomainName", pTypeDef.Domain)
		if !val.Valid {
			return fmt.Errorf("ServicePrincipal.domain does not contain a valid DomainName (%v)", val.Error)
		}
	}
	if pTypeDef.Service == "" {
		return fmt.Errorf("ServicePrincipal.service is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "EntityName", pTypeDef.Service)
		if !val.Valid {
			return fmt.Errorf("ServicePrincipal.service does not contain a valid EntityName (%v)", val.Error)
		}
	}
	if pTypeDef.Token == "" {
		return fmt.Errorf("ServicePrincipal.token is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "SignedToken", pTypeDef.Token)
		if !val.Valid {
			return fmt.Errorf("ServicePrincipal.token does not contain a valid SignedToken (%v)", val.Error)
		}
	}
	return nil
}
