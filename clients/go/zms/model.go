// Code generated by rdl 1.5.2 DO NOT EDIT.

package zms

import (
	"encoding/json"
	"fmt"
	rdl "github.com/ardielle/ardielle-go/rdl"
)

var _ = rdl.Version
var _ = json.Marshal
var _ = fmt.Printf

// SimpleName - Copyright The Athenz Authors Licensed under the terms of the
// Apache version 2.0 license. See LICENSE file for terms. Common name types
// used by several API definitions A simple identifier, an element of compound
// name.
type SimpleName string

// CompoundName - A compound name. Most names in this API are compound names.
type CompoundName string

// DomainName - A domain name is the general qualifier prefix, as its
// uniqueness is managed.
type DomainName string

// EntityName - An entity name is a short form of a resource name, including
// only the domain and entity.
type EntityName string

// ServiceName - A service name will generally be a unique subdomain.
type ServiceName string

// LocationName - A location name is not yet defined, but will be a dotted name
// like everything else.
type LocationName string

// ActionName - An action (operation) name.
type ActionName string

// ResourceName - A resource name Note that the EntityName part is optional,
// that is, a domain name followed by a colon is valid resource name.
type ResourceName string

// ResourceNames - A comma separated list of resource names
type ResourceNames string

// YBase64 - The Y-specific URL-safe Base64 variant.
type YBase64 string

// YEncoded - YEncoded includes ybase64 chars, as well as = and %. This can
// represent a user cookie and URL-encoded values.
type YEncoded string

// AuthorityName - Used as the prefix in a signed assertion. This uniquely
// identifies a signing authority.
type AuthorityName string

// SignedToken - A signed assertion if identity. i.e. the user cookie value.
// This token will only make sense to the authority that generated it, so it is
// beneficial to have something in the value that is cheaply recognized to
// quickly reject if it belongs to another authority. In addition to the
// YEncoded set our token includes ; to separate components and , to separate
// roles and : for IPv6 addresses
type SignedToken string

// GroupName - A group name
type GroupName string

// GroupMemberName - A group member name
type GroupMemberName string

// MemberName - Role Member name - could be one of four values: *, DomainName.*
// or ServiceName[*], or GroupNames
type MemberName string

// AuthorityKeyword - A comma separated list of authority keywords
type AuthorityKeyword string

// AuthorityKeywords -
type AuthorityKeywords string

// TagKey -
type TagKey string

// TagValue - TagValue to contain generic string patterns
type TagValue string

// TagCompoundValue - A compound value of TagValue
type TagCompoundValue string

// TagValueList -
type TagValueList struct {

	//
	// list of tag values
	//
	List []TagCompoundValue `json:"list"`
}

// NewTagValueList - creates an initialized TagValueList instance, returns a pointer to it
func NewTagValueList(init ...*TagValueList) *TagValueList {
	var o *TagValueList
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(TagValueList)
	}
	return o.Init()
}

// Init - sets up the instance according to its default field values, if any
func (self *TagValueList) Init() *TagValueList {
	if self.List == nil {
		self.List = make([]TagCompoundValue, 0)
	}
	return self
}

type rawTagValueList TagValueList

// UnmarshalJSON is defined for proper JSON decoding of a TagValueList
func (self *TagValueList) UnmarshalJSON(b []byte) error {
	var m rawTagValueList
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := TagValueList(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *TagValueList) Validate() error {
	if self.List == nil {
		return fmt.Errorf("TagValueList: Missing required field: list")
	}
	return nil
}

// AssertionConditionKeyPattern -
type AssertionConditionKeyPattern string

// AssertionConditionKey -
type AssertionConditionKey string

// AssertionConditionValuePattern -
type AssertionConditionValuePattern string

// AssertionConditionValue -
type AssertionConditionValue string

// ResourceOwnerName -
type ResourceOwnerName string

// ResourceDomainOwnership - The representation of the domain ownership object
type ResourceDomainOwnership struct {

	//
	// owner of the object's meta attribute
	//
	MetaOwner SimpleName `json:"metaOwner,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// owner of the object itself - checked for object deletion
	//
	ObjectOwner SimpleName `json:"objectOwner,omitempty" rdl:"optional" yaml:",omitempty"`
}

// NewResourceDomainOwnership - creates an initialized ResourceDomainOwnership instance, returns a pointer to it
func NewResourceDomainOwnership(init ...*ResourceDomainOwnership) *ResourceDomainOwnership {
	var o *ResourceDomainOwnership
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(ResourceDomainOwnership)
	}
	return o
}

type rawResourceDomainOwnership ResourceDomainOwnership

// UnmarshalJSON is defined for proper JSON decoding of a ResourceDomainOwnership
func (self *ResourceDomainOwnership) UnmarshalJSON(b []byte) error {
	var m rawResourceDomainOwnership
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := ResourceDomainOwnership(m)
		*self = o
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *ResourceDomainOwnership) Validate() error {
	if self.MetaOwner != "" {
		val := rdl.Validate(ZMSSchema(), "SimpleName", self.MetaOwner)
		if !val.Valid {
			return fmt.Errorf("ResourceDomainOwnership.metaOwner does not contain a valid SimpleName (%v)", val.Error)
		}
	}
	if self.ObjectOwner != "" {
		val := rdl.Validate(ZMSSchema(), "SimpleName", self.ObjectOwner)
		if !val.Valid {
			return fmt.Errorf("ResourceDomainOwnership.objectOwner does not contain a valid SimpleName (%v)", val.Error)
		}
	}
	return nil
}

// DomainMeta - Set of metadata attributes that all domains may have and can be
// changed.
type DomainMeta struct {

	//
	// a description of the domain
	//
	Description string `json:"description" rdl:"optional" yaml:",omitempty"`

	//
	// a reference to an audit organization defined in athenz
	//
	Org ResourceName `json:"org,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// Future use only, currently not used
	//
	Enabled *bool `json:"enabled,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// Flag indicates whether or not domain modifications should be logged for
	// SOX+Auditing. If true, the auditRef parameter must be supplied(not empty) for
	// any API defining it.
	//
	AuditEnabled *bool `json:"auditEnabled,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// associated aws account id (system attribute - uniqueness check - if
	// enabled)
	//
	Account string `json:"account" rdl:"optional" yaml:",omitempty"`

	//
	// associated product id (system attribute - uniqueness check - if enabled)
	//
	YpmId *int32 `json:"ypmId,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// associated application id
	//
	ApplicationId string `json:"applicationId" rdl:"optional" yaml:",omitempty"`

	//
	// domain certificate dns domain (system attribute)
	//
	CertDnsDomain string `json:"certDnsDomain" rdl:"optional" yaml:",omitempty"`

	//
	// all user members in the domain will have specified max expiry days
	//
	MemberExpiryDays *int32 `json:"memberExpiryDays,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// tokens issued for this domain will have specified max timeout in mins
	//
	TokenExpiryMins *int32 `json:"tokenExpiryMins,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// service identity certs issued for this domain will have specified max
	// timeout in mins
	//
	ServiceCertExpiryMins *int32 `json:"serviceCertExpiryMins,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// role certs issued for this domain will have specified max timeout in mins
	//
	RoleCertExpiryMins *int32 `json:"roleCertExpiryMins,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// rsa or ec signing algorithm to be used for tokens
	//
	SignAlgorithm string `json:"signAlgorithm" rdl:"optional" yaml:",omitempty"`

	//
	// all services in the domain roles will have specified max expiry days
	//
	ServiceExpiryDays *int32 `json:"serviceExpiryDays,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// all groups in the domain roles will have specified max expiry days
	//
	GroupExpiryDays *int32 `json:"groupExpiryDays,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// membership filtered based on user authority configured attributes
	//
	UserAuthorityFilter string `json:"userAuthorityFilter" rdl:"optional" yaml:",omitempty"`

	//
	// associated azure subscription id (system attribute - uniqueness check - if
	// enabled)
	//
	AzureSubscription string `json:"azureSubscription" rdl:"optional" yaml:",omitempty"`

	//
	// associated azure tenant id (system attribute)
	//
	AzureTenant string `json:"azureTenant" rdl:"optional" yaml:",omitempty"`

	//
	// associated azure client id (system attribute)
	//
	AzureClient string `json:"azureClient" rdl:"optional" yaml:",omitempty"`

	//
	// associated gcp project id (system attribute - uniqueness check - if
	// enabled)
	//
	GcpProject string `json:"gcpProject" rdl:"optional" yaml:",omitempty"`

	//
	// associated gcp project number (system attribute)
	//
	GcpProjectNumber string `json:"gcpProjectNumber" rdl:"optional" yaml:",omitempty"`

	//
	// key-value pair tags, tag might contain multiple values
	//
	Tags map[TagKey]*TagValueList `json:"tags,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// associated business service with domain
	//
	BusinessService string `json:"businessService" rdl:"optional" yaml:",omitempty"`

	//
	// purge role/group members with expiry date configured days in the past
	//
	MemberPurgeExpiryDays *int32 `json:"memberPurgeExpiryDays,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// associated product id (system attribute - uniqueness check - if enabled)
	//
	ProductId string `json:"productId" rdl:"optional" yaml:",omitempty"`

	//
	// features enabled per domain (system attribute)
	//
	FeatureFlags *int32 `json:"featureFlags,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// list of domain contacts (PE-Owner, Product-Owner, etc), each type can have
	// a single value
	//
	Contacts map[SimpleName]string `json:"contacts,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// domain environment e.g. production, staging, etc
	//
	Environment string `json:"environment" rdl:"optional" yaml:",omitempty"`

	//
	// ownership information for the domain (read-only attribute)
	//
	ResourceOwnership *ResourceDomainOwnership `json:"resourceOwnership,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// requested x509 cert signer key id (system attribute)
	//
	X509CertSignerKeyId string `json:"x509CertSignerKeyId" rdl:"optional" yaml:",omitempty"`

	//
	// requested ssh cert signer key id (system attribute)
	//
	SshCertSignerKeyId string `json:"sshCertSignerKeyId" rdl:"optional" yaml:",omitempty"`

	//
	// slack channel for any notifications in this domain
	//
	SlackChannel string `json:"slackChannel" rdl:"optional" yaml:",omitempty"`
}

// NewDomainMeta - creates an initialized DomainMeta instance, returns a pointer to it
func NewDomainMeta(init ...*DomainMeta) *DomainMeta {
	var o *DomainMeta
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(DomainMeta)
	}
	return o.Init()
}

// Init - sets up the instance according to its default field values, if any
func (self *DomainMeta) Init() *DomainMeta {
	if self.Enabled == nil {
		d := true
		self.Enabled = &d
	}
	if self.AuditEnabled == nil {
		d := false
		self.AuditEnabled = &d
	}
	return self
}

type rawDomainMeta DomainMeta

// UnmarshalJSON is defined for proper JSON decoding of a DomainMeta
func (self *DomainMeta) UnmarshalJSON(b []byte) error {
	var m rawDomainMeta
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := DomainMeta(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *DomainMeta) Validate() error {
	if self.Description != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.Description)
		if !val.Valid {
			return fmt.Errorf("DomainMeta.description does not contain a valid String (%v)", val.Error)
		}
	}
	if self.Org != "" {
		val := rdl.Validate(ZMSSchema(), "ResourceName", self.Org)
		if !val.Valid {
			return fmt.Errorf("DomainMeta.org does not contain a valid ResourceName (%v)", val.Error)
		}
	}
	if self.Account != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.Account)
		if !val.Valid {
			return fmt.Errorf("DomainMeta.account does not contain a valid String (%v)", val.Error)
		}
	}
	if self.ApplicationId != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.ApplicationId)
		if !val.Valid {
			return fmt.Errorf("DomainMeta.applicationId does not contain a valid String (%v)", val.Error)
		}
	}
	if self.CertDnsDomain != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.CertDnsDomain)
		if !val.Valid {
			return fmt.Errorf("DomainMeta.certDnsDomain does not contain a valid String (%v)", val.Error)
		}
	}
	if self.SignAlgorithm != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.SignAlgorithm)
		if !val.Valid {
			return fmt.Errorf("DomainMeta.signAlgorithm does not contain a valid String (%v)", val.Error)
		}
	}
	if self.UserAuthorityFilter != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.UserAuthorityFilter)
		if !val.Valid {
			return fmt.Errorf("DomainMeta.userAuthorityFilter does not contain a valid String (%v)", val.Error)
		}
	}
	if self.AzureSubscription != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.AzureSubscription)
		if !val.Valid {
			return fmt.Errorf("DomainMeta.azureSubscription does not contain a valid String (%v)", val.Error)
		}
	}
	if self.AzureTenant != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.AzureTenant)
		if !val.Valid {
			return fmt.Errorf("DomainMeta.azureTenant does not contain a valid String (%v)", val.Error)
		}
	}
	if self.AzureClient != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.AzureClient)
		if !val.Valid {
			return fmt.Errorf("DomainMeta.azureClient does not contain a valid String (%v)", val.Error)
		}
	}
	if self.GcpProject != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.GcpProject)
		if !val.Valid {
			return fmt.Errorf("DomainMeta.gcpProject does not contain a valid String (%v)", val.Error)
		}
	}
	if self.GcpProjectNumber != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.GcpProjectNumber)
		if !val.Valid {
			return fmt.Errorf("DomainMeta.gcpProjectNumber does not contain a valid String (%v)", val.Error)
		}
	}
	if self.BusinessService != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.BusinessService)
		if !val.Valid {
			return fmt.Errorf("DomainMeta.businessService does not contain a valid String (%v)", val.Error)
		}
	}
	if self.ProductId != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.ProductId)
		if !val.Valid {
			return fmt.Errorf("DomainMeta.productId does not contain a valid String (%v)", val.Error)
		}
	}
	if self.Environment != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.Environment)
		if !val.Valid {
			return fmt.Errorf("DomainMeta.environment does not contain a valid String (%v)", val.Error)
		}
	}
	if self.X509CertSignerKeyId != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.X509CertSignerKeyId)
		if !val.Valid {
			return fmt.Errorf("DomainMeta.x509CertSignerKeyId does not contain a valid String (%v)", val.Error)
		}
	}
	if self.SshCertSignerKeyId != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.SshCertSignerKeyId)
		if !val.Valid {
			return fmt.Errorf("DomainMeta.sshCertSignerKeyId does not contain a valid String (%v)", val.Error)
		}
	}
	if self.SlackChannel != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.SlackChannel)
		if !val.Valid {
			return fmt.Errorf("DomainMeta.slackChannel does not contain a valid String (%v)", val.Error)
		}
	}
	return nil
}

// Domain - A domain is an independent partition of users, roles, and
// resources. Its name represents the definition of a namespace; the only way a
// new namespace can be created, from the top, is by creating Domains.
// Administration of a domain is governed by the parent domain (using
// reverse-DNS namespaces). The top level domains are governed by the special
// "sys.auth" domain.
type Domain struct {

	//
	// a description of the domain
	//
	Description string `json:"description" rdl:"optional" yaml:",omitempty"`

	//
	// a reference to an audit organization defined in athenz
	//
	Org ResourceName `json:"org,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// Future use only, currently not used
	//
	Enabled *bool `json:"enabled,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// Flag indicates whether or not domain modifications should be logged for
	// SOX+Auditing. If true, the auditRef parameter must be supplied(not empty) for
	// any API defining it.
	//
	AuditEnabled *bool `json:"auditEnabled,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// associated aws account id (system attribute - uniqueness check - if
	// enabled)
	//
	Account string `json:"account" rdl:"optional" yaml:",omitempty"`

	//
	// associated product id (system attribute - uniqueness check - if enabled)
	//
	YpmId *int32 `json:"ypmId,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// associated application id
	//
	ApplicationId string `json:"applicationId" rdl:"optional" yaml:",omitempty"`

	//
	// domain certificate dns domain (system attribute)
	//
	CertDnsDomain string `json:"certDnsDomain" rdl:"optional" yaml:",omitempty"`

	//
	// all user members in the domain will have specified max expiry days
	//
	MemberExpiryDays *int32 `json:"memberExpiryDays,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// tokens issued for this domain will have specified max timeout in mins
	//
	TokenExpiryMins *int32 `json:"tokenExpiryMins,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// service identity certs issued for this domain will have specified max
	// timeout in mins
	//
	ServiceCertExpiryMins *int32 `json:"serviceCertExpiryMins,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// role certs issued for this domain will have specified max timeout in mins
	//
	RoleCertExpiryMins *int32 `json:"roleCertExpiryMins,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// rsa or ec signing algorithm to be used for tokens
	//
	SignAlgorithm string `json:"signAlgorithm" rdl:"optional" yaml:",omitempty"`

	//
	// all services in the domain roles will have specified max expiry days
	//
	ServiceExpiryDays *int32 `json:"serviceExpiryDays,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// all groups in the domain roles will have specified max expiry days
	//
	GroupExpiryDays *int32 `json:"groupExpiryDays,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// membership filtered based on user authority configured attributes
	//
	UserAuthorityFilter string `json:"userAuthorityFilter" rdl:"optional" yaml:",omitempty"`

	//
	// associated azure subscription id (system attribute - uniqueness check - if
	// enabled)
	//
	AzureSubscription string `json:"azureSubscription" rdl:"optional" yaml:",omitempty"`

	//
	// associated azure tenant id (system attribute)
	//
	AzureTenant string `json:"azureTenant" rdl:"optional" yaml:",omitempty"`

	//
	// associated azure client id (system attribute)
	//
	AzureClient string `json:"azureClient" rdl:"optional" yaml:",omitempty"`

	//
	// associated gcp project id (system attribute - uniqueness check - if
	// enabled)
	//
	GcpProject string `json:"gcpProject" rdl:"optional" yaml:",omitempty"`

	//
	// associated gcp project number (system attribute)
	//
	GcpProjectNumber string `json:"gcpProjectNumber" rdl:"optional" yaml:",omitempty"`

	//
	// key-value pair tags, tag might contain multiple values
	//
	Tags map[TagKey]*TagValueList `json:"tags,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// associated business service with domain
	//
	BusinessService string `json:"businessService" rdl:"optional" yaml:",omitempty"`

	//
	// purge role/group members with expiry date configured days in the past
	//
	MemberPurgeExpiryDays *int32 `json:"memberPurgeExpiryDays,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// associated product id (system attribute - uniqueness check - if enabled)
	//
	ProductId string `json:"productId" rdl:"optional" yaml:",omitempty"`

	//
	// features enabled per domain (system attribute)
	//
	FeatureFlags *int32 `json:"featureFlags,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// list of domain contacts (PE-Owner, Product-Owner, etc), each type can have
	// a single value
	//
	Contacts map[SimpleName]string `json:"contacts,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// domain environment e.g. production, staging, etc
	//
	Environment string `json:"environment" rdl:"optional" yaml:",omitempty"`

	//
	// ownership information for the domain (read-only attribute)
	//
	ResourceOwnership *ResourceDomainOwnership `json:"resourceOwnership,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// requested x509 cert signer key id (system attribute)
	//
	X509CertSignerKeyId string `json:"x509CertSignerKeyId" rdl:"optional" yaml:",omitempty"`

	//
	// requested ssh cert signer key id (system attribute)
	//
	SshCertSignerKeyId string `json:"sshCertSignerKeyId" rdl:"optional" yaml:",omitempty"`

	//
	// slack channel for any notifications in this domain
	//
	SlackChannel string `json:"slackChannel" rdl:"optional" yaml:",omitempty"`

	//
	// the common name to be referred to, the symbolic id. It is immutable
	//
	Name DomainName `json:"name"`

	//
	// the last modification timestamp of any object or attribute in this domain
	//
	Modified *rdl.Timestamp `json:"modified,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// unique identifier of the domain. generated on create, never reused
	//
	Id *rdl.UUID `json:"id,omitempty" rdl:"optional" yaml:",omitempty"`
}

// NewDomain - creates an initialized Domain instance, returns a pointer to it
func NewDomain(init ...*Domain) *Domain {
	var o *Domain
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(Domain)
	}
	return o.Init()
}

// Init - sets up the instance according to its default field values, if any
func (self *Domain) Init() *Domain {
	if self.Enabled == nil {
		d := true
		self.Enabled = &d
	}
	if self.AuditEnabled == nil {
		d := false
		self.AuditEnabled = &d
	}
	return self
}

type rawDomain Domain

// UnmarshalJSON is defined for proper JSON decoding of a Domain
func (self *Domain) UnmarshalJSON(b []byte) error {
	var m rawDomain
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := Domain(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *Domain) Validate() error {
	if self.Description != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.Description)
		if !val.Valid {
			return fmt.Errorf("Domain.description does not contain a valid String (%v)", val.Error)
		}
	}
	if self.Org != "" {
		val := rdl.Validate(ZMSSchema(), "ResourceName", self.Org)
		if !val.Valid {
			return fmt.Errorf("Domain.org does not contain a valid ResourceName (%v)", val.Error)
		}
	}
	if self.Account != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.Account)
		if !val.Valid {
			return fmt.Errorf("Domain.account does not contain a valid String (%v)", val.Error)
		}
	}
	if self.ApplicationId != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.ApplicationId)
		if !val.Valid {
			return fmt.Errorf("Domain.applicationId does not contain a valid String (%v)", val.Error)
		}
	}
	if self.CertDnsDomain != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.CertDnsDomain)
		if !val.Valid {
			return fmt.Errorf("Domain.certDnsDomain does not contain a valid String (%v)", val.Error)
		}
	}
	if self.SignAlgorithm != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.SignAlgorithm)
		if !val.Valid {
			return fmt.Errorf("Domain.signAlgorithm does not contain a valid String (%v)", val.Error)
		}
	}
	if self.UserAuthorityFilter != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.UserAuthorityFilter)
		if !val.Valid {
			return fmt.Errorf("Domain.userAuthorityFilter does not contain a valid String (%v)", val.Error)
		}
	}
	if self.AzureSubscription != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.AzureSubscription)
		if !val.Valid {
			return fmt.Errorf("Domain.azureSubscription does not contain a valid String (%v)", val.Error)
		}
	}
	if self.AzureTenant != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.AzureTenant)
		if !val.Valid {
			return fmt.Errorf("Domain.azureTenant does not contain a valid String (%v)", val.Error)
		}
	}
	if self.AzureClient != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.AzureClient)
		if !val.Valid {
			return fmt.Errorf("Domain.azureClient does not contain a valid String (%v)", val.Error)
		}
	}
	if self.GcpProject != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.GcpProject)
		if !val.Valid {
			return fmt.Errorf("Domain.gcpProject does not contain a valid String (%v)", val.Error)
		}
	}
	if self.GcpProjectNumber != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.GcpProjectNumber)
		if !val.Valid {
			return fmt.Errorf("Domain.gcpProjectNumber does not contain a valid String (%v)", val.Error)
		}
	}
	if self.BusinessService != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.BusinessService)
		if !val.Valid {
			return fmt.Errorf("Domain.businessService does not contain a valid String (%v)", val.Error)
		}
	}
	if self.ProductId != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.ProductId)
		if !val.Valid {
			return fmt.Errorf("Domain.productId does not contain a valid String (%v)", val.Error)
		}
	}
	if self.Environment != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.Environment)
		if !val.Valid {
			return fmt.Errorf("Domain.environment does not contain a valid String (%v)", val.Error)
		}
	}
	if self.X509CertSignerKeyId != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.X509CertSignerKeyId)
		if !val.Valid {
			return fmt.Errorf("Domain.x509CertSignerKeyId does not contain a valid String (%v)", val.Error)
		}
	}
	if self.SshCertSignerKeyId != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.SshCertSignerKeyId)
		if !val.Valid {
			return fmt.Errorf("Domain.sshCertSignerKeyId does not contain a valid String (%v)", val.Error)
		}
	}
	if self.SlackChannel != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.SlackChannel)
		if !val.Valid {
			return fmt.Errorf("Domain.slackChannel does not contain a valid String (%v)", val.Error)
		}
	}
	if self.Name == "" {
		return fmt.Errorf("Domain.name is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "DomainName", self.Name)
		if !val.Valid {
			return fmt.Errorf("Domain.name does not contain a valid DomainName (%v)", val.Error)
		}
	}
	return nil
}

// DomainMetaList - A list of domain objects with their meta attributes.
type DomainMetaList struct {

	//
	// list of domain objects
	//
	Domains []*Domain `json:"domains"`
}

// NewDomainMetaList - creates an initialized DomainMetaList instance, returns a pointer to it
func NewDomainMetaList(init ...*DomainMetaList) *DomainMetaList {
	var o *DomainMetaList
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(DomainMetaList)
	}
	return o.Init()
}

// Init - sets up the instance according to its default field values, if any
func (self *DomainMetaList) Init() *DomainMetaList {
	if self.Domains == nil {
		self.Domains = make([]*Domain, 0)
	}
	return self
}

type rawDomainMetaList DomainMetaList

// UnmarshalJSON is defined for proper JSON decoding of a DomainMetaList
func (self *DomainMetaList) UnmarshalJSON(b []byte) error {
	var m rawDomainMetaList
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := DomainMetaList(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *DomainMetaList) Validate() error {
	if self.Domains == nil {
		return fmt.Errorf("DomainMetaList: Missing required field: domains")
	}
	return nil
}

// DomainList - A paginated list of domains.
type DomainList struct {

	//
	// list of domain names
	//
	Names []DomainName `json:"names"`

	//
	// if the response is a paginated list, this attribute specifies the value to
	// be used in the next domain list request as the value for the skip query
	// parameter.
	//
	Next string `json:"next" rdl:"optional" yaml:",omitempty"`
}

// NewDomainList - creates an initialized DomainList instance, returns a pointer to it
func NewDomainList(init ...*DomainList) *DomainList {
	var o *DomainList
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(DomainList)
	}
	return o.Init()
}

// Init - sets up the instance according to its default field values, if any
func (self *DomainList) Init() *DomainList {
	if self.Names == nil {
		self.Names = make([]DomainName, 0)
	}
	return self
}

type rawDomainList DomainList

// UnmarshalJSON is defined for proper JSON decoding of a DomainList
func (self *DomainList) UnmarshalJSON(b []byte) error {
	var m rawDomainList
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := DomainList(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *DomainList) Validate() error {
	if self.Names == nil {
		return fmt.Errorf("DomainList: Missing required field: names")
	}
	if self.Next != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.Next)
		if !val.Valid {
			return fmt.Errorf("DomainList.next does not contain a valid String (%v)", val.Error)
		}
	}
	return nil
}

// DomainAttributes - A domain attributes for the changelog support
type DomainAttributes struct {

	//
	// timestamp when the domain object was fetched from ZMS
	//
	FetchTime int64 `json:"fetchTime"`
}

// NewDomainAttributes - creates an initialized DomainAttributes instance, returns a pointer to it
func NewDomainAttributes(init ...*DomainAttributes) *DomainAttributes {
	var o *DomainAttributes
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(DomainAttributes)
	}
	return o
}

type rawDomainAttributes DomainAttributes

// UnmarshalJSON is defined for proper JSON decoding of a DomainAttributes
func (self *DomainAttributes) UnmarshalJSON(b []byte) error {
	var m rawDomainAttributes
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := DomainAttributes(m)
		*self = o
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *DomainAttributes) Validate() error {
	return nil
}

// DomainOptions - A domain options for enforcing uniqueness checks
type DomainOptions struct {

	//
	// enforce domains are associated with unique product ids
	//
	EnforceUniqueProductIds bool `json:"enforceUniqueProductIds"`

	//
	// enforce domains are associated with unique aws accounts
	//
	EnforceUniqueAWSAccounts bool `json:"enforceUniqueAWSAccounts"`

	//
	// enforce domains are associated with unique azure subscriptions
	//
	EnforceUniqueAzureSubscriptions bool `json:"enforceUniqueAzureSubscriptions"`

	//
	// enforce domains are associated with unique gcp projects
	//
	EnforceUniqueGCPProjects bool `json:"enforceUniqueGCPProjects"`
}

// NewDomainOptions - creates an initialized DomainOptions instance, returns a pointer to it
func NewDomainOptions(init ...*DomainOptions) *DomainOptions {
	var o *DomainOptions
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(DomainOptions)
	}
	return o
}

type rawDomainOptions DomainOptions

// UnmarshalJSON is defined for proper JSON decoding of a DomainOptions
func (self *DomainOptions) UnmarshalJSON(b []byte) error {
	var m rawDomainOptions
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := DomainOptions(m)
		*self = o
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *DomainOptions) Validate() error {
	return nil
}

// RoleList - The representation for an enumeration of roles in the namespace,
// with pagination.
type RoleList struct {

	//
	// list of role names
	//
	Names []EntityName `json:"names"`

	//
	// if the response is a paginated list, this attribute specifies the value to
	// be used in the next role list request as the value for the skip query
	// parameter.
	//
	Next string `json:"next" rdl:"optional" yaml:",omitempty"`
}

// NewRoleList - creates an initialized RoleList instance, returns a pointer to it
func NewRoleList(init ...*RoleList) *RoleList {
	var o *RoleList
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(RoleList)
	}
	return o.Init()
}

// Init - sets up the instance according to its default field values, if any
func (self *RoleList) Init() *RoleList {
	if self.Names == nil {
		self.Names = make([]EntityName, 0)
	}
	return self
}

type rawRoleList RoleList

// UnmarshalJSON is defined for proper JSON decoding of a RoleList
func (self *RoleList) UnmarshalJSON(b []byte) error {
	var m rawRoleList
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := RoleList(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *RoleList) Validate() error {
	if self.Names == nil {
		return fmt.Errorf("RoleList: Missing required field: names")
	}
	if self.Next != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.Next)
		if !val.Valid {
			return fmt.Errorf("RoleList.next does not contain a valid String (%v)", val.Error)
		}
	}
	return nil
}

// RoleAuditLog - An audit log entry for role membership change.
type RoleAuditLog struct {

	//
	// name of the role member
	//
	Member MemberName `json:"member"`

	//
	// name of the principal executing the change
	//
	Admin ResourceName `json:"admin"`

	//
	// timestamp of the entry
	//
	Created rdl.Timestamp `json:"created"`

	//
	// log action - e.g. add, delete, approve, etc
	//
	Action string `json:"action"`

	//
	// audit reference string for the change as supplied by admin
	//
	AuditRef string `json:"auditRef" rdl:"optional" yaml:",omitempty"`
}

// NewRoleAuditLog - creates an initialized RoleAuditLog instance, returns a pointer to it
func NewRoleAuditLog(init ...*RoleAuditLog) *RoleAuditLog {
	var o *RoleAuditLog
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(RoleAuditLog)
	}
	return o
}

type rawRoleAuditLog RoleAuditLog

// UnmarshalJSON is defined for proper JSON decoding of a RoleAuditLog
func (self *RoleAuditLog) UnmarshalJSON(b []byte) error {
	var m rawRoleAuditLog
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := RoleAuditLog(m)
		*self = o
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *RoleAuditLog) Validate() error {
	if self.Member == "" {
		return fmt.Errorf("RoleAuditLog.member is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "MemberName", self.Member)
		if !val.Valid {
			return fmt.Errorf("RoleAuditLog.member does not contain a valid MemberName (%v)", val.Error)
		}
	}
	if self.Admin == "" {
		return fmt.Errorf("RoleAuditLog.admin is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "ResourceName", self.Admin)
		if !val.Valid {
			return fmt.Errorf("RoleAuditLog.admin does not contain a valid ResourceName (%v)", val.Error)
		}
	}
	if self.Created.IsZero() {
		return fmt.Errorf("RoleAuditLog: Missing required field: created")
	}
	if self.Action == "" {
		return fmt.Errorf("RoleAuditLog.action is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "String", self.Action)
		if !val.Valid {
			return fmt.Errorf("RoleAuditLog.action does not contain a valid String (%v)", val.Error)
		}
	}
	if self.AuditRef != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.AuditRef)
		if !val.Valid {
			return fmt.Errorf("RoleAuditLog.auditRef does not contain a valid String (%v)", val.Error)
		}
	}
	return nil
}

// RoleMember -
type RoleMember struct {

	//
	// name of the member
	//
	MemberName MemberName `json:"memberName"`

	//
	// the expiration timestamp
	//
	Expiration *rdl.Timestamp `json:"expiration,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// the review reminder timestamp
	//
	ReviewReminder *rdl.Timestamp `json:"reviewReminder,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// Flag to indicate whether membership is active
	//
	Active *bool `json:"active,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// Flag to indicate whether membership is approved either by delegates ( in
	// case of auditEnabled roles ) or by domain admins ( in case of selfserve roles
	// )
	//
	Approved *bool `json:"approved,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// audit reference string for the change as supplied by admin
	//
	AuditRef string `json:"auditRef" rdl:"optional" yaml:",omitempty"`

	//
	// for pending membership requests, the request time
	//
	RequestTime *rdl.Timestamp `json:"requestTime,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// for pending membership requests, time when last notification was sent
	//
	LastNotifiedTime *rdl.Timestamp `json:"lastNotifiedTime,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// pending members only - name of the principal requesting the change
	//
	RequestPrincipal ResourceName `json:"requestPrincipal,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// for pending membership requests, time when last notification was sent (for
	// file store)
	//
	ReviewLastNotifiedTime *rdl.Timestamp `json:"reviewLastNotifiedTime,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// user disabled by system based on configured role setting
	//
	SystemDisabled *int32 `json:"systemDisabled,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// server use only - principal type: unknown(0), user(1), service(2), or
	// group(3)
	//
	PrincipalType *int32 `json:"principalType,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// for pending membership requests, the request state - e.g. add, delete
	//
	PendingState string `json:"pendingState" rdl:"optional" yaml:",omitempty"`
}

// NewRoleMember - creates an initialized RoleMember instance, returns a pointer to it
func NewRoleMember(init ...*RoleMember) *RoleMember {
	var o *RoleMember
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(RoleMember)
	}
	return o.Init()
}

// Init - sets up the instance according to its default field values, if any
func (self *RoleMember) Init() *RoleMember {
	if self.Active == nil {
		d := true
		self.Active = &d
	}
	if self.Approved == nil {
		d := true
		self.Approved = &d
	}
	return self
}

type rawRoleMember RoleMember

// UnmarshalJSON is defined for proper JSON decoding of a RoleMember
func (self *RoleMember) UnmarshalJSON(b []byte) error {
	var m rawRoleMember
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := RoleMember(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *RoleMember) Validate() error {
	if self.MemberName == "" {
		return fmt.Errorf("RoleMember.memberName is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "MemberName", self.MemberName)
		if !val.Valid {
			return fmt.Errorf("RoleMember.memberName does not contain a valid MemberName (%v)", val.Error)
		}
	}
	if self.AuditRef != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.AuditRef)
		if !val.Valid {
			return fmt.Errorf("RoleMember.auditRef does not contain a valid String (%v)", val.Error)
		}
	}
	if self.RequestPrincipal != "" {
		val := rdl.Validate(ZMSSchema(), "ResourceName", self.RequestPrincipal)
		if !val.Valid {
			return fmt.Errorf("RoleMember.requestPrincipal does not contain a valid ResourceName (%v)", val.Error)
		}
	}
	if self.PendingState != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.PendingState)
		if !val.Valid {
			return fmt.Errorf("RoleMember.pendingState does not contain a valid String (%v)", val.Error)
		}
	}
	return nil
}

// ResourceRoleOwnership - The representation of the role ownership object
type ResourceRoleOwnership struct {

	//
	// owner of the object's meta attribute
	//
	MetaOwner SimpleName `json:"metaOwner,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// owner of the object's members attribute
	//
	MembersOwner SimpleName `json:"membersOwner,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// owner of the object itself - checked for object deletion
	//
	ObjectOwner SimpleName `json:"objectOwner,omitempty" rdl:"optional" yaml:",omitempty"`
}

// NewResourceRoleOwnership - creates an initialized ResourceRoleOwnership instance, returns a pointer to it
func NewResourceRoleOwnership(init ...*ResourceRoleOwnership) *ResourceRoleOwnership {
	var o *ResourceRoleOwnership
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(ResourceRoleOwnership)
	}
	return o
}

type rawResourceRoleOwnership ResourceRoleOwnership

// UnmarshalJSON is defined for proper JSON decoding of a ResourceRoleOwnership
func (self *ResourceRoleOwnership) UnmarshalJSON(b []byte) error {
	var m rawResourceRoleOwnership
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := ResourceRoleOwnership(m)
		*self = o
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *ResourceRoleOwnership) Validate() error {
	if self.MetaOwner != "" {
		val := rdl.Validate(ZMSSchema(), "SimpleName", self.MetaOwner)
		if !val.Valid {
			return fmt.Errorf("ResourceRoleOwnership.metaOwner does not contain a valid SimpleName (%v)", val.Error)
		}
	}
	if self.MembersOwner != "" {
		val := rdl.Validate(ZMSSchema(), "SimpleName", self.MembersOwner)
		if !val.Valid {
			return fmt.Errorf("ResourceRoleOwnership.membersOwner does not contain a valid SimpleName (%v)", val.Error)
		}
	}
	if self.ObjectOwner != "" {
		val := rdl.Validate(ZMSSchema(), "SimpleName", self.ObjectOwner)
		if !val.Valid {
			return fmt.Errorf("ResourceRoleOwnership.objectOwner does not contain a valid SimpleName (%v)", val.Error)
		}
	}
	return nil
}

// RoleMeta - Set of metadata attributes that all roles may have and can be
// changed by domain admins.
type RoleMeta struct {

	//
	// Flag indicates whether or not role allows self service. Users can add
	// themselves in the role, but it has to be approved by domain admins to be
	// effective.
	//
	SelfServe *bool `json:"selfServe,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// all user members in the role will have specified max expiry days
	//
	MemberExpiryDays *int32 `json:"memberExpiryDays,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// tokens issued for this role will have specified max timeout in mins
	//
	TokenExpiryMins *int32 `json:"tokenExpiryMins,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// certs issued for this role will have specified max timeout in mins
	//
	CertExpiryMins *int32 `json:"certExpiryMins,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// rsa or ec signing algorithm to be used for tokens
	//
	SignAlgorithm string `json:"signAlgorithm" rdl:"optional" yaml:",omitempty"`

	//
	// all services in the role will have specified max expiry days
	//
	ServiceExpiryDays *int32 `json:"serviceExpiryDays,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// all user members in the role will have specified max review days
	//
	MemberReviewDays *int32 `json:"memberReviewDays,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// all services in the role will have specified max review days
	//
	ServiceReviewDays *int32 `json:"serviceReviewDays,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// Flag indicates whether or not role updates require another review and
	// approval
	//
	ReviewEnabled *bool `json:"reviewEnabled,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// list of roles whose members should be notified for member review/approval
	//
	NotifyRoles string `json:"notifyRoles" rdl:"optional" yaml:",omitempty"`

	//
	// membership filtered based on user authority configured attributes
	//
	UserAuthorityFilter string `json:"userAuthorityFilter" rdl:"optional" yaml:",omitempty"`

	//
	// expiration enforced by a user authority configured attribute
	//
	UserAuthorityExpiration string `json:"userAuthorityExpiration" rdl:"optional" yaml:",omitempty"`

	//
	// all groups in the domain roles will have specified max expiry days
	//
	GroupExpiryDays *int32 `json:"groupExpiryDays,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// all groups in the domain roles will have specified max review days
	//
	GroupReviewDays *int32 `json:"groupReviewDays,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// key-value pair tags, tag might contain multiple values
	//
	Tags map[TagKey]*TagValueList `json:"tags,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// a description of the role
	//
	Description string `json:"description" rdl:"optional" yaml:",omitempty"`

	//
	// Flag indicates whether or not role updates should be approved by GRC. If
	// true, the auditRef parameter must be supplied(not empty) for any API defining
	// it.
	//
	AuditEnabled *bool `json:"auditEnabled,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// If true, ask for delete confirmation in audit and review enabled roles.
	//
	DeleteProtection *bool `json:"deleteProtection,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// last review timestamp of the role
	//
	LastReviewedDate *rdl.Timestamp `json:"lastReviewedDate,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// Flag indicates whether to allow expired members to renew their membership
	//
	SelfRenew *bool `json:"selfRenew,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// Number of minutes members can renew their membership if self review option
	// is enabled
	//
	SelfRenewMins *int32 `json:"selfRenewMins,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// Maximum number of members allowed in the group
	//
	MaxMembers *int32 `json:"maxMembers,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// ownership information for the role (read-only attribute)
	//
	ResourceOwnership *ResourceRoleOwnership `json:"resourceOwnership,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// membership filtered based on configured principal domains
	//
	PrincipalDomainFilter string `json:"principalDomainFilter" rdl:"optional" yaml:",omitempty"`

	//
	// additional details included in the notifications
	//
	NotifyDetails string `json:"notifyDetails" rdl:"optional" yaml:",omitempty"`
}

// NewRoleMeta - creates an initialized RoleMeta instance, returns a pointer to it
func NewRoleMeta(init ...*RoleMeta) *RoleMeta {
	var o *RoleMeta
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(RoleMeta)
	}
	return o
}

type rawRoleMeta RoleMeta

// UnmarshalJSON is defined for proper JSON decoding of a RoleMeta
func (self *RoleMeta) UnmarshalJSON(b []byte) error {
	var m rawRoleMeta
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := RoleMeta(m)
		*self = o
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *RoleMeta) Validate() error {
	if self.SignAlgorithm != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.SignAlgorithm)
		if !val.Valid {
			return fmt.Errorf("RoleMeta.signAlgorithm does not contain a valid String (%v)", val.Error)
		}
	}
	if self.NotifyRoles != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.NotifyRoles)
		if !val.Valid {
			return fmt.Errorf("RoleMeta.notifyRoles does not contain a valid String (%v)", val.Error)
		}
	}
	if self.UserAuthorityFilter != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.UserAuthorityFilter)
		if !val.Valid {
			return fmt.Errorf("RoleMeta.userAuthorityFilter does not contain a valid String (%v)", val.Error)
		}
	}
	if self.UserAuthorityExpiration != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.UserAuthorityExpiration)
		if !val.Valid {
			return fmt.Errorf("RoleMeta.userAuthorityExpiration does not contain a valid String (%v)", val.Error)
		}
	}
	if self.Description != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.Description)
		if !val.Valid {
			return fmt.Errorf("RoleMeta.description does not contain a valid String (%v)", val.Error)
		}
	}
	if self.PrincipalDomainFilter != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.PrincipalDomainFilter)
		if !val.Valid {
			return fmt.Errorf("RoleMeta.principalDomainFilter does not contain a valid String (%v)", val.Error)
		}
	}
	if self.NotifyDetails != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.NotifyDetails)
		if !val.Valid {
			return fmt.Errorf("RoleMeta.notifyDetails does not contain a valid String (%v)", val.Error)
		}
	}
	return nil
}

// Role - The representation for a Role with set of members. The members
// (Array<MemberName>) field is deprecated and not used in role objects since it
// incorrectly lists all the members in the role without taking into account if
// the member is expired or possibly disabled. Thus, using this attribute will
// result in incorrect authorization checks by the client and, thus, it's no
// longer being populated. All applications must use the roleMembers field and
// take into account all the attributes of the member.
type Role struct {

	//
	// Flag indicates whether or not role allows self service. Users can add
	// themselves in the role, but it has to be approved by domain admins to be
	// effective.
	//
	SelfServe *bool `json:"selfServe,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// all user members in the role will have specified max expiry days
	//
	MemberExpiryDays *int32 `json:"memberExpiryDays,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// tokens issued for this role will have specified max timeout in mins
	//
	TokenExpiryMins *int32 `json:"tokenExpiryMins,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// certs issued for this role will have specified max timeout in mins
	//
	CertExpiryMins *int32 `json:"certExpiryMins,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// rsa or ec signing algorithm to be used for tokens
	//
	SignAlgorithm string `json:"signAlgorithm" rdl:"optional" yaml:",omitempty"`

	//
	// all services in the role will have specified max expiry days
	//
	ServiceExpiryDays *int32 `json:"serviceExpiryDays,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// all user members in the role will have specified max review days
	//
	MemberReviewDays *int32 `json:"memberReviewDays,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// all services in the role will have specified max review days
	//
	ServiceReviewDays *int32 `json:"serviceReviewDays,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// Flag indicates whether or not role updates require another review and
	// approval
	//
	ReviewEnabled *bool `json:"reviewEnabled,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// list of roles whose members should be notified for member review/approval
	//
	NotifyRoles string `json:"notifyRoles" rdl:"optional" yaml:",omitempty"`

	//
	// membership filtered based on user authority configured attributes
	//
	UserAuthorityFilter string `json:"userAuthorityFilter" rdl:"optional" yaml:",omitempty"`

	//
	// expiration enforced by a user authority configured attribute
	//
	UserAuthorityExpiration string `json:"userAuthorityExpiration" rdl:"optional" yaml:",omitempty"`

	//
	// all groups in the domain roles will have specified max expiry days
	//
	GroupExpiryDays *int32 `json:"groupExpiryDays,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// all groups in the domain roles will have specified max review days
	//
	GroupReviewDays *int32 `json:"groupReviewDays,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// key-value pair tags, tag might contain multiple values
	//
	Tags map[TagKey]*TagValueList `json:"tags,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// a description of the role
	//
	Description string `json:"description" rdl:"optional" yaml:",omitempty"`

	//
	// Flag indicates whether or not role updates should be approved by GRC. If
	// true, the auditRef parameter must be supplied(not empty) for any API defining
	// it.
	//
	AuditEnabled *bool `json:"auditEnabled,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// If true, ask for delete confirmation in audit and review enabled roles.
	//
	DeleteProtection *bool `json:"deleteProtection,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// last review timestamp of the role
	//
	LastReviewedDate *rdl.Timestamp `json:"lastReviewedDate,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// Flag indicates whether to allow expired members to renew their membership
	//
	SelfRenew *bool `json:"selfRenew,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// Number of minutes members can renew their membership if self review option
	// is enabled
	//
	SelfRenewMins *int32 `json:"selfRenewMins,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// Maximum number of members allowed in the group
	//
	MaxMembers *int32 `json:"maxMembers,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// ownership information for the role (read-only attribute)
	//
	ResourceOwnership *ResourceRoleOwnership `json:"resourceOwnership,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// membership filtered based on configured principal domains
	//
	PrincipalDomainFilter string `json:"principalDomainFilter" rdl:"optional" yaml:",omitempty"`

	//
	// additional details included in the notifications
	//
	NotifyDetails string `json:"notifyDetails" rdl:"optional" yaml:",omitempty"`

	//
	// name of the role
	//
	Name ResourceName `json:"name"`

	//
	// last modification timestamp of the role
	//
	Modified *rdl.Timestamp `json:"modified,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// deprecated and not used
	//
	Members []MemberName `json:"members,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// members with expiration and other member attributes. might be empty or
	// null, if trust is set
	//
	RoleMembers []*RoleMember `json:"roleMembers,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// a trusted domain to delegate membership decisions to
	//
	Trust DomainName `json:"trust,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// an audit log for role membership changes
	//
	AuditLog []*RoleAuditLog `json:"auditLog,omitempty" rdl:"optional" yaml:",omitempty"`
}

// NewRole - creates an initialized Role instance, returns a pointer to it
func NewRole(init ...*Role) *Role {
	var o *Role
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(Role)
	}
	return o
}

type rawRole Role

// UnmarshalJSON is defined for proper JSON decoding of a Role
func (self *Role) UnmarshalJSON(b []byte) error {
	var m rawRole
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := Role(m)
		*self = o
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *Role) Validate() error {
	if self.SignAlgorithm != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.SignAlgorithm)
		if !val.Valid {
			return fmt.Errorf("Role.signAlgorithm does not contain a valid String (%v)", val.Error)
		}
	}
	if self.NotifyRoles != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.NotifyRoles)
		if !val.Valid {
			return fmt.Errorf("Role.notifyRoles does not contain a valid String (%v)", val.Error)
		}
	}
	if self.UserAuthorityFilter != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.UserAuthorityFilter)
		if !val.Valid {
			return fmt.Errorf("Role.userAuthorityFilter does not contain a valid String (%v)", val.Error)
		}
	}
	if self.UserAuthorityExpiration != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.UserAuthorityExpiration)
		if !val.Valid {
			return fmt.Errorf("Role.userAuthorityExpiration does not contain a valid String (%v)", val.Error)
		}
	}
	if self.Description != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.Description)
		if !val.Valid {
			return fmt.Errorf("Role.description does not contain a valid String (%v)", val.Error)
		}
	}
	if self.PrincipalDomainFilter != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.PrincipalDomainFilter)
		if !val.Valid {
			return fmt.Errorf("Role.principalDomainFilter does not contain a valid String (%v)", val.Error)
		}
	}
	if self.NotifyDetails != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.NotifyDetails)
		if !val.Valid {
			return fmt.Errorf("Role.notifyDetails does not contain a valid String (%v)", val.Error)
		}
	}
	if self.Name == "" {
		return fmt.Errorf("Role.name is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "ResourceName", self.Name)
		if !val.Valid {
			return fmt.Errorf("Role.name does not contain a valid ResourceName (%v)", val.Error)
		}
	}
	if self.Trust != "" {
		val := rdl.Validate(ZMSSchema(), "DomainName", self.Trust)
		if !val.Valid {
			return fmt.Errorf("Role.trust does not contain a valid DomainName (%v)", val.Error)
		}
	}
	return nil
}

// Roles - The representation for a list of roles with full details
type Roles struct {

	//
	// list of role objects
	//
	List []*Role `json:"list"`
}

// NewRoles - creates an initialized Roles instance, returns a pointer to it
func NewRoles(init ...*Roles) *Roles {
	var o *Roles
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(Roles)
	}
	return o.Init()
}

// Init - sets up the instance according to its default field values, if any
func (self *Roles) Init() *Roles {
	if self.List == nil {
		self.List = make([]*Role, 0)
	}
	return self
}

type rawRoles Roles

// UnmarshalJSON is defined for proper JSON decoding of a Roles
func (self *Roles) UnmarshalJSON(b []byte) error {
	var m rawRoles
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := Roles(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *Roles) Validate() error {
	if self.List == nil {
		return fmt.Errorf("Roles: Missing required field: list")
	}
	return nil
}

// Membership - The representation for a role membership.
type Membership struct {

	//
	// name of the member
	//
	MemberName MemberName `json:"memberName"`

	//
	// flag to indicate whether or the user is a member or not
	//
	IsMember *bool `json:"isMember,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// name of the role
	//
	RoleName ResourceName `json:"roleName,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// the expiration timestamp
	//
	Expiration *rdl.Timestamp `json:"expiration,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// the review reminder timestamp
	//
	ReviewReminder *rdl.Timestamp `json:"reviewReminder,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// Flag to indicate whether membership is active
	//
	Active *bool `json:"active,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// Flag to indicate whether membership is approved either by delegates ( in
	// case of auditEnabled roles ) or by domain admins ( in case of selfserve roles
	// )
	//
	Approved *bool `json:"approved,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// audit reference string for the change as supplied by admin
	//
	AuditRef string `json:"auditRef" rdl:"optional" yaml:",omitempty"`

	//
	// pending members only - name of the principal requesting the change
	//
	RequestPrincipal ResourceName `json:"requestPrincipal,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// user disabled by system based on configured role setting
	//
	SystemDisabled *int32 `json:"systemDisabled,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// for pending membership requests, the request state - e.g. add, delete
	//
	PendingState string `json:"pendingState" rdl:"optional" yaml:",omitempty"`
}

// NewMembership - creates an initialized Membership instance, returns a pointer to it
func NewMembership(init ...*Membership) *Membership {
	var o *Membership
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(Membership)
	}
	return o.Init()
}

// Init - sets up the instance according to its default field values, if any
func (self *Membership) Init() *Membership {
	if self.IsMember == nil {
		d := true
		self.IsMember = &d
	}
	if self.Active == nil {
		d := true
		self.Active = &d
	}
	if self.Approved == nil {
		d := true
		self.Approved = &d
	}
	return self
}

type rawMembership Membership

// UnmarshalJSON is defined for proper JSON decoding of a Membership
func (self *Membership) UnmarshalJSON(b []byte) error {
	var m rawMembership
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := Membership(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *Membership) Validate() error {
	if self.MemberName == "" {
		return fmt.Errorf("Membership.memberName is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "MemberName", self.MemberName)
		if !val.Valid {
			return fmt.Errorf("Membership.memberName does not contain a valid MemberName (%v)", val.Error)
		}
	}
	if self.RoleName != "" {
		val := rdl.Validate(ZMSSchema(), "ResourceName", self.RoleName)
		if !val.Valid {
			return fmt.Errorf("Membership.roleName does not contain a valid ResourceName (%v)", val.Error)
		}
	}
	if self.AuditRef != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.AuditRef)
		if !val.Valid {
			return fmt.Errorf("Membership.auditRef does not contain a valid String (%v)", val.Error)
		}
	}
	if self.RequestPrincipal != "" {
		val := rdl.Validate(ZMSSchema(), "ResourceName", self.RequestPrincipal)
		if !val.Valid {
			return fmt.Errorf("Membership.requestPrincipal does not contain a valid ResourceName (%v)", val.Error)
		}
	}
	if self.PendingState != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.PendingState)
		if !val.Valid {
			return fmt.Errorf("Membership.pendingState does not contain a valid String (%v)", val.Error)
		}
	}
	return nil
}

// DefaultAdmins - The list of domain administrators.
type DefaultAdmins struct {

	//
	// list of domain administrators
	//
	Admins []ResourceName `json:"admins"`
}

// NewDefaultAdmins - creates an initialized DefaultAdmins instance, returns a pointer to it
func NewDefaultAdmins(init ...*DefaultAdmins) *DefaultAdmins {
	var o *DefaultAdmins
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(DefaultAdmins)
	}
	return o.Init()
}

// Init - sets up the instance according to its default field values, if any
func (self *DefaultAdmins) Init() *DefaultAdmins {
	if self.Admins == nil {
		self.Admins = make([]ResourceName, 0)
	}
	return self
}

type rawDefaultAdmins DefaultAdmins

// UnmarshalJSON is defined for proper JSON decoding of a DefaultAdmins
func (self *DefaultAdmins) UnmarshalJSON(b []byte) error {
	var m rawDefaultAdmins
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := DefaultAdmins(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *DefaultAdmins) Validate() error {
	if self.Admins == nil {
		return fmt.Errorf("DefaultAdmins: Missing required field: admins")
	}
	return nil
}

// MemberRole -
type MemberRole struct {

	//
	// name of the role
	//
	RoleName ResourceName `json:"roleName"`

	//
	// name of the domain
	//
	DomainName DomainName `json:"domainName,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// name of the member
	//
	MemberName MemberName `json:"memberName,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// the expiration timestamp
	//
	Expiration *rdl.Timestamp `json:"expiration,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// the review reminder timestamp
	//
	ReviewReminder *rdl.Timestamp `json:"reviewReminder,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// Flag to indicate whether membership is active
	//
	Active *bool `json:"active,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// audit reference string for the change as supplied by admin
	//
	AuditRef string `json:"auditRef" rdl:"optional" yaml:",omitempty"`

	//
	// pending members only - name of the principal requesting the change
	//
	RequestPrincipal EntityName `json:"requestPrincipal,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// for pending membership requests, the request time
	//
	RequestTime *rdl.Timestamp `json:"requestTime,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// user disabled by system based on configured role setting
	//
	SystemDisabled *int32 `json:"systemDisabled,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// for pending membership requests, the request state - e.g. add, delete
	//
	PendingState string `json:"pendingState" rdl:"optional" yaml:",omitempty"`

	//
	// name of the role that handles the membership delegation for the role
	// specified in roleName
	//
	TrustRoleName ResourceName `json:"trustRoleName,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// list of roles whose members should be notified for member
	// review/approval/expiry
	//
	NotifyRoles string `json:"notifyRoles" rdl:"optional" yaml:",omitempty"`

	//
	// additional details included in the notifications
	//
	NotifyDetails string `json:"notifyDetails" rdl:"optional" yaml:",omitempty"`
}

// NewMemberRole - creates an initialized MemberRole instance, returns a pointer to it
func NewMemberRole(init ...*MemberRole) *MemberRole {
	var o *MemberRole
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(MemberRole)
	}
	return o.Init()
}

// Init - sets up the instance according to its default field values, if any
func (self *MemberRole) Init() *MemberRole {
	if self.Active == nil {
		d := true
		self.Active = &d
	}
	return self
}

type rawMemberRole MemberRole

// UnmarshalJSON is defined for proper JSON decoding of a MemberRole
func (self *MemberRole) UnmarshalJSON(b []byte) error {
	var m rawMemberRole
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := MemberRole(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *MemberRole) Validate() error {
	if self.RoleName == "" {
		return fmt.Errorf("MemberRole.roleName is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "ResourceName", self.RoleName)
		if !val.Valid {
			return fmt.Errorf("MemberRole.roleName does not contain a valid ResourceName (%v)", val.Error)
		}
	}
	if self.DomainName != "" {
		val := rdl.Validate(ZMSSchema(), "DomainName", self.DomainName)
		if !val.Valid {
			return fmt.Errorf("MemberRole.domainName does not contain a valid DomainName (%v)", val.Error)
		}
	}
	if self.MemberName != "" {
		val := rdl.Validate(ZMSSchema(), "MemberName", self.MemberName)
		if !val.Valid {
			return fmt.Errorf("MemberRole.memberName does not contain a valid MemberName (%v)", val.Error)
		}
	}
	if self.AuditRef != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.AuditRef)
		if !val.Valid {
			return fmt.Errorf("MemberRole.auditRef does not contain a valid String (%v)", val.Error)
		}
	}
	if self.RequestPrincipal != "" {
		val := rdl.Validate(ZMSSchema(), "EntityName", self.RequestPrincipal)
		if !val.Valid {
			return fmt.Errorf("MemberRole.requestPrincipal does not contain a valid EntityName (%v)", val.Error)
		}
	}
	if self.PendingState != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.PendingState)
		if !val.Valid {
			return fmt.Errorf("MemberRole.pendingState does not contain a valid String (%v)", val.Error)
		}
	}
	if self.TrustRoleName != "" {
		val := rdl.Validate(ZMSSchema(), "ResourceName", self.TrustRoleName)
		if !val.Valid {
			return fmt.Errorf("MemberRole.trustRoleName does not contain a valid ResourceName (%v)", val.Error)
		}
	}
	if self.NotifyRoles != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.NotifyRoles)
		if !val.Valid {
			return fmt.Errorf("MemberRole.notifyRoles does not contain a valid String (%v)", val.Error)
		}
	}
	if self.NotifyDetails != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.NotifyDetails)
		if !val.Valid {
			return fmt.Errorf("MemberRole.notifyDetails does not contain a valid String (%v)", val.Error)
		}
	}
	return nil
}

// DomainRoleMember -
type DomainRoleMember struct {

	//
	// name of the member
	//
	MemberName MemberName `json:"memberName"`

	//
	// roles for this member
	//
	MemberRoles []*MemberRole `json:"memberRoles"`
}

// NewDomainRoleMember - creates an initialized DomainRoleMember instance, returns a pointer to it
func NewDomainRoleMember(init ...*DomainRoleMember) *DomainRoleMember {
	var o *DomainRoleMember
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(DomainRoleMember)
	}
	return o.Init()
}

// Init - sets up the instance according to its default field values, if any
func (self *DomainRoleMember) Init() *DomainRoleMember {
	if self.MemberRoles == nil {
		self.MemberRoles = make([]*MemberRole, 0)
	}
	return self
}

type rawDomainRoleMember DomainRoleMember

// UnmarshalJSON is defined for proper JSON decoding of a DomainRoleMember
func (self *DomainRoleMember) UnmarshalJSON(b []byte) error {
	var m rawDomainRoleMember
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := DomainRoleMember(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *DomainRoleMember) Validate() error {
	if self.MemberName == "" {
		return fmt.Errorf("DomainRoleMember.memberName is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "MemberName", self.MemberName)
		if !val.Valid {
			return fmt.Errorf("DomainRoleMember.memberName does not contain a valid MemberName (%v)", val.Error)
		}
	}
	if self.MemberRoles == nil {
		return fmt.Errorf("DomainRoleMember: Missing required field: memberRoles")
	}
	return nil
}

// DomainRoleMembers -
type DomainRoleMembers struct {

	//
	// name of the domain
	//
	DomainName DomainName `json:"domainName"`

	//
	// role members
	//
	Members []*DomainRoleMember `json:"members"`
}

// NewDomainRoleMembers - creates an initialized DomainRoleMembers instance, returns a pointer to it
func NewDomainRoleMembers(init ...*DomainRoleMembers) *DomainRoleMembers {
	var o *DomainRoleMembers
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(DomainRoleMembers)
	}
	return o.Init()
}

// Init - sets up the instance according to its default field values, if any
func (self *DomainRoleMembers) Init() *DomainRoleMembers {
	if self.Members == nil {
		self.Members = make([]*DomainRoleMember, 0)
	}
	return self
}

type rawDomainRoleMembers DomainRoleMembers

// UnmarshalJSON is defined for proper JSON decoding of a DomainRoleMembers
func (self *DomainRoleMembers) UnmarshalJSON(b []byte) error {
	var m rawDomainRoleMembers
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := DomainRoleMembers(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *DomainRoleMembers) Validate() error {
	if self.DomainName == "" {
		return fmt.Errorf("DomainRoleMembers.domainName is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "DomainName", self.DomainName)
		if !val.Valid {
			return fmt.Errorf("DomainRoleMembers.domainName does not contain a valid DomainName (%v)", val.Error)
		}
	}
	if self.Members == nil {
		return fmt.Errorf("DomainRoleMembers: Missing required field: members")
	}
	return nil
}

// RoleSystemMeta - Set of system metadata attributes that all roles may have
// and can be changed by system admins.
type RoleSystemMeta struct {

	//
	// Flag indicates whether or not role updates should be approved by GRC. If
	// true, the auditRef parameter must be supplied(not empty) for any API defining
	// it.
	//
	AuditEnabled *bool `json:"auditEnabled,omitempty" rdl:"optional" yaml:",omitempty"`
}

// NewRoleSystemMeta - creates an initialized RoleSystemMeta instance, returns a pointer to it
func NewRoleSystemMeta(init ...*RoleSystemMeta) *RoleSystemMeta {
	var o *RoleSystemMeta
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(RoleSystemMeta)
	}
	return o
}

type rawRoleSystemMeta RoleSystemMeta

// UnmarshalJSON is defined for proper JSON decoding of a RoleSystemMeta
func (self *RoleSystemMeta) UnmarshalJSON(b []byte) error {
	var m rawRoleSystemMeta
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := RoleSystemMeta(m)
		*self = o
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *RoleSystemMeta) Validate() error {
	return nil
}

// AssertionEffect - Every assertion can have the effect of ALLOW or DENY.
type AssertionEffect int

// AssertionEffect constants
const (
	_ AssertionEffect = iota
	ALLOW
	DENY
)

var namesAssertionEffect = []string{
	ALLOW: "ALLOW",
	DENY:  "DENY",
}

// NewAssertionEffect - return a string representation of the enum
func NewAssertionEffect(init ...interface{}) AssertionEffect {
	if len(init) == 1 {
		switch v := init[0].(type) {
		case AssertionEffect:
			return v
		case int:
			return AssertionEffect(v)
		case int32:
			return AssertionEffect(v)
		case string:
			for i, s := range namesAssertionEffect {
				if s == v {
					return AssertionEffect(i)
				}
			}
		default:
			panic("Bad init value for AssertionEffect enum")
		}
	}
	return AssertionEffect(0) //default to the first enum value
}

// String - return a string representation of the enum
func (e AssertionEffect) String() string {
	return namesAssertionEffect[e]
}

// SymbolSet - return an array of all valid string representations (symbols) of the enum
func (e AssertionEffect) SymbolSet() []string {
	return namesAssertionEffect
}

// MarshalJSON is defined for proper JSON encoding of a AssertionEffect
func (e AssertionEffect) MarshalJSON() ([]byte, error) {
	return json.Marshal(e.String())
}

// UnmarshalJSON is defined for proper JSON decoding of a AssertionEffect
func (e *AssertionEffect) UnmarshalJSON(b []byte) error {
	var j string
	err := json.Unmarshal(b, &j)
	if err == nil {
		s := string(j)
		for v, s2 := range namesAssertionEffect {
			if s == s2 {
				*e = AssertionEffect(v)
				return nil
			}
		}
		err = fmt.Errorf("Bad enum symbol for type AssertionEffect: %s", s)
	}
	return err
}

// AssertionConditionOperator - Allowed operators for assertion conditions
type AssertionConditionOperator int

// AssertionConditionOperator constants
const (
	_ AssertionConditionOperator = iota
	EQUALS
)

var namesAssertionConditionOperator = []string{
	EQUALS: "EQUALS",
}

// NewAssertionConditionOperator - return a string representation of the enum
func NewAssertionConditionOperator(init ...interface{}) AssertionConditionOperator {
	if len(init) == 1 {
		switch v := init[0].(type) {
		case AssertionConditionOperator:
			return v
		case int:
			return AssertionConditionOperator(v)
		case int32:
			return AssertionConditionOperator(v)
		case string:
			for i, s := range namesAssertionConditionOperator {
				if s == v {
					return AssertionConditionOperator(i)
				}
			}
		default:
			panic("Bad init value for AssertionConditionOperator enum")
		}
	}
	return AssertionConditionOperator(0) //default to the first enum value
}

// String - return a string representation of the enum
func (e AssertionConditionOperator) String() string {
	return namesAssertionConditionOperator[e]
}

// SymbolSet - return an array of all valid string representations (symbols) of the enum
func (e AssertionConditionOperator) SymbolSet() []string {
	return namesAssertionConditionOperator
}

// MarshalJSON is defined for proper JSON encoding of a AssertionConditionOperator
func (e AssertionConditionOperator) MarshalJSON() ([]byte, error) {
	return json.Marshal(e.String())
}

// UnmarshalJSON is defined for proper JSON decoding of a AssertionConditionOperator
func (e *AssertionConditionOperator) UnmarshalJSON(b []byte) error {
	var j string
	err := json.Unmarshal(b, &j)
	if err == nil {
		s := string(j)
		for v, s2 := range namesAssertionConditionOperator {
			if s == s2 {
				*e = AssertionConditionOperator(v)
				return nil
			}
		}
		err = fmt.Errorf("Bad enum symbol for type AssertionConditionOperator: %s", s)
	}
	return err
}

// AssertionConditionData - A representation of details associated with an
// assertion condition key
type AssertionConditionData struct {

	//
	// Operator for the assertion condition
	//
	Operator AssertionConditionOperator `json:"operator"`

	//
	// Value of the assertion condition
	//
	Value AssertionConditionValue `json:"value"`
}

// NewAssertionConditionData - creates an initialized AssertionConditionData instance, returns a pointer to it
func NewAssertionConditionData(init ...*AssertionConditionData) *AssertionConditionData {
	var o *AssertionConditionData
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(AssertionConditionData)
	}
	return o
}

type rawAssertionConditionData AssertionConditionData

// UnmarshalJSON is defined for proper JSON decoding of a AssertionConditionData
func (self *AssertionConditionData) UnmarshalJSON(b []byte) error {
	var m rawAssertionConditionData
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := AssertionConditionData(m)
		*self = o
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *AssertionConditionData) Validate() error {
	if self.Value == "" {
		return fmt.Errorf("AssertionConditionData.value is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "AssertionConditionValue", self.Value)
		if !val.Valid {
			return fmt.Errorf("AssertionConditionData.value does not contain a valid AssertionConditionValue (%v)", val.Error)
		}
	}
	return nil
}

// AssertionCondition - A representation of condition associated with an
// assertion
type AssertionCondition struct {

	//
	// condition id - auto generated by server. Not required during put
	// operations.
	//
	Id *int32 `json:"id,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// each key in the map represents a unique condition. All the keys present in
	// the map form a logical condition with AND operation.
	//
	ConditionsMap map[AssertionConditionKey]*AssertionConditionData `json:"conditionsMap"`
}

// NewAssertionCondition - creates an initialized AssertionCondition instance, returns a pointer to it
func NewAssertionCondition(init ...*AssertionCondition) *AssertionCondition {
	var o *AssertionCondition
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(AssertionCondition)
	}
	return o.Init()
}

// Init - sets up the instance according to its default field values, if any
func (self *AssertionCondition) Init() *AssertionCondition {
	if self.ConditionsMap == nil {
		self.ConditionsMap = make(map[AssertionConditionKey]*AssertionConditionData)
	}
	return self
}

type rawAssertionCondition AssertionCondition

// UnmarshalJSON is defined for proper JSON decoding of a AssertionCondition
func (self *AssertionCondition) UnmarshalJSON(b []byte) error {
	var m rawAssertionCondition
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := AssertionCondition(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *AssertionCondition) Validate() error {
	if self.ConditionsMap == nil {
		return fmt.Errorf("AssertionCondition: Missing required field: conditionsMap")
	}
	return nil
}

// AssertionConditions - The representation of list of assertion conditions
type AssertionConditions struct {

	//
	// list of assertion conditions.
	//
	ConditionsList []*AssertionCondition `json:"conditionsList"`
}

// NewAssertionConditions - creates an initialized AssertionConditions instance, returns a pointer to it
func NewAssertionConditions(init ...*AssertionConditions) *AssertionConditions {
	var o *AssertionConditions
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(AssertionConditions)
	}
	return o.Init()
}

// Init - sets up the instance according to its default field values, if any
func (self *AssertionConditions) Init() *AssertionConditions {
	if self.ConditionsList == nil {
		self.ConditionsList = make([]*AssertionCondition, 0)
	}
	return self
}

type rawAssertionConditions AssertionConditions

// UnmarshalJSON is defined for proper JSON decoding of a AssertionConditions
func (self *AssertionConditions) UnmarshalJSON(b []byte) error {
	var m rawAssertionConditions
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := AssertionConditions(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *AssertionConditions) Validate() error {
	if self.ConditionsList == nil {
		return fmt.Errorf("AssertionConditions: Missing required field: conditionsList")
	}
	return nil
}

// Assertion - A representation for the encapsulation of an action to be
// performed on a resource by a principal.
type Assertion struct {

	//
	// the subject of the assertion - a role
	//
	Role string `json:"role"`

	//
	// the object of the assertion. Must be in the local namespace. Can contain
	// wildcards
	//
	Resource string `json:"resource"`

	//
	// the predicate of the assertion. Can contain wildcards
	//
	Action string `json:"action"`

	//
	// the effect of the assertion in the policy language
	//
	Effect *AssertionEffect `json:"effect,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// assertion id - auto generated by server. Not required during put
	// operations.
	//
	Id *int64 `json:"id,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// If true, we should store action and resource in their original case
	//
	CaseSensitive *bool `json:"caseSensitive,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// optional list of assertion conditions associated with given assertion
	//
	Conditions *AssertionConditions `json:"conditions,omitempty" rdl:"optional" yaml:",omitempty"`
}

// NewAssertion - creates an initialized Assertion instance, returns a pointer to it
func NewAssertion(init ...*Assertion) *Assertion {
	var o *Assertion
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(Assertion)
	}
	return o
}

type rawAssertion Assertion

// UnmarshalJSON is defined for proper JSON decoding of a Assertion
func (self *Assertion) UnmarshalJSON(b []byte) error {
	var m rawAssertion
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := Assertion(m)
		*self = o
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *Assertion) Validate() error {
	if self.Role == "" {
		return fmt.Errorf("Assertion.role is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "String", self.Role)
		if !val.Valid {
			return fmt.Errorf("Assertion.role does not contain a valid String (%v)", val.Error)
		}
	}
	if self.Resource == "" {
		return fmt.Errorf("Assertion.resource is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "String", self.Resource)
		if !val.Valid {
			return fmt.Errorf("Assertion.resource does not contain a valid String (%v)", val.Error)
		}
	}
	if self.Action == "" {
		return fmt.Errorf("Assertion.action is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "String", self.Action)
		if !val.Valid {
			return fmt.Errorf("Assertion.action does not contain a valid String (%v)", val.Error)
		}
	}
	return nil
}

// ResourcePolicyOwnership - The representation of the policy ownership object
type ResourcePolicyOwnership struct {

	//
	// owner of the object's assertions attribute
	//
	AssertionsOwner SimpleName `json:"assertionsOwner,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// owner of the object itself - checked for object deletion
	//
	ObjectOwner SimpleName `json:"objectOwner,omitempty" rdl:"optional" yaml:",omitempty"`
}

// NewResourcePolicyOwnership - creates an initialized ResourcePolicyOwnership instance, returns a pointer to it
func NewResourcePolicyOwnership(init ...*ResourcePolicyOwnership) *ResourcePolicyOwnership {
	var o *ResourcePolicyOwnership
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(ResourcePolicyOwnership)
	}
	return o
}

type rawResourcePolicyOwnership ResourcePolicyOwnership

// UnmarshalJSON is defined for proper JSON decoding of a ResourcePolicyOwnership
func (self *ResourcePolicyOwnership) UnmarshalJSON(b []byte) error {
	var m rawResourcePolicyOwnership
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := ResourcePolicyOwnership(m)
		*self = o
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *ResourcePolicyOwnership) Validate() error {
	if self.AssertionsOwner != "" {
		val := rdl.Validate(ZMSSchema(), "SimpleName", self.AssertionsOwner)
		if !val.Valid {
			return fmt.Errorf("ResourcePolicyOwnership.assertionsOwner does not contain a valid SimpleName (%v)", val.Error)
		}
	}
	if self.ObjectOwner != "" {
		val := rdl.Validate(ZMSSchema(), "SimpleName", self.ObjectOwner)
		if !val.Valid {
			return fmt.Errorf("ResourcePolicyOwnership.objectOwner does not contain a valid SimpleName (%v)", val.Error)
		}
	}
	return nil
}

// Policy - The representation for a Policy with set of assertions.
type Policy struct {

	//
	// name of the policy
	//
	Name ResourceName `json:"name"`

	//
	// last modification timestamp of this policy
	//
	Modified *rdl.Timestamp `json:"modified,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// list of defined assertions for this policy
	//
	Assertions []*Assertion `json:"assertions"`

	//
	// If true, we should store action and resource in their original case
	//
	CaseSensitive *bool `json:"caseSensitive,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// optional version string, defaults to 0
	//
	Version SimpleName `json:"version,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// if multi-version policy then indicates active version
	//
	Active *bool `json:"active,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// a description of the policy
	//
	Description string `json:"description" rdl:"optional" yaml:",omitempty"`

	//
	// key-value pair tags, tag might contain multiple values
	//
	Tags map[TagKey]*TagValueList `json:"tags,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// ownership information for the policy (read-only attribute)
	//
	ResourceOwnership *ResourcePolicyOwnership `json:"resourceOwnership,omitempty" rdl:"optional" yaml:",omitempty"`
}

// NewPolicy - creates an initialized Policy instance, returns a pointer to it
func NewPolicy(init ...*Policy) *Policy {
	var o *Policy
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(Policy)
	}
	return o.Init()
}

// Init - sets up the instance according to its default field values, if any
func (self *Policy) Init() *Policy {
	if self.Assertions == nil {
		self.Assertions = make([]*Assertion, 0)
	}
	return self
}

type rawPolicy Policy

// UnmarshalJSON is defined for proper JSON decoding of a Policy
func (self *Policy) UnmarshalJSON(b []byte) error {
	var m rawPolicy
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := Policy(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *Policy) Validate() error {
	if self.Name == "" {
		return fmt.Errorf("Policy.name is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "ResourceName", self.Name)
		if !val.Valid {
			return fmt.Errorf("Policy.name does not contain a valid ResourceName (%v)", val.Error)
		}
	}
	if self.Assertions == nil {
		return fmt.Errorf("Policy: Missing required field: assertions")
	}
	if self.Version != "" {
		val := rdl.Validate(ZMSSchema(), "SimpleName", self.Version)
		if !val.Valid {
			return fmt.Errorf("Policy.version does not contain a valid SimpleName (%v)", val.Error)
		}
	}
	if self.Description != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.Description)
		if !val.Valid {
			return fmt.Errorf("Policy.description does not contain a valid String (%v)", val.Error)
		}
	}
	return nil
}

// Policies - The representation of list of policy objects
type Policies struct {

	//
	// list of policy objects
	//
	List []*Policy `json:"list"`
}

// NewPolicies - creates an initialized Policies instance, returns a pointer to it
func NewPolicies(init ...*Policies) *Policies {
	var o *Policies
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(Policies)
	}
	return o.Init()
}

// Init - sets up the instance according to its default field values, if any
func (self *Policies) Init() *Policies {
	if self.List == nil {
		self.List = make([]*Policy, 0)
	}
	return self
}

type rawPolicies Policies

// UnmarshalJSON is defined for proper JSON decoding of a Policies
func (self *Policies) UnmarshalJSON(b []byte) error {
	var m rawPolicies
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := Policies(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *Policies) Validate() error {
	if self.List == nil {
		return fmt.Errorf("Policies: Missing required field: list")
	}
	return nil
}

// PolicyOptions - Options for Policy Management Requests
type PolicyOptions struct {

	//
	// policy version
	//
	Version SimpleName `json:"version"`

	//
	// optional source version used when creating a new version, defaults to 0
	//
	FromVersion SimpleName `json:"fromVersion,omitempty" rdl:"optional" yaml:",omitempty"`
}

// NewPolicyOptions - creates an initialized PolicyOptions instance, returns a pointer to it
func NewPolicyOptions(init ...*PolicyOptions) *PolicyOptions {
	var o *PolicyOptions
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(PolicyOptions)
	}
	return o
}

type rawPolicyOptions PolicyOptions

// UnmarshalJSON is defined for proper JSON decoding of a PolicyOptions
func (self *PolicyOptions) UnmarshalJSON(b []byte) error {
	var m rawPolicyOptions
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := PolicyOptions(m)
		*self = o
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *PolicyOptions) Validate() error {
	if self.Version == "" {
		return fmt.Errorf("PolicyOptions.version is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "SimpleName", self.Version)
		if !val.Valid {
			return fmt.Errorf("PolicyOptions.version does not contain a valid SimpleName (%v)", val.Error)
		}
	}
	if self.FromVersion != "" {
		val := rdl.Validate(ZMSSchema(), "SimpleName", self.FromVersion)
		if !val.Valid {
			return fmt.Errorf("PolicyOptions.fromVersion does not contain a valid SimpleName (%v)", val.Error)
		}
	}
	return nil
}

// PublicKeyEntry - The representation of the public key in a service identity
// object.
type PublicKeyEntry struct {

	//
	// the public key for the service
	//
	Key string `json:"key"`

	//
	// the key identifier (version or zone name)
	//
	Id string `json:"id"`
}

// NewPublicKeyEntry - creates an initialized PublicKeyEntry instance, returns a pointer to it
func NewPublicKeyEntry(init ...*PublicKeyEntry) *PublicKeyEntry {
	var o *PublicKeyEntry
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(PublicKeyEntry)
	}
	return o
}

type rawPublicKeyEntry PublicKeyEntry

// UnmarshalJSON is defined for proper JSON decoding of a PublicKeyEntry
func (self *PublicKeyEntry) UnmarshalJSON(b []byte) error {
	var m rawPublicKeyEntry
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := PublicKeyEntry(m)
		*self = o
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *PublicKeyEntry) Validate() error {
	if self.Key == "" {
		return fmt.Errorf("PublicKeyEntry.key is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "String", self.Key)
		if !val.Valid {
			return fmt.Errorf("PublicKeyEntry.key does not contain a valid String (%v)", val.Error)
		}
	}
	if self.Id == "" {
		return fmt.Errorf("PublicKeyEntry.id is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "String", self.Id)
		if !val.Valid {
			return fmt.Errorf("PublicKeyEntry.id does not contain a valid String (%v)", val.Error)
		}
	}
	return nil
}

// CredsEntry - The representation of the credentials for a service identity
// object.
type CredsEntry struct {

	//
	// the secret for the service
	//
	Value string `json:"value" rdl:"optional" yaml:",omitempty"`
}

// NewCredsEntry - creates an initialized CredsEntry instance, returns a pointer to it
func NewCredsEntry(init ...*CredsEntry) *CredsEntry {
	var o *CredsEntry
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(CredsEntry)
	}
	return o
}

type rawCredsEntry CredsEntry

// UnmarshalJSON is defined for proper JSON decoding of a CredsEntry
func (self *CredsEntry) UnmarshalJSON(b []byte) error {
	var m rawCredsEntry
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := CredsEntry(m)
		*self = o
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *CredsEntry) Validate() error {
	if self.Value != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.Value)
		if !val.Valid {
			return fmt.Errorf("CredsEntry.value does not contain a valid String (%v)", val.Error)
		}
	}
	return nil
}

// ResourceServiceIdentityOwnership - The representation of the service
// identity ownership object
type ResourceServiceIdentityOwnership struct {

	//
	// owner of the object's public keys attribute
	//
	PublicKeysOwner SimpleName `json:"publicKeysOwner,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// owner of the object's host list attribute
	//
	HostsOwner SimpleName `json:"hostsOwner,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// owner of the object itself - checked for object deletion
	//
	ObjectOwner SimpleName `json:"objectOwner,omitempty" rdl:"optional" yaml:",omitempty"`
}

// NewResourceServiceIdentityOwnership - creates an initialized ResourceServiceIdentityOwnership instance, returns a pointer to it
func NewResourceServiceIdentityOwnership(init ...*ResourceServiceIdentityOwnership) *ResourceServiceIdentityOwnership {
	var o *ResourceServiceIdentityOwnership
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(ResourceServiceIdentityOwnership)
	}
	return o
}

type rawResourceServiceIdentityOwnership ResourceServiceIdentityOwnership

// UnmarshalJSON is defined for proper JSON decoding of a ResourceServiceIdentityOwnership
func (self *ResourceServiceIdentityOwnership) UnmarshalJSON(b []byte) error {
	var m rawResourceServiceIdentityOwnership
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := ResourceServiceIdentityOwnership(m)
		*self = o
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *ResourceServiceIdentityOwnership) Validate() error {
	if self.PublicKeysOwner != "" {
		val := rdl.Validate(ZMSSchema(), "SimpleName", self.PublicKeysOwner)
		if !val.Valid {
			return fmt.Errorf("ResourceServiceIdentityOwnership.publicKeysOwner does not contain a valid SimpleName (%v)", val.Error)
		}
	}
	if self.HostsOwner != "" {
		val := rdl.Validate(ZMSSchema(), "SimpleName", self.HostsOwner)
		if !val.Valid {
			return fmt.Errorf("ResourceServiceIdentityOwnership.hostsOwner does not contain a valid SimpleName (%v)", val.Error)
		}
	}
	if self.ObjectOwner != "" {
		val := rdl.Validate(ZMSSchema(), "SimpleName", self.ObjectOwner)
		if !val.Valid {
			return fmt.Errorf("ResourceServiceIdentityOwnership.objectOwner does not contain a valid SimpleName (%v)", val.Error)
		}
	}
	return nil
}

// ServiceIdentity - The representation of the service identity object.
type ServiceIdentity struct {

	//
	// the full name of the service, i.e. "sports.storage"
	//
	Name ServiceName `json:"name"`

	//
	// description of the service
	//
	Description string `json:"description" rdl:"optional" yaml:",omitempty"`

	//
	// array of public keys for key rotation
	//
	PublicKeys []*PublicKeyEntry `json:"publicKeys,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// if present, then this service can provision tenants via this endpoint.
	//
	ProviderEndpoint string `json:"providerEndpoint" rdl:"optional" yaml:",omitempty"`

	//
	// the timestamp when this entry was last modified
	//
	Modified *rdl.Timestamp `json:"modified,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// the path of the executable that runs the service
	//
	Executable string `json:"executable" rdl:"optional" yaml:",omitempty"`

	//
	// list of host names that this service can run on
	//
	Hosts []string `json:"hosts,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// local (unix) user name this service can run as
	//
	User string `json:"user" rdl:"optional" yaml:",omitempty"`

	//
	// local (unix) group name this service can run as
	//
	Group string `json:"group" rdl:"optional" yaml:",omitempty"`

	//
	// key-value pair tags, tag might contain multiple values
	//
	Tags map[TagKey]*TagValueList `json:"tags,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// ownership information for the service (read-only attribute)
	//
	ResourceOwnership *ResourceServiceIdentityOwnership `json:"resourceOwnership,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// requested x509 cert signer key id (system attribute)
	//
	X509CertSignerKeyId string `json:"x509CertSignerKeyId" rdl:"optional" yaml:",omitempty"`

	//
	// requested ssh cert signer key id (system attribute)
	//
	SshCertSignerKeyId string `json:"sshCertSignerKeyId" rdl:"optional" yaml:",omitempty"`

	//
	// the credentials for the service
	//
	Creds string `json:"creds" rdl:"optional" yaml:",omitempty"`
}

// NewServiceIdentity - creates an initialized ServiceIdentity instance, returns a pointer to it
func NewServiceIdentity(init ...*ServiceIdentity) *ServiceIdentity {
	var o *ServiceIdentity
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(ServiceIdentity)
	}
	return o
}

type rawServiceIdentity ServiceIdentity

// UnmarshalJSON is defined for proper JSON decoding of a ServiceIdentity
func (self *ServiceIdentity) UnmarshalJSON(b []byte) error {
	var m rawServiceIdentity
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := ServiceIdentity(m)
		*self = o
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *ServiceIdentity) Validate() error {
	if self.Name == "" {
		return fmt.Errorf("ServiceIdentity.name is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "ServiceName", self.Name)
		if !val.Valid {
			return fmt.Errorf("ServiceIdentity.name does not contain a valid ServiceName (%v)", val.Error)
		}
	}
	if self.Description != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.Description)
		if !val.Valid {
			return fmt.Errorf("ServiceIdentity.description does not contain a valid String (%v)", val.Error)
		}
	}
	if self.ProviderEndpoint != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.ProviderEndpoint)
		if !val.Valid {
			return fmt.Errorf("ServiceIdentity.providerEndpoint does not contain a valid String (%v)", val.Error)
		}
	}
	if self.Executable != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.Executable)
		if !val.Valid {
			return fmt.Errorf("ServiceIdentity.executable does not contain a valid String (%v)", val.Error)
		}
	}
	if self.User != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.User)
		if !val.Valid {
			return fmt.Errorf("ServiceIdentity.user does not contain a valid String (%v)", val.Error)
		}
	}
	if self.Group != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.Group)
		if !val.Valid {
			return fmt.Errorf("ServiceIdentity.group does not contain a valid String (%v)", val.Error)
		}
	}
	if self.X509CertSignerKeyId != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.X509CertSignerKeyId)
		if !val.Valid {
			return fmt.Errorf("ServiceIdentity.x509CertSignerKeyId does not contain a valid String (%v)", val.Error)
		}
	}
	if self.SshCertSignerKeyId != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.SshCertSignerKeyId)
		if !val.Valid {
			return fmt.Errorf("ServiceIdentity.sshCertSignerKeyId does not contain a valid String (%v)", val.Error)
		}
	}
	if self.Creds != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.Creds)
		if !val.Valid {
			return fmt.Errorf("ServiceIdentity.creds does not contain a valid String (%v)", val.Error)
		}
	}
	return nil
}

// ServiceIdentities - The representation of list of services
type ServiceIdentities struct {

	//
	// list of services
	//
	List []*ServiceIdentity `json:"list"`

	//
	// if set, the value indicates the total number of services in the system that
	// match the query criteria but not returned due to limit constraints; thus, the
	// result in the list is a partial set.
	//
	ServiceMatchCount int64 `json:"serviceMatchCount"`
}

// NewServiceIdentities - creates an initialized ServiceIdentities instance, returns a pointer to it
func NewServiceIdentities(init ...*ServiceIdentities) *ServiceIdentities {
	var o *ServiceIdentities
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(ServiceIdentities)
	}
	return o.Init()
}

// Init - sets up the instance according to its default field values, if any
func (self *ServiceIdentities) Init() *ServiceIdentities {
	if self.List == nil {
		self.List = make([]*ServiceIdentity, 0)
	}
	return self
}

type rawServiceIdentities ServiceIdentities

// UnmarshalJSON is defined for proper JSON decoding of a ServiceIdentities
func (self *ServiceIdentities) UnmarshalJSON(b []byte) error {
	var m rawServiceIdentities
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := ServiceIdentities(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *ServiceIdentities) Validate() error {
	if self.List == nil {
		return fmt.Errorf("ServiceIdentities: Missing required field: list")
	}
	return nil
}

// ServiceIdentityList - The representation for an enumeration of services in
// the namespace, with pagination.
type ServiceIdentityList struct {

	//
	// list of service names
	//
	Names []EntityName `json:"names"`

	//
	// if the response is a paginated list, this attribute specifies the value to
	// be used in the next service list request as the value for the skip query
	// parameter.
	//
	Next string `json:"next" rdl:"optional" yaml:",omitempty"`
}

// NewServiceIdentityList - creates an initialized ServiceIdentityList instance, returns a pointer to it
func NewServiceIdentityList(init ...*ServiceIdentityList) *ServiceIdentityList {
	var o *ServiceIdentityList
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(ServiceIdentityList)
	}
	return o.Init()
}

// Init - sets up the instance according to its default field values, if any
func (self *ServiceIdentityList) Init() *ServiceIdentityList {
	if self.Names == nil {
		self.Names = make([]EntityName, 0)
	}
	return self
}

type rawServiceIdentityList ServiceIdentityList

// UnmarshalJSON is defined for proper JSON decoding of a ServiceIdentityList
func (self *ServiceIdentityList) UnmarshalJSON(b []byte) error {
	var m rawServiceIdentityList
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := ServiceIdentityList(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *ServiceIdentityList) Validate() error {
	if self.Names == nil {
		return fmt.Errorf("ServiceIdentityList: Missing required field: names")
	}
	if self.Next != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.Next)
		if !val.Valid {
			return fmt.Errorf("ServiceIdentityList.next does not contain a valid String (%v)", val.Error)
		}
	}
	return nil
}

// ServiceIdentitySystemMeta - Set of system metadata attributes that all
// services may have and can be changed by system admins.
type ServiceIdentitySystemMeta struct {

	//
	// provider callback endpoint
	//
	ProviderEndpoint string `json:"providerEndpoint" rdl:"optional" yaml:",omitempty"`

	//
	// requested x509 cert signer key id
	//
	X509CertSignerKeyId string `json:"x509CertSignerKeyId" rdl:"optional" yaml:",omitempty"`

	//
	// requested ssh cert signer key id
	//
	SshCertSignerKeyId string `json:"sshCertSignerKeyId" rdl:"optional" yaml:",omitempty"`
}

// NewServiceIdentitySystemMeta - creates an initialized ServiceIdentitySystemMeta instance, returns a pointer to it
func NewServiceIdentitySystemMeta(init ...*ServiceIdentitySystemMeta) *ServiceIdentitySystemMeta {
	var o *ServiceIdentitySystemMeta
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(ServiceIdentitySystemMeta)
	}
	return o
}

type rawServiceIdentitySystemMeta ServiceIdentitySystemMeta

// UnmarshalJSON is defined for proper JSON decoding of a ServiceIdentitySystemMeta
func (self *ServiceIdentitySystemMeta) UnmarshalJSON(b []byte) error {
	var m rawServiceIdentitySystemMeta
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := ServiceIdentitySystemMeta(m)
		*self = o
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *ServiceIdentitySystemMeta) Validate() error {
	if self.ProviderEndpoint != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.ProviderEndpoint)
		if !val.Valid {
			return fmt.Errorf("ServiceIdentitySystemMeta.providerEndpoint does not contain a valid String (%v)", val.Error)
		}
	}
	if self.X509CertSignerKeyId != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.X509CertSignerKeyId)
		if !val.Valid {
			return fmt.Errorf("ServiceIdentitySystemMeta.x509CertSignerKeyId does not contain a valid String (%v)", val.Error)
		}
	}
	if self.SshCertSignerKeyId != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.SshCertSignerKeyId)
		if !val.Valid {
			return fmt.Errorf("ServiceIdentitySystemMeta.sshCertSignerKeyId does not contain a valid String (%v)", val.Error)
		}
	}
	return nil
}

// TemplateMetaData - MetaData for template.
type TemplateMetaData struct {

	//
	// name of the template
	//
	TemplateName string `json:"templateName" rdl:"optional" yaml:",omitempty"`

	//
	// description of the template
	//
	Description string `json:"description" rdl:"optional" yaml:",omitempty"`

	//
	// Version from DB(zms_store->domain_template->version)
	//
	CurrentVersion *int32 `json:"currentVersion,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// Bumped up version from solutions-template.json when there is a change
	//
	LatestVersion *int32 `json:"latestVersion,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// placeholders in the template roles/policies to replace (ex:_service_)
	//
	KeywordsToReplace string `json:"keywordsToReplace" rdl:"optional" yaml:",omitempty"`

	//
	// the updated timestamp of the template(solution_templates.json)
	//
	Timestamp *rdl.Timestamp `json:"timestamp,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// flag to automatically update the roles/policies that belongs to the
	// template
	//
	AutoUpdate *bool `json:"autoUpdate,omitempty" rdl:"optional" yaml:",omitempty"`
}

// NewTemplateMetaData - creates an initialized TemplateMetaData instance, returns a pointer to it
func NewTemplateMetaData(init ...*TemplateMetaData) *TemplateMetaData {
	var o *TemplateMetaData
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(TemplateMetaData)
	}
	return o
}

type rawTemplateMetaData TemplateMetaData

// UnmarshalJSON is defined for proper JSON decoding of a TemplateMetaData
func (self *TemplateMetaData) UnmarshalJSON(b []byte) error {
	var m rawTemplateMetaData
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := TemplateMetaData(m)
		*self = o
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *TemplateMetaData) Validate() error {
	if self.TemplateName != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.TemplateName)
		if !val.Valid {
			return fmt.Errorf("TemplateMetaData.templateName does not contain a valid String (%v)", val.Error)
		}
	}
	if self.Description != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.Description)
		if !val.Valid {
			return fmt.Errorf("TemplateMetaData.description does not contain a valid String (%v)", val.Error)
		}
	}
	if self.KeywordsToReplace != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.KeywordsToReplace)
		if !val.Valid {
			return fmt.Errorf("TemplateMetaData.keywordsToReplace does not contain a valid String (%v)", val.Error)
		}
	}
	return nil
}

// Template - Solution Template object defined on the server
type Template struct {

	//
	// list of roles in the template
	//
	Roles []*Role `json:"roles"`

	//
	// list of policies defined in this template
	//
	Policies []*Policy `json:"policies"`

	//
	// list of services defined in this template
	//
	Services []*ServiceIdentity `json:"services,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// list of services defined in this template
	//
	Metadata *TemplateMetaData `json:"metadata,omitempty" rdl:"optional" yaml:",omitempty"`
}

// NewTemplate - creates an initialized Template instance, returns a pointer to it
func NewTemplate(init ...*Template) *Template {
	var o *Template
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(Template)
	}
	return o.Init()
}

// Init - sets up the instance according to its default field values, if any
func (self *Template) Init() *Template {
	if self.Roles == nil {
		self.Roles = make([]*Role, 0)
	}
	if self.Policies == nil {
		self.Policies = make([]*Policy, 0)
	}
	return self
}

type rawTemplate Template

// UnmarshalJSON is defined for proper JSON decoding of a Template
func (self *Template) UnmarshalJSON(b []byte) error {
	var m rawTemplate
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := Template(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *Template) Validate() error {
	if self.Roles == nil {
		return fmt.Errorf("Template: Missing required field: roles")
	}
	if self.Policies == nil {
		return fmt.Errorf("Template: Missing required field: policies")
	}
	return nil
}

// TemplateList - List of template names that is the base struct for server and
// domain templates
type TemplateList struct {

	//
	// list of template names
	//
	TemplateNames []SimpleName `json:"templateNames"`
}

// NewTemplateList - creates an initialized TemplateList instance, returns a pointer to it
func NewTemplateList(init ...*TemplateList) *TemplateList {
	var o *TemplateList
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(TemplateList)
	}
	return o.Init()
}

// Init - sets up the instance according to its default field values, if any
func (self *TemplateList) Init() *TemplateList {
	if self.TemplateNames == nil {
		self.TemplateNames = make([]SimpleName, 0)
	}
	return self
}

type rawTemplateList TemplateList

// UnmarshalJSON is defined for proper JSON decoding of a TemplateList
func (self *TemplateList) UnmarshalJSON(b []byte) error {
	var m rawTemplateList
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := TemplateList(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *TemplateList) Validate() error {
	if self.TemplateNames == nil {
		return fmt.Errorf("TemplateList: Missing required field: templateNames")
	}
	return nil
}

// TemplateParam -
type TemplateParam struct {

	//
	// name of the parameter
	//
	Name SimpleName `json:"name"`

	//
	// value of the parameter
	//
	Value string `json:"value"`
}

// NewTemplateParam - creates an initialized TemplateParam instance, returns a pointer to it
func NewTemplateParam(init ...*TemplateParam) *TemplateParam {
	var o *TemplateParam
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(TemplateParam)
	}
	return o
}

type rawTemplateParam TemplateParam

// UnmarshalJSON is defined for proper JSON decoding of a TemplateParam
func (self *TemplateParam) UnmarshalJSON(b []byte) error {
	var m rawTemplateParam
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := TemplateParam(m)
		*self = o
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *TemplateParam) Validate() error {
	if self.Name == "" {
		return fmt.Errorf("TemplateParam.name is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "SimpleName", self.Name)
		if !val.Valid {
			return fmt.Errorf("TemplateParam.name does not contain a valid SimpleName (%v)", val.Error)
		}
	}
	if self.Value == "" {
		return fmt.Errorf("TemplateParam.value is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "String", self.Value)
		if !val.Valid {
			return fmt.Errorf("TemplateParam.value does not contain a valid String (%v)", val.Error)
		}
	}
	return nil
}

// DomainTemplate - solution template(s) to be applied to a domain
type DomainTemplate struct {

	//
	// list of template names
	//
	TemplateNames []SimpleName `json:"templateNames"`

	//
	// optional template parameters
	//
	Params []*TemplateParam `json:"params,omitempty" rdl:"optional" yaml:",omitempty"`
}

// NewDomainTemplate - creates an initialized DomainTemplate instance, returns a pointer to it
func NewDomainTemplate(init ...*DomainTemplate) *DomainTemplate {
	var o *DomainTemplate
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(DomainTemplate)
	}
	return o.Init()
}

// Init - sets up the instance according to its default field values, if any
func (self *DomainTemplate) Init() *DomainTemplate {
	if self.TemplateNames == nil {
		self.TemplateNames = make([]SimpleName, 0)
	}
	return self
}

type rawDomainTemplate DomainTemplate

// UnmarshalJSON is defined for proper JSON decoding of a DomainTemplate
func (self *DomainTemplate) UnmarshalJSON(b []byte) error {
	var m rawDomainTemplate
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := DomainTemplate(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *DomainTemplate) Validate() error {
	if self.TemplateNames == nil {
		return fmt.Errorf("DomainTemplate: Missing required field: templateNames")
	}
	return nil
}

// DomainTemplateList - List of solution templates to be applied to a domain
type DomainTemplateList struct {

	//
	// list of template names
	//
	TemplateNames []SimpleName `json:"templateNames"`
}

// NewDomainTemplateList - creates an initialized DomainTemplateList instance, returns a pointer to it
func NewDomainTemplateList(init ...*DomainTemplateList) *DomainTemplateList {
	var o *DomainTemplateList
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(DomainTemplateList)
	}
	return o.Init()
}

// Init - sets up the instance according to its default field values, if any
func (self *DomainTemplateList) Init() *DomainTemplateList {
	if self.TemplateNames == nil {
		self.TemplateNames = make([]SimpleName, 0)
	}
	return self
}

type rawDomainTemplateList DomainTemplateList

// UnmarshalJSON is defined for proper JSON decoding of a DomainTemplateList
func (self *DomainTemplateList) UnmarshalJSON(b []byte) error {
	var m rawDomainTemplateList
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := DomainTemplateList(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *DomainTemplateList) Validate() error {
	if self.TemplateNames == nil {
		return fmt.Errorf("DomainTemplateList: Missing required field: templateNames")
	}
	return nil
}

// ServerTemplateList - List of solution templates available in the server
type ServerTemplateList struct {

	//
	// list of template names
	//
	TemplateNames []SimpleName `json:"templateNames"`
}

// NewServerTemplateList - creates an initialized ServerTemplateList instance, returns a pointer to it
func NewServerTemplateList(init ...*ServerTemplateList) *ServerTemplateList {
	var o *ServerTemplateList
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(ServerTemplateList)
	}
	return o.Init()
}

// Init - sets up the instance according to its default field values, if any
func (self *ServerTemplateList) Init() *ServerTemplateList {
	if self.TemplateNames == nil {
		self.TemplateNames = make([]SimpleName, 0)
	}
	return self
}

type rawServerTemplateList ServerTemplateList

// UnmarshalJSON is defined for proper JSON decoding of a ServerTemplateList
func (self *ServerTemplateList) UnmarshalJSON(b []byte) error {
	var m rawServerTemplateList
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := ServerTemplateList(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *ServerTemplateList) Validate() error {
	if self.TemplateNames == nil {
		return fmt.Errorf("ServerTemplateList: Missing required field: templateNames")
	}
	return nil
}

// DomainTemplateDetailsList - List of templates with metadata details given a
// domain
type DomainTemplateDetailsList struct {

	//
	// list of template metadata
	//
	MetaData []*TemplateMetaData `json:"metaData"`
}

// NewDomainTemplateDetailsList - creates an initialized DomainTemplateDetailsList instance, returns a pointer to it
func NewDomainTemplateDetailsList(init ...*DomainTemplateDetailsList) *DomainTemplateDetailsList {
	var o *DomainTemplateDetailsList
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(DomainTemplateDetailsList)
	}
	return o.Init()
}

// Init - sets up the instance according to its default field values, if any
func (self *DomainTemplateDetailsList) Init() *DomainTemplateDetailsList {
	if self.MetaData == nil {
		self.MetaData = make([]*TemplateMetaData, 0)
	}
	return self
}

type rawDomainTemplateDetailsList DomainTemplateDetailsList

// UnmarshalJSON is defined for proper JSON decoding of a DomainTemplateDetailsList
func (self *DomainTemplateDetailsList) UnmarshalJSON(b []byte) error {
	var m rawDomainTemplateDetailsList
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := DomainTemplateDetailsList(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *DomainTemplateDetailsList) Validate() error {
	if self.MetaData == nil {
		return fmt.Errorf("DomainTemplateDetailsList: Missing required field: metaData")
	}
	return nil
}

// TopLevelDomain - Top Level Domain object. The required attributes include
// the name of the domain and list of domain administrators.
type TopLevelDomain struct {

	//
	// a description of the domain
	//
	Description string `json:"description" rdl:"optional" yaml:",omitempty"`

	//
	// a reference to an audit organization defined in athenz
	//
	Org ResourceName `json:"org,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// Future use only, currently not used
	//
	Enabled *bool `json:"enabled,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// Flag indicates whether or not domain modifications should be logged for
	// SOX+Auditing. If true, the auditRef parameter must be supplied(not empty) for
	// any API defining it.
	//
	AuditEnabled *bool `json:"auditEnabled,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// associated aws account id (system attribute - uniqueness check - if
	// enabled)
	//
	Account string `json:"account" rdl:"optional" yaml:",omitempty"`

	//
	// associated product id (system attribute - uniqueness check - if enabled)
	//
	YpmId *int32 `json:"ypmId,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// associated application id
	//
	ApplicationId string `json:"applicationId" rdl:"optional" yaml:",omitempty"`

	//
	// domain certificate dns domain (system attribute)
	//
	CertDnsDomain string `json:"certDnsDomain" rdl:"optional" yaml:",omitempty"`

	//
	// all user members in the domain will have specified max expiry days
	//
	MemberExpiryDays *int32 `json:"memberExpiryDays,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// tokens issued for this domain will have specified max timeout in mins
	//
	TokenExpiryMins *int32 `json:"tokenExpiryMins,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// service identity certs issued for this domain will have specified max
	// timeout in mins
	//
	ServiceCertExpiryMins *int32 `json:"serviceCertExpiryMins,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// role certs issued for this domain will have specified max timeout in mins
	//
	RoleCertExpiryMins *int32 `json:"roleCertExpiryMins,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// rsa or ec signing algorithm to be used for tokens
	//
	SignAlgorithm string `json:"signAlgorithm" rdl:"optional" yaml:",omitempty"`

	//
	// all services in the domain roles will have specified max expiry days
	//
	ServiceExpiryDays *int32 `json:"serviceExpiryDays,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// all groups in the domain roles will have specified max expiry days
	//
	GroupExpiryDays *int32 `json:"groupExpiryDays,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// membership filtered based on user authority configured attributes
	//
	UserAuthorityFilter string `json:"userAuthorityFilter" rdl:"optional" yaml:",omitempty"`

	//
	// associated azure subscription id (system attribute - uniqueness check - if
	// enabled)
	//
	AzureSubscription string `json:"azureSubscription" rdl:"optional" yaml:",omitempty"`

	//
	// associated azure tenant id (system attribute)
	//
	AzureTenant string `json:"azureTenant" rdl:"optional" yaml:",omitempty"`

	//
	// associated azure client id (system attribute)
	//
	AzureClient string `json:"azureClient" rdl:"optional" yaml:",omitempty"`

	//
	// associated gcp project id (system attribute - uniqueness check - if
	// enabled)
	//
	GcpProject string `json:"gcpProject" rdl:"optional" yaml:",omitempty"`

	//
	// associated gcp project number (system attribute)
	//
	GcpProjectNumber string `json:"gcpProjectNumber" rdl:"optional" yaml:",omitempty"`

	//
	// key-value pair tags, tag might contain multiple values
	//
	Tags map[TagKey]*TagValueList `json:"tags,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// associated business service with domain
	//
	BusinessService string `json:"businessService" rdl:"optional" yaml:",omitempty"`

	//
	// purge role/group members with expiry date configured days in the past
	//
	MemberPurgeExpiryDays *int32 `json:"memberPurgeExpiryDays,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// associated product id (system attribute - uniqueness check - if enabled)
	//
	ProductId string `json:"productId" rdl:"optional" yaml:",omitempty"`

	//
	// features enabled per domain (system attribute)
	//
	FeatureFlags *int32 `json:"featureFlags,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// list of domain contacts (PE-Owner, Product-Owner, etc), each type can have
	// a single value
	//
	Contacts map[SimpleName]string `json:"contacts,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// domain environment e.g. production, staging, etc
	//
	Environment string `json:"environment" rdl:"optional" yaml:",omitempty"`

	//
	// ownership information for the domain (read-only attribute)
	//
	ResourceOwnership *ResourceDomainOwnership `json:"resourceOwnership,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// requested x509 cert signer key id (system attribute)
	//
	X509CertSignerKeyId string `json:"x509CertSignerKeyId" rdl:"optional" yaml:",omitempty"`

	//
	// requested ssh cert signer key id (system attribute)
	//
	SshCertSignerKeyId string `json:"sshCertSignerKeyId" rdl:"optional" yaml:",omitempty"`

	//
	// slack channel for any notifications in this domain
	//
	SlackChannel string `json:"slackChannel" rdl:"optional" yaml:",omitempty"`

	//
	// name of the domain
	//
	Name SimpleName `json:"name"`

	//
	// list of domain administrators
	//
	AdminUsers []ResourceName `json:"adminUsers"`

	//
	// list of solution template names
	//
	Templates *DomainTemplateList `json:"templates,omitempty" rdl:"optional" yaml:",omitempty"`
}

// NewTopLevelDomain - creates an initialized TopLevelDomain instance, returns a pointer to it
func NewTopLevelDomain(init ...*TopLevelDomain) *TopLevelDomain {
	var o *TopLevelDomain
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(TopLevelDomain)
	}
	return o.Init()
}

// Init - sets up the instance according to its default field values, if any
func (self *TopLevelDomain) Init() *TopLevelDomain {
	if self.Enabled == nil {
		d := true
		self.Enabled = &d
	}
	if self.AuditEnabled == nil {
		d := false
		self.AuditEnabled = &d
	}
	if self.AdminUsers == nil {
		self.AdminUsers = make([]ResourceName, 0)
	}
	return self
}

type rawTopLevelDomain TopLevelDomain

// UnmarshalJSON is defined for proper JSON decoding of a TopLevelDomain
func (self *TopLevelDomain) UnmarshalJSON(b []byte) error {
	var m rawTopLevelDomain
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := TopLevelDomain(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *TopLevelDomain) Validate() error {
	if self.Description != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.Description)
		if !val.Valid {
			return fmt.Errorf("TopLevelDomain.description does not contain a valid String (%v)", val.Error)
		}
	}
	if self.Org != "" {
		val := rdl.Validate(ZMSSchema(), "ResourceName", self.Org)
		if !val.Valid {
			return fmt.Errorf("TopLevelDomain.org does not contain a valid ResourceName (%v)", val.Error)
		}
	}
	if self.Account != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.Account)
		if !val.Valid {
			return fmt.Errorf("TopLevelDomain.account does not contain a valid String (%v)", val.Error)
		}
	}
	if self.ApplicationId != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.ApplicationId)
		if !val.Valid {
			return fmt.Errorf("TopLevelDomain.applicationId does not contain a valid String (%v)", val.Error)
		}
	}
	if self.CertDnsDomain != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.CertDnsDomain)
		if !val.Valid {
			return fmt.Errorf("TopLevelDomain.certDnsDomain does not contain a valid String (%v)", val.Error)
		}
	}
	if self.SignAlgorithm != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.SignAlgorithm)
		if !val.Valid {
			return fmt.Errorf("TopLevelDomain.signAlgorithm does not contain a valid String (%v)", val.Error)
		}
	}
	if self.UserAuthorityFilter != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.UserAuthorityFilter)
		if !val.Valid {
			return fmt.Errorf("TopLevelDomain.userAuthorityFilter does not contain a valid String (%v)", val.Error)
		}
	}
	if self.AzureSubscription != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.AzureSubscription)
		if !val.Valid {
			return fmt.Errorf("TopLevelDomain.azureSubscription does not contain a valid String (%v)", val.Error)
		}
	}
	if self.AzureTenant != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.AzureTenant)
		if !val.Valid {
			return fmt.Errorf("TopLevelDomain.azureTenant does not contain a valid String (%v)", val.Error)
		}
	}
	if self.AzureClient != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.AzureClient)
		if !val.Valid {
			return fmt.Errorf("TopLevelDomain.azureClient does not contain a valid String (%v)", val.Error)
		}
	}
	if self.GcpProject != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.GcpProject)
		if !val.Valid {
			return fmt.Errorf("TopLevelDomain.gcpProject does not contain a valid String (%v)", val.Error)
		}
	}
	if self.GcpProjectNumber != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.GcpProjectNumber)
		if !val.Valid {
			return fmt.Errorf("TopLevelDomain.gcpProjectNumber does not contain a valid String (%v)", val.Error)
		}
	}
	if self.BusinessService != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.BusinessService)
		if !val.Valid {
			return fmt.Errorf("TopLevelDomain.businessService does not contain a valid String (%v)", val.Error)
		}
	}
	if self.ProductId != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.ProductId)
		if !val.Valid {
			return fmt.Errorf("TopLevelDomain.productId does not contain a valid String (%v)", val.Error)
		}
	}
	if self.Environment != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.Environment)
		if !val.Valid {
			return fmt.Errorf("TopLevelDomain.environment does not contain a valid String (%v)", val.Error)
		}
	}
	if self.X509CertSignerKeyId != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.X509CertSignerKeyId)
		if !val.Valid {
			return fmt.Errorf("TopLevelDomain.x509CertSignerKeyId does not contain a valid String (%v)", val.Error)
		}
	}
	if self.SshCertSignerKeyId != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.SshCertSignerKeyId)
		if !val.Valid {
			return fmt.Errorf("TopLevelDomain.sshCertSignerKeyId does not contain a valid String (%v)", val.Error)
		}
	}
	if self.SlackChannel != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.SlackChannel)
		if !val.Valid {
			return fmt.Errorf("TopLevelDomain.slackChannel does not contain a valid String (%v)", val.Error)
		}
	}
	if self.Name == "" {
		return fmt.Errorf("TopLevelDomain.name is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "SimpleName", self.Name)
		if !val.Valid {
			return fmt.Errorf("TopLevelDomain.name does not contain a valid SimpleName (%v)", val.Error)
		}
	}
	if self.AdminUsers == nil {
		return fmt.Errorf("TopLevelDomain: Missing required field: adminUsers")
	}
	return nil
}

// SubDomain - A Subdomain is a TopLevelDomain, except it has a parent.
type SubDomain struct {

	//
	// a description of the domain
	//
	Description string `json:"description" rdl:"optional" yaml:",omitempty"`

	//
	// a reference to an audit organization defined in athenz
	//
	Org ResourceName `json:"org,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// Future use only, currently not used
	//
	Enabled *bool `json:"enabled,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// Flag indicates whether or not domain modifications should be logged for
	// SOX+Auditing. If true, the auditRef parameter must be supplied(not empty) for
	// any API defining it.
	//
	AuditEnabled *bool `json:"auditEnabled,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// associated aws account id (system attribute - uniqueness check - if
	// enabled)
	//
	Account string `json:"account" rdl:"optional" yaml:",omitempty"`

	//
	// associated product id (system attribute - uniqueness check - if enabled)
	//
	YpmId *int32 `json:"ypmId,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// associated application id
	//
	ApplicationId string `json:"applicationId" rdl:"optional" yaml:",omitempty"`

	//
	// domain certificate dns domain (system attribute)
	//
	CertDnsDomain string `json:"certDnsDomain" rdl:"optional" yaml:",omitempty"`

	//
	// all user members in the domain will have specified max expiry days
	//
	MemberExpiryDays *int32 `json:"memberExpiryDays,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// tokens issued for this domain will have specified max timeout in mins
	//
	TokenExpiryMins *int32 `json:"tokenExpiryMins,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// service identity certs issued for this domain will have specified max
	// timeout in mins
	//
	ServiceCertExpiryMins *int32 `json:"serviceCertExpiryMins,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// role certs issued for this domain will have specified max timeout in mins
	//
	RoleCertExpiryMins *int32 `json:"roleCertExpiryMins,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// rsa or ec signing algorithm to be used for tokens
	//
	SignAlgorithm string `json:"signAlgorithm" rdl:"optional" yaml:",omitempty"`

	//
	// all services in the domain roles will have specified max expiry days
	//
	ServiceExpiryDays *int32 `json:"serviceExpiryDays,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// all groups in the domain roles will have specified max expiry days
	//
	GroupExpiryDays *int32 `json:"groupExpiryDays,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// membership filtered based on user authority configured attributes
	//
	UserAuthorityFilter string `json:"userAuthorityFilter" rdl:"optional" yaml:",omitempty"`

	//
	// associated azure subscription id (system attribute - uniqueness check - if
	// enabled)
	//
	AzureSubscription string `json:"azureSubscription" rdl:"optional" yaml:",omitempty"`

	//
	// associated azure tenant id (system attribute)
	//
	AzureTenant string `json:"azureTenant" rdl:"optional" yaml:",omitempty"`

	//
	// associated azure client id (system attribute)
	//
	AzureClient string `json:"azureClient" rdl:"optional" yaml:",omitempty"`

	//
	// associated gcp project id (system attribute - uniqueness check - if
	// enabled)
	//
	GcpProject string `json:"gcpProject" rdl:"optional" yaml:",omitempty"`

	//
	// associated gcp project number (system attribute)
	//
	GcpProjectNumber string `json:"gcpProjectNumber" rdl:"optional" yaml:",omitempty"`

	//
	// key-value pair tags, tag might contain multiple values
	//
	Tags map[TagKey]*TagValueList `json:"tags,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// associated business service with domain
	//
	BusinessService string `json:"businessService" rdl:"optional" yaml:",omitempty"`

	//
	// purge role/group members with expiry date configured days in the past
	//
	MemberPurgeExpiryDays *int32 `json:"memberPurgeExpiryDays,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// associated product id (system attribute - uniqueness check - if enabled)
	//
	ProductId string `json:"productId" rdl:"optional" yaml:",omitempty"`

	//
	// features enabled per domain (system attribute)
	//
	FeatureFlags *int32 `json:"featureFlags,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// list of domain contacts (PE-Owner, Product-Owner, etc), each type can have
	// a single value
	//
	Contacts map[SimpleName]string `json:"contacts,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// domain environment e.g. production, staging, etc
	//
	Environment string `json:"environment" rdl:"optional" yaml:",omitempty"`

	//
	// ownership information for the domain (read-only attribute)
	//
	ResourceOwnership *ResourceDomainOwnership `json:"resourceOwnership,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// requested x509 cert signer key id (system attribute)
	//
	X509CertSignerKeyId string `json:"x509CertSignerKeyId" rdl:"optional" yaml:",omitempty"`

	//
	// requested ssh cert signer key id (system attribute)
	//
	SshCertSignerKeyId string `json:"sshCertSignerKeyId" rdl:"optional" yaml:",omitempty"`

	//
	// slack channel for any notifications in this domain
	//
	SlackChannel string `json:"slackChannel" rdl:"optional" yaml:",omitempty"`

	//
	// name of the domain
	//
	Name SimpleName `json:"name"`

	//
	// list of domain administrators
	//
	AdminUsers []ResourceName `json:"adminUsers"`

	//
	// list of solution template names
	//
	Templates *DomainTemplateList `json:"templates,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// name of the parent domain
	//
	Parent DomainName `json:"parent"`
}

// NewSubDomain - creates an initialized SubDomain instance, returns a pointer to it
func NewSubDomain(init ...*SubDomain) *SubDomain {
	var o *SubDomain
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(SubDomain)
	}
	return o.Init()
}

// Init - sets up the instance according to its default field values, if any
func (self *SubDomain) Init() *SubDomain {
	if self.Enabled == nil {
		d := true
		self.Enabled = &d
	}
	if self.AuditEnabled == nil {
		d := false
		self.AuditEnabled = &d
	}
	if self.AdminUsers == nil {
		self.AdminUsers = make([]ResourceName, 0)
	}
	return self
}

type rawSubDomain SubDomain

// UnmarshalJSON is defined for proper JSON decoding of a SubDomain
func (self *SubDomain) UnmarshalJSON(b []byte) error {
	var m rawSubDomain
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := SubDomain(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *SubDomain) Validate() error {
	if self.Description != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.Description)
		if !val.Valid {
			return fmt.Errorf("SubDomain.description does not contain a valid String (%v)", val.Error)
		}
	}
	if self.Org != "" {
		val := rdl.Validate(ZMSSchema(), "ResourceName", self.Org)
		if !val.Valid {
			return fmt.Errorf("SubDomain.org does not contain a valid ResourceName (%v)", val.Error)
		}
	}
	if self.Account != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.Account)
		if !val.Valid {
			return fmt.Errorf("SubDomain.account does not contain a valid String (%v)", val.Error)
		}
	}
	if self.ApplicationId != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.ApplicationId)
		if !val.Valid {
			return fmt.Errorf("SubDomain.applicationId does not contain a valid String (%v)", val.Error)
		}
	}
	if self.CertDnsDomain != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.CertDnsDomain)
		if !val.Valid {
			return fmt.Errorf("SubDomain.certDnsDomain does not contain a valid String (%v)", val.Error)
		}
	}
	if self.SignAlgorithm != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.SignAlgorithm)
		if !val.Valid {
			return fmt.Errorf("SubDomain.signAlgorithm does not contain a valid String (%v)", val.Error)
		}
	}
	if self.UserAuthorityFilter != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.UserAuthorityFilter)
		if !val.Valid {
			return fmt.Errorf("SubDomain.userAuthorityFilter does not contain a valid String (%v)", val.Error)
		}
	}
	if self.AzureSubscription != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.AzureSubscription)
		if !val.Valid {
			return fmt.Errorf("SubDomain.azureSubscription does not contain a valid String (%v)", val.Error)
		}
	}
	if self.AzureTenant != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.AzureTenant)
		if !val.Valid {
			return fmt.Errorf("SubDomain.azureTenant does not contain a valid String (%v)", val.Error)
		}
	}
	if self.AzureClient != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.AzureClient)
		if !val.Valid {
			return fmt.Errorf("SubDomain.azureClient does not contain a valid String (%v)", val.Error)
		}
	}
	if self.GcpProject != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.GcpProject)
		if !val.Valid {
			return fmt.Errorf("SubDomain.gcpProject does not contain a valid String (%v)", val.Error)
		}
	}
	if self.GcpProjectNumber != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.GcpProjectNumber)
		if !val.Valid {
			return fmt.Errorf("SubDomain.gcpProjectNumber does not contain a valid String (%v)", val.Error)
		}
	}
	if self.BusinessService != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.BusinessService)
		if !val.Valid {
			return fmt.Errorf("SubDomain.businessService does not contain a valid String (%v)", val.Error)
		}
	}
	if self.ProductId != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.ProductId)
		if !val.Valid {
			return fmt.Errorf("SubDomain.productId does not contain a valid String (%v)", val.Error)
		}
	}
	if self.Environment != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.Environment)
		if !val.Valid {
			return fmt.Errorf("SubDomain.environment does not contain a valid String (%v)", val.Error)
		}
	}
	if self.X509CertSignerKeyId != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.X509CertSignerKeyId)
		if !val.Valid {
			return fmt.Errorf("SubDomain.x509CertSignerKeyId does not contain a valid String (%v)", val.Error)
		}
	}
	if self.SshCertSignerKeyId != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.SshCertSignerKeyId)
		if !val.Valid {
			return fmt.Errorf("SubDomain.sshCertSignerKeyId does not contain a valid String (%v)", val.Error)
		}
	}
	if self.SlackChannel != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.SlackChannel)
		if !val.Valid {
			return fmt.Errorf("SubDomain.slackChannel does not contain a valid String (%v)", val.Error)
		}
	}
	if self.Name == "" {
		return fmt.Errorf("SubDomain.name is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "SimpleName", self.Name)
		if !val.Valid {
			return fmt.Errorf("SubDomain.name does not contain a valid SimpleName (%v)", val.Error)
		}
	}
	if self.AdminUsers == nil {
		return fmt.Errorf("SubDomain: Missing required field: adminUsers")
	}
	if self.Parent == "" {
		return fmt.Errorf("SubDomain.parent is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "DomainName", self.Parent)
		if !val.Valid {
			return fmt.Errorf("SubDomain.parent does not contain a valid DomainName (%v)", val.Error)
		}
	}
	return nil
}

// UserDomain - A UserDomain is the user's own top level domain in user - e.g.
// user.hga
type UserDomain struct {

	//
	// a description of the domain
	//
	Description string `json:"description" rdl:"optional" yaml:",omitempty"`

	//
	// a reference to an audit organization defined in athenz
	//
	Org ResourceName `json:"org,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// Future use only, currently not used
	//
	Enabled *bool `json:"enabled,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// Flag indicates whether or not domain modifications should be logged for
	// SOX+Auditing. If true, the auditRef parameter must be supplied(not empty) for
	// any API defining it.
	//
	AuditEnabled *bool `json:"auditEnabled,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// associated aws account id (system attribute - uniqueness check - if
	// enabled)
	//
	Account string `json:"account" rdl:"optional" yaml:",omitempty"`

	//
	// associated product id (system attribute - uniqueness check - if enabled)
	//
	YpmId *int32 `json:"ypmId,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// associated application id
	//
	ApplicationId string `json:"applicationId" rdl:"optional" yaml:",omitempty"`

	//
	// domain certificate dns domain (system attribute)
	//
	CertDnsDomain string `json:"certDnsDomain" rdl:"optional" yaml:",omitempty"`

	//
	// all user members in the domain will have specified max expiry days
	//
	MemberExpiryDays *int32 `json:"memberExpiryDays,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// tokens issued for this domain will have specified max timeout in mins
	//
	TokenExpiryMins *int32 `json:"tokenExpiryMins,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// service identity certs issued for this domain will have specified max
	// timeout in mins
	//
	ServiceCertExpiryMins *int32 `json:"serviceCertExpiryMins,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// role certs issued for this domain will have specified max timeout in mins
	//
	RoleCertExpiryMins *int32 `json:"roleCertExpiryMins,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// rsa or ec signing algorithm to be used for tokens
	//
	SignAlgorithm string `json:"signAlgorithm" rdl:"optional" yaml:",omitempty"`

	//
	// all services in the domain roles will have specified max expiry days
	//
	ServiceExpiryDays *int32 `json:"serviceExpiryDays,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// all groups in the domain roles will have specified max expiry days
	//
	GroupExpiryDays *int32 `json:"groupExpiryDays,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// membership filtered based on user authority configured attributes
	//
	UserAuthorityFilter string `json:"userAuthorityFilter" rdl:"optional" yaml:",omitempty"`

	//
	// associated azure subscription id (system attribute - uniqueness check - if
	// enabled)
	//
	AzureSubscription string `json:"azureSubscription" rdl:"optional" yaml:",omitempty"`

	//
	// associated azure tenant id (system attribute)
	//
	AzureTenant string `json:"azureTenant" rdl:"optional" yaml:",omitempty"`

	//
	// associated azure client id (system attribute)
	//
	AzureClient string `json:"azureClient" rdl:"optional" yaml:",omitempty"`

	//
	// associated gcp project id (system attribute - uniqueness check - if
	// enabled)
	//
	GcpProject string `json:"gcpProject" rdl:"optional" yaml:",omitempty"`

	//
	// associated gcp project number (system attribute)
	//
	GcpProjectNumber string `json:"gcpProjectNumber" rdl:"optional" yaml:",omitempty"`

	//
	// key-value pair tags, tag might contain multiple values
	//
	Tags map[TagKey]*TagValueList `json:"tags,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// associated business service with domain
	//
	BusinessService string `json:"businessService" rdl:"optional" yaml:",omitempty"`

	//
	// purge role/group members with expiry date configured days in the past
	//
	MemberPurgeExpiryDays *int32 `json:"memberPurgeExpiryDays,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// associated product id (system attribute - uniqueness check - if enabled)
	//
	ProductId string `json:"productId" rdl:"optional" yaml:",omitempty"`

	//
	// features enabled per domain (system attribute)
	//
	FeatureFlags *int32 `json:"featureFlags,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// list of domain contacts (PE-Owner, Product-Owner, etc), each type can have
	// a single value
	//
	Contacts map[SimpleName]string `json:"contacts,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// domain environment e.g. production, staging, etc
	//
	Environment string `json:"environment" rdl:"optional" yaml:",omitempty"`

	//
	// ownership information for the domain (read-only attribute)
	//
	ResourceOwnership *ResourceDomainOwnership `json:"resourceOwnership,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// requested x509 cert signer key id (system attribute)
	//
	X509CertSignerKeyId string `json:"x509CertSignerKeyId" rdl:"optional" yaml:",omitempty"`

	//
	// requested ssh cert signer key id (system attribute)
	//
	SshCertSignerKeyId string `json:"sshCertSignerKeyId" rdl:"optional" yaml:",omitempty"`

	//
	// slack channel for any notifications in this domain
	//
	SlackChannel string `json:"slackChannel" rdl:"optional" yaml:",omitempty"`

	//
	// user id which will be the domain name
	//
	Name SimpleName `json:"name"`

	//
	// list of solution template names
	//
	Templates *DomainTemplateList `json:"templates,omitempty" rdl:"optional" yaml:",omitempty"`
}

// NewUserDomain - creates an initialized UserDomain instance, returns a pointer to it
func NewUserDomain(init ...*UserDomain) *UserDomain {
	var o *UserDomain
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(UserDomain)
	}
	return o.Init()
}

// Init - sets up the instance according to its default field values, if any
func (self *UserDomain) Init() *UserDomain {
	if self.Enabled == nil {
		d := true
		self.Enabled = &d
	}
	if self.AuditEnabled == nil {
		d := false
		self.AuditEnabled = &d
	}
	return self
}

type rawUserDomain UserDomain

// UnmarshalJSON is defined for proper JSON decoding of a UserDomain
func (self *UserDomain) UnmarshalJSON(b []byte) error {
	var m rawUserDomain
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := UserDomain(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *UserDomain) Validate() error {
	if self.Description != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.Description)
		if !val.Valid {
			return fmt.Errorf("UserDomain.description does not contain a valid String (%v)", val.Error)
		}
	}
	if self.Org != "" {
		val := rdl.Validate(ZMSSchema(), "ResourceName", self.Org)
		if !val.Valid {
			return fmt.Errorf("UserDomain.org does not contain a valid ResourceName (%v)", val.Error)
		}
	}
	if self.Account != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.Account)
		if !val.Valid {
			return fmt.Errorf("UserDomain.account does not contain a valid String (%v)", val.Error)
		}
	}
	if self.ApplicationId != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.ApplicationId)
		if !val.Valid {
			return fmt.Errorf("UserDomain.applicationId does not contain a valid String (%v)", val.Error)
		}
	}
	if self.CertDnsDomain != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.CertDnsDomain)
		if !val.Valid {
			return fmt.Errorf("UserDomain.certDnsDomain does not contain a valid String (%v)", val.Error)
		}
	}
	if self.SignAlgorithm != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.SignAlgorithm)
		if !val.Valid {
			return fmt.Errorf("UserDomain.signAlgorithm does not contain a valid String (%v)", val.Error)
		}
	}
	if self.UserAuthorityFilter != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.UserAuthorityFilter)
		if !val.Valid {
			return fmt.Errorf("UserDomain.userAuthorityFilter does not contain a valid String (%v)", val.Error)
		}
	}
	if self.AzureSubscription != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.AzureSubscription)
		if !val.Valid {
			return fmt.Errorf("UserDomain.azureSubscription does not contain a valid String (%v)", val.Error)
		}
	}
	if self.AzureTenant != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.AzureTenant)
		if !val.Valid {
			return fmt.Errorf("UserDomain.azureTenant does not contain a valid String (%v)", val.Error)
		}
	}
	if self.AzureClient != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.AzureClient)
		if !val.Valid {
			return fmt.Errorf("UserDomain.azureClient does not contain a valid String (%v)", val.Error)
		}
	}
	if self.GcpProject != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.GcpProject)
		if !val.Valid {
			return fmt.Errorf("UserDomain.gcpProject does not contain a valid String (%v)", val.Error)
		}
	}
	if self.GcpProjectNumber != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.GcpProjectNumber)
		if !val.Valid {
			return fmt.Errorf("UserDomain.gcpProjectNumber does not contain a valid String (%v)", val.Error)
		}
	}
	if self.BusinessService != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.BusinessService)
		if !val.Valid {
			return fmt.Errorf("UserDomain.businessService does not contain a valid String (%v)", val.Error)
		}
	}
	if self.ProductId != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.ProductId)
		if !val.Valid {
			return fmt.Errorf("UserDomain.productId does not contain a valid String (%v)", val.Error)
		}
	}
	if self.Environment != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.Environment)
		if !val.Valid {
			return fmt.Errorf("UserDomain.environment does not contain a valid String (%v)", val.Error)
		}
	}
	if self.X509CertSignerKeyId != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.X509CertSignerKeyId)
		if !val.Valid {
			return fmt.Errorf("UserDomain.x509CertSignerKeyId does not contain a valid String (%v)", val.Error)
		}
	}
	if self.SshCertSignerKeyId != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.SshCertSignerKeyId)
		if !val.Valid {
			return fmt.Errorf("UserDomain.sshCertSignerKeyId does not contain a valid String (%v)", val.Error)
		}
	}
	if self.SlackChannel != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.SlackChannel)
		if !val.Valid {
			return fmt.Errorf("UserDomain.slackChannel does not contain a valid String (%v)", val.Error)
		}
	}
	if self.Name == "" {
		return fmt.Errorf("UserDomain.name is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "SimpleName", self.Name)
		if !val.Valid {
			return fmt.Errorf("UserDomain.name does not contain a valid SimpleName (%v)", val.Error)
		}
	}
	return nil
}

// DomainMetaStoreValidValuesList - List of valid domain meta attribute values
type DomainMetaStoreValidValuesList struct {

	//
	// list of valid values for attribute
	//
	ValidValues []string `json:"validValues"`
}

// NewDomainMetaStoreValidValuesList - creates an initialized DomainMetaStoreValidValuesList instance, returns a pointer to it
func NewDomainMetaStoreValidValuesList(init ...*DomainMetaStoreValidValuesList) *DomainMetaStoreValidValuesList {
	var o *DomainMetaStoreValidValuesList
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(DomainMetaStoreValidValuesList)
	}
	return o.Init()
}

// Init - sets up the instance according to its default field values, if any
func (self *DomainMetaStoreValidValuesList) Init() *DomainMetaStoreValidValuesList {
	if self.ValidValues == nil {
		self.ValidValues = make([]string, 0)
	}
	return self
}

type rawDomainMetaStoreValidValuesList DomainMetaStoreValidValuesList

// UnmarshalJSON is defined for proper JSON decoding of a DomainMetaStoreValidValuesList
func (self *DomainMetaStoreValidValuesList) UnmarshalJSON(b []byte) error {
	var m rawDomainMetaStoreValidValuesList
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := DomainMetaStoreValidValuesList(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *DomainMetaStoreValidValuesList) Validate() error {
	if self.ValidValues == nil {
		return fmt.Errorf("DomainMetaStoreValidValuesList: Missing required field: validValues")
	}
	return nil
}

// AuthHistory -
type AuthHistory struct {

	//
	// Name of the domain from URI
	//
	UriDomain DomainName `json:"uriDomain"`

	//
	// Principal domain
	//
	PrincipalDomain DomainName `json:"principalDomain"`

	//
	// Principal name
	//
	PrincipalName SimpleName `json:"principalName"`

	//
	// Last authorization event timestamp
	//
	Timestamp rdl.Timestamp `json:"timestamp"`

	//
	// Last authorization endpoint used
	//
	Endpoint string `json:"endpoint"`

	//
	// Time until the record will expire
	//
	Ttl int64 `json:"ttl"`
}

// NewAuthHistory - creates an initialized AuthHistory instance, returns a pointer to it
func NewAuthHistory(init ...*AuthHistory) *AuthHistory {
	var o *AuthHistory
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(AuthHistory)
	}
	return o
}

type rawAuthHistory AuthHistory

// UnmarshalJSON is defined for proper JSON decoding of a AuthHistory
func (self *AuthHistory) UnmarshalJSON(b []byte) error {
	var m rawAuthHistory
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := AuthHistory(m)
		*self = o
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *AuthHistory) Validate() error {
	if self.UriDomain == "" {
		return fmt.Errorf("AuthHistory.uriDomain is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "DomainName", self.UriDomain)
		if !val.Valid {
			return fmt.Errorf("AuthHistory.uriDomain does not contain a valid DomainName (%v)", val.Error)
		}
	}
	if self.PrincipalDomain == "" {
		return fmt.Errorf("AuthHistory.principalDomain is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "DomainName", self.PrincipalDomain)
		if !val.Valid {
			return fmt.Errorf("AuthHistory.principalDomain does not contain a valid DomainName (%v)", val.Error)
		}
	}
	if self.PrincipalName == "" {
		return fmt.Errorf("AuthHistory.principalName is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "SimpleName", self.PrincipalName)
		if !val.Valid {
			return fmt.Errorf("AuthHistory.principalName does not contain a valid SimpleName (%v)", val.Error)
		}
	}
	if self.Timestamp.IsZero() {
		return fmt.Errorf("AuthHistory: Missing required field: timestamp")
	}
	if self.Endpoint == "" {
		return fmt.Errorf("AuthHistory.endpoint is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "String", self.Endpoint)
		if !val.Valid {
			return fmt.Errorf("AuthHistory.endpoint does not contain a valid String (%v)", val.Error)
		}
	}
	return nil
}

// AuthHistoryDependencies -
type AuthHistoryDependencies struct {

	//
	// list of incoming auth dependencies for domain
	//
	IncomingDependencies []*AuthHistory `json:"incomingDependencies"`

	//
	// list of incoming auth dependencies for domain
	//
	OutgoingDependencies []*AuthHistory `json:"outgoingDependencies"`
}

// NewAuthHistoryDependencies - creates an initialized AuthHistoryDependencies instance, returns a pointer to it
func NewAuthHistoryDependencies(init ...*AuthHistoryDependencies) *AuthHistoryDependencies {
	var o *AuthHistoryDependencies
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(AuthHistoryDependencies)
	}
	return o.Init()
}

// Init - sets up the instance according to its default field values, if any
func (self *AuthHistoryDependencies) Init() *AuthHistoryDependencies {
	if self.IncomingDependencies == nil {
		self.IncomingDependencies = make([]*AuthHistory, 0)
	}
	if self.OutgoingDependencies == nil {
		self.OutgoingDependencies = make([]*AuthHistory, 0)
	}
	return self
}

type rawAuthHistoryDependencies AuthHistoryDependencies

// UnmarshalJSON is defined for proper JSON decoding of a AuthHistoryDependencies
func (self *AuthHistoryDependencies) UnmarshalJSON(b []byte) error {
	var m rawAuthHistoryDependencies
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := AuthHistoryDependencies(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *AuthHistoryDependencies) Validate() error {
	if self.IncomingDependencies == nil {
		return fmt.Errorf("AuthHistoryDependencies: Missing required field: incomingDependencies")
	}
	if self.OutgoingDependencies == nil {
		return fmt.Errorf("AuthHistoryDependencies: Missing required field: outgoingDependencies")
	}
	return nil
}

// ExpiryMember -
type ExpiryMember struct {

	//
	// name of the domain
	//
	DomainName DomainName `json:"domainName"`

	//
	// name of the collection
	//
	CollectionName EntityName `json:"collectionName"`

	//
	// name of the principal
	//
	PrincipalName ResourceName `json:"principalName"`

	//
	// the expiration timestamp
	//
	Expiration rdl.Timestamp `json:"expiration"`
}

// NewExpiryMember - creates an initialized ExpiryMember instance, returns a pointer to it
func NewExpiryMember(init ...*ExpiryMember) *ExpiryMember {
	var o *ExpiryMember
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(ExpiryMember)
	}
	return o
}

type rawExpiryMember ExpiryMember

// UnmarshalJSON is defined for proper JSON decoding of a ExpiryMember
func (self *ExpiryMember) UnmarshalJSON(b []byte) error {
	var m rawExpiryMember
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := ExpiryMember(m)
		*self = o
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *ExpiryMember) Validate() error {
	if self.DomainName == "" {
		return fmt.Errorf("ExpiryMember.domainName is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "DomainName", self.DomainName)
		if !val.Valid {
			return fmt.Errorf("ExpiryMember.domainName does not contain a valid DomainName (%v)", val.Error)
		}
	}
	if self.CollectionName == "" {
		return fmt.Errorf("ExpiryMember.collectionName is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "EntityName", self.CollectionName)
		if !val.Valid {
			return fmt.Errorf("ExpiryMember.collectionName does not contain a valid EntityName (%v)", val.Error)
		}
	}
	if self.PrincipalName == "" {
		return fmt.Errorf("ExpiryMember.principalName is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "ResourceName", self.PrincipalName)
		if !val.Valid {
			return fmt.Errorf("ExpiryMember.principalName does not contain a valid ResourceName (%v)", val.Error)
		}
	}
	if self.Expiration.IsZero() {
		return fmt.Errorf("ExpiryMember: Missing required field: expiration")
	}
	return nil
}

// ExpiredMembers -
type ExpiredMembers struct {

	//
	// list of deleted expired role members
	//
	ExpiredRoleMembers []*ExpiryMember `json:"expiredRoleMembers"`

	//
	// list of deleted expired groups members
	//
	ExpiredGroupMembers []*ExpiryMember `json:"expiredGroupMembers"`
}

// NewExpiredMembers - creates an initialized ExpiredMembers instance, returns a pointer to it
func NewExpiredMembers(init ...*ExpiredMembers) *ExpiredMembers {
	var o *ExpiredMembers
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(ExpiredMembers)
	}
	return o.Init()
}

// Init - sets up the instance according to its default field values, if any
func (self *ExpiredMembers) Init() *ExpiredMembers {
	if self.ExpiredRoleMembers == nil {
		self.ExpiredRoleMembers = make([]*ExpiryMember, 0)
	}
	if self.ExpiredGroupMembers == nil {
		self.ExpiredGroupMembers = make([]*ExpiryMember, 0)
	}
	return self
}

type rawExpiredMembers ExpiredMembers

// UnmarshalJSON is defined for proper JSON decoding of a ExpiredMembers
func (self *ExpiredMembers) UnmarshalJSON(b []byte) error {
	var m rawExpiredMembers
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := ExpiredMembers(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *ExpiredMembers) Validate() error {
	if self.ExpiredRoleMembers == nil {
		return fmt.Errorf("ExpiredMembers: Missing required field: expiredRoleMembers")
	}
	if self.ExpiredGroupMembers == nil {
		return fmt.Errorf("ExpiredMembers: Missing required field: expiredGroupMembers")
	}
	return nil
}

// DanglingPolicy - A dangling policy where the assertion is referencing a role
// name that doesn't exist in the domain
type DanglingPolicy struct {
	PolicyName EntityName `json:"policyName"`
	RoleName   EntityName `json:"roleName"`
}

// NewDanglingPolicy - creates an initialized DanglingPolicy instance, returns a pointer to it
func NewDanglingPolicy(init ...*DanglingPolicy) *DanglingPolicy {
	var o *DanglingPolicy
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(DanglingPolicy)
	}
	return o
}

type rawDanglingPolicy DanglingPolicy

// UnmarshalJSON is defined for proper JSON decoding of a DanglingPolicy
func (self *DanglingPolicy) UnmarshalJSON(b []byte) error {
	var m rawDanglingPolicy
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := DanglingPolicy(m)
		*self = o
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *DanglingPolicy) Validate() error {
	if self.PolicyName == "" {
		return fmt.Errorf("DanglingPolicy.policyName is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "EntityName", self.PolicyName)
		if !val.Valid {
			return fmt.Errorf("DanglingPolicy.policyName does not contain a valid EntityName (%v)", val.Error)
		}
	}
	if self.RoleName == "" {
		return fmt.Errorf("DanglingPolicy.roleName is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "EntityName", self.RoleName)
		if !val.Valid {
			return fmt.Errorf("DanglingPolicy.roleName does not contain a valid EntityName (%v)", val.Error)
		}
	}
	return nil
}

// DomainDataCheck - Domain data object representing the results of a check
// operation looking for dangling roles, policies and trust relationships that
// are set either on tenant or provider side only
type DomainDataCheck struct {

	//
	// Names of roles not specified in any assertion. Might be empty or null if no
	// dangling roles.
	//
	DanglingRoles []EntityName `json:"danglingRoles,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// Policy+role tuples where role doesnt exist. Might be empty or null if no
	// dangling policies.
	//
	DanglingPolicies []*DanglingPolicy `json:"danglingPolicies,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// total number of policies
	//
	PolicyCount int32 `json:"policyCount"`

	//
	// total number of assertions
	//
	AssertionCount int32 `json:"assertionCount"`

	//
	// total number of assertions containing roles as wildcards
	//
	RoleWildCardCount int32 `json:"roleWildCardCount"`

	//
	// Service names (domain.service) that dont contain trust role if this is a
	// tenant domain. Might be empty or null, if not a tenant or if all providers
	// support this tenant.
	//
	ProvidersWithoutTrust []ServiceName `json:"providersWithoutTrust,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// Names of Tenant domains that dont contain assume role assertions if this is
	// a provider domain. Might be empty or null, if not a provider or if all
	// tenants support use this provider.
	//
	TenantsWithoutAssumeRole []DomainName `json:"tenantsWithoutAssumeRole,omitempty" rdl:"optional" yaml:",omitempty"`
}

// NewDomainDataCheck - creates an initialized DomainDataCheck instance, returns a pointer to it
func NewDomainDataCheck(init ...*DomainDataCheck) *DomainDataCheck {
	var o *DomainDataCheck
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(DomainDataCheck)
	}
	return o
}

type rawDomainDataCheck DomainDataCheck

// UnmarshalJSON is defined for proper JSON decoding of a DomainDataCheck
func (self *DomainDataCheck) UnmarshalJSON(b []byte) error {
	var m rawDomainDataCheck
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := DomainDataCheck(m)
		*self = o
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *DomainDataCheck) Validate() error {
	return nil
}

// Entity - An entity is a name and a structured value. some entity
// names/prefixes are reserved (i.e. "role",  "policy", "meta", "domain",
// "service")
type Entity struct {

	//
	// name of the entity object
	//
	Name ResourceName `json:"name"`

	//
	// value of the entity
	//
	Value rdl.Struct `json:"value"`
}

// NewEntity - creates an initialized Entity instance, returns a pointer to it
func NewEntity(init ...*Entity) *Entity {
	var o *Entity
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(Entity)
	}
	return o.Init()
}

// Init - sets up the instance according to its default field values, if any
func (self *Entity) Init() *Entity {
	if self.Value == nil {
		self.Value = make(rdl.Struct)
	}
	return self
}

type rawEntity Entity

// UnmarshalJSON is defined for proper JSON decoding of a Entity
func (self *Entity) UnmarshalJSON(b []byte) error {
	var m rawEntity
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := Entity(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *Entity) Validate() error {
	if self.Name == "" {
		return fmt.Errorf("Entity.name is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "ResourceName", self.Name)
		if !val.Valid {
			return fmt.Errorf("Entity.name does not contain a valid ResourceName (%v)", val.Error)
		}
	}
	if self.Value == nil {
		return fmt.Errorf("Entity: Missing required field: value")
	}
	return nil
}

// EntityList - The representation for an enumeration of entities in the
// namespace
type EntityList struct {

	//
	// list of entity names
	//
	Names []EntityName `json:"names"`
}

// NewEntityList - creates an initialized EntityList instance, returns a pointer to it
func NewEntityList(init ...*EntityList) *EntityList {
	var o *EntityList
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(EntityList)
	}
	return o.Init()
}

// Init - sets up the instance according to its default field values, if any
func (self *EntityList) Init() *EntityList {
	if self.Names == nil {
		self.Names = make([]EntityName, 0)
	}
	return self
}

type rawEntityList EntityList

// UnmarshalJSON is defined for proper JSON decoding of a EntityList
func (self *EntityList) UnmarshalJSON(b []byte) error {
	var m rawEntityList
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := EntityList(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *EntityList) Validate() error {
	if self.Names == nil {
		return fmt.Errorf("EntityList: Missing required field: names")
	}
	return nil
}

// GroupAuditLog - An audit log entry for group membership change.
type GroupAuditLog struct {

	//
	// name of the group member
	//
	Member GroupMemberName `json:"member"`

	//
	// name of the principal executing the change
	//
	Admin ResourceName `json:"admin"`

	//
	// timestamp of the entry
	//
	Created rdl.Timestamp `json:"created"`

	//
	// log action - e.g. add, delete, approve, etc
	//
	Action string `json:"action"`

	//
	// audit reference string for the change as supplied by admin
	//
	AuditRef string `json:"auditRef" rdl:"optional" yaml:",omitempty"`
}

// NewGroupAuditLog - creates an initialized GroupAuditLog instance, returns a pointer to it
func NewGroupAuditLog(init ...*GroupAuditLog) *GroupAuditLog {
	var o *GroupAuditLog
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(GroupAuditLog)
	}
	return o
}

type rawGroupAuditLog GroupAuditLog

// UnmarshalJSON is defined for proper JSON decoding of a GroupAuditLog
func (self *GroupAuditLog) UnmarshalJSON(b []byte) error {
	var m rawGroupAuditLog
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := GroupAuditLog(m)
		*self = o
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *GroupAuditLog) Validate() error {
	if self.Member == "" {
		return fmt.Errorf("GroupAuditLog.member is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "GroupMemberName", self.Member)
		if !val.Valid {
			return fmt.Errorf("GroupAuditLog.member does not contain a valid GroupMemberName (%v)", val.Error)
		}
	}
	if self.Admin == "" {
		return fmt.Errorf("GroupAuditLog.admin is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "ResourceName", self.Admin)
		if !val.Valid {
			return fmt.Errorf("GroupAuditLog.admin does not contain a valid ResourceName (%v)", val.Error)
		}
	}
	if self.Created.IsZero() {
		return fmt.Errorf("GroupAuditLog: Missing required field: created")
	}
	if self.Action == "" {
		return fmt.Errorf("GroupAuditLog.action is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "String", self.Action)
		if !val.Valid {
			return fmt.Errorf("GroupAuditLog.action does not contain a valid String (%v)", val.Error)
		}
	}
	if self.AuditRef != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.AuditRef)
		if !val.Valid {
			return fmt.Errorf("GroupAuditLog.auditRef does not contain a valid String (%v)", val.Error)
		}
	}
	return nil
}

// GroupMember -
type GroupMember struct {

	//
	// name of the member
	//
	MemberName GroupMemberName `json:"memberName,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// name of the group
	//
	GroupName ResourceName `json:"groupName,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// name of the domain
	//
	DomainName DomainName `json:"domainName,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// the expiration timestamp
	//
	Expiration *rdl.Timestamp `json:"expiration,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// Flag to indicate whether membership is active
	//
	Active *bool `json:"active,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// Flag to indicate whether membership is approved either by delegates ( in
	// case of auditEnabled groups ) or by domain admins ( in case of selfserve
	// groups )
	//
	Approved *bool `json:"approved,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// audit reference string for the change as supplied by admin
	//
	AuditRef string `json:"auditRef" rdl:"optional" yaml:",omitempty"`

	//
	// for pending membership requests, the request time
	//
	RequestTime *rdl.Timestamp `json:"requestTime,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// for pending membership requests, time when last notification was sent
	//
	LastNotifiedTime *rdl.Timestamp `json:"lastNotifiedTime,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// pending members only - name of the principal requesting the change
	//
	RequestPrincipal ResourceName `json:"requestPrincipal,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// for pending membership requests, time when last notification was sent (for
	// file store)
	//
	ReviewLastNotifiedTime *rdl.Timestamp `json:"reviewLastNotifiedTime,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// user disabled by system based on configured group setting
	//
	SystemDisabled *int32 `json:"systemDisabled,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// server use only - principal type: unknown(0), user(1) or service(2)
	//
	PrincipalType *int32 `json:"principalType,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// for pending membership requests, the request state - e.g. add, delete
	//
	PendingState string `json:"pendingState" rdl:"optional" yaml:",omitempty"`

	//
	// list of roles whose members should be notified for member
	// review/approval/expiry
	//
	NotifyRoles string `json:"notifyRoles" rdl:"optional" yaml:",omitempty"`

	//
	// additional details included in the notifications
	//
	NotifyDetails string `json:"notifyDetails" rdl:"optional" yaml:",omitempty"`
}

// NewGroupMember - creates an initialized GroupMember instance, returns a pointer to it
func NewGroupMember(init ...*GroupMember) *GroupMember {
	var o *GroupMember
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(GroupMember)
	}
	return o.Init()
}

// Init - sets up the instance according to its default field values, if any
func (self *GroupMember) Init() *GroupMember {
	if self.Active == nil {
		d := true
		self.Active = &d
	}
	if self.Approved == nil {
		d := true
		self.Approved = &d
	}
	return self
}

type rawGroupMember GroupMember

// UnmarshalJSON is defined for proper JSON decoding of a GroupMember
func (self *GroupMember) UnmarshalJSON(b []byte) error {
	var m rawGroupMember
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := GroupMember(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *GroupMember) Validate() error {
	if self.MemberName != "" {
		val := rdl.Validate(ZMSSchema(), "GroupMemberName", self.MemberName)
		if !val.Valid {
			return fmt.Errorf("GroupMember.memberName does not contain a valid GroupMemberName (%v)", val.Error)
		}
	}
	if self.GroupName != "" {
		val := rdl.Validate(ZMSSchema(), "ResourceName", self.GroupName)
		if !val.Valid {
			return fmt.Errorf("GroupMember.groupName does not contain a valid ResourceName (%v)", val.Error)
		}
	}
	if self.DomainName != "" {
		val := rdl.Validate(ZMSSchema(), "DomainName", self.DomainName)
		if !val.Valid {
			return fmt.Errorf("GroupMember.domainName does not contain a valid DomainName (%v)", val.Error)
		}
	}
	if self.AuditRef != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.AuditRef)
		if !val.Valid {
			return fmt.Errorf("GroupMember.auditRef does not contain a valid String (%v)", val.Error)
		}
	}
	if self.RequestPrincipal != "" {
		val := rdl.Validate(ZMSSchema(), "ResourceName", self.RequestPrincipal)
		if !val.Valid {
			return fmt.Errorf("GroupMember.requestPrincipal does not contain a valid ResourceName (%v)", val.Error)
		}
	}
	if self.PendingState != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.PendingState)
		if !val.Valid {
			return fmt.Errorf("GroupMember.pendingState does not contain a valid String (%v)", val.Error)
		}
	}
	if self.NotifyRoles != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.NotifyRoles)
		if !val.Valid {
			return fmt.Errorf("GroupMember.notifyRoles does not contain a valid String (%v)", val.Error)
		}
	}
	if self.NotifyDetails != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.NotifyDetails)
		if !val.Valid {
			return fmt.Errorf("GroupMember.notifyDetails does not contain a valid String (%v)", val.Error)
		}
	}
	return nil
}

// GroupMembership - The representation for a group membership.
type GroupMembership struct {

	//
	// name of the member
	//
	MemberName GroupMemberName `json:"memberName"`

	//
	// flag to indicate whether or the user is a member or not
	//
	IsMember *bool `json:"isMember,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// name of the group
	//
	GroupName ResourceName `json:"groupName,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// the expiration timestamp
	//
	Expiration *rdl.Timestamp `json:"expiration,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// Flag to indicate whether membership is active
	//
	Active *bool `json:"active,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// Flag to indicate whether membership is approved either by delegates ( in
	// case of auditEnabled groups ) or by domain admins ( in case of selfserve
	// groups )
	//
	Approved *bool `json:"approved,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// audit reference string for the change as supplied by admin
	//
	AuditRef string `json:"auditRef" rdl:"optional" yaml:",omitempty"`

	//
	// pending members only - name of the principal requesting the change
	//
	RequestPrincipal ResourceName `json:"requestPrincipal,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// user disabled by system based on configured group setting
	//
	SystemDisabled *int32 `json:"systemDisabled,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// for pending membership requests, the request state - e.g. add, delete
	//
	PendingState string `json:"pendingState" rdl:"optional" yaml:",omitempty"`
}

// NewGroupMembership - creates an initialized GroupMembership instance, returns a pointer to it
func NewGroupMembership(init ...*GroupMembership) *GroupMembership {
	var o *GroupMembership
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(GroupMembership)
	}
	return o.Init()
}

// Init - sets up the instance according to its default field values, if any
func (self *GroupMembership) Init() *GroupMembership {
	if self.IsMember == nil {
		d := true
		self.IsMember = &d
	}
	if self.Active == nil {
		d := true
		self.Active = &d
	}
	if self.Approved == nil {
		d := true
		self.Approved = &d
	}
	return self
}

type rawGroupMembership GroupMembership

// UnmarshalJSON is defined for proper JSON decoding of a GroupMembership
func (self *GroupMembership) UnmarshalJSON(b []byte) error {
	var m rawGroupMembership
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := GroupMembership(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *GroupMembership) Validate() error {
	if self.MemberName == "" {
		return fmt.Errorf("GroupMembership.memberName is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "GroupMemberName", self.MemberName)
		if !val.Valid {
			return fmt.Errorf("GroupMembership.memberName does not contain a valid GroupMemberName (%v)", val.Error)
		}
	}
	if self.GroupName != "" {
		val := rdl.Validate(ZMSSchema(), "ResourceName", self.GroupName)
		if !val.Valid {
			return fmt.Errorf("GroupMembership.groupName does not contain a valid ResourceName (%v)", val.Error)
		}
	}
	if self.AuditRef != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.AuditRef)
		if !val.Valid {
			return fmt.Errorf("GroupMembership.auditRef does not contain a valid String (%v)", val.Error)
		}
	}
	if self.RequestPrincipal != "" {
		val := rdl.Validate(ZMSSchema(), "ResourceName", self.RequestPrincipal)
		if !val.Valid {
			return fmt.Errorf("GroupMembership.requestPrincipal does not contain a valid ResourceName (%v)", val.Error)
		}
	}
	if self.PendingState != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.PendingState)
		if !val.Valid {
			return fmt.Errorf("GroupMembership.pendingState does not contain a valid String (%v)", val.Error)
		}
	}
	return nil
}

// ResourceGroupOwnership - The representation of the group ownership object
type ResourceGroupOwnership struct {

	//
	// owner of the object's meta attribute
	//
	MetaOwner SimpleName `json:"metaOwner,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// owner of the object's members attribute
	//
	MembersOwner SimpleName `json:"membersOwner,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// owner of the object itself - checked for object deletion
	//
	ObjectOwner SimpleName `json:"objectOwner,omitempty" rdl:"optional" yaml:",omitempty"`
}

// NewResourceGroupOwnership - creates an initialized ResourceGroupOwnership instance, returns a pointer to it
func NewResourceGroupOwnership(init ...*ResourceGroupOwnership) *ResourceGroupOwnership {
	var o *ResourceGroupOwnership
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(ResourceGroupOwnership)
	}
	return o
}

type rawResourceGroupOwnership ResourceGroupOwnership

// UnmarshalJSON is defined for proper JSON decoding of a ResourceGroupOwnership
func (self *ResourceGroupOwnership) UnmarshalJSON(b []byte) error {
	var m rawResourceGroupOwnership
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := ResourceGroupOwnership(m)
		*self = o
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *ResourceGroupOwnership) Validate() error {
	if self.MetaOwner != "" {
		val := rdl.Validate(ZMSSchema(), "SimpleName", self.MetaOwner)
		if !val.Valid {
			return fmt.Errorf("ResourceGroupOwnership.metaOwner does not contain a valid SimpleName (%v)", val.Error)
		}
	}
	if self.MembersOwner != "" {
		val := rdl.Validate(ZMSSchema(), "SimpleName", self.MembersOwner)
		if !val.Valid {
			return fmt.Errorf("ResourceGroupOwnership.membersOwner does not contain a valid SimpleName (%v)", val.Error)
		}
	}
	if self.ObjectOwner != "" {
		val := rdl.Validate(ZMSSchema(), "SimpleName", self.ObjectOwner)
		if !val.Valid {
			return fmt.Errorf("ResourceGroupOwnership.objectOwner does not contain a valid SimpleName (%v)", val.Error)
		}
	}
	return nil
}

// GroupMeta - Set of metadata attributes that all groups may have and can be
// changed by domain admins.
type GroupMeta struct {

	//
	// Flag indicates whether or not group allows self service. Users can add
	// themselves in the group, but it has to be approved by domain admins to be
	// effective.
	//
	SelfServe *bool `json:"selfServe,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// Flag indicates whether or not group updates require another review and
	// approval
	//
	ReviewEnabled *bool `json:"reviewEnabled,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// list of roles whose members should be notified for member review/approval
	//
	NotifyRoles string `json:"notifyRoles" rdl:"optional" yaml:",omitempty"`

	//
	// membership filtered based on user authority configured attributes
	//
	UserAuthorityFilter string `json:"userAuthorityFilter" rdl:"optional" yaml:",omitempty"`

	//
	// expiration enforced by a user authority configured attribute
	//
	UserAuthorityExpiration string `json:"userAuthorityExpiration" rdl:"optional" yaml:",omitempty"`

	//
	// all user members in the group will have specified max expiry days
	//
	MemberExpiryDays *int32 `json:"memberExpiryDays,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// all services in the group will have specified max expiry days
	//
	ServiceExpiryDays *int32 `json:"serviceExpiryDays,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// key-value pair tags, tag might contain multiple values
	//
	Tags map[TagKey]*TagValueList `json:"tags,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// Flag indicates whether or not group updates should require GRC approval. If
	// true, the auditRef parameter must be supplied(not empty) for any API defining
	// it
	//
	AuditEnabled *bool `json:"auditEnabled,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// If true, ask for delete confirmation in audit and review enabled groups.
	//
	DeleteProtection *bool `json:"deleteProtection,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// last review timestamp of the group
	//
	LastReviewedDate *rdl.Timestamp `json:"lastReviewedDate,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// Flag indicates whether to allow expired members to renew their membership
	//
	SelfRenew *bool `json:"selfRenew,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// Number of minutes members can renew their membership if self review option
	// is enabled
	//
	SelfRenewMins *int32 `json:"selfRenewMins,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// Maximum number of members allowed in the group
	//
	MaxMembers *int32 `json:"maxMembers,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// ownership information for the group (read-only attribute)
	//
	ResourceOwnership *ResourceGroupOwnership `json:"resourceOwnership,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// membership filtered based on configured principal domains
	//
	PrincipalDomainFilter string `json:"principalDomainFilter" rdl:"optional" yaml:",omitempty"`

	//
	// additional details included in the notifications
	//
	NotifyDetails string `json:"notifyDetails" rdl:"optional" yaml:",omitempty"`
}

// NewGroupMeta - creates an initialized GroupMeta instance, returns a pointer to it
func NewGroupMeta(init ...*GroupMeta) *GroupMeta {
	var o *GroupMeta
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(GroupMeta)
	}
	return o
}

type rawGroupMeta GroupMeta

// UnmarshalJSON is defined for proper JSON decoding of a GroupMeta
func (self *GroupMeta) UnmarshalJSON(b []byte) error {
	var m rawGroupMeta
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := GroupMeta(m)
		*self = o
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *GroupMeta) Validate() error {
	if self.NotifyRoles != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.NotifyRoles)
		if !val.Valid {
			return fmt.Errorf("GroupMeta.notifyRoles does not contain a valid String (%v)", val.Error)
		}
	}
	if self.UserAuthorityFilter != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.UserAuthorityFilter)
		if !val.Valid {
			return fmt.Errorf("GroupMeta.userAuthorityFilter does not contain a valid String (%v)", val.Error)
		}
	}
	if self.UserAuthorityExpiration != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.UserAuthorityExpiration)
		if !val.Valid {
			return fmt.Errorf("GroupMeta.userAuthorityExpiration does not contain a valid String (%v)", val.Error)
		}
	}
	if self.PrincipalDomainFilter != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.PrincipalDomainFilter)
		if !val.Valid {
			return fmt.Errorf("GroupMeta.principalDomainFilter does not contain a valid String (%v)", val.Error)
		}
	}
	if self.NotifyDetails != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.NotifyDetails)
		if !val.Valid {
			return fmt.Errorf("GroupMeta.notifyDetails does not contain a valid String (%v)", val.Error)
		}
	}
	return nil
}

// Group - The representation for a Group with set of members.
type Group struct {

	//
	// Flag indicates whether or not group allows self service. Users can add
	// themselves in the group, but it has to be approved by domain admins to be
	// effective.
	//
	SelfServe *bool `json:"selfServe,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// Flag indicates whether or not group updates require another review and
	// approval
	//
	ReviewEnabled *bool `json:"reviewEnabled,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// list of roles whose members should be notified for member review/approval
	//
	NotifyRoles string `json:"notifyRoles" rdl:"optional" yaml:",omitempty"`

	//
	// membership filtered based on user authority configured attributes
	//
	UserAuthorityFilter string `json:"userAuthorityFilter" rdl:"optional" yaml:",omitempty"`

	//
	// expiration enforced by a user authority configured attribute
	//
	UserAuthorityExpiration string `json:"userAuthorityExpiration" rdl:"optional" yaml:",omitempty"`

	//
	// all user members in the group will have specified max expiry days
	//
	MemberExpiryDays *int32 `json:"memberExpiryDays,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// all services in the group will have specified max expiry days
	//
	ServiceExpiryDays *int32 `json:"serviceExpiryDays,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// key-value pair tags, tag might contain multiple values
	//
	Tags map[TagKey]*TagValueList `json:"tags,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// Flag indicates whether or not group updates should require GRC approval. If
	// true, the auditRef parameter must be supplied(not empty) for any API defining
	// it
	//
	AuditEnabled *bool `json:"auditEnabled,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// If true, ask for delete confirmation in audit and review enabled groups.
	//
	DeleteProtection *bool `json:"deleteProtection,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// last review timestamp of the group
	//
	LastReviewedDate *rdl.Timestamp `json:"lastReviewedDate,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// Flag indicates whether to allow expired members to renew their membership
	//
	SelfRenew *bool `json:"selfRenew,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// Number of minutes members can renew their membership if self review option
	// is enabled
	//
	SelfRenewMins *int32 `json:"selfRenewMins,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// Maximum number of members allowed in the group
	//
	MaxMembers *int32 `json:"maxMembers,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// ownership information for the group (read-only attribute)
	//
	ResourceOwnership *ResourceGroupOwnership `json:"resourceOwnership,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// membership filtered based on configured principal domains
	//
	PrincipalDomainFilter string `json:"principalDomainFilter" rdl:"optional" yaml:",omitempty"`

	//
	// additional details included in the notifications
	//
	NotifyDetails string `json:"notifyDetails" rdl:"optional" yaml:",omitempty"`

	//
	// name of the group
	//
	Name ResourceName `json:"name"`

	//
	// last modification timestamp of the group
	//
	Modified *rdl.Timestamp `json:"modified,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// members with expiration
	//
	GroupMembers []*GroupMember `json:"groupMembers,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// an audit log for group membership changes
	//
	AuditLog []*GroupAuditLog `json:"auditLog,omitempty" rdl:"optional" yaml:",omitempty"`
}

// NewGroup - creates an initialized Group instance, returns a pointer to it
func NewGroup(init ...*Group) *Group {
	var o *Group
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(Group)
	}
	return o
}

type rawGroup Group

// UnmarshalJSON is defined for proper JSON decoding of a Group
func (self *Group) UnmarshalJSON(b []byte) error {
	var m rawGroup
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := Group(m)
		*self = o
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *Group) Validate() error {
	if self.NotifyRoles != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.NotifyRoles)
		if !val.Valid {
			return fmt.Errorf("Group.notifyRoles does not contain a valid String (%v)", val.Error)
		}
	}
	if self.UserAuthorityFilter != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.UserAuthorityFilter)
		if !val.Valid {
			return fmt.Errorf("Group.userAuthorityFilter does not contain a valid String (%v)", val.Error)
		}
	}
	if self.UserAuthorityExpiration != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.UserAuthorityExpiration)
		if !val.Valid {
			return fmt.Errorf("Group.userAuthorityExpiration does not contain a valid String (%v)", val.Error)
		}
	}
	if self.PrincipalDomainFilter != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.PrincipalDomainFilter)
		if !val.Valid {
			return fmt.Errorf("Group.principalDomainFilter does not contain a valid String (%v)", val.Error)
		}
	}
	if self.NotifyDetails != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.NotifyDetails)
		if !val.Valid {
			return fmt.Errorf("Group.notifyDetails does not contain a valid String (%v)", val.Error)
		}
	}
	if self.Name == "" {
		return fmt.Errorf("Group.name is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "ResourceName", self.Name)
		if !val.Valid {
			return fmt.Errorf("Group.name does not contain a valid ResourceName (%v)", val.Error)
		}
	}
	return nil
}

// Groups - The representation for a list of groups with full details
type Groups struct {

	//
	// list of group objects
	//
	List []*Group `json:"list"`
}

// NewGroups - creates an initialized Groups instance, returns a pointer to it
func NewGroups(init ...*Groups) *Groups {
	var o *Groups
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(Groups)
	}
	return o.Init()
}

// Init - sets up the instance according to its default field values, if any
func (self *Groups) Init() *Groups {
	if self.List == nil {
		self.List = make([]*Group, 0)
	}
	return self
}

type rawGroups Groups

// UnmarshalJSON is defined for proper JSON decoding of a Groups
func (self *Groups) UnmarshalJSON(b []byte) error {
	var m rawGroups
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := Groups(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *Groups) Validate() error {
	if self.List == nil {
		return fmt.Errorf("Groups: Missing required field: list")
	}
	return nil
}

// DomainGroupMember -
type DomainGroupMember struct {

	//
	// name of the member
	//
	MemberName GroupMemberName `json:"memberName"`

	//
	// groups for this member
	//
	MemberGroups []*GroupMember `json:"memberGroups"`
}

// NewDomainGroupMember - creates an initialized DomainGroupMember instance, returns a pointer to it
func NewDomainGroupMember(init ...*DomainGroupMember) *DomainGroupMember {
	var o *DomainGroupMember
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(DomainGroupMember)
	}
	return o.Init()
}

// Init - sets up the instance according to its default field values, if any
func (self *DomainGroupMember) Init() *DomainGroupMember {
	if self.MemberGroups == nil {
		self.MemberGroups = make([]*GroupMember, 0)
	}
	return self
}

type rawDomainGroupMember DomainGroupMember

// UnmarshalJSON is defined for proper JSON decoding of a DomainGroupMember
func (self *DomainGroupMember) UnmarshalJSON(b []byte) error {
	var m rawDomainGroupMember
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := DomainGroupMember(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *DomainGroupMember) Validate() error {
	if self.MemberName == "" {
		return fmt.Errorf("DomainGroupMember.memberName is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "GroupMemberName", self.MemberName)
		if !val.Valid {
			return fmt.Errorf("DomainGroupMember.memberName does not contain a valid GroupMemberName (%v)", val.Error)
		}
	}
	if self.MemberGroups == nil {
		return fmt.Errorf("DomainGroupMember: Missing required field: memberGroups")
	}
	return nil
}

// DomainGroupMembers -
type DomainGroupMembers struct {

	//
	// name of the domain
	//
	DomainName DomainName `json:"domainName"`

	//
	// group members
	//
	Members []*DomainGroupMember `json:"members"`
}

// NewDomainGroupMembers - creates an initialized DomainGroupMembers instance, returns a pointer to it
func NewDomainGroupMembers(init ...*DomainGroupMembers) *DomainGroupMembers {
	var o *DomainGroupMembers
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(DomainGroupMembers)
	}
	return o.Init()
}

// Init - sets up the instance according to its default field values, if any
func (self *DomainGroupMembers) Init() *DomainGroupMembers {
	if self.Members == nil {
		self.Members = make([]*DomainGroupMember, 0)
	}
	return self
}

type rawDomainGroupMembers DomainGroupMembers

// UnmarshalJSON is defined for proper JSON decoding of a DomainGroupMembers
func (self *DomainGroupMembers) UnmarshalJSON(b []byte) error {
	var m rawDomainGroupMembers
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := DomainGroupMembers(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *DomainGroupMembers) Validate() error {
	if self.DomainName == "" {
		return fmt.Errorf("DomainGroupMembers.domainName is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "DomainName", self.DomainName)
		if !val.Valid {
			return fmt.Errorf("DomainGroupMembers.domainName does not contain a valid DomainName (%v)", val.Error)
		}
	}
	if self.Members == nil {
		return fmt.Errorf("DomainGroupMembers: Missing required field: members")
	}
	return nil
}

// DomainGroupMembership -
type DomainGroupMembership struct {
	DomainGroupMembersList []*DomainGroupMembers `json:"domainGroupMembersList"`
}

// NewDomainGroupMembership - creates an initialized DomainGroupMembership instance, returns a pointer to it
func NewDomainGroupMembership(init ...*DomainGroupMembership) *DomainGroupMembership {
	var o *DomainGroupMembership
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(DomainGroupMembership)
	}
	return o.Init()
}

// Init - sets up the instance according to its default field values, if any
func (self *DomainGroupMembership) Init() *DomainGroupMembership {
	if self.DomainGroupMembersList == nil {
		self.DomainGroupMembersList = make([]*DomainGroupMembers, 0)
	}
	return self
}

type rawDomainGroupMembership DomainGroupMembership

// UnmarshalJSON is defined for proper JSON decoding of a DomainGroupMembership
func (self *DomainGroupMembership) UnmarshalJSON(b []byte) error {
	var m rawDomainGroupMembership
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := DomainGroupMembership(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *DomainGroupMembership) Validate() error {
	if self.DomainGroupMembersList == nil {
		return fmt.Errorf("DomainGroupMembership: Missing required field: domainGroupMembersList")
	}
	return nil
}

// GroupSystemMeta - Set of system metadata attributes that all groups may have
// and can be changed by system admins.
type GroupSystemMeta struct {

	//
	// Flag indicates whether or not group updates should be approved by GRC. If
	// true, the auditRef parameter must be supplied(not empty) for any API defining
	// it.
	//
	AuditEnabled *bool `json:"auditEnabled,omitempty" rdl:"optional" yaml:",omitempty"`
}

// NewGroupSystemMeta - creates an initialized GroupSystemMeta instance, returns a pointer to it
func NewGroupSystemMeta(init ...*GroupSystemMeta) *GroupSystemMeta {
	var o *GroupSystemMeta
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(GroupSystemMeta)
	}
	return o
}

type rawGroupSystemMeta GroupSystemMeta

// UnmarshalJSON is defined for proper JSON decoding of a GroupSystemMeta
func (self *GroupSystemMeta) UnmarshalJSON(b []byte) error {
	var m rawGroupSystemMeta
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := GroupSystemMeta(m)
		*self = o
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *GroupSystemMeta) Validate() error {
	return nil
}

// PolicyList - The representation for an enumeration of policies in the
// namespace, with pagination.
type PolicyList struct {

	//
	// list of policy names
	//
	Names []EntityName `json:"names"`

	//
	// if the response is a paginated list, this attribute specifies the value to
	// be used in the next policy list request as the value for the skip query
	// parameter.
	//
	Next string `json:"next" rdl:"optional" yaml:",omitempty"`
}

// NewPolicyList - creates an initialized PolicyList instance, returns a pointer to it
func NewPolicyList(init ...*PolicyList) *PolicyList {
	var o *PolicyList
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(PolicyList)
	}
	return o.Init()
}

// Init - sets up the instance according to its default field values, if any
func (self *PolicyList) Init() *PolicyList {
	if self.Names == nil {
		self.Names = make([]EntityName, 0)
	}
	return self
}

type rawPolicyList PolicyList

// UnmarshalJSON is defined for proper JSON decoding of a PolicyList
func (self *PolicyList) UnmarshalJSON(b []byte) error {
	var m rawPolicyList
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := PolicyList(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *PolicyList) Validate() error {
	if self.Names == nil {
		return fmt.Errorf("PolicyList: Missing required field: names")
	}
	if self.Next != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.Next)
		if !val.Valid {
			return fmt.Errorf("PolicyList.next does not contain a valid String (%v)", val.Error)
		}
	}
	return nil
}

// Tenancy - A representation of tenant.
type Tenancy struct {

	//
	// the domain that is to get a tenancy
	//
	Domain DomainName `json:"domain"`

	//
	// the provider service on which the tenancy is to reside
	//
	Service ServiceName `json:"service"`

	//
	// registered resource groups for this tenant
	//
	ResourceGroups []EntityName `json:"resourceGroups,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// optional flag indicating whether to create a default tenancy admin role
	//
	CreateAdminRole *bool `json:"createAdminRole,omitempty" rdl:"optional" yaml:",omitempty"`
}

// NewTenancy - creates an initialized Tenancy instance, returns a pointer to it
func NewTenancy(init ...*Tenancy) *Tenancy {
	var o *Tenancy
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(Tenancy)
	}
	return o.Init()
}

// Init - sets up the instance according to its default field values, if any
func (self *Tenancy) Init() *Tenancy {
	if self.CreateAdminRole == nil {
		d := true
		self.CreateAdminRole = &d
	}
	return self
}

type rawTenancy Tenancy

// UnmarshalJSON is defined for proper JSON decoding of a Tenancy
func (self *Tenancy) UnmarshalJSON(b []byte) error {
	var m rawTenancy
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := Tenancy(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *Tenancy) Validate() error {
	if self.Domain == "" {
		return fmt.Errorf("Tenancy.domain is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "DomainName", self.Domain)
		if !val.Valid {
			return fmt.Errorf("Tenancy.domain does not contain a valid DomainName (%v)", val.Error)
		}
	}
	if self.Service == "" {
		return fmt.Errorf("Tenancy.service is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "ServiceName", self.Service)
		if !val.Valid {
			return fmt.Errorf("Tenancy.service does not contain a valid ServiceName (%v)", val.Error)
		}
	}
	return nil
}

// TenantRoleAction - A representation of tenant role action.
type TenantRoleAction struct {

	//
	// name of the role
	//
	Role SimpleName `json:"role"`

	//
	// action value for the generated policy assertion
	//
	Action string `json:"action"`
}

// NewTenantRoleAction - creates an initialized TenantRoleAction instance, returns a pointer to it
func NewTenantRoleAction(init ...*TenantRoleAction) *TenantRoleAction {
	var o *TenantRoleAction
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(TenantRoleAction)
	}
	return o
}

type rawTenantRoleAction TenantRoleAction

// UnmarshalJSON is defined for proper JSON decoding of a TenantRoleAction
func (self *TenantRoleAction) UnmarshalJSON(b []byte) error {
	var m rawTenantRoleAction
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := TenantRoleAction(m)
		*self = o
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *TenantRoleAction) Validate() error {
	if self.Role == "" {
		return fmt.Errorf("TenantRoleAction.role is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "SimpleName", self.Role)
		if !val.Valid {
			return fmt.Errorf("TenantRoleAction.role does not contain a valid SimpleName (%v)", val.Error)
		}
	}
	if self.Action == "" {
		return fmt.Errorf("TenantRoleAction.action is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "String", self.Action)
		if !val.Valid {
			return fmt.Errorf("TenantRoleAction.action does not contain a valid String (%v)", val.Error)
		}
	}
	return nil
}

// TenantResourceGroupRoles - A representation of tenant roles for resource
// groups to be provisioned.
type TenantResourceGroupRoles struct {

	//
	// name of the provider domain
	//
	Domain DomainName `json:"domain"`

	//
	// name of the provider service
	//
	Service SimpleName `json:"service"`

	//
	// name of the tenant domain
	//
	Tenant DomainName `json:"tenant"`

	//
	// the role/action pairs to provision
	//
	Roles []*TenantRoleAction `json:"roles"`

	//
	// tenant resource group
	//
	ResourceGroup EntityName `json:"resourceGroup"`
}

// NewTenantResourceGroupRoles - creates an initialized TenantResourceGroupRoles instance, returns a pointer to it
func NewTenantResourceGroupRoles(init ...*TenantResourceGroupRoles) *TenantResourceGroupRoles {
	var o *TenantResourceGroupRoles
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(TenantResourceGroupRoles)
	}
	return o.Init()
}

// Init - sets up the instance according to its default field values, if any
func (self *TenantResourceGroupRoles) Init() *TenantResourceGroupRoles {
	if self.Roles == nil {
		self.Roles = make([]*TenantRoleAction, 0)
	}
	return self
}

type rawTenantResourceGroupRoles TenantResourceGroupRoles

// UnmarshalJSON is defined for proper JSON decoding of a TenantResourceGroupRoles
func (self *TenantResourceGroupRoles) UnmarshalJSON(b []byte) error {
	var m rawTenantResourceGroupRoles
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := TenantResourceGroupRoles(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *TenantResourceGroupRoles) Validate() error {
	if self.Domain == "" {
		return fmt.Errorf("TenantResourceGroupRoles.domain is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "DomainName", self.Domain)
		if !val.Valid {
			return fmt.Errorf("TenantResourceGroupRoles.domain does not contain a valid DomainName (%v)", val.Error)
		}
	}
	if self.Service == "" {
		return fmt.Errorf("TenantResourceGroupRoles.service is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "SimpleName", self.Service)
		if !val.Valid {
			return fmt.Errorf("TenantResourceGroupRoles.service does not contain a valid SimpleName (%v)", val.Error)
		}
	}
	if self.Tenant == "" {
		return fmt.Errorf("TenantResourceGroupRoles.tenant is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "DomainName", self.Tenant)
		if !val.Valid {
			return fmt.Errorf("TenantResourceGroupRoles.tenant does not contain a valid DomainName (%v)", val.Error)
		}
	}
	if self.Roles == nil {
		return fmt.Errorf("TenantResourceGroupRoles: Missing required field: roles")
	}
	if self.ResourceGroup == "" {
		return fmt.Errorf("TenantResourceGroupRoles.resourceGroup is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "EntityName", self.ResourceGroup)
		if !val.Valid {
			return fmt.Errorf("TenantResourceGroupRoles.resourceGroup does not contain a valid EntityName (%v)", val.Error)
		}
	}
	return nil
}

// ProviderResourceGroupRoles - A representation of provider roles to be
// provisioned.
type ProviderResourceGroupRoles struct {

	//
	// name of the provider domain
	//
	Domain DomainName `json:"domain"`

	//
	// name of the provider service
	//
	Service SimpleName `json:"service"`

	//
	// name of the tenant domain
	//
	Tenant DomainName `json:"tenant"`

	//
	// the role/action pairs to provision
	//
	Roles []*TenantRoleAction `json:"roles"`

	//
	// tenant resource group
	//
	ResourceGroup EntityName `json:"resourceGroup"`

	//
	// optional flag indicating whether to create a default tenancy admin role
	//
	CreateAdminRole *bool `json:"createAdminRole,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// optional flag indicating to skip adding the caller principal into the
	// resource role
	//
	SkipPrincipalMember *bool `json:"skipPrincipalMember,omitempty" rdl:"optional" yaml:",omitempty"`
}

// NewProviderResourceGroupRoles - creates an initialized ProviderResourceGroupRoles instance, returns a pointer to it
func NewProviderResourceGroupRoles(init ...*ProviderResourceGroupRoles) *ProviderResourceGroupRoles {
	var o *ProviderResourceGroupRoles
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(ProviderResourceGroupRoles)
	}
	return o.Init()
}

// Init - sets up the instance according to its default field values, if any
func (self *ProviderResourceGroupRoles) Init() *ProviderResourceGroupRoles {
	if self.Roles == nil {
		self.Roles = make([]*TenantRoleAction, 0)
	}
	if self.CreateAdminRole == nil {
		d := true
		self.CreateAdminRole = &d
	}
	if self.SkipPrincipalMember == nil {
		d := false
		self.SkipPrincipalMember = &d
	}
	return self
}

type rawProviderResourceGroupRoles ProviderResourceGroupRoles

// UnmarshalJSON is defined for proper JSON decoding of a ProviderResourceGroupRoles
func (self *ProviderResourceGroupRoles) UnmarshalJSON(b []byte) error {
	var m rawProviderResourceGroupRoles
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := ProviderResourceGroupRoles(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *ProviderResourceGroupRoles) Validate() error {
	if self.Domain == "" {
		return fmt.Errorf("ProviderResourceGroupRoles.domain is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "DomainName", self.Domain)
		if !val.Valid {
			return fmt.Errorf("ProviderResourceGroupRoles.domain does not contain a valid DomainName (%v)", val.Error)
		}
	}
	if self.Service == "" {
		return fmt.Errorf("ProviderResourceGroupRoles.service is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "SimpleName", self.Service)
		if !val.Valid {
			return fmt.Errorf("ProviderResourceGroupRoles.service does not contain a valid SimpleName (%v)", val.Error)
		}
	}
	if self.Tenant == "" {
		return fmt.Errorf("ProviderResourceGroupRoles.tenant is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "DomainName", self.Tenant)
		if !val.Valid {
			return fmt.Errorf("ProviderResourceGroupRoles.tenant does not contain a valid DomainName (%v)", val.Error)
		}
	}
	if self.Roles == nil {
		return fmt.Errorf("ProviderResourceGroupRoles: Missing required field: roles")
	}
	if self.ResourceGroup == "" {
		return fmt.Errorf("ProviderResourceGroupRoles.resourceGroup is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "EntityName", self.ResourceGroup)
		if !val.Valid {
			return fmt.Errorf("ProviderResourceGroupRoles.resourceGroup does not contain a valid EntityName (%v)", val.Error)
		}
	}
	return nil
}

// Access - Access can be checked and returned as this resource.
type Access struct {

	//
	// true (allowed) or false (denied)
	//
	Granted bool `json:"granted"`
}

// NewAccess - creates an initialized Access instance, returns a pointer to it
func NewAccess(init ...*Access) *Access {
	var o *Access
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(Access)
	}
	return o
}

type rawAccess Access

// UnmarshalJSON is defined for proper JSON decoding of a Access
func (self *Access) UnmarshalJSON(b []byte) error {
	var m rawAccess
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := Access(m)
		*self = o
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *Access) Validate() error {
	return nil
}

// ResourceAccess -
type ResourceAccess struct {
	Principal  ResourceName `json:"principal"`
	Assertions []*Assertion `json:"assertions"`
}

// NewResourceAccess - creates an initialized ResourceAccess instance, returns a pointer to it
func NewResourceAccess(init ...*ResourceAccess) *ResourceAccess {
	var o *ResourceAccess
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(ResourceAccess)
	}
	return o.Init()
}

// Init - sets up the instance according to its default field values, if any
func (self *ResourceAccess) Init() *ResourceAccess {
	if self.Assertions == nil {
		self.Assertions = make([]*Assertion, 0)
	}
	return self
}

type rawResourceAccess ResourceAccess

// UnmarshalJSON is defined for proper JSON decoding of a ResourceAccess
func (self *ResourceAccess) UnmarshalJSON(b []byte) error {
	var m rawResourceAccess
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := ResourceAccess(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *ResourceAccess) Validate() error {
	if self.Principal == "" {
		return fmt.Errorf("ResourceAccess.principal is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "ResourceName", self.Principal)
		if !val.Valid {
			return fmt.Errorf("ResourceAccess.principal does not contain a valid ResourceName (%v)", val.Error)
		}
	}
	if self.Assertions == nil {
		return fmt.Errorf("ResourceAccess: Missing required field: assertions")
	}
	return nil
}

// ResourceAccessList -
type ResourceAccessList struct {
	Resources []*ResourceAccess `json:"resources"`
}

// NewResourceAccessList - creates an initialized ResourceAccessList instance, returns a pointer to it
func NewResourceAccessList(init ...*ResourceAccessList) *ResourceAccessList {
	var o *ResourceAccessList
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(ResourceAccessList)
	}
	return o.Init()
}

// Init - sets up the instance according to its default field values, if any
func (self *ResourceAccessList) Init() *ResourceAccessList {
	if self.Resources == nil {
		self.Resources = make([]*ResourceAccess, 0)
	}
	return self
}

type rawResourceAccessList ResourceAccessList

// UnmarshalJSON is defined for proper JSON decoding of a ResourceAccessList
func (self *ResourceAccessList) UnmarshalJSON(b []byte) error {
	var m rawResourceAccessList
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := ResourceAccessList(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *ResourceAccessList) Validate() error {
	if self.Resources == nil {
		return fmt.Errorf("ResourceAccessList: Missing required field: resources")
	}
	return nil
}

// DomainPolicies - We need to include the name of the domain in this struct
// since this data will be passed back to ZPU through ZTS so we need to sign not
// only the list of policies but also the corresponding domain name that the
// policies belong to.
type DomainPolicies struct {

	//
	// name of the domain
	//
	Domain DomainName `json:"domain"`

	//
	// list of policies defined in this server
	//
	Policies []*Policy `json:"policies"`
}

// NewDomainPolicies - creates an initialized DomainPolicies instance, returns a pointer to it
func NewDomainPolicies(init ...*DomainPolicies) *DomainPolicies {
	var o *DomainPolicies
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(DomainPolicies)
	}
	return o.Init()
}

// Init - sets up the instance according to its default field values, if any
func (self *DomainPolicies) Init() *DomainPolicies {
	if self.Policies == nil {
		self.Policies = make([]*Policy, 0)
	}
	return self
}

type rawDomainPolicies DomainPolicies

// UnmarshalJSON is defined for proper JSON decoding of a DomainPolicies
func (self *DomainPolicies) UnmarshalJSON(b []byte) error {
	var m rawDomainPolicies
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := DomainPolicies(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *DomainPolicies) Validate() error {
	if self.Domain == "" {
		return fmt.Errorf("DomainPolicies.domain is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "DomainName", self.Domain)
		if !val.Valid {
			return fmt.Errorf("DomainPolicies.domain does not contain a valid DomainName (%v)", val.Error)
		}
	}
	if self.Policies == nil {
		return fmt.Errorf("DomainPolicies: Missing required field: policies")
	}
	return nil
}

// SignedPolicies - A signed bulk transfer of policies. The data is signed with
// server's private key.
type SignedPolicies struct {

	//
	// list of policies defined in a domain
	//
	Contents *DomainPolicies `json:"contents"`

	//
	// signature generated based on the domain active policies object
	//
	Signature string `json:"signature"`

	//
	// the identifier of the key used to generate the signature
	//
	KeyId string `json:"keyId"`
}

// NewSignedPolicies - creates an initialized SignedPolicies instance, returns a pointer to it
func NewSignedPolicies(init ...*SignedPolicies) *SignedPolicies {
	var o *SignedPolicies
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(SignedPolicies)
	}
	return o.Init()
}

// Init - sets up the instance according to its default field values, if any
func (self *SignedPolicies) Init() *SignedPolicies {
	if self.Contents == nil {
		self.Contents = NewDomainPolicies()
	}
	return self
}

type rawSignedPolicies SignedPolicies

// UnmarshalJSON is defined for proper JSON decoding of a SignedPolicies
func (self *SignedPolicies) UnmarshalJSON(b []byte) error {
	var m rawSignedPolicies
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := SignedPolicies(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *SignedPolicies) Validate() error {
	if self.Contents == nil {
		return fmt.Errorf("SignedPolicies: Missing required field: contents")
	}
	if self.Signature == "" {
		return fmt.Errorf("SignedPolicies.signature is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "String", self.Signature)
		if !val.Valid {
			return fmt.Errorf("SignedPolicies.signature does not contain a valid String (%v)", val.Error)
		}
	}
	if self.KeyId == "" {
		return fmt.Errorf("SignedPolicies.keyId is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "String", self.KeyId)
		if !val.Valid {
			return fmt.Errorf("SignedPolicies.keyId does not contain a valid String (%v)", val.Error)
		}
	}
	return nil
}

// DomainData - A domain object that includes its roles, policies and services.
type DomainData struct {

	//
	// a description of the domain
	//
	Description string `json:"description" rdl:"optional" yaml:",omitempty"`

	//
	// a reference to an audit organization defined in athenz
	//
	Org ResourceName `json:"org,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// Future use only, currently not used
	//
	Enabled *bool `json:"enabled,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// Flag indicates whether or not domain modifications should be logged for
	// SOX+Auditing. If true, the auditRef parameter must be supplied(not empty) for
	// any API defining it.
	//
	AuditEnabled *bool `json:"auditEnabled,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// associated aws account id (system attribute - uniqueness check - if
	// enabled)
	//
	Account string `json:"account" rdl:"optional" yaml:",omitempty"`

	//
	// associated product id (system attribute - uniqueness check - if enabled)
	//
	YpmId *int32 `json:"ypmId,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// associated application id
	//
	ApplicationId string `json:"applicationId" rdl:"optional" yaml:",omitempty"`

	//
	// domain certificate dns domain (system attribute)
	//
	CertDnsDomain string `json:"certDnsDomain" rdl:"optional" yaml:",omitempty"`

	//
	// all user members in the domain will have specified max expiry days
	//
	MemberExpiryDays *int32 `json:"memberExpiryDays,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// tokens issued for this domain will have specified max timeout in mins
	//
	TokenExpiryMins *int32 `json:"tokenExpiryMins,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// service identity certs issued for this domain will have specified max
	// timeout in mins
	//
	ServiceCertExpiryMins *int32 `json:"serviceCertExpiryMins,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// role certs issued for this domain will have specified max timeout in mins
	//
	RoleCertExpiryMins *int32 `json:"roleCertExpiryMins,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// rsa or ec signing algorithm to be used for tokens
	//
	SignAlgorithm string `json:"signAlgorithm" rdl:"optional" yaml:",omitempty"`

	//
	// all services in the domain roles will have specified max expiry days
	//
	ServiceExpiryDays *int32 `json:"serviceExpiryDays,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// all groups in the domain roles will have specified max expiry days
	//
	GroupExpiryDays *int32 `json:"groupExpiryDays,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// membership filtered based on user authority configured attributes
	//
	UserAuthorityFilter string `json:"userAuthorityFilter" rdl:"optional" yaml:",omitempty"`

	//
	// associated azure subscription id (system attribute - uniqueness check - if
	// enabled)
	//
	AzureSubscription string `json:"azureSubscription" rdl:"optional" yaml:",omitempty"`

	//
	// associated azure tenant id (system attribute)
	//
	AzureTenant string `json:"azureTenant" rdl:"optional" yaml:",omitempty"`

	//
	// associated azure client id (system attribute)
	//
	AzureClient string `json:"azureClient" rdl:"optional" yaml:",omitempty"`

	//
	// associated gcp project id (system attribute - uniqueness check - if
	// enabled)
	//
	GcpProject string `json:"gcpProject" rdl:"optional" yaml:",omitempty"`

	//
	// associated gcp project number (system attribute)
	//
	GcpProjectNumber string `json:"gcpProjectNumber" rdl:"optional" yaml:",omitempty"`

	//
	// key-value pair tags, tag might contain multiple values
	//
	Tags map[TagKey]*TagValueList `json:"tags,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// associated business service with domain
	//
	BusinessService string `json:"businessService" rdl:"optional" yaml:",omitempty"`

	//
	// purge role/group members with expiry date configured days in the past
	//
	MemberPurgeExpiryDays *int32 `json:"memberPurgeExpiryDays,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// associated product id (system attribute - uniqueness check - if enabled)
	//
	ProductId string `json:"productId" rdl:"optional" yaml:",omitempty"`

	//
	// features enabled per domain (system attribute)
	//
	FeatureFlags *int32 `json:"featureFlags,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// list of domain contacts (PE-Owner, Product-Owner, etc), each type can have
	// a single value
	//
	Contacts map[SimpleName]string `json:"contacts,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// domain environment e.g. production, staging, etc
	//
	Environment string `json:"environment" rdl:"optional" yaml:",omitempty"`

	//
	// ownership information for the domain (read-only attribute)
	//
	ResourceOwnership *ResourceDomainOwnership `json:"resourceOwnership,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// requested x509 cert signer key id (system attribute)
	//
	X509CertSignerKeyId string `json:"x509CertSignerKeyId" rdl:"optional" yaml:",omitempty"`

	//
	// requested ssh cert signer key id (system attribute)
	//
	SshCertSignerKeyId string `json:"sshCertSignerKeyId" rdl:"optional" yaml:",omitempty"`

	//
	// slack channel for any notifications in this domain
	//
	SlackChannel string `json:"slackChannel" rdl:"optional" yaml:",omitempty"`

	//
	// name of the domain
	//
	Name DomainName `json:"name"`

	//
	// list of roles in the domain
	//
	Roles []*Role `json:"roles"`

	//
	// list of policies in the domain signed with ZMS private key
	//
	Policies *SignedPolicies `json:"policies"`

	//
	// list of services in the domain
	//
	Services []*ServiceIdentity `json:"services"`

	//
	// list of entities in the domain
	//
	Entities []*Entity `json:"entities"`

	//
	// list of groups in the domain
	//
	Groups []*Group `json:"groups"`

	//
	// last modification timestamp
	//
	Modified rdl.Timestamp `json:"modified"`
}

// NewDomainData - creates an initialized DomainData instance, returns a pointer to it
func NewDomainData(init ...*DomainData) *DomainData {
	var o *DomainData
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(DomainData)
	}
	return o.Init()
}

// Init - sets up the instance according to its default field values, if any
func (self *DomainData) Init() *DomainData {
	if self.Enabled == nil {
		d := true
		self.Enabled = &d
	}
	if self.AuditEnabled == nil {
		d := false
		self.AuditEnabled = &d
	}
	if self.Roles == nil {
		self.Roles = make([]*Role, 0)
	}
	if self.Policies == nil {
		self.Policies = NewSignedPolicies()
	}
	if self.Services == nil {
		self.Services = make([]*ServiceIdentity, 0)
	}
	if self.Entities == nil {
		self.Entities = make([]*Entity, 0)
	}
	if self.Groups == nil {
		self.Groups = make([]*Group, 0)
	}
	return self
}

type rawDomainData DomainData

// UnmarshalJSON is defined for proper JSON decoding of a DomainData
func (self *DomainData) UnmarshalJSON(b []byte) error {
	var m rawDomainData
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := DomainData(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *DomainData) Validate() error {
	if self.Description != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.Description)
		if !val.Valid {
			return fmt.Errorf("DomainData.description does not contain a valid String (%v)", val.Error)
		}
	}
	if self.Org != "" {
		val := rdl.Validate(ZMSSchema(), "ResourceName", self.Org)
		if !val.Valid {
			return fmt.Errorf("DomainData.org does not contain a valid ResourceName (%v)", val.Error)
		}
	}
	if self.Account != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.Account)
		if !val.Valid {
			return fmt.Errorf("DomainData.account does not contain a valid String (%v)", val.Error)
		}
	}
	if self.ApplicationId != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.ApplicationId)
		if !val.Valid {
			return fmt.Errorf("DomainData.applicationId does not contain a valid String (%v)", val.Error)
		}
	}
	if self.CertDnsDomain != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.CertDnsDomain)
		if !val.Valid {
			return fmt.Errorf("DomainData.certDnsDomain does not contain a valid String (%v)", val.Error)
		}
	}
	if self.SignAlgorithm != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.SignAlgorithm)
		if !val.Valid {
			return fmt.Errorf("DomainData.signAlgorithm does not contain a valid String (%v)", val.Error)
		}
	}
	if self.UserAuthorityFilter != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.UserAuthorityFilter)
		if !val.Valid {
			return fmt.Errorf("DomainData.userAuthorityFilter does not contain a valid String (%v)", val.Error)
		}
	}
	if self.AzureSubscription != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.AzureSubscription)
		if !val.Valid {
			return fmt.Errorf("DomainData.azureSubscription does not contain a valid String (%v)", val.Error)
		}
	}
	if self.AzureTenant != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.AzureTenant)
		if !val.Valid {
			return fmt.Errorf("DomainData.azureTenant does not contain a valid String (%v)", val.Error)
		}
	}
	if self.AzureClient != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.AzureClient)
		if !val.Valid {
			return fmt.Errorf("DomainData.azureClient does not contain a valid String (%v)", val.Error)
		}
	}
	if self.GcpProject != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.GcpProject)
		if !val.Valid {
			return fmt.Errorf("DomainData.gcpProject does not contain a valid String (%v)", val.Error)
		}
	}
	if self.GcpProjectNumber != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.GcpProjectNumber)
		if !val.Valid {
			return fmt.Errorf("DomainData.gcpProjectNumber does not contain a valid String (%v)", val.Error)
		}
	}
	if self.BusinessService != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.BusinessService)
		if !val.Valid {
			return fmt.Errorf("DomainData.businessService does not contain a valid String (%v)", val.Error)
		}
	}
	if self.ProductId != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.ProductId)
		if !val.Valid {
			return fmt.Errorf("DomainData.productId does not contain a valid String (%v)", val.Error)
		}
	}
	if self.Environment != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.Environment)
		if !val.Valid {
			return fmt.Errorf("DomainData.environment does not contain a valid String (%v)", val.Error)
		}
	}
	if self.X509CertSignerKeyId != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.X509CertSignerKeyId)
		if !val.Valid {
			return fmt.Errorf("DomainData.x509CertSignerKeyId does not contain a valid String (%v)", val.Error)
		}
	}
	if self.SshCertSignerKeyId != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.SshCertSignerKeyId)
		if !val.Valid {
			return fmt.Errorf("DomainData.sshCertSignerKeyId does not contain a valid String (%v)", val.Error)
		}
	}
	if self.SlackChannel != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.SlackChannel)
		if !val.Valid {
			return fmt.Errorf("DomainData.slackChannel does not contain a valid String (%v)", val.Error)
		}
	}
	if self.Name == "" {
		return fmt.Errorf("DomainData.name is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "DomainName", self.Name)
		if !val.Valid {
			return fmt.Errorf("DomainData.name does not contain a valid DomainName (%v)", val.Error)
		}
	}
	if self.Roles == nil {
		return fmt.Errorf("DomainData: Missing required field: roles")
	}
	if self.Policies == nil {
		return fmt.Errorf("DomainData: Missing required field: policies")
	}
	if self.Services == nil {
		return fmt.Errorf("DomainData: Missing required field: services")
	}
	if self.Entities == nil {
		return fmt.Errorf("DomainData: Missing required field: entities")
	}
	if self.Groups == nil {
		return fmt.Errorf("DomainData: Missing required field: groups")
	}
	if self.Modified.IsZero() {
		return fmt.Errorf("DomainData: Missing required field: modified")
	}
	return nil
}

// SignedDomain - A domain object signed with server's private key. The
// signature and keyid are optional if the metaonly flag is set to true in the
// getSignedDomains api call
type SignedDomain struct {

	//
	// domain object with its roles, policies and services
	//
	Domain *DomainData `json:"domain"`

	//
	// signature generated based on the domain object
	//
	Signature string `json:"signature" rdl:"optional" yaml:",omitempty"`

	//
	// the identifier of the key used to generate the signature
	//
	KeyId string `json:"keyId" rdl:"optional" yaml:",omitempty"`
}

// NewSignedDomain - creates an initialized SignedDomain instance, returns a pointer to it
func NewSignedDomain(init ...*SignedDomain) *SignedDomain {
	var o *SignedDomain
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(SignedDomain)
	}
	return o.Init()
}

// Init - sets up the instance according to its default field values, if any
func (self *SignedDomain) Init() *SignedDomain {
	if self.Domain == nil {
		self.Domain = NewDomainData()
	}
	return self
}

type rawSignedDomain SignedDomain

// UnmarshalJSON is defined for proper JSON decoding of a SignedDomain
func (self *SignedDomain) UnmarshalJSON(b []byte) error {
	var m rawSignedDomain
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := SignedDomain(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *SignedDomain) Validate() error {
	if self.Domain == nil {
		return fmt.Errorf("SignedDomain: Missing required field: domain")
	}
	if self.Signature != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.Signature)
		if !val.Valid {
			return fmt.Errorf("SignedDomain.signature does not contain a valid String (%v)", val.Error)
		}
	}
	if self.KeyId != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.KeyId)
		if !val.Valid {
			return fmt.Errorf("SignedDomain.keyId does not contain a valid String (%v)", val.Error)
		}
	}
	return nil
}

// SignedDomains - A list of signed domain objects
type SignedDomains struct {
	Domains []*SignedDomain `json:"domains"`
}

// NewSignedDomains - creates an initialized SignedDomains instance, returns a pointer to it
func NewSignedDomains(init ...*SignedDomains) *SignedDomains {
	var o *SignedDomains
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(SignedDomains)
	}
	return o.Init()
}

// Init - sets up the instance according to its default field values, if any
func (self *SignedDomains) Init() *SignedDomains {
	if self.Domains == nil {
		self.Domains = make([]*SignedDomain, 0)
	}
	return self
}

type rawSignedDomains SignedDomains

// UnmarshalJSON is defined for proper JSON decoding of a SignedDomains
func (self *SignedDomains) UnmarshalJSON(b []byte) error {
	var m rawSignedDomains
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := SignedDomains(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *SignedDomains) Validate() error {
	if self.Domains == nil {
		return fmt.Errorf("SignedDomains: Missing required field: domains")
	}
	return nil
}

// JWSDomain - SignedDomain using flattened JWS JSON Serialization syntax.
// https://tools.ietf.org/html/rfc7515#section-7.2.2
type JWSDomain struct {
	Payload   string            `json:"payload"`
	Protected string            `json:"protected"`
	Header    map[string]string `json:"header"`
	Signature string            `json:"signature"`
}

// NewJWSDomain - creates an initialized JWSDomain instance, returns a pointer to it
func NewJWSDomain(init ...*JWSDomain) *JWSDomain {
	var o *JWSDomain
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(JWSDomain)
	}
	return o.Init()
}

// Init - sets up the instance according to its default field values, if any
func (self *JWSDomain) Init() *JWSDomain {
	if self.Header == nil {
		self.Header = make(map[string]string)
	}
	return self
}

type rawJWSDomain JWSDomain

// UnmarshalJSON is defined for proper JSON decoding of a JWSDomain
func (self *JWSDomain) UnmarshalJSON(b []byte) error {
	var m rawJWSDomain
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := JWSDomain(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *JWSDomain) Validate() error {
	if self.Payload == "" {
		return fmt.Errorf("JWSDomain.payload is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "String", self.Payload)
		if !val.Valid {
			return fmt.Errorf("JWSDomain.payload does not contain a valid String (%v)", val.Error)
		}
	}
	if self.Protected == "" {
		return fmt.Errorf("JWSDomain.protected is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "String", self.Protected)
		if !val.Valid {
			return fmt.Errorf("JWSDomain.protected does not contain a valid String (%v)", val.Error)
		}
	}
	if self.Header == nil {
		return fmt.Errorf("JWSDomain: Missing required field: header")
	}
	if self.Signature == "" {
		return fmt.Errorf("JWSDomain.signature is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "String", self.Signature)
		if !val.Valid {
			return fmt.Errorf("JWSDomain.signature does not contain a valid String (%v)", val.Error)
		}
	}
	return nil
}

// UserToken - A user token generated based on user's credentials
type UserToken struct {

	//
	// Signed user token identifying a specific authenticated user
	//
	Token SignedToken `json:"token"`

	//
	// Authorization header name for the token
	//
	Header string `json:"header" rdl:"optional" yaml:",omitempty"`
}

// NewUserToken - creates an initialized UserToken instance, returns a pointer to it
func NewUserToken(init ...*UserToken) *UserToken {
	var o *UserToken
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(UserToken)
	}
	return o
}

type rawUserToken UserToken

// UnmarshalJSON is defined for proper JSON decoding of a UserToken
func (self *UserToken) UnmarshalJSON(b []byte) error {
	var m rawUserToken
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := UserToken(m)
		*self = o
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *UserToken) Validate() error {
	if self.Token == "" {
		return fmt.Errorf("UserToken.token is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "SignedToken", self.Token)
		if !val.Valid {
			return fmt.Errorf("UserToken.token does not contain a valid SignedToken (%v)", val.Error)
		}
	}
	if self.Header != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.Header)
		if !val.Valid {
			return fmt.Errorf("UserToken.header does not contain a valid String (%v)", val.Error)
		}
	}
	return nil
}

// ServicePrincipal - A service principal object identifying a given service.
type ServicePrincipal struct {

	//
	// name of the domain
	//
	Domain DomainName `json:"domain"`

	//
	// name of the service
	//
	Service EntityName `json:"service"`

	//
	// service's signed token
	//
	Token SignedToken `json:"token"`
}

// NewServicePrincipal - creates an initialized ServicePrincipal instance, returns a pointer to it
func NewServicePrincipal(init ...*ServicePrincipal) *ServicePrincipal {
	var o *ServicePrincipal
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(ServicePrincipal)
	}
	return o
}

type rawServicePrincipal ServicePrincipal

// UnmarshalJSON is defined for proper JSON decoding of a ServicePrincipal
func (self *ServicePrincipal) UnmarshalJSON(b []byte) error {
	var m rawServicePrincipal
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := ServicePrincipal(m)
		*self = o
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *ServicePrincipal) Validate() error {
	if self.Domain == "" {
		return fmt.Errorf("ServicePrincipal.domain is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "DomainName", self.Domain)
		if !val.Valid {
			return fmt.Errorf("ServicePrincipal.domain does not contain a valid DomainName (%v)", val.Error)
		}
	}
	if self.Service == "" {
		return fmt.Errorf("ServicePrincipal.service is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "EntityName", self.Service)
		if !val.Valid {
			return fmt.Errorf("ServicePrincipal.service does not contain a valid EntityName (%v)", val.Error)
		}
	}
	if self.Token == "" {
		return fmt.Errorf("ServicePrincipal.token is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "SignedToken", self.Token)
		if !val.Valid {
			return fmt.Errorf("ServicePrincipal.token does not contain a valid SignedToken (%v)", val.Error)
		}
	}
	return nil
}

// User - The representation for a user
type User struct {

	//
	// name of the user
	//
	Name SimpleName `json:"name"`
}

// NewUser - creates an initialized User instance, returns a pointer to it
func NewUser(init ...*User) *User {
	var o *User
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(User)
	}
	return o
}

type rawUser User

// UnmarshalJSON is defined for proper JSON decoding of a User
func (self *User) UnmarshalJSON(b []byte) error {
	var m rawUser
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := User(m)
		*self = o
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *User) Validate() error {
	if self.Name == "" {
		return fmt.Errorf("User.name is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "SimpleName", self.Name)
		if !val.Valid {
			return fmt.Errorf("User.name does not contain a valid SimpleName (%v)", val.Error)
		}
	}
	return nil
}

// UserList -
type UserList struct {

	//
	// list of user names
	//
	Names []SimpleName `json:"names"`
}

// NewUserList - creates an initialized UserList instance, returns a pointer to it
func NewUserList(init ...*UserList) *UserList {
	var o *UserList
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(UserList)
	}
	return o.Init()
}

// Init - sets up the instance according to its default field values, if any
func (self *UserList) Init() *UserList {
	if self.Names == nil {
		self.Names = make([]SimpleName, 0)
	}
	return self
}

type rawUserList UserList

// UnmarshalJSON is defined for proper JSON decoding of a UserList
func (self *UserList) UnmarshalJSON(b []byte) error {
	var m rawUserList
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := UserList(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *UserList) Validate() error {
	if self.Names == nil {
		return fmt.Errorf("UserList: Missing required field: names")
	}
	return nil
}

// Quota - The representation for a quota object
type Quota struct {

	//
	// name of the domain object
	//
	Name DomainName `json:"name"`

	//
	// number of subdomains allowed (applied at top level domain level)
	//
	Subdomain int32 `json:"subdomain"`

	//
	// number of roles allowed
	//
	Role int32 `json:"role"`

	//
	// number of members a role may have
	//
	RoleMember int32 `json:"roleMember"`

	//
	// number of policies allowed
	//
	Policy int32 `json:"policy"`

	//
	// total number of assertions a policy may have
	//
	Assertion int32 `json:"assertion"`

	//
	// total number of entity objects
	//
	Entity int32 `json:"entity"`

	//
	// number of services allowed
	//
	Service int32 `json:"service"`

	//
	// number of hosts allowed per service
	//
	ServiceHost int32 `json:"serviceHost"`

	//
	// number of public keys per service
	//
	PublicKey int32 `json:"publicKey"`

	//
	// number of groups per domain
	//
	Group int32 `json:"group"`

	//
	// number of members a group may have
	//
	GroupMember int32 `json:"groupMember"`

	//
	// the last modification timestamp of the quota object
	//
	Modified *rdl.Timestamp `json:"modified,omitempty" rdl:"optional" yaml:",omitempty"`
}

// NewQuota - creates an initialized Quota instance, returns a pointer to it
func NewQuota(init ...*Quota) *Quota {
	var o *Quota
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(Quota)
	}
	return o
}

type rawQuota Quota

// UnmarshalJSON is defined for proper JSON decoding of a Quota
func (self *Quota) UnmarshalJSON(b []byte) error {
	var m rawQuota
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := Quota(m)
		*self = o
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *Quota) Validate() error {
	if self.Name == "" {
		return fmt.Errorf("Quota.name is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "DomainName", self.Name)
		if !val.Valid {
			return fmt.Errorf("Quota.name does not contain a valid DomainName (%v)", val.Error)
		}
	}
	return nil
}

// Status - The representation for a status object
type Status struct {

	//
	// status message code
	//
	Code int32 `json:"code"`

	//
	// status message of the server
	//
	Message string `json:"message"`
}

// NewStatus - creates an initialized Status instance, returns a pointer to it
func NewStatus(init ...*Status) *Status {
	var o *Status
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(Status)
	}
	return o
}

type rawStatus Status

// UnmarshalJSON is defined for proper JSON decoding of a Status
func (self *Status) UnmarshalJSON(b []byte) error {
	var m rawStatus
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := Status(m)
		*self = o
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *Status) Validate() error {
	if self.Message == "" {
		return fmt.Errorf("Status.message is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "String", self.Message)
		if !val.Valid {
			return fmt.Errorf("Status.message does not contain a valid String (%v)", val.Error)
		}
	}
	return nil
}

// DomainRoleMembership -
type DomainRoleMembership struct {
	DomainRoleMembersList []*DomainRoleMembers `json:"domainRoleMembersList"`
}

// NewDomainRoleMembership - creates an initialized DomainRoleMembership instance, returns a pointer to it
func NewDomainRoleMembership(init ...*DomainRoleMembership) *DomainRoleMembership {
	var o *DomainRoleMembership
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(DomainRoleMembership)
	}
	return o.Init()
}

// Init - sets up the instance according to its default field values, if any
func (self *DomainRoleMembership) Init() *DomainRoleMembership {
	if self.DomainRoleMembersList == nil {
		self.DomainRoleMembersList = make([]*DomainRoleMembers, 0)
	}
	return self
}

type rawDomainRoleMembership DomainRoleMembership

// UnmarshalJSON is defined for proper JSON decoding of a DomainRoleMembership
func (self *DomainRoleMembership) UnmarshalJSON(b []byte) error {
	var m rawDomainRoleMembership
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := DomainRoleMembership(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *DomainRoleMembership) Validate() error {
	if self.DomainRoleMembersList == nil {
		return fmt.Errorf("DomainRoleMembership: Missing required field: domainRoleMembersList")
	}
	return nil
}

// UserAuthorityAttributes - Copyright The Athenz Authors Licensed under the
// terms of the Apache version 2.0 license. See LICENSE file for terms.
type UserAuthorityAttributes struct {
	Values []string `json:"values"`
}

// NewUserAuthorityAttributes - creates an initialized UserAuthorityAttributes instance, returns a pointer to it
func NewUserAuthorityAttributes(init ...*UserAuthorityAttributes) *UserAuthorityAttributes {
	var o *UserAuthorityAttributes
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(UserAuthorityAttributes)
	}
	return o.Init()
}

// Init - sets up the instance according to its default field values, if any
func (self *UserAuthorityAttributes) Init() *UserAuthorityAttributes {
	if self.Values == nil {
		self.Values = make([]string, 0)
	}
	return self
}

type rawUserAuthorityAttributes UserAuthorityAttributes

// UnmarshalJSON is defined for proper JSON decoding of a UserAuthorityAttributes
func (self *UserAuthorityAttributes) UnmarshalJSON(b []byte) error {
	var m rawUserAuthorityAttributes
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := UserAuthorityAttributes(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *UserAuthorityAttributes) Validate() error {
	if self.Values == nil {
		return fmt.Errorf("UserAuthorityAttributes: Missing required field: values")
	}
	return nil
}

// UserAuthorityAttributeMap - Map of user authority attributes
type UserAuthorityAttributeMap struct {

	//
	// map of type to attribute values
	//
	Attributes map[SimpleName]*UserAuthorityAttributes `json:"attributes"`
}

// NewUserAuthorityAttributeMap - creates an initialized UserAuthorityAttributeMap instance, returns a pointer to it
func NewUserAuthorityAttributeMap(init ...*UserAuthorityAttributeMap) *UserAuthorityAttributeMap {
	var o *UserAuthorityAttributeMap
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(UserAuthorityAttributeMap)
	}
	return o.Init()
}

// Init - sets up the instance according to its default field values, if any
func (self *UserAuthorityAttributeMap) Init() *UserAuthorityAttributeMap {
	if self.Attributes == nil {
		self.Attributes = make(map[SimpleName]*UserAuthorityAttributes)
	}
	return self
}

type rawUserAuthorityAttributeMap UserAuthorityAttributeMap

// UnmarshalJSON is defined for proper JSON decoding of a UserAuthorityAttributeMap
func (self *UserAuthorityAttributeMap) UnmarshalJSON(b []byte) error {
	var m rawUserAuthorityAttributeMap
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := UserAuthorityAttributeMap(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *UserAuthorityAttributeMap) Validate() error {
	if self.Attributes == nil {
		return fmt.Errorf("UserAuthorityAttributeMap: Missing required field: attributes")
	}
	return nil
}

// Stats - The representation for a stats object
type Stats struct {

	//
	// name of the domain object, null for system stats
	//
	Name DomainName `json:"name,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// number of subdomains in this domain (all levels)
	//
	Subdomain int32 `json:"subdomain"`

	//
	// number of roles
	//
	Role int32 `json:"role"`

	//
	// number of members in all the roles
	//
	RoleMember int32 `json:"roleMember"`

	//
	// number of policies
	//
	Policy int32 `json:"policy"`

	//
	// total number of assertions in all policies
	//
	Assertion int32 `json:"assertion"`

	//
	// total number of entity objects
	//
	Entity int32 `json:"entity"`

	//
	// number of services
	//
	Service int32 `json:"service"`

	//
	// number of hosts defined in all services
	//
	ServiceHost int32 `json:"serviceHost"`

	//
	// number of public keys in all services
	//
	PublicKey int32 `json:"publicKey"`

	//
	// number of groups
	//
	Group int32 `json:"group"`

	//
	// number of members in all the groups
	//
	GroupMember int32 `json:"groupMember"`
}

// NewStats - creates an initialized Stats instance, returns a pointer to it
func NewStats(init ...*Stats) *Stats {
	var o *Stats
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(Stats)
	}
	return o
}

type rawStats Stats

// UnmarshalJSON is defined for proper JSON decoding of a Stats
func (self *Stats) UnmarshalJSON(b []byte) error {
	var m rawStats
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := Stats(m)
		*self = o
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *Stats) Validate() error {
	if self.Name != "" {
		val := rdl.Validate(ZMSSchema(), "DomainName", self.Name)
		if !val.Valid {
			return fmt.Errorf("Stats.name does not contain a valid DomainName (%v)", val.Error)
		}
	}
	return nil
}

// DependentService - Dependent service provider details
type DependentService struct {

	//
	// name of the service
	//
	Service ServiceName `json:"service"`
}

// NewDependentService - creates an initialized DependentService instance, returns a pointer to it
func NewDependentService(init ...*DependentService) *DependentService {
	var o *DependentService
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(DependentService)
	}
	return o
}

type rawDependentService DependentService

// UnmarshalJSON is defined for proper JSON decoding of a DependentService
func (self *DependentService) UnmarshalJSON(b []byte) error {
	var m rawDependentService
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := DependentService(m)
		*self = o
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *DependentService) Validate() error {
	if self.Service == "" {
		return fmt.Errorf("DependentService.service is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "ServiceName", self.Service)
		if !val.Valid {
			return fmt.Errorf("DependentService.service does not contain a valid ServiceName (%v)", val.Error)
		}
	}
	return nil
}

// DependentServiceResourceGroup -
type DependentServiceResourceGroup struct {

	//
	// name of the service
	//
	Service ServiceName `json:"service"`

	//
	// name of the dependent domain
	//
	Domain DomainName `json:"domain"`

	//
	// registered resource groups for this service and domain
	//
	ResourceGroups []EntityName `json:"resourceGroups,omitempty" rdl:"optional" yaml:",omitempty"`
}

// NewDependentServiceResourceGroup - creates an initialized DependentServiceResourceGroup instance, returns a pointer to it
func NewDependentServiceResourceGroup(init ...*DependentServiceResourceGroup) *DependentServiceResourceGroup {
	var o *DependentServiceResourceGroup
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(DependentServiceResourceGroup)
	}
	return o
}

type rawDependentServiceResourceGroup DependentServiceResourceGroup

// UnmarshalJSON is defined for proper JSON decoding of a DependentServiceResourceGroup
func (self *DependentServiceResourceGroup) UnmarshalJSON(b []byte) error {
	var m rawDependentServiceResourceGroup
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := DependentServiceResourceGroup(m)
		*self = o
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *DependentServiceResourceGroup) Validate() error {
	if self.Service == "" {
		return fmt.Errorf("DependentServiceResourceGroup.service is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "ServiceName", self.Service)
		if !val.Valid {
			return fmt.Errorf("DependentServiceResourceGroup.service does not contain a valid ServiceName (%v)", val.Error)
		}
	}
	if self.Domain == "" {
		return fmt.Errorf("DependentServiceResourceGroup.domain is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "DomainName", self.Domain)
		if !val.Valid {
			return fmt.Errorf("DependentServiceResourceGroup.domain does not contain a valid DomainName (%v)", val.Error)
		}
	}
	return nil
}

// DependentServiceResourceGroupList -
type DependentServiceResourceGroupList struct {

	//
	// collection of dependent services and resource groups for tenant domain
	//
	ServiceAndResourceGroups []*DependentServiceResourceGroup `json:"serviceAndResourceGroups"`
}

// NewDependentServiceResourceGroupList - creates an initialized DependentServiceResourceGroupList instance, returns a pointer to it
func NewDependentServiceResourceGroupList(init ...*DependentServiceResourceGroupList) *DependentServiceResourceGroupList {
	var o *DependentServiceResourceGroupList
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(DependentServiceResourceGroupList)
	}
	return o.Init()
}

// Init - sets up the instance according to its default field values, if any
func (self *DependentServiceResourceGroupList) Init() *DependentServiceResourceGroupList {
	if self.ServiceAndResourceGroups == nil {
		self.ServiceAndResourceGroups = make([]*DependentServiceResourceGroup, 0)
	}
	return self
}

type rawDependentServiceResourceGroupList DependentServiceResourceGroupList

// UnmarshalJSON is defined for proper JSON decoding of a DependentServiceResourceGroupList
func (self *DependentServiceResourceGroupList) UnmarshalJSON(b []byte) error {
	var m rawDependentServiceResourceGroupList
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := DependentServiceResourceGroupList(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *DependentServiceResourceGroupList) Validate() error {
	if self.ServiceAndResourceGroups == nil {
		return fmt.Errorf("DependentServiceResourceGroupList: Missing required field: serviceAndResourceGroups")
	}
	return nil
}

// ReviewObject - Details for the roles and/or groups that need to be reviewed
type ReviewObject struct {

	//
	// name of the domain
	//
	DomainName DomainName `json:"domainName"`

	//
	// name of the role and/or group
	//
	Name EntityName `json:"name"`

	//
	// all user members in the object have specified max expiry days
	//
	MemberExpiryDays int32 `json:"memberExpiryDays"`

	//
	// all user members in the object have specified max review days
	//
	MemberReviewDays int32 `json:"memberReviewDays"`

	//
	// all services in the object have specified max expiry days
	//
	ServiceExpiryDays int32 `json:"serviceExpiryDays"`

	//
	// all services in the object have specified max review days
	//
	ServiceReviewDays int32 `json:"serviceReviewDays"`

	//
	// all groups in the object have specified max expiry days
	//
	GroupExpiryDays int32 `json:"groupExpiryDays"`

	//
	// all groups in the object have specified max review days
	//
	GroupReviewDays int32 `json:"groupReviewDays"`

	//
	// last review timestamp of the object
	//
	LastReviewedDate *rdl.Timestamp `json:"lastReviewedDate,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// creation time of the object
	//
	Created rdl.Timestamp `json:"created"`
}

// NewReviewObject - creates an initialized ReviewObject instance, returns a pointer to it
func NewReviewObject(init ...*ReviewObject) *ReviewObject {
	var o *ReviewObject
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(ReviewObject)
	}
	return o
}

type rawReviewObject ReviewObject

// UnmarshalJSON is defined for proper JSON decoding of a ReviewObject
func (self *ReviewObject) UnmarshalJSON(b []byte) error {
	var m rawReviewObject
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := ReviewObject(m)
		*self = o
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *ReviewObject) Validate() error {
	if self.DomainName == "" {
		return fmt.Errorf("ReviewObject.domainName is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "DomainName", self.DomainName)
		if !val.Valid {
			return fmt.Errorf("ReviewObject.domainName does not contain a valid DomainName (%v)", val.Error)
		}
	}
	if self.Name == "" {
		return fmt.Errorf("ReviewObject.name is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "EntityName", self.Name)
		if !val.Valid {
			return fmt.Errorf("ReviewObject.name does not contain a valid EntityName (%v)", val.Error)
		}
	}
	if self.Created.IsZero() {
		return fmt.Errorf("ReviewObject: Missing required field: created")
	}
	return nil
}

// ReviewObjects - The representation for a list of objects with full details
type ReviewObjects struct {

	//
	// list of review objects
	//
	List []*ReviewObject `json:"list"`
}

// NewReviewObjects - creates an initialized ReviewObjects instance, returns a pointer to it
func NewReviewObjects(init ...*ReviewObjects) *ReviewObjects {
	var o *ReviewObjects
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(ReviewObjects)
	}
	return o.Init()
}

// Init - sets up the instance according to its default field values, if any
func (self *ReviewObjects) Init() *ReviewObjects {
	if self.List == nil {
		self.List = make([]*ReviewObject, 0)
	}
	return self
}

type rawReviewObjects ReviewObjects

// UnmarshalJSON is defined for proper JSON decoding of a ReviewObjects
func (self *ReviewObjects) UnmarshalJSON(b []byte) error {
	var m rawReviewObjects
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := ReviewObjects(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *ReviewObjects) Validate() error {
	if self.List == nil {
		return fmt.Errorf("ReviewObjects: Missing required field: list")
	}
	return nil
}

// Info - Copyright The Athenz Authors Licensed under the terms of the Apache
// version 2.0 license. See LICENSE file for terms. The representation for an
// info object
type Info struct {

	//
	// jdk build version
	//
	BuildJdkSpec string `json:"buildJdkSpec" rdl:"optional" yaml:",omitempty"`

	//
	// implementation title - e.g. athenz-zms-server
	//
	ImplementationTitle string `json:"implementationTitle" rdl:"optional" yaml:",omitempty"`

	//
	// implementation version - e.g. 1.11.1
	//
	ImplementationVersion string `json:"implementationVersion" rdl:"optional" yaml:",omitempty"`

	//
	// implementation vendor - Athenz
	//
	ImplementationVendor string `json:"implementationVendor" rdl:"optional" yaml:",omitempty"`
}

// NewInfo - creates an initialized Info instance, returns a pointer to it
func NewInfo(init ...*Info) *Info {
	var o *Info
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(Info)
	}
	return o
}

type rawInfo Info

// UnmarshalJSON is defined for proper JSON decoding of a Info
func (self *Info) UnmarshalJSON(b []byte) error {
	var m rawInfo
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := Info(m)
		*self = o
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *Info) Validate() error {
	if self.BuildJdkSpec != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.BuildJdkSpec)
		if !val.Valid {
			return fmt.Errorf("Info.buildJdkSpec does not contain a valid String (%v)", val.Error)
		}
	}
	if self.ImplementationTitle != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.ImplementationTitle)
		if !val.Valid {
			return fmt.Errorf("Info.implementationTitle does not contain a valid String (%v)", val.Error)
		}
	}
	if self.ImplementationVersion != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.ImplementationVersion)
		if !val.Valid {
			return fmt.Errorf("Info.implementationVersion does not contain a valid String (%v)", val.Error)
		}
	}
	if self.ImplementationVendor != "" {
		val := rdl.Validate(ZMSSchema(), "String", self.ImplementationVendor)
		if !val.Valid {
			return fmt.Errorf("Info.implementationVendor does not contain a valid String (%v)", val.Error)
		}
	}
	return nil
}

// PrincipalMember -
type PrincipalMember struct {

	//
	// name of the principal
	//
	PrincipalName MemberName `json:"principalName"`

	//
	// current system suspended state of the principal
	//
	SuspendedState int32 `json:"suspendedState"`
}

// NewPrincipalMember - creates an initialized PrincipalMember instance, returns a pointer to it
func NewPrincipalMember(init ...*PrincipalMember) *PrincipalMember {
	var o *PrincipalMember
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(PrincipalMember)
	}
	return o
}

type rawPrincipalMember PrincipalMember

// UnmarshalJSON is defined for proper JSON decoding of a PrincipalMember
func (self *PrincipalMember) UnmarshalJSON(b []byte) error {
	var m rawPrincipalMember
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := PrincipalMember(m)
		*self = o
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *PrincipalMember) Validate() error {
	if self.PrincipalName == "" {
		return fmt.Errorf("PrincipalMember.principalName is missing but is a required field")
	} else {
		val := rdl.Validate(ZMSSchema(), "MemberName", self.PrincipalName)
		if !val.Valid {
			return fmt.Errorf("PrincipalMember.principalName does not contain a valid MemberName (%v)", val.Error)
		}
	}
	return nil
}

// PrincipalState - A principal state entry
type PrincipalState struct {

	//
	// athenz suspended state for the principal
	//
	Suspended bool `json:"suspended"`
}

// NewPrincipalState - creates an initialized PrincipalState instance, returns a pointer to it
func NewPrincipalState(init ...*PrincipalState) *PrincipalState {
	var o *PrincipalState
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(PrincipalState)
	}
	return o
}

type rawPrincipalState PrincipalState

// UnmarshalJSON is defined for proper JSON decoding of a PrincipalState
func (self *PrincipalState) UnmarshalJSON(b []byte) error {
	var m rawPrincipalState
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := PrincipalState(m)
		*self = o
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *PrincipalState) Validate() error {
	return nil
}
