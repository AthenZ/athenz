//
// This file generated by rdl 1.4.14
//

package zms

import (
	"bytes"
	"encoding/json"
	"fmt"
	rdl "github.com/ardielle/ardielle-go/rdl"
	"io"
	"io/ioutil"
	"net/http"
	"net/url"
	"strconv"
	"strings"
	"time"
)

var _ = json.Marshal
var _ = fmt.Printf
var _ = rdl.BaseTypeAny
var _ = ioutil.NopCloser

type ZMSClient struct {
	URL         string
	Transport   http.RoundTripper
	CredsHeader *string
	CredsToken  *string
	Timeout     time.Duration
}

// NewClient creates and returns a new HTTP client object for the ZMS service
func NewClient(url string, transport http.RoundTripper) ZMSClient {
	return ZMSClient{url, transport, nil, nil, 0}
}

// AddCredentials adds the credentials to the client for subsequent requests.
func (client *ZMSClient) AddCredentials(header string, token string) {
	client.CredsHeader = &header
	client.CredsToken = &token
}

func (client ZMSClient) getClient() *http.Client {
	var c *http.Client
	if client.Transport != nil {
		c = &http.Client{Transport: client.Transport}
	} else {
		c = &http.Client{}
	}
	if client.Timeout > 0 {
		c.Timeout = client.Timeout
	}
	return c
}

func (client ZMSClient) addAuthHeader(req *http.Request) {
	if client.CredsHeader != nil && client.CredsToken != nil {
		if strings.HasPrefix(*client.CredsHeader, "Cookie.") {
			req.Header.Add("Cookie", (*client.CredsHeader)[7:]+"="+*client.CredsToken)
		} else {
			req.Header.Add(*client.CredsHeader, *client.CredsToken)
		}
	}
}

func (client ZMSClient) httpGet(url string, headers map[string]string) (*http.Response, error) {
	hclient := client.getClient()
	req, err := http.NewRequest("GET", url, nil)
	if err != nil {
		return nil, err
	}
	client.addAuthHeader(req)
	if headers != nil {
		for k, v := range headers {
			req.Header.Add(k, v)
		}
	}
	return hclient.Do(req)
}

func (client ZMSClient) httpDelete(url string, headers map[string]string) (*http.Response, error) {
	hclient := client.getClient()
	req, err := http.NewRequest("DELETE", url, nil)
	if err != nil {
		return nil, err
	}
	client.addAuthHeader(req)
	if headers != nil {
		for k, v := range headers {
			req.Header.Add(k, v)
		}
	}
	return hclient.Do(req)
}

func (client ZMSClient) httpPut(url string, headers map[string]string, body []byte) (*http.Response, error) {
	var contentReader io.Reader
	if body != nil {
		contentReader = bytes.NewReader(body)
	}
	hclient := client.getClient()
	req, err := http.NewRequest("PUT", url, contentReader)
	if err != nil {
		return nil, err
	}
	req.Header.Add("Content-type", "application/json")
	client.addAuthHeader(req)
	if headers != nil {
		for k, v := range headers {
			req.Header.Add(k, v)
		}
	}
	return hclient.Do(req)
}

func (client ZMSClient) httpPost(url string, headers map[string]string, body []byte) (*http.Response, error) {
	var contentReader io.Reader
	if body != nil {
		contentReader = bytes.NewReader(body)
	}
	hclient := client.getClient()
	req, err := http.NewRequest("POST", url, contentReader)
	if err != nil {
		return nil, err
	}
	req.Header.Add("Content-type", "application/json")
	client.addAuthHeader(req)
	if headers != nil {
		for k, v := range headers {
			req.Header.Add(k, v)
		}
	}
	return hclient.Do(req)
}

func (client ZMSClient) httpPatch(url string, headers map[string]string, body []byte) (*http.Response, error) {
	var contentReader io.Reader
	if body != nil {
		contentReader = bytes.NewReader(body)
	}
	hclient := client.getClient()
	req, err := http.NewRequest("PATCH", url, contentReader)
	if err != nil {
		return nil, err
	}
	req.Header.Add("Content-type", "application/json")
	client.addAuthHeader(req)
	if headers != nil {
		for k, v := range headers {
			req.Header.Add(k, v)
		}
	}
	return hclient.Do(req)
}

func (client ZMSClient) httpOptions(url string, headers map[string]string, body []byte) (*http.Response, error) {
	var contentReader io.Reader = nil
	if body != nil {
		contentReader = bytes.NewReader(body)
	}
	hclient := client.getClient()
	req, err := http.NewRequest("OPTIONS", url, contentReader)
	if err != nil {
		return nil, err
	}
	if contentReader != nil {
		req.Header.Add("Content-type", "application/json")
	}
	client.addAuthHeader(req)
	if headers != nil {
		for k, v := range headers {
			req.Header.Add(k, v)
		}
	}
	return hclient.Do(req)
}

func encodeStringParam(name string, val string, def string) string {
	if val == def {
		return ""
	}
	return "&" + name + "=" + url.QueryEscape(val)
}
func encodeBoolParam(name string, b bool, def bool) string {
	if b == def {
		return ""
	}
	return fmt.Sprintf("&%s=%v", name, b)
}
func encodeInt8Param(name string, i int8, def int8) string {
	if i == def {
		return ""
	}
	return "&" + name + "=" + strconv.Itoa(int(i))
}
func encodeInt16Param(name string, i int16, def int16) string {
	if i == def {
		return ""
	}
	return "&" + name + "=" + strconv.Itoa(int(i))
}
func encodeInt32Param(name string, i int32, def int32) string {
	if i == def {
		return ""
	}
	return "&" + name + "=" + strconv.Itoa(int(i))
}
func encodeInt64Param(name string, i int64, def int64) string {
	if i == def {
		return ""
	}
	return "&" + name + "=" + strconv.FormatInt(i, 10)
}
func encodeFloat32Param(name string, i float32, def float32) string {
	if i == def {
		return ""
	}
	return "&" + name + "=" + strconv.FormatFloat(float64(i), 'g', -1, 32)
}
func encodeFloat64Param(name string, i float64, def float64) string {
	if i == def {
		return ""
	}
	return "&" + name + "=" + strconv.FormatFloat(i, 'g', -1, 64)
}
func encodeOptionalEnumParam(name string, e interface{}) string {
	if e == nil {
		return "\"\""
	}
	return fmt.Sprintf("&%s=%v", name, e)
}
func encodeOptionalBoolParam(name string, b *bool) string {
	if b == nil {
		return ""
	}
	return fmt.Sprintf("&%s=%v", name, *b)
}
func encodeOptionalInt32Param(name string, i *int32) string {
	if i == nil {
		return ""
	}
	return "&" + name + "=" + strconv.Itoa(int(*i))
}
func encodeOptionalInt64Param(name string, i *int64) string {
	if i == nil {
		return ""
	}
	return "&" + name + "=" + strconv.Itoa(int(*i))
}
func encodeParams(objs ...string) string {
	s := strings.Join(objs, "")
	if s == "" {
		return s
	}
	return "?" + s[1:]
}

func (client ZMSClient) GetDomain(domain DomainName) (*Domain, error) {
	var data *Domain
	url := client.URL + "/domain/" + fmt.Sprint(domain)
	resp, err := client.httpGet(url, nil)
	if err != nil {
		return data, err
	}
	contentBytes, err := ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return data, err
	}
	switch resp.StatusCode {
	case 200:
		err = json.Unmarshal(contentBytes, &data)
		if err != nil {
			return data, err
		}
		return data, nil
	default:
		var errobj rdl.ResourceError
		json.Unmarshal(contentBytes, &errobj)
		if errobj.Code == 0 {
			errobj.Code = resp.StatusCode
		}
		if errobj.Message == "" {
			errobj.Message = string(contentBytes)
		}
		return data, errobj
	}
}

func (client ZMSClient) GetDomainList(limit *int32, skip string, prefix string, depth *int32, account string, productId *int32, roleMember ResourceName, roleName ResourceName, modifiedSince string) (*DomainList, error) {
	var data *DomainList
	headers := map[string]string{
		"If-Modified-Since": modifiedSince,
	}
	url := client.URL + "/domain" + encodeParams(encodeOptionalInt32Param("limit", limit), encodeStringParam("skip", string(skip), ""), encodeStringParam("prefix", string(prefix), ""), encodeOptionalInt32Param("depth", depth), encodeStringParam("account", string(account), ""), encodeOptionalInt32Param("ypmid", productId), encodeStringParam("member", string(roleMember), ""), encodeStringParam("role", string(roleName), ""))
	resp, err := client.httpGet(url, headers)
	if err != nil {
		return data, err
	}
	contentBytes, err := ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return data, err
	}
	switch resp.StatusCode {
	case 200:
		err = json.Unmarshal(contentBytes, &data)
		if err != nil {
			return data, err
		}
		return data, nil
	default:
		var errobj rdl.ResourceError
		json.Unmarshal(contentBytes, &errobj)
		if errobj.Code == 0 {
			errobj.Code = resp.StatusCode
		}
		if errobj.Message == "" {
			errobj.Message = string(contentBytes)
		}
		return data, errobj
	}
}

func (client ZMSClient) PostTopLevelDomain(auditRef string, detail *TopLevelDomain) (*Domain, error) {
	var data *Domain
	headers := map[string]string{
		"Y-Audit-Ref": auditRef,
	}
	url := client.URL + "/domain"
	contentBytes, err := json.Marshal(detail)
	if err != nil {
		return data, err
	}
	resp, err := client.httpPost(url, headers, contentBytes)
	if err != nil {
		return data, err
	}
	contentBytes, err = ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return data, err
	}
	switch resp.StatusCode {
	case 200:
		err = json.Unmarshal(contentBytes, &data)
		if err != nil {
			return data, err
		}
		return data, nil
	default:
		var errobj rdl.ResourceError
		json.Unmarshal(contentBytes, &errobj)
		if errobj.Code == 0 {
			errobj.Code = resp.StatusCode
		}
		if errobj.Message == "" {
			errobj.Message = string(contentBytes)
		}
		return data, errobj
	}
}

func (client ZMSClient) PostSubDomain(parent DomainName, auditRef string, detail *SubDomain) (*Domain, error) {
	var data *Domain
	headers := map[string]string{
		"Y-Audit-Ref": auditRef,
	}
	url := client.URL + "/subdomain/" + fmt.Sprint(parent)
	contentBytes, err := json.Marshal(detail)
	if err != nil {
		return data, err
	}
	resp, err := client.httpPost(url, headers, contentBytes)
	if err != nil {
		return data, err
	}
	contentBytes, err = ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return data, err
	}
	switch resp.StatusCode {
	case 200:
		err = json.Unmarshal(contentBytes, &data)
		if err != nil {
			return data, err
		}
		return data, nil
	default:
		var errobj rdl.ResourceError
		json.Unmarshal(contentBytes, &errobj)
		if errobj.Code == 0 {
			errobj.Code = resp.StatusCode
		}
		if errobj.Message == "" {
			errobj.Message = string(contentBytes)
		}
		return data, errobj
	}
}

func (client ZMSClient) PostUserDomain(name SimpleName, auditRef string, detail *UserDomain) (*Domain, error) {
	var data *Domain
	headers := map[string]string{
		"Y-Audit-Ref": auditRef,
	}
	url := client.URL + "/userdomain/" + fmt.Sprint(name)
	contentBytes, err := json.Marshal(detail)
	if err != nil {
		return data, err
	}
	resp, err := client.httpPost(url, headers, contentBytes)
	if err != nil {
		return data, err
	}
	contentBytes, err = ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return data, err
	}
	switch resp.StatusCode {
	case 200:
		err = json.Unmarshal(contentBytes, &data)
		if err != nil {
			return data, err
		}
		return data, nil
	default:
		var errobj rdl.ResourceError
		json.Unmarshal(contentBytes, &errobj)
		if errobj.Code == 0 {
			errobj.Code = resp.StatusCode
		}
		if errobj.Message == "" {
			errobj.Message = string(contentBytes)
		}
		return data, errobj
	}
}

func (client ZMSClient) DeleteTopLevelDomain(name SimpleName, auditRef string) error {
	headers := map[string]string{
		"Y-Audit-Ref": auditRef,
	}
	url := client.URL + "/domain/" + fmt.Sprint(name)
	resp, err := client.httpDelete(url, headers)
	if err != nil {
		return err
	}
	contentBytes, err := ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return err
	}
	switch resp.StatusCode {
	case 204:
		return nil
	default:
		var errobj rdl.ResourceError
		json.Unmarshal(contentBytes, &errobj)
		if errobj.Code == 0 {
			errobj.Code = resp.StatusCode
		}
		if errobj.Message == "" {
			errobj.Message = string(contentBytes)
		}
		return errobj
	}
}

func (client ZMSClient) DeleteSubDomain(parent DomainName, name SimpleName, auditRef string) error {
	headers := map[string]string{
		"Y-Audit-Ref": auditRef,
	}
	url := client.URL + "/subdomain/" + fmt.Sprint(parent) + "/" + fmt.Sprint(name)
	resp, err := client.httpDelete(url, headers)
	if err != nil {
		return err
	}
	contentBytes, err := ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return err
	}
	switch resp.StatusCode {
	case 204:
		return nil
	default:
		var errobj rdl.ResourceError
		json.Unmarshal(contentBytes, &errobj)
		if errobj.Code == 0 {
			errobj.Code = resp.StatusCode
		}
		if errobj.Message == "" {
			errobj.Message = string(contentBytes)
		}
		return errobj
	}
}

func (client ZMSClient) DeleteUserDomain(name SimpleName, auditRef string) error {
	headers := map[string]string{
		"Y-Audit-Ref": auditRef,
	}
	url := client.URL + "/userdomain/" + fmt.Sprint(name)
	resp, err := client.httpDelete(url, headers)
	if err != nil {
		return err
	}
	contentBytes, err := ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return err
	}
	switch resp.StatusCode {
	case 204:
		return nil
	default:
		var errobj rdl.ResourceError
		json.Unmarshal(contentBytes, &errobj)
		if errobj.Code == 0 {
			errobj.Code = resp.StatusCode
		}
		if errobj.Message == "" {
			errobj.Message = string(contentBytes)
		}
		return errobj
	}
}

func (client ZMSClient) PutDomainMeta(name DomainName, auditRef string, detail *DomainMeta) error {
	headers := map[string]string{
		"Y-Audit-Ref": auditRef,
	}
	url := client.URL + "/domain/" + fmt.Sprint(name) + "/meta"
	contentBytes, err := json.Marshal(detail)
	if err != nil {
		return err
	}
	resp, err := client.httpPut(url, headers, contentBytes)
	if err != nil {
		return err
	}
	contentBytes, err = ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return err
	}
	switch resp.StatusCode {
	case 204:
		return nil
	default:
		var errobj rdl.ResourceError
		json.Unmarshal(contentBytes, &errobj)
		if errobj.Code == 0 {
			errobj.Code = resp.StatusCode
		}
		if errobj.Message == "" {
			errobj.Message = string(contentBytes)
		}
		return errobj
	}
}

func (client ZMSClient) PutDomainTemplate(name DomainName, auditRef string, template *DomainTemplate) error {
	headers := map[string]string{
		"Y-Audit-Ref": auditRef,
	}
	url := client.URL + "/domain/" + fmt.Sprint(name) + "/template"
	contentBytes, err := json.Marshal(template)
	if err != nil {
		return err
	}
	resp, err := client.httpPut(url, headers, contentBytes)
	if err != nil {
		return err
	}
	contentBytes, err = ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return err
	}
	switch resp.StatusCode {
	case 204:
		return nil
	default:
		var errobj rdl.ResourceError
		json.Unmarshal(contentBytes, &errobj)
		if errobj.Code == 0 {
			errobj.Code = resp.StatusCode
		}
		if errobj.Message == "" {
			errobj.Message = string(contentBytes)
		}
		return errobj
	}
}

func (client ZMSClient) GetDomainTemplateList(name DomainName) (*DomainTemplateList, error) {
	var data *DomainTemplateList
	url := client.URL + "/domain/" + fmt.Sprint(name) + "/template"
	resp, err := client.httpGet(url, nil)
	if err != nil {
		return data, err
	}
	contentBytes, err := ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return data, err
	}
	switch resp.StatusCode {
	case 200:
		err = json.Unmarshal(contentBytes, &data)
		if err != nil {
			return data, err
		}
		return data, nil
	default:
		var errobj rdl.ResourceError
		json.Unmarshal(contentBytes, &errobj)
		if errobj.Code == 0 {
			errobj.Code = resp.StatusCode
		}
		if errobj.Message == "" {
			errobj.Message = string(contentBytes)
		}
		return data, errobj
	}
}

func (client ZMSClient) DeleteDomainTemplate(name DomainName, template SimpleName, auditRef string) error {
	headers := map[string]string{
		"Y-Audit-Ref": auditRef,
	}
	url := client.URL + "/domain/" + fmt.Sprint(name) + "/template/" + fmt.Sprint(template)
	resp, err := client.httpDelete(url, headers)
	if err != nil {
		return err
	}
	contentBytes, err := ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return err
	}
	switch resp.StatusCode {
	case 204:
		return nil
	default:
		var errobj rdl.ResourceError
		json.Unmarshal(contentBytes, &errobj)
		if errobj.Code == 0 {
			errobj.Code = resp.StatusCode
		}
		if errobj.Message == "" {
			errobj.Message = string(contentBytes)
		}
		return errobj
	}
}

func (client ZMSClient) GetDomainDataCheck(domainName DomainName) (*DomainDataCheck, error) {
	var data *DomainDataCheck
	url := client.URL + "/domain/" + fmt.Sprint(domainName) + "/check"
	resp, err := client.httpGet(url, nil)
	if err != nil {
		return data, err
	}
	contentBytes, err := ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return data, err
	}
	switch resp.StatusCode {
	case 200:
		err = json.Unmarshal(contentBytes, &data)
		if err != nil {
			return data, err
		}
		return data, nil
	default:
		var errobj rdl.ResourceError
		json.Unmarshal(contentBytes, &errobj)
		if errobj.Code == 0 {
			errobj.Code = resp.StatusCode
		}
		if errobj.Message == "" {
			errobj.Message = string(contentBytes)
		}
		return data, errobj
	}
}

func (client ZMSClient) PutEntity(domainName DomainName, entityName EntityName, auditRef string, entity *Entity) error {
	headers := map[string]string{
		"Y-Audit-Ref": auditRef,
	}
	url := client.URL + "/domain/" + fmt.Sprint(domainName) + "/entity/" + fmt.Sprint(entityName)
	contentBytes, err := json.Marshal(entity)
	if err != nil {
		return err
	}
	resp, err := client.httpPut(url, headers, contentBytes)
	if err != nil {
		return err
	}
	contentBytes, err = ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return err
	}
	switch resp.StatusCode {
	case 204:
		return nil
	default:
		var errobj rdl.ResourceError
		json.Unmarshal(contentBytes, &errobj)
		if errobj.Code == 0 {
			errobj.Code = resp.StatusCode
		}
		if errobj.Message == "" {
			errobj.Message = string(contentBytes)
		}
		return errobj
	}
}

func (client ZMSClient) GetEntity(domainName DomainName, entityName EntityName) (*Entity, error) {
	var data *Entity
	url := client.URL + "/domain/" + fmt.Sprint(domainName) + "/entity/" + fmt.Sprint(entityName)
	resp, err := client.httpGet(url, nil)
	if err != nil {
		return data, err
	}
	contentBytes, err := ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return data, err
	}
	switch resp.StatusCode {
	case 200:
		err = json.Unmarshal(contentBytes, &data)
		if err != nil {
			return data, err
		}
		return data, nil
	default:
		var errobj rdl.ResourceError
		json.Unmarshal(contentBytes, &errobj)
		if errobj.Code == 0 {
			errobj.Code = resp.StatusCode
		}
		if errobj.Message == "" {
			errobj.Message = string(contentBytes)
		}
		return data, errobj
	}
}

func (client ZMSClient) DeleteEntity(domainName DomainName, entityName EntityName, auditRef string) error {
	headers := map[string]string{
		"Y-Audit-Ref": auditRef,
	}
	url := client.URL + "/domain/" + fmt.Sprint(domainName) + "/entity/" + fmt.Sprint(entityName)
	resp, err := client.httpDelete(url, headers)
	if err != nil {
		return err
	}
	contentBytes, err := ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return err
	}
	switch resp.StatusCode {
	case 204:
		return nil
	default:
		var errobj rdl.ResourceError
		json.Unmarshal(contentBytes, &errobj)
		if errobj.Code == 0 {
			errobj.Code = resp.StatusCode
		}
		if errobj.Message == "" {
			errobj.Message = string(contentBytes)
		}
		return errobj
	}
}

func (client ZMSClient) GetEntityList(domainName DomainName) (*EntityList, error) {
	var data *EntityList
	url := client.URL + "/domain/" + fmt.Sprint(domainName) + "/entity"
	resp, err := client.httpGet(url, nil)
	if err != nil {
		return data, err
	}
	contentBytes, err := ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return data, err
	}
	switch resp.StatusCode {
	case 200:
		err = json.Unmarshal(contentBytes, &data)
		if err != nil {
			return data, err
		}
		return data, nil
	default:
		var errobj rdl.ResourceError
		json.Unmarshal(contentBytes, &errobj)
		if errobj.Code == 0 {
			errobj.Code = resp.StatusCode
		}
		if errobj.Message == "" {
			errobj.Message = string(contentBytes)
		}
		return data, errobj
	}
}

func (client ZMSClient) GetRoleList(domainName DomainName, limit *int32, skip string) (*RoleList, error) {
	var data *RoleList
	url := client.URL + "/domain/" + fmt.Sprint(domainName) + "/role" + encodeParams(encodeOptionalInt32Param("limit", limit), encodeStringParam("skip", string(skip), ""))
	resp, err := client.httpGet(url, nil)
	if err != nil {
		return data, err
	}
	contentBytes, err := ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return data, err
	}
	switch resp.StatusCode {
	case 200:
		err = json.Unmarshal(contentBytes, &data)
		if err != nil {
			return data, err
		}
		return data, nil
	default:
		var errobj rdl.ResourceError
		json.Unmarshal(contentBytes, &errobj)
		if errobj.Code == 0 {
			errobj.Code = resp.StatusCode
		}
		if errobj.Message == "" {
			errobj.Message = string(contentBytes)
		}
		return data, errobj
	}
}

func (client ZMSClient) GetRoles(domainName DomainName, members *bool) (*Roles, error) {
	var data *Roles
	url := client.URL + "/domain/" + fmt.Sprint(domainName) + "/roles" + encodeParams(encodeOptionalBoolParam("members", members))
	resp, err := client.httpGet(url, nil)
	if err != nil {
		return data, err
	}
	contentBytes, err := ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return data, err
	}
	switch resp.StatusCode {
	case 200:
		err = json.Unmarshal(contentBytes, &data)
		if err != nil {
			return data, err
		}
		return data, nil
	default:
		var errobj rdl.ResourceError
		json.Unmarshal(contentBytes, &errobj)
		if errobj.Code == 0 {
			errobj.Code = resp.StatusCode
		}
		if errobj.Message == "" {
			errobj.Message = string(contentBytes)
		}
		return data, errobj
	}
}

func (client ZMSClient) GetRole(domainName DomainName, roleName EntityName, auditLog *bool, expand *bool) (*Role, error) {
	var data *Role
	url := client.URL + "/domain/" + fmt.Sprint(domainName) + "/role/" + fmt.Sprint(roleName) + encodeParams(encodeOptionalBoolParam("auditLog", auditLog), encodeOptionalBoolParam("expand", expand))
	resp, err := client.httpGet(url, nil)
	if err != nil {
		return data, err
	}
	contentBytes, err := ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return data, err
	}
	switch resp.StatusCode {
	case 200:
		err = json.Unmarshal(contentBytes, &data)
		if err != nil {
			return data, err
		}
		return data, nil
	default:
		var errobj rdl.ResourceError
		json.Unmarshal(contentBytes, &errobj)
		if errobj.Code == 0 {
			errobj.Code = resp.StatusCode
		}
		if errobj.Message == "" {
			errobj.Message = string(contentBytes)
		}
		return data, errobj
	}
}

func (client ZMSClient) PutRole(domainName DomainName, roleName EntityName, auditRef string, role *Role) error {
	headers := map[string]string{
		"Y-Audit-Ref": auditRef,
	}
	url := client.URL + "/domain/" + fmt.Sprint(domainName) + "/role/" + fmt.Sprint(roleName)
	contentBytes, err := json.Marshal(role)
	if err != nil {
		return err
	}
	resp, err := client.httpPut(url, headers, contentBytes)
	if err != nil {
		return err
	}
	contentBytes, err = ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return err
	}
	switch resp.StatusCode {
	case 204:
		return nil
	default:
		var errobj rdl.ResourceError
		json.Unmarshal(contentBytes, &errobj)
		if errobj.Code == 0 {
			errobj.Code = resp.StatusCode
		}
		if errobj.Message == "" {
			errobj.Message = string(contentBytes)
		}
		return errobj
	}
}

func (client ZMSClient) DeleteRole(domainName DomainName, roleName EntityName, auditRef string) error {
	headers := map[string]string{
		"Y-Audit-Ref": auditRef,
	}
	url := client.URL + "/domain/" + fmt.Sprint(domainName) + "/role/" + fmt.Sprint(roleName)
	resp, err := client.httpDelete(url, headers)
	if err != nil {
		return err
	}
	contentBytes, err := ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return err
	}
	switch resp.StatusCode {
	case 204:
		return nil
	default:
		var errobj rdl.ResourceError
		json.Unmarshal(contentBytes, &errobj)
		if errobj.Code == 0 {
			errobj.Code = resp.StatusCode
		}
		if errobj.Message == "" {
			errobj.Message = string(contentBytes)
		}
		return errobj
	}
}

func (client ZMSClient) GetMembership(domainName DomainName, roleName EntityName, memberName MemberName) (*Membership, error) {
	var data *Membership
	url := client.URL + "/domain/" + fmt.Sprint(domainName) + "/role/" + fmt.Sprint(roleName) + "/member/" + fmt.Sprint(memberName)
	resp, err := client.httpGet(url, nil)
	if err != nil {
		return data, err
	}
	contentBytes, err := ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return data, err
	}
	switch resp.StatusCode {
	case 200:
		err = json.Unmarshal(contentBytes, &data)
		if err != nil {
			return data, err
		}
		return data, nil
	default:
		var errobj rdl.ResourceError
		json.Unmarshal(contentBytes, &errobj)
		if errobj.Code == 0 {
			errobj.Code = resp.StatusCode
		}
		if errobj.Message == "" {
			errobj.Message = string(contentBytes)
		}
		return data, errobj
	}
}

func (client ZMSClient) PutMembership(domainName DomainName, roleName EntityName, memberName MemberName, auditRef string, membership *Membership) error {
	headers := map[string]string{
		"Y-Audit-Ref": auditRef,
	}
	url := client.URL + "/domain/" + fmt.Sprint(domainName) + "/role/" + fmt.Sprint(roleName) + "/member/" + fmt.Sprint(memberName)
	contentBytes, err := json.Marshal(membership)
	if err != nil {
		return err
	}
	resp, err := client.httpPut(url, headers, contentBytes)
	if err != nil {
		return err
	}
	contentBytes, err = ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return err
	}
	switch resp.StatusCode {
	case 204:
		return nil
	default:
		var errobj rdl.ResourceError
		json.Unmarshal(contentBytes, &errobj)
		if errobj.Code == 0 {
			errobj.Code = resp.StatusCode
		}
		if errobj.Message == "" {
			errobj.Message = string(contentBytes)
		}
		return errobj
	}
}

func (client ZMSClient) DeleteMembership(domainName DomainName, roleName EntityName, memberName MemberName, auditRef string) error {
	headers := map[string]string{
		"Y-Audit-Ref": auditRef,
	}
	url := client.URL + "/domain/" + fmt.Sprint(domainName) + "/role/" + fmt.Sprint(roleName) + "/member/" + fmt.Sprint(memberName)
	resp, err := client.httpDelete(url, headers)
	if err != nil {
		return err
	}
	contentBytes, err := ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return err
	}
	switch resp.StatusCode {
	case 204:
		return nil
	default:
		var errobj rdl.ResourceError
		json.Unmarshal(contentBytes, &errobj)
		if errobj.Code == 0 {
			errobj.Code = resp.StatusCode
		}
		if errobj.Message == "" {
			errobj.Message = string(contentBytes)
		}
		return errobj
	}
}

func (client ZMSClient) PutDefaultAdmins(domainName DomainName, auditRef string, defaultAdmins *DefaultAdmins) error {
	headers := map[string]string{
		"Y-Audit-Ref": auditRef,
	}
	url := client.URL + "/domain/" + fmt.Sprint(domainName) + "/admins"
	contentBytes, err := json.Marshal(defaultAdmins)
	if err != nil {
		return err
	}
	resp, err := client.httpPut(url, headers, contentBytes)
	if err != nil {
		return err
	}
	contentBytes, err = ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return err
	}
	switch resp.StatusCode {
	case 204:
		return nil
	default:
		var errobj rdl.ResourceError
		json.Unmarshal(contentBytes, &errobj)
		if errobj.Code == 0 {
			errobj.Code = resp.StatusCode
		}
		if errobj.Message == "" {
			errobj.Message = string(contentBytes)
		}
		return errobj
	}
}

func (client ZMSClient) GetPolicyList(domainName DomainName, limit *int32, skip string) (*PolicyList, error) {
	var data *PolicyList
	url := client.URL + "/domain/" + fmt.Sprint(domainName) + "/policy" + encodeParams(encodeOptionalInt32Param("limit", limit), encodeStringParam("skip", string(skip), ""))
	resp, err := client.httpGet(url, nil)
	if err != nil {
		return data, err
	}
	contentBytes, err := ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return data, err
	}
	switch resp.StatusCode {
	case 200:
		err = json.Unmarshal(contentBytes, &data)
		if err != nil {
			return data, err
		}
		return data, nil
	default:
		var errobj rdl.ResourceError
		json.Unmarshal(contentBytes, &errobj)
		if errobj.Code == 0 {
			errobj.Code = resp.StatusCode
		}
		if errobj.Message == "" {
			errobj.Message = string(contentBytes)
		}
		return data, errobj
	}
}

func (client ZMSClient) GetPolicies(domainName DomainName, assertions *bool) (*Policies, error) {
	var data *Policies
	url := client.URL + "/domain/" + fmt.Sprint(domainName) + "/policies" + encodeParams(encodeOptionalBoolParam("assertions", assertions))
	resp, err := client.httpGet(url, nil)
	if err != nil {
		return data, err
	}
	contentBytes, err := ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return data, err
	}
	switch resp.StatusCode {
	case 200:
		err = json.Unmarshal(contentBytes, &data)
		if err != nil {
			return data, err
		}
		return data, nil
	default:
		var errobj rdl.ResourceError
		json.Unmarshal(contentBytes, &errobj)
		if errobj.Code == 0 {
			errobj.Code = resp.StatusCode
		}
		if errobj.Message == "" {
			errobj.Message = string(contentBytes)
		}
		return data, errobj
	}
}

func (client ZMSClient) GetPolicy(domainName DomainName, policyName EntityName) (*Policy, error) {
	var data *Policy
	url := client.URL + "/domain/" + fmt.Sprint(domainName) + "/policy/" + fmt.Sprint(policyName)
	resp, err := client.httpGet(url, nil)
	if err != nil {
		return data, err
	}
	contentBytes, err := ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return data, err
	}
	switch resp.StatusCode {
	case 200:
		err = json.Unmarshal(contentBytes, &data)
		if err != nil {
			return data, err
		}
		return data, nil
	default:
		var errobj rdl.ResourceError
		json.Unmarshal(contentBytes, &errobj)
		if errobj.Code == 0 {
			errobj.Code = resp.StatusCode
		}
		if errobj.Message == "" {
			errobj.Message = string(contentBytes)
		}
		return data, errobj
	}
}

func (client ZMSClient) PutPolicy(domainName DomainName, policyName EntityName, auditRef string, policy *Policy) error {
	headers := map[string]string{
		"Y-Audit-Ref": auditRef,
	}
	url := client.URL + "/domain/" + fmt.Sprint(domainName) + "/policy/" + fmt.Sprint(policyName)
	contentBytes, err := json.Marshal(policy)
	if err != nil {
		return err
	}
	resp, err := client.httpPut(url, headers, contentBytes)
	if err != nil {
		return err
	}
	contentBytes, err = ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return err
	}
	switch resp.StatusCode {
	case 204:
		return nil
	default:
		var errobj rdl.ResourceError
		json.Unmarshal(contentBytes, &errobj)
		if errobj.Code == 0 {
			errobj.Code = resp.StatusCode
		}
		if errobj.Message == "" {
			errobj.Message = string(contentBytes)
		}
		return errobj
	}
}

func (client ZMSClient) DeletePolicy(domainName DomainName, policyName EntityName, auditRef string) error {
	headers := map[string]string{
		"Y-Audit-Ref": auditRef,
	}
	url := client.URL + "/domain/" + fmt.Sprint(domainName) + "/policy/" + fmt.Sprint(policyName)
	resp, err := client.httpDelete(url, headers)
	if err != nil {
		return err
	}
	contentBytes, err := ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return err
	}
	switch resp.StatusCode {
	case 204:
		return nil
	default:
		var errobj rdl.ResourceError
		json.Unmarshal(contentBytes, &errobj)
		if errobj.Code == 0 {
			errobj.Code = resp.StatusCode
		}
		if errobj.Message == "" {
			errobj.Message = string(contentBytes)
		}
		return errobj
	}
}

func (client ZMSClient) GetAssertion(domainName DomainName, policyName EntityName, assertionId int64) (*Assertion, error) {
	var data *Assertion
	url := client.URL + "/domain/" + fmt.Sprint(domainName) + "/policy/" + fmt.Sprint(policyName) + "/assertion/" + fmt.Sprint(assertionId)
	resp, err := client.httpGet(url, nil)
	if err != nil {
		return data, err
	}
	contentBytes, err := ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return data, err
	}
	switch resp.StatusCode {
	case 200:
		err = json.Unmarshal(contentBytes, &data)
		if err != nil {
			return data, err
		}
		return data, nil
	default:
		var errobj rdl.ResourceError
		json.Unmarshal(contentBytes, &errobj)
		if errobj.Code == 0 {
			errobj.Code = resp.StatusCode
		}
		if errobj.Message == "" {
			errobj.Message = string(contentBytes)
		}
		return data, errobj
	}
}

func (client ZMSClient) PutAssertion(domainName DomainName, policyName EntityName, auditRef string, assertion *Assertion) (*Assertion, error) {
	var data *Assertion
	headers := map[string]string{
		"Y-Audit-Ref": auditRef,
	}
	url := client.URL + "/domain/" + fmt.Sprint(domainName) + "/policy/" + fmt.Sprint(policyName) + "/assertion"
	contentBytes, err := json.Marshal(assertion)
	if err != nil {
		return data, err
	}
	resp, err := client.httpPut(url, headers, contentBytes)
	if err != nil {
		return data, err
	}
	contentBytes, err = ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return data, err
	}
	switch resp.StatusCode {
	case 200, 201:
		err = json.Unmarshal(contentBytes, &data)
		if err != nil {
			return data, err
		}
		return data, nil
	default:
		var errobj rdl.ResourceError
		json.Unmarshal(contentBytes, &errobj)
		if errobj.Code == 0 {
			errobj.Code = resp.StatusCode
		}
		if errobj.Message == "" {
			errobj.Message = string(contentBytes)
		}
		return data, errobj
	}
}

func (client ZMSClient) DeleteAssertion(domainName DomainName, policyName EntityName, assertionId int64, auditRef string) error {
	headers := map[string]string{
		"Y-Audit-Ref": auditRef,
	}
	url := client.URL + "/domain/" + fmt.Sprint(domainName) + "/policy/" + fmt.Sprint(policyName) + "/assertion/" + fmt.Sprint(assertionId)
	resp, err := client.httpDelete(url, headers)
	if err != nil {
		return err
	}
	contentBytes, err := ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return err
	}
	switch resp.StatusCode {
	case 204:
		return nil
	default:
		var errobj rdl.ResourceError
		json.Unmarshal(contentBytes, &errobj)
		if errobj.Code == 0 {
			errobj.Code = resp.StatusCode
		}
		if errobj.Message == "" {
			errobj.Message = string(contentBytes)
		}
		return errobj
	}
}

func (client ZMSClient) PutServiceIdentity(domain DomainName, service SimpleName, auditRef string, detail *ServiceIdentity) error {
	headers := map[string]string{
		"Y-Audit-Ref": auditRef,
	}
	url := client.URL + "/domain/" + fmt.Sprint(domain) + "/service/" + fmt.Sprint(service)
	contentBytes, err := json.Marshal(detail)
	if err != nil {
		return err
	}
	resp, err := client.httpPut(url, headers, contentBytes)
	if err != nil {
		return err
	}
	contentBytes, err = ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return err
	}
	switch resp.StatusCode {
	case 204:
		return nil
	default:
		var errobj rdl.ResourceError
		json.Unmarshal(contentBytes, &errobj)
		if errobj.Code == 0 {
			errobj.Code = resp.StatusCode
		}
		if errobj.Message == "" {
			errobj.Message = string(contentBytes)
		}
		return errobj
	}
}

func (client ZMSClient) GetServiceIdentity(domain DomainName, service SimpleName) (*ServiceIdentity, error) {
	var data *ServiceIdentity
	url := client.URL + "/domain/" + fmt.Sprint(domain) + "/service/" + fmt.Sprint(service)
	resp, err := client.httpGet(url, nil)
	if err != nil {
		return data, err
	}
	contentBytes, err := ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return data, err
	}
	switch resp.StatusCode {
	case 200:
		err = json.Unmarshal(contentBytes, &data)
		if err != nil {
			return data, err
		}
		return data, nil
	default:
		var errobj rdl.ResourceError
		json.Unmarshal(contentBytes, &errobj)
		if errobj.Code == 0 {
			errobj.Code = resp.StatusCode
		}
		if errobj.Message == "" {
			errobj.Message = string(contentBytes)
		}
		return data, errobj
	}
}

func (client ZMSClient) DeleteServiceIdentity(domain DomainName, service SimpleName, auditRef string) error {
	headers := map[string]string{
		"Y-Audit-Ref": auditRef,
	}
	url := client.URL + "/domain/" + fmt.Sprint(domain) + "/service/" + fmt.Sprint(service)
	resp, err := client.httpDelete(url, headers)
	if err != nil {
		return err
	}
	contentBytes, err := ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return err
	}
	switch resp.StatusCode {
	case 204:
		return nil
	default:
		var errobj rdl.ResourceError
		json.Unmarshal(contentBytes, &errobj)
		if errobj.Code == 0 {
			errobj.Code = resp.StatusCode
		}
		if errobj.Message == "" {
			errobj.Message = string(contentBytes)
		}
		return errobj
	}
}

func (client ZMSClient) GetServiceIdentities(domainName DomainName, publickeys *bool, hosts *bool) (*ServiceIdentities, error) {
	var data *ServiceIdentities
	url := client.URL + "/domain/" + fmt.Sprint(domainName) + "/services" + encodeParams(encodeOptionalBoolParam("publickeys", publickeys), encodeOptionalBoolParam("hosts", hosts))
	resp, err := client.httpGet(url, nil)
	if err != nil {
		return data, err
	}
	contentBytes, err := ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return data, err
	}
	switch resp.StatusCode {
	case 200:
		err = json.Unmarshal(contentBytes, &data)
		if err != nil {
			return data, err
		}
		return data, nil
	default:
		var errobj rdl.ResourceError
		json.Unmarshal(contentBytes, &errobj)
		if errobj.Code == 0 {
			errobj.Code = resp.StatusCode
		}
		if errobj.Message == "" {
			errobj.Message = string(contentBytes)
		}
		return data, errobj
	}
}

func (client ZMSClient) GetServiceIdentityList(domainName DomainName, limit *int32, skip string) (*ServiceIdentityList, error) {
	var data *ServiceIdentityList
	url := client.URL + "/domain/" + fmt.Sprint(domainName) + "/service" + encodeParams(encodeOptionalInt32Param("limit", limit), encodeStringParam("skip", string(skip), ""))
	resp, err := client.httpGet(url, nil)
	if err != nil {
		return data, err
	}
	contentBytes, err := ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return data, err
	}
	switch resp.StatusCode {
	case 200:
		err = json.Unmarshal(contentBytes, &data)
		if err != nil {
			return data, err
		}
		return data, nil
	default:
		var errobj rdl.ResourceError
		json.Unmarshal(contentBytes, &errobj)
		if errobj.Code == 0 {
			errobj.Code = resp.StatusCode
		}
		if errobj.Message == "" {
			errobj.Message = string(contentBytes)
		}
		return data, errobj
	}
}

func (client ZMSClient) GetPublicKeyEntry(domain DomainName, service SimpleName, id string) (*PublicKeyEntry, error) {
	var data *PublicKeyEntry
	url := client.URL + "/domain/" + fmt.Sprint(domain) + "/service/" + fmt.Sprint(service) + "/publickey/" + id
	resp, err := client.httpGet(url, nil)
	if err != nil {
		return data, err
	}
	contentBytes, err := ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return data, err
	}
	switch resp.StatusCode {
	case 200:
		err = json.Unmarshal(contentBytes, &data)
		if err != nil {
			return data, err
		}
		return data, nil
	default:
		var errobj rdl.ResourceError
		json.Unmarshal(contentBytes, &errobj)
		if errobj.Code == 0 {
			errobj.Code = resp.StatusCode
		}
		if errobj.Message == "" {
			errobj.Message = string(contentBytes)
		}
		return data, errobj
	}
}

func (client ZMSClient) PutPublicKeyEntry(domain DomainName, service SimpleName, id string, auditRef string, publicKeyEntry *PublicKeyEntry) error {
	headers := map[string]string{
		"Y-Audit-Ref": auditRef,
	}
	url := client.URL + "/domain/" + fmt.Sprint(domain) + "/service/" + fmt.Sprint(service) + "/publickey/" + id
	contentBytes, err := json.Marshal(publicKeyEntry)
	if err != nil {
		return err
	}
	resp, err := client.httpPut(url, headers, contentBytes)
	if err != nil {
		return err
	}
	contentBytes, err = ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return err
	}
	switch resp.StatusCode {
	case 204:
		return nil
	default:
		var errobj rdl.ResourceError
		json.Unmarshal(contentBytes, &errobj)
		if errobj.Code == 0 {
			errobj.Code = resp.StatusCode
		}
		if errobj.Message == "" {
			errobj.Message = string(contentBytes)
		}
		return errobj
	}
}

func (client ZMSClient) DeletePublicKeyEntry(domain DomainName, service SimpleName, id string, auditRef string) error {
	headers := map[string]string{
		"Y-Audit-Ref": auditRef,
	}
	url := client.URL + "/domain/" + fmt.Sprint(domain) + "/service/" + fmt.Sprint(service) + "/publickey/" + id
	resp, err := client.httpDelete(url, headers)
	if err != nil {
		return err
	}
	contentBytes, err := ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return err
	}
	switch resp.StatusCode {
	case 204:
		return nil
	default:
		var errobj rdl.ResourceError
		json.Unmarshal(contentBytes, &errobj)
		if errobj.Code == 0 {
			errobj.Code = resp.StatusCode
		}
		if errobj.Message == "" {
			errobj.Message = string(contentBytes)
		}
		return errobj
	}
}

func (client ZMSClient) PutTenancy(domain DomainName, service ServiceName, auditRef string, detail *Tenancy) error {
	headers := map[string]string{
		"Y-Audit-Ref": auditRef,
	}
	url := client.URL + "/domain/" + fmt.Sprint(domain) + "/tenancy/" + fmt.Sprint(service)
	contentBytes, err := json.Marshal(detail)
	if err != nil {
		return err
	}
	resp, err := client.httpPut(url, headers, contentBytes)
	if err != nil {
		return err
	}
	contentBytes, err = ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return err
	}
	switch resp.StatusCode {
	case 204:
		return nil
	default:
		var errobj rdl.ResourceError
		json.Unmarshal(contentBytes, &errobj)
		if errobj.Code == 0 {
			errobj.Code = resp.StatusCode
		}
		if errobj.Message == "" {
			errobj.Message = string(contentBytes)
		}
		return errobj
	}
}

func (client ZMSClient) GetTenancy(domain DomainName, service ServiceName) (*Tenancy, error) {
	var data *Tenancy
	url := client.URL + "/domain/" + fmt.Sprint(domain) + "/tenancy/" + fmt.Sprint(service)
	resp, err := client.httpGet(url, nil)
	if err != nil {
		return data, err
	}
	contentBytes, err := ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return data, err
	}
	switch resp.StatusCode {
	case 200:
		err = json.Unmarshal(contentBytes, &data)
		if err != nil {
			return data, err
		}
		return data, nil
	default:
		var errobj rdl.ResourceError
		json.Unmarshal(contentBytes, &errobj)
		if errobj.Code == 0 {
			errobj.Code = resp.StatusCode
		}
		if errobj.Message == "" {
			errobj.Message = string(contentBytes)
		}
		return data, errobj
	}
}

func (client ZMSClient) DeleteTenancy(domain DomainName, service ServiceName, auditRef string) error {
	headers := map[string]string{
		"Y-Audit-Ref": auditRef,
	}
	url := client.URL + "/domain/" + fmt.Sprint(domain) + "/tenancy/" + fmt.Sprint(service)
	resp, err := client.httpDelete(url, headers)
	if err != nil {
		return err
	}
	contentBytes, err := ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return err
	}
	switch resp.StatusCode {
	case 204:
		return nil
	default:
		var errobj rdl.ResourceError
		json.Unmarshal(contentBytes, &errobj)
		if errobj.Code == 0 {
			errobj.Code = resp.StatusCode
		}
		if errobj.Message == "" {
			errobj.Message = string(contentBytes)
		}
		return errobj
	}
}

func (client ZMSClient) PutTenancyResourceGroup(domain DomainName, service ServiceName, resourceGroup EntityName, auditRef string, detail *TenancyResourceGroup) error {
	headers := map[string]string{
		"Y-Audit-Ref": auditRef,
	}
	url := client.URL + "/domain/" + fmt.Sprint(domain) + "/tenancy/" + fmt.Sprint(service) + "/resourceGroup/" + fmt.Sprint(resourceGroup)
	contentBytes, err := json.Marshal(detail)
	if err != nil {
		return err
	}
	resp, err := client.httpPut(url, headers, contentBytes)
	if err != nil {
		return err
	}
	contentBytes, err = ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return err
	}
	switch resp.StatusCode {
	case 204:
		return nil
	default:
		var errobj rdl.ResourceError
		json.Unmarshal(contentBytes, &errobj)
		if errobj.Code == 0 {
			errobj.Code = resp.StatusCode
		}
		if errobj.Message == "" {
			errobj.Message = string(contentBytes)
		}
		return errobj
	}
}

func (client ZMSClient) DeleteTenancyResourceGroup(domain DomainName, service ServiceName, resourceGroup EntityName, auditRef string) error {
	headers := map[string]string{
		"Y-Audit-Ref": auditRef,
	}
	url := client.URL + "/domain/" + fmt.Sprint(domain) + "/tenancy/" + fmt.Sprint(service) + "/resourceGroup/" + fmt.Sprint(resourceGroup)
	resp, err := client.httpDelete(url, headers)
	if err != nil {
		return err
	}
	contentBytes, err := ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return err
	}
	switch resp.StatusCode {
	case 204:
		return nil
	default:
		var errobj rdl.ResourceError
		json.Unmarshal(contentBytes, &errobj)
		if errobj.Code == 0 {
			errobj.Code = resp.StatusCode
		}
		if errobj.Message == "" {
			errobj.Message = string(contentBytes)
		}
		return errobj
	}
}

func (client ZMSClient) PutTenantRoles(domain DomainName, service SimpleName, tenantDomain DomainName, auditRef string, detail *TenantRoles) (*TenantRoles, error) {
	var data *TenantRoles
	headers := map[string]string{
		"Y-Audit-Ref": auditRef,
	}
	url := client.URL + "/domain/" + fmt.Sprint(domain) + "/service/" + fmt.Sprint(service) + "/tenant/" + fmt.Sprint(tenantDomain)
	contentBytes, err := json.Marshal(detail)
	if err != nil {
		return data, err
	}
	resp, err := client.httpPut(url, headers, contentBytes)
	if err != nil {
		return data, err
	}
	contentBytes, err = ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return data, err
	}
	switch resp.StatusCode {
	case 200, 201:
		err = json.Unmarshal(contentBytes, &data)
		if err != nil {
			return data, err
		}
		return data, nil
	default:
		var errobj rdl.ResourceError
		json.Unmarshal(contentBytes, &errobj)
		if errobj.Code == 0 {
			errobj.Code = resp.StatusCode
		}
		if errobj.Message == "" {
			errobj.Message = string(contentBytes)
		}
		return data, errobj
	}
}

func (client ZMSClient) GetTenantRoles(domain DomainName, service SimpleName, tenantDomain DomainName) (*TenantRoles, error) {
	var data *TenantRoles
	url := client.URL + "/domain/" + fmt.Sprint(domain) + "/service/" + fmt.Sprint(service) + "/tenant/" + fmt.Sprint(tenantDomain)
	resp, err := client.httpGet(url, nil)
	if err != nil {
		return data, err
	}
	contentBytes, err := ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return data, err
	}
	switch resp.StatusCode {
	case 200:
		err = json.Unmarshal(contentBytes, &data)
		if err != nil {
			return data, err
		}
		return data, nil
	default:
		var errobj rdl.ResourceError
		json.Unmarshal(contentBytes, &errobj)
		if errobj.Code == 0 {
			errobj.Code = resp.StatusCode
		}
		if errobj.Message == "" {
			errobj.Message = string(contentBytes)
		}
		return data, errobj
	}
}

func (client ZMSClient) DeleteTenantRoles(domain DomainName, service SimpleName, tenantDomain DomainName, auditRef string) error {
	headers := map[string]string{
		"Y-Audit-Ref": auditRef,
	}
	url := client.URL + "/domain/" + fmt.Sprint(domain) + "/service/" + fmt.Sprint(service) + "/tenant/" + fmt.Sprint(tenantDomain)
	resp, err := client.httpDelete(url, headers)
	if err != nil {
		return err
	}
	contentBytes, err := ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return err
	}
	switch resp.StatusCode {
	case 204:
		return nil
	default:
		var errobj rdl.ResourceError
		json.Unmarshal(contentBytes, &errobj)
		if errobj.Code == 0 {
			errobj.Code = resp.StatusCode
		}
		if errobj.Message == "" {
			errobj.Message = string(contentBytes)
		}
		return errobj
	}
}

func (client ZMSClient) PutTenantResourceGroupRoles(domain DomainName, service SimpleName, tenantDomain DomainName, resourceGroup EntityName, auditRef string, detail *TenantResourceGroupRoles) (*TenantResourceGroupRoles, error) {
	var data *TenantResourceGroupRoles
	headers := map[string]string{
		"Y-Audit-Ref": auditRef,
	}
	url := client.URL + "/domain/" + fmt.Sprint(domain) + "/service/" + fmt.Sprint(service) + "/tenant/" + fmt.Sprint(tenantDomain) + "/resourceGroup/" + fmt.Sprint(resourceGroup)
	contentBytes, err := json.Marshal(detail)
	if err != nil {
		return data, err
	}
	resp, err := client.httpPut(url, headers, contentBytes)
	if err != nil {
		return data, err
	}
	contentBytes, err = ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return data, err
	}
	switch resp.StatusCode {
	case 200, 201:
		err = json.Unmarshal(contentBytes, &data)
		if err != nil {
			return data, err
		}
		return data, nil
	default:
		var errobj rdl.ResourceError
		json.Unmarshal(contentBytes, &errobj)
		if errobj.Code == 0 {
			errobj.Code = resp.StatusCode
		}
		if errobj.Message == "" {
			errobj.Message = string(contentBytes)
		}
		return data, errobj
	}
}

func (client ZMSClient) GetTenantResourceGroupRoles(domain DomainName, service SimpleName, tenantDomain DomainName, resourceGroup EntityName) (*TenantResourceGroupRoles, error) {
	var data *TenantResourceGroupRoles
	url := client.URL + "/domain/" + fmt.Sprint(domain) + "/service/" + fmt.Sprint(service) + "/tenant/" + fmt.Sprint(tenantDomain) + "/resourceGroup/" + fmt.Sprint(resourceGroup)
	resp, err := client.httpGet(url, nil)
	if err != nil {
		return data, err
	}
	contentBytes, err := ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return data, err
	}
	switch resp.StatusCode {
	case 200:
		err = json.Unmarshal(contentBytes, &data)
		if err != nil {
			return data, err
		}
		return data, nil
	default:
		var errobj rdl.ResourceError
		json.Unmarshal(contentBytes, &errobj)
		if errobj.Code == 0 {
			errobj.Code = resp.StatusCode
		}
		if errobj.Message == "" {
			errobj.Message = string(contentBytes)
		}
		return data, errobj
	}
}

func (client ZMSClient) DeleteTenantResourceGroupRoles(domain DomainName, service SimpleName, tenantDomain DomainName, resourceGroup EntityName, auditRef string) error {
	headers := map[string]string{
		"Y-Audit-Ref": auditRef,
	}
	url := client.URL + "/domain/" + fmt.Sprint(domain) + "/service/" + fmt.Sprint(service) + "/tenant/" + fmt.Sprint(tenantDomain) + "/resourceGroup/" + fmt.Sprint(resourceGroup)
	resp, err := client.httpDelete(url, headers)
	if err != nil {
		return err
	}
	contentBytes, err := ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return err
	}
	switch resp.StatusCode {
	case 204:
		return nil
	default:
		var errobj rdl.ResourceError
		json.Unmarshal(contentBytes, &errobj)
		if errobj.Code == 0 {
			errobj.Code = resp.StatusCode
		}
		if errobj.Message == "" {
			errobj.Message = string(contentBytes)
		}
		return errobj
	}
}

func (client ZMSClient) PutProviderResourceGroupRoles(tenantDomain DomainName, provDomain DomainName, provService SimpleName, resourceGroup EntityName, auditRef string, detail *ProviderResourceGroupRoles) (*ProviderResourceGroupRoles, error) {
	var data *ProviderResourceGroupRoles
	headers := map[string]string{
		"Y-Audit-Ref": auditRef,
	}
	url := client.URL + "/domain/" + fmt.Sprint(tenantDomain) + "/provDomain/" + fmt.Sprint(provDomain) + "/provService/" + fmt.Sprint(provService) + "/resourceGroup/" + fmt.Sprint(resourceGroup)
	contentBytes, err := json.Marshal(detail)
	if err != nil {
		return data, err
	}
	resp, err := client.httpPut(url, headers, contentBytes)
	if err != nil {
		return data, err
	}
	contentBytes, err = ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return data, err
	}
	switch resp.StatusCode {
	case 200, 201:
		err = json.Unmarshal(contentBytes, &data)
		if err != nil {
			return data, err
		}
		return data, nil
	default:
		var errobj rdl.ResourceError
		json.Unmarshal(contentBytes, &errobj)
		if errobj.Code == 0 {
			errobj.Code = resp.StatusCode
		}
		if errobj.Message == "" {
			errobj.Message = string(contentBytes)
		}
		return data, errobj
	}
}

func (client ZMSClient) GetProviderResourceGroupRoles(tenantDomain DomainName, provDomain DomainName, provService SimpleName, resourceGroup EntityName) (*ProviderResourceGroupRoles, error) {
	var data *ProviderResourceGroupRoles
	url := client.URL + "/domain/" + fmt.Sprint(tenantDomain) + "/provDomain/" + fmt.Sprint(provDomain) + "/provService/" + fmt.Sprint(provService) + "/resourceGroup/" + fmt.Sprint(resourceGroup)
	resp, err := client.httpGet(url, nil)
	if err != nil {
		return data, err
	}
	contentBytes, err := ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return data, err
	}
	switch resp.StatusCode {
	case 200:
		err = json.Unmarshal(contentBytes, &data)
		if err != nil {
			return data, err
		}
		return data, nil
	default:
		var errobj rdl.ResourceError
		json.Unmarshal(contentBytes, &errobj)
		if errobj.Code == 0 {
			errobj.Code = resp.StatusCode
		}
		if errobj.Message == "" {
			errobj.Message = string(contentBytes)
		}
		return data, errobj
	}
}

func (client ZMSClient) DeleteProviderResourceGroupRoles(tenantDomain DomainName, provDomain DomainName, provService SimpleName, resourceGroup EntityName, auditRef string) error {
	headers := map[string]string{
		"Y-Audit-Ref": auditRef,
	}
	url := client.URL + "/domain/" + fmt.Sprint(tenantDomain) + "/provDomain/" + fmt.Sprint(provDomain) + "/provService/" + fmt.Sprint(provService) + "/resourceGroup/" + fmt.Sprint(resourceGroup)
	resp, err := client.httpDelete(url, headers)
	if err != nil {
		return err
	}
	contentBytes, err := ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return err
	}
	switch resp.StatusCode {
	case 204:
		return nil
	default:
		var errobj rdl.ResourceError
		json.Unmarshal(contentBytes, &errobj)
		if errobj.Code == 0 {
			errobj.Code = resp.StatusCode
		}
		if errobj.Message == "" {
			errobj.Message = string(contentBytes)
		}
		return errobj
	}
}

func (client ZMSClient) GetAccess(action ActionName, resource ResourceName, domain DomainName, checkPrincipal EntityName) (*Access, error) {
	var data *Access
	url := client.URL + "/access/" + fmt.Sprint(action) + "/" + fmt.Sprint(resource) + encodeParams(encodeStringParam("domain", string(domain), ""), encodeStringParam("principal", string(checkPrincipal), ""))
	resp, err := client.httpGet(url, nil)
	if err != nil {
		return data, err
	}
	contentBytes, err := ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return data, err
	}
	switch resp.StatusCode {
	case 200:
		err = json.Unmarshal(contentBytes, &data)
		if err != nil {
			return data, err
		}
		return data, nil
	default:
		var errobj rdl.ResourceError
		json.Unmarshal(contentBytes, &errobj)
		if errobj.Code == 0 {
			errobj.Code = resp.StatusCode
		}
		if errobj.Message == "" {
			errobj.Message = string(contentBytes)
		}
		return data, errobj
	}
}

func (client ZMSClient) GetAccessExt(action ActionName, resource string, domain DomainName, checkPrincipal EntityName) (*Access, error) {
	var data *Access
	url := client.URL + "/access/" + fmt.Sprint(action) + encodeParams(encodeStringParam("resource", string(resource), ""), encodeStringParam("domain", string(domain), ""), encodeStringParam("principal", string(checkPrincipal), ""))
	resp, err := client.httpGet(url, nil)
	if err != nil {
		return data, err
	}
	contentBytes, err := ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return data, err
	}
	switch resp.StatusCode {
	case 200:
		err = json.Unmarshal(contentBytes, &data)
		if err != nil {
			return data, err
		}
		return data, nil
	default:
		var errobj rdl.ResourceError
		json.Unmarshal(contentBytes, &errobj)
		if errobj.Code == 0 {
			errobj.Code = resp.StatusCode
		}
		if errobj.Message == "" {
			errobj.Message = string(contentBytes)
		}
		return data, errobj
	}
}

func (client ZMSClient) GetResourceAccessList(principal EntityName, action ActionName) (*ResourceAccessList, error) {
	var data *ResourceAccessList
	url := client.URL + "/resource" + encodeParams(encodeStringParam("principal", string(principal), ""), encodeStringParam("action", string(action), ""))
	resp, err := client.httpGet(url, nil)
	if err != nil {
		return data, err
	}
	contentBytes, err := ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return data, err
	}
	switch resp.StatusCode {
	case 200:
		err = json.Unmarshal(contentBytes, &data)
		if err != nil {
			return data, err
		}
		return data, nil
	default:
		var errobj rdl.ResourceError
		json.Unmarshal(contentBytes, &errobj)
		if errobj.Code == 0 {
			errobj.Code = resp.StatusCode
		}
		if errobj.Message == "" {
			errobj.Message = string(contentBytes)
		}
		return data, errobj
	}
}

func (client ZMSClient) GetSignedDomains(domain DomainName, metaOnly string, matchingTag string) (*SignedDomains, string, error) {
	var data *SignedDomains
	headers := map[string]string{
		"If-None-Match": matchingTag,
	}
	url := client.URL + "/sys/modified_domains" + encodeParams(encodeStringParam("domain", string(domain), ""), encodeStringParam("metaonly", string(metaOnly), ""))
	resp, err := client.httpGet(url, headers)
	if err != nil {
		return nil, "", err
	}
	contentBytes, err := ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return nil, "", err
	}
	switch resp.StatusCode {
	case 200, 304:
		if 304 != resp.StatusCode {
			err = json.Unmarshal(contentBytes, &data)
			if err != nil {
				return nil, "", err
			}
		}
		tag := resp.Header.Get(rdl.FoldHttpHeaderName("ETag"))
		return data, tag, nil
	default:
		var errobj rdl.ResourceError
		json.Unmarshal(contentBytes, &errobj)
		if errobj.Code == 0 {
			errobj.Code = resp.StatusCode
		}
		if errobj.Message == "" {
			errobj.Message = string(contentBytes)
		}
		return nil, "", errobj
	}
}

func (client ZMSClient) GetUserToken(userName SimpleName, serviceNames string, header *bool) (*UserToken, error) {
	var data *UserToken
	url := client.URL + "/user/" + fmt.Sprint(userName) + "/token" + encodeParams(encodeStringParam("services", string(serviceNames), ""), encodeOptionalBoolParam("header", header))
	resp, err := client.httpGet(url, nil)
	if err != nil {
		return data, err
	}
	contentBytes, err := ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return data, err
	}
	switch resp.StatusCode {
	case 200:
		err = json.Unmarshal(contentBytes, &data)
		if err != nil {
			return data, err
		}
		return data, nil
	default:
		var errobj rdl.ResourceError
		json.Unmarshal(contentBytes, &errobj)
		if errobj.Code == 0 {
			errobj.Code = resp.StatusCode
		}
		if errobj.Message == "" {
			errobj.Message = string(contentBytes)
		}
		return data, errobj
	}
}

func (client ZMSClient) OptionsUserToken(userName SimpleName, serviceNames string) (*UserToken, error) {
	var data *UserToken
	url := client.URL + "/user/" + fmt.Sprint(userName) + "/token" + encodeParams(encodeStringParam("services", string(serviceNames), ""))
	resp, err := client.httpOptions(url, nil, nil)
	if err != nil {
		return data, err
	}
	contentBytes, err := ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return data, err
	}
	switch resp.StatusCode {
	case 200:
		err = json.Unmarshal(contentBytes, &data)
		if err != nil {
			return data, err
		}
		return data, nil
	default:
		var errobj rdl.ResourceError
		json.Unmarshal(contentBytes, &errobj)
		if errobj.Code == 0 {
			errobj.Code = resp.StatusCode
		}
		if errobj.Message == "" {
			errobj.Message = string(contentBytes)
		}
		return data, errobj
	}
}

func (client ZMSClient) GetServicePrincipal() (*ServicePrincipal, error) {
	var data *ServicePrincipal
	url := client.URL + "/principal"
	resp, err := client.httpGet(url, nil)
	if err != nil {
		return data, err
	}
	contentBytes, err := ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return data, err
	}
	switch resp.StatusCode {
	case 200:
		err = json.Unmarshal(contentBytes, &data)
		if err != nil {
			return data, err
		}
		return data, nil
	default:
		var errobj rdl.ResourceError
		json.Unmarshal(contentBytes, &errobj)
		if errobj.Code == 0 {
			errobj.Code = resp.StatusCode
		}
		if errobj.Message == "" {
			errobj.Message = string(contentBytes)
		}
		return data, errobj
	}
}

func (client ZMSClient) GetServerTemplateList() (*ServerTemplateList, error) {
	var data *ServerTemplateList
	url := client.URL + "/template"
	resp, err := client.httpGet(url, nil)
	if err != nil {
		return data, err
	}
	contentBytes, err := ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return data, err
	}
	switch resp.StatusCode {
	case 200:
		err = json.Unmarshal(contentBytes, &data)
		if err != nil {
			return data, err
		}
		return data, nil
	default:
		var errobj rdl.ResourceError
		json.Unmarshal(contentBytes, &errobj)
		if errobj.Code == 0 {
			errobj.Code = resp.StatusCode
		}
		if errobj.Message == "" {
			errobj.Message = string(contentBytes)
		}
		return data, errobj
	}
}

func (client ZMSClient) GetTemplate(template SimpleName) (*Template, error) {
	var data *Template
	url := client.URL + "/template/" + fmt.Sprint(template)
	resp, err := client.httpGet(url, nil)
	if err != nil {
		return data, err
	}
	contentBytes, err := ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return data, err
	}
	switch resp.StatusCode {
	case 200:
		err = json.Unmarshal(contentBytes, &data)
		if err != nil {
			return data, err
		}
		return data, nil
	default:
		var errobj rdl.ResourceError
		json.Unmarshal(contentBytes, &errobj)
		if errobj.Code == 0 {
			errobj.Code = resp.StatusCode
		}
		if errobj.Message == "" {
			errobj.Message = string(contentBytes)
		}
		return data, errobj
	}
}

func (client ZMSClient) GetUserList() (*UserList, error) {
	var data *UserList
	url := client.URL + "/user"
	resp, err := client.httpGet(url, nil)
	if err != nil {
		return data, err
	}
	contentBytes, err := ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return data, err
	}
	switch resp.StatusCode {
	case 200:
		err = json.Unmarshal(contentBytes, &data)
		if err != nil {
			return data, err
		}
		return data, nil
	default:
		var errobj rdl.ResourceError
		json.Unmarshal(contentBytes, &errobj)
		if errobj.Code == 0 {
			errobj.Code = resp.StatusCode
		}
		if errobj.Message == "" {
			errobj.Message = string(contentBytes)
		}
		return data, errobj
	}
}

func (client ZMSClient) DeleteUser(name SimpleName, auditRef string) error {
	headers := map[string]string{
		"Y-Audit-Ref": auditRef,
	}
	url := client.URL + "/user/" + fmt.Sprint(name)
	resp, err := client.httpDelete(url, headers)
	if err != nil {
		return err
	}
	contentBytes, err := ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return err
	}
	switch resp.StatusCode {
	case 204:
		return nil
	default:
		var errobj rdl.ResourceError
		json.Unmarshal(contentBytes, &errobj)
		if errobj.Code == 0 {
			errobj.Code = resp.StatusCode
		}
		if errobj.Message == "" {
			errobj.Message = string(contentBytes)
		}
		return errobj
	}
}

func (client ZMSClient) GetQuota(name DomainName) (*Quota, error) {
	var data *Quota
	url := client.URL + "/domain/" + fmt.Sprint(name) + "/quota"
	resp, err := client.httpGet(url, nil)
	if err != nil {
		return data, err
	}
	contentBytes, err := ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return data, err
	}
	switch resp.StatusCode {
	case 200:
		err = json.Unmarshal(contentBytes, &data)
		if err != nil {
			return data, err
		}
		return data, nil
	default:
		var errobj rdl.ResourceError
		json.Unmarshal(contentBytes, &errobj)
		if errobj.Code == 0 {
			errobj.Code = resp.StatusCode
		}
		if errobj.Message == "" {
			errobj.Message = string(contentBytes)
		}
		return data, errobj
	}
}

func (client ZMSClient) PutQuota(name DomainName, auditRef string, quota *Quota) error {
	headers := map[string]string{
		"Y-Audit-Ref": auditRef,
	}
	url := client.URL + "/domain/" + fmt.Sprint(name) + "/quota"
	contentBytes, err := json.Marshal(quota)
	if err != nil {
		return err
	}
	resp, err := client.httpPut(url, headers, contentBytes)
	if err != nil {
		return err
	}
	contentBytes, err = ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return err
	}
	switch resp.StatusCode {
	case 204:
		return nil
	default:
		var errobj rdl.ResourceError
		json.Unmarshal(contentBytes, &errobj)
		if errobj.Code == 0 {
			errobj.Code = resp.StatusCode
		}
		if errobj.Message == "" {
			errobj.Message = string(contentBytes)
		}
		return errobj
	}
}

func (client ZMSClient) DeleteQuota(name DomainName, auditRef string) error {
	headers := map[string]string{
		"Y-Audit-Ref": auditRef,
	}
	url := client.URL + "/domain/" + fmt.Sprint(name) + "/quota"
	resp, err := client.httpDelete(url, headers)
	if err != nil {
		return err
	}
	contentBytes, err := ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return err
	}
	switch resp.StatusCode {
	case 204:
		return nil
	default:
		var errobj rdl.ResourceError
		json.Unmarshal(contentBytes, &errobj)
		if errobj.Code == 0 {
			errobj.Code = resp.StatusCode
		}
		if errobj.Message == "" {
			errobj.Message = string(contentBytes)
		}
		return errobj
	}
}

func (client ZMSClient) GetStatus() (*Status, error) {
	var data *Status
	url := client.URL + "/status"
	resp, err := client.httpGet(url, nil)
	if err != nil {
		return data, err
	}
	contentBytes, err := ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return data, err
	}
	switch resp.StatusCode {
	case 200:
		err = json.Unmarshal(contentBytes, &data)
		if err != nil {
			return data, err
		}
		return data, nil
	default:
		var errobj rdl.ResourceError
		json.Unmarshal(contentBytes, &errobj)
		if errobj.Code == 0 {
			errobj.Code = resp.StatusCode
		}
		if errobj.Message == "" {
			errobj.Message = string(contentBytes)
		}
		return data, errobj
	}
}
