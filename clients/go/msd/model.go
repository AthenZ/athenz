//
// Code generated by rdl 1.5.2 DO NOT EDIT.
//

package msd

import (
	"encoding/json"
	"fmt"
	rdl "github.com/ardielle/ardielle-go/rdl"
)

var _ = rdl.Version
var _ = json.Marshal
var _ = fmt.Printf

//
// SimpleName - Copyright The Athenz Authors Licensed under the terms of the
// Apache version 2.0 license. See LICENSE file for terms. Common name types
// used by several API definitions A simple identifier, an element of compound
// name.
//
type SimpleName string

//
// CompoundName - A compound name. Most names in this API are compound names.
//
type CompoundName string

//
// DomainName - A domain name is the general qualifier prefix, as its
// uniqueness is managed.
//
type DomainName string

//
// EntityName - An entity name is a short form of a resource name, including
// only the domain and entity.
//
type EntityName string

//
// EntityList - An Entity list is comma separated compound Names
//
type EntityList string

//
// ServiceName - A service name will generally be a unique subdomain.
//
type ServiceName string

//
// ActionName - An action (operation) name.
//
type ActionName string

//
// ResourceName - A resource name Note that the EntityName part is optional,
// that is, a domain name followed by a colon is valid resource name.
//
type ResourceName string

//
// YBase64 - The Y-specific URL-safe Base64 variant.
//
type YBase64 string

//
// YEncoded - YEncoded includes ybase64 chars, as well as = and %. This can
// represent a user cookie and URL-encoded values.
//
type YEncoded string

//
// AuthorityName - Used as the prefix in a signed assertion. This uniquely
// identifies a signing authority.
//
type AuthorityName string

//
// PathElement - A uri-safe path element
//
type PathElement string

//
// TransportPolicySubjectDomainName - DomainName in TransportPolicySubject
// should allow * to indicate ANY
//
type TransportPolicySubjectDomainName string

//
// TransportPolicySubjectServiceName - ServiceName in TransportPolicySubject
// should allow * to indicate ANY
//
type TransportPolicySubjectServiceName string

//
// TransportPolicyEnforcementState - Types of transport policy enforcement
// states
//
type TransportPolicyEnforcementState int

//
// TransportPolicyEnforcementState constants
//
const (
	_ TransportPolicyEnforcementState = iota
	ENFORCE
	REPORT
)

var namesTransportPolicyEnforcementState = []string{
	ENFORCE: "ENFORCE",
	REPORT:  "REPORT",
}

//
// NewTransportPolicyEnforcementState - return a string representation of the enum
//
func NewTransportPolicyEnforcementState(init ...interface{}) TransportPolicyEnforcementState {
	if len(init) == 1 {
		switch v := init[0].(type) {
		case TransportPolicyEnforcementState:
			return v
		case int:
			return TransportPolicyEnforcementState(v)
		case int32:
			return TransportPolicyEnforcementState(v)
		case string:
			for i, s := range namesTransportPolicyEnforcementState {
				if s == v {
					return TransportPolicyEnforcementState(i)
				}
			}
		default:
			panic("Bad init value for TransportPolicyEnforcementState enum")
		}
	}
	return TransportPolicyEnforcementState(0) //default to the first enum value
}

//
// String - return a string representation of the enum
//
func (e TransportPolicyEnforcementState) String() string {
	return namesTransportPolicyEnforcementState[e]
}

//
// SymbolSet - return an array of all valid string representations (symbols) of the enum
//
func (e TransportPolicyEnforcementState) SymbolSet() []string {
	return namesTransportPolicyEnforcementState
}

//
// MarshalJSON is defined for proper JSON encoding of a TransportPolicyEnforcementState
//
func (e TransportPolicyEnforcementState) MarshalJSON() ([]byte, error) {
	return json.Marshal(e.String())
}

//
// UnmarshalJSON is defined for proper JSON decoding of a TransportPolicyEnforcementState
//
func (e *TransportPolicyEnforcementState) UnmarshalJSON(b []byte) error {
	var j string
	err := json.Unmarshal(b, &j)
	if err == nil {
		s := string(j)
		for v, s2 := range namesTransportPolicyEnforcementState {
			if s == s2 {
				*e = TransportPolicyEnforcementState(v)
				return nil
			}
		}
		err = fmt.Errorf("Bad enum symbol for type TransportPolicyEnforcementState: %s", s)
	}
	return err
}

//
// TransportPolicyProtocol - Types of transport policy protocols
//
type TransportPolicyProtocol int

//
// TransportPolicyProtocol constants
//
const (
	_ TransportPolicyProtocol = iota
	TCP
	UDP
)

var namesTransportPolicyProtocol = []string{
	TCP: "TCP",
	UDP: "UDP",
}

//
// NewTransportPolicyProtocol - return a string representation of the enum
//
func NewTransportPolicyProtocol(init ...interface{}) TransportPolicyProtocol {
	if len(init) == 1 {
		switch v := init[0].(type) {
		case TransportPolicyProtocol:
			return v
		case int:
			return TransportPolicyProtocol(v)
		case int32:
			return TransportPolicyProtocol(v)
		case string:
			for i, s := range namesTransportPolicyProtocol {
				if s == v {
					return TransportPolicyProtocol(i)
				}
			}
		default:
			panic("Bad init value for TransportPolicyProtocol enum")
		}
	}
	return TransportPolicyProtocol(0) //default to the first enum value
}

//
// String - return a string representation of the enum
//
func (e TransportPolicyProtocol) String() string {
	return namesTransportPolicyProtocol[e]
}

//
// SymbolSet - return an array of all valid string representations (symbols) of the enum
//
func (e TransportPolicyProtocol) SymbolSet() []string {
	return namesTransportPolicyProtocol
}

//
// MarshalJSON is defined for proper JSON encoding of a TransportPolicyProtocol
//
func (e TransportPolicyProtocol) MarshalJSON() ([]byte, error) {
	return json.Marshal(e.String())
}

//
// UnmarshalJSON is defined for proper JSON decoding of a TransportPolicyProtocol
//
func (e *TransportPolicyProtocol) UnmarshalJSON(b []byte) error {
	var j string
	err := json.Unmarshal(b, &j)
	if err == nil {
		s := string(j)
		for v, s2 := range namesTransportPolicyProtocol {
			if s == s2 {
				*e = TransportPolicyProtocol(v)
				return nil
			}
		}
		err = fmt.Errorf("Bad enum symbol for type TransportPolicyProtocol: %s", s)
	}
	return err
}

//
// TransportPolicyValidationStatus - Validation Status of transport policy vs
// network policy
//
type TransportPolicyValidationStatus int

//
// TransportPolicyValidationStatus constants
//
const (
	_ TransportPolicyValidationStatus = iota
	VALID
	INVALID
	PARTIAL
)

var namesTransportPolicyValidationStatus = []string{
	VALID:   "VALID",
	INVALID: "INVALID",
	PARTIAL: "PARTIAL",
}

//
// NewTransportPolicyValidationStatus - return a string representation of the enum
//
func NewTransportPolicyValidationStatus(init ...interface{}) TransportPolicyValidationStatus {
	if len(init) == 1 {
		switch v := init[0].(type) {
		case TransportPolicyValidationStatus:
			return v
		case int:
			return TransportPolicyValidationStatus(v)
		case int32:
			return TransportPolicyValidationStatus(v)
		case string:
			for i, s := range namesTransportPolicyValidationStatus {
				if s == v {
					return TransportPolicyValidationStatus(i)
				}
			}
		default:
			panic("Bad init value for TransportPolicyValidationStatus enum")
		}
	}
	return TransportPolicyValidationStatus(0) //default to the first enum value
}

//
// String - return a string representation of the enum
//
func (e TransportPolicyValidationStatus) String() string {
	return namesTransportPolicyValidationStatus[e]
}

//
// SymbolSet - return an array of all valid string representations (symbols) of the enum
//
func (e TransportPolicyValidationStatus) SymbolSet() []string {
	return namesTransportPolicyValidationStatus
}

//
// MarshalJSON is defined for proper JSON encoding of a TransportPolicyValidationStatus
//
func (e TransportPolicyValidationStatus) MarshalJSON() ([]byte, error) {
	return json.Marshal(e.String())
}

//
// UnmarshalJSON is defined for proper JSON decoding of a TransportPolicyValidationStatus
//
func (e *TransportPolicyValidationStatus) UnmarshalJSON(b []byte) error {
	var j string
	err := json.Unmarshal(b, &j)
	if err == nil {
		s := string(j)
		for v, s2 := range namesTransportPolicyValidationStatus {
			if s == s2 {
				*e = TransportPolicyValidationStatus(v)
				return nil
			}
		}
		err = fmt.Errorf("Bad enum symbol for type TransportPolicyValidationStatus: %s", s)
	}
	return err
}

//
// TransportPolicyTrafficDirection - Types of transport policy traffic
// direction
//
type TransportPolicyTrafficDirection int

//
// TransportPolicyTrafficDirection constants
//
const (
	_ TransportPolicyTrafficDirection = iota
	INGRESS
	EGRESS
)

var namesTransportPolicyTrafficDirection = []string{
	INGRESS: "INGRESS",
	EGRESS:  "EGRESS",
}

//
// NewTransportPolicyTrafficDirection - return a string representation of the enum
//
func NewTransportPolicyTrafficDirection(init ...interface{}) TransportPolicyTrafficDirection {
	if len(init) == 1 {
		switch v := init[0].(type) {
		case TransportPolicyTrafficDirection:
			return v
		case int:
			return TransportPolicyTrafficDirection(v)
		case int32:
			return TransportPolicyTrafficDirection(v)
		case string:
			for i, s := range namesTransportPolicyTrafficDirection {
				if s == v {
					return TransportPolicyTrafficDirection(i)
				}
			}
		default:
			panic("Bad init value for TransportPolicyTrafficDirection enum")
		}
	}
	return TransportPolicyTrafficDirection(0) //default to the first enum value
}

//
// String - return a string representation of the enum
//
func (e TransportPolicyTrafficDirection) String() string {
	return namesTransportPolicyTrafficDirection[e]
}

//
// SymbolSet - return an array of all valid string representations (symbols) of the enum
//
func (e TransportPolicyTrafficDirection) SymbolSet() []string {
	return namesTransportPolicyTrafficDirection
}

//
// MarshalJSON is defined for proper JSON encoding of a TransportPolicyTrafficDirection
//
func (e TransportPolicyTrafficDirection) MarshalJSON() ([]byte, error) {
	return json.Marshal(e.String())
}

//
// UnmarshalJSON is defined for proper JSON decoding of a TransportPolicyTrafficDirection
//
func (e *TransportPolicyTrafficDirection) UnmarshalJSON(b []byte) error {
	var j string
	err := json.Unmarshal(b, &j)
	if err == nil {
		s := string(j)
		for v, s2 := range namesTransportPolicyTrafficDirection {
			if s == s2 {
				*e = TransportPolicyTrafficDirection(v)
				return nil
			}
		}
		err = fmt.Errorf("Bad enum symbol for type TransportPolicyTrafficDirection: %s", s)
	}
	return err
}

//
// TransportPolicySubject - Subject for a transport policy
//
type TransportPolicySubject struct {

	//
	// Name of the domain
	//
	DomainName TransportPolicySubjectDomainName `json:"domainName"`

	//
	// Name of the service
	//
	ServiceName TransportPolicySubjectServiceName `json:"serviceName"`
}

//
// NewTransportPolicySubject - creates an initialized TransportPolicySubject instance, returns a pointer to it
//
func NewTransportPolicySubject(init ...*TransportPolicySubject) *TransportPolicySubject {
	var o *TransportPolicySubject
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(TransportPolicySubject)
	}
	return o
}

type rawTransportPolicySubject TransportPolicySubject

//
// UnmarshalJSON is defined for proper JSON decoding of a TransportPolicySubject
//
func (self *TransportPolicySubject) UnmarshalJSON(b []byte) error {
	var m rawTransportPolicySubject
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := TransportPolicySubject(m)
		*self = o
		err = self.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (self *TransportPolicySubject) Validate() error {
	if self.DomainName == "" {
		return fmt.Errorf("TransportPolicySubject.domainName is missing but is a required field")
	} else {
		val := rdl.Validate(MSDSchema(), "TransportPolicySubjectDomainName", self.DomainName)
		if !val.Valid {
			return fmt.Errorf("TransportPolicySubject.domainName does not contain a valid TransportPolicySubjectDomainName (%v)", val.Error)
		}
	}
	if self.ServiceName == "" {
		return fmt.Errorf("TransportPolicySubject.serviceName is missing but is a required field")
	} else {
		val := rdl.Validate(MSDSchema(), "TransportPolicySubjectServiceName", self.ServiceName)
		if !val.Valid {
			return fmt.Errorf("TransportPolicySubject.serviceName does not contain a valid TransportPolicySubjectServiceName (%v)", val.Error)
		}
	}
	return nil
}

//
// TransportPolicyCondition - Transport policy condition. Used to specify
// additional restrictions for the subject of a transport policy
//
type TransportPolicyCondition struct {

	//
	// State of transport policy enforcement ( ENFORCE / REPORT )
	//
	EnforcementState TransportPolicyEnforcementState `json:"enforcementState"`

	//
	// Acts as restrictions. If present, this transport policy should be
	// restricted to only mentioned instances.
	//
	Instances []string `json:"instances,omitempty" rdl:"optional" yaml:",omitempty"`
}

//
// NewTransportPolicyCondition - creates an initialized TransportPolicyCondition instance, returns a pointer to it
//
func NewTransportPolicyCondition(init ...*TransportPolicyCondition) *TransportPolicyCondition {
	var o *TransportPolicyCondition
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(TransportPolicyCondition)
	}
	return o
}

type rawTransportPolicyCondition TransportPolicyCondition

//
// UnmarshalJSON is defined for proper JSON decoding of a TransportPolicyCondition
//
func (self *TransportPolicyCondition) UnmarshalJSON(b []byte) error {
	var m rawTransportPolicyCondition
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := TransportPolicyCondition(m)
		*self = o
		err = self.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (self *TransportPolicyCondition) Validate() error {
	return nil
}

//
// PolicyPort - generic policy port. Will be used by TransportPolicyPort and
// NetworkPolicyPort structs
//
type PolicyPort struct {

	//
	// Start port of the port range. port and endPort will have same values for a
	// single port definition.
	//
	Port int32 `json:"port"`

	//
	// End port of the port range. port and endPort will have same values for a
	// single port definition.
	//
	EndPort int32 `json:"endPort"`
}

//
// NewPolicyPort - creates an initialized PolicyPort instance, returns a pointer to it
//
func NewPolicyPort(init ...*PolicyPort) *PolicyPort {
	var o *PolicyPort
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(PolicyPort)
	}
	return o
}

type rawPolicyPort PolicyPort

//
// UnmarshalJSON is defined for proper JSON decoding of a PolicyPort
//
func (self *PolicyPort) UnmarshalJSON(b []byte) error {
	var m rawPolicyPort
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := PolicyPort(m)
		*self = o
		err = self.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (self *PolicyPort) Validate() error {
	return nil
}

//
// TransportPolicyPort - Transport policy port
//
type TransportPolicyPort struct {

	//
	// Start port of the port range. port and endPort will have same values for a
	// single port definition.
	//
	Port int32 `json:"port"`

	//
	// End port of the port range. port and endPort will have same values for a
	// single port definition.
	//
	EndPort int32 `json:"endPort"`

	//
	// Protocol for this transport policy
	//
	Protocol TransportPolicyProtocol `json:"protocol"`
}

//
// NewTransportPolicyPort - creates an initialized TransportPolicyPort instance, returns a pointer to it
//
func NewTransportPolicyPort(init ...*TransportPolicyPort) *TransportPolicyPort {
	var o *TransportPolicyPort
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(TransportPolicyPort)
	}
	return o
}

type rawTransportPolicyPort TransportPolicyPort

//
// UnmarshalJSON is defined for proper JSON decoding of a TransportPolicyPort
//
func (self *TransportPolicyPort) UnmarshalJSON(b []byte) error {
	var m rawTransportPolicyPort
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := TransportPolicyPort(m)
		*self = o
		err = self.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (self *TransportPolicyPort) Validate() error {
	return nil
}

//
// TransportPolicyMatch - Selector for the subject of a transport policy
//
type TransportPolicyMatch struct {

	//
	// Subject where this transport policy applies
	//
	AthenzService *TransportPolicySubject `json:"athenzService"`

	//
	// List of additional requirements for restrictions. Requirements are ANDed.
	//
	Conditions []*TransportPolicyCondition `json:"conditions"`
}

//
// NewTransportPolicyMatch - creates an initialized TransportPolicyMatch instance, returns a pointer to it
//
func NewTransportPolicyMatch(init ...*TransportPolicyMatch) *TransportPolicyMatch {
	var o *TransportPolicyMatch
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(TransportPolicyMatch)
	}
	return o.Init()
}

//
// Init - sets up the instance according to its default field values, if any
//
func (self *TransportPolicyMatch) Init() *TransportPolicyMatch {
	if self.AthenzService == nil {
		self.AthenzService = NewTransportPolicySubject()
	}
	if self.Conditions == nil {
		self.Conditions = make([]*TransportPolicyCondition, 0)
	}
	return self
}

type rawTransportPolicyMatch TransportPolicyMatch

//
// UnmarshalJSON is defined for proper JSON decoding of a TransportPolicyMatch
//
func (self *TransportPolicyMatch) UnmarshalJSON(b []byte) error {
	var m rawTransportPolicyMatch
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := TransportPolicyMatch(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (self *TransportPolicyMatch) Validate() error {
	if self.AthenzService == nil {
		return fmt.Errorf("TransportPolicyMatch: Missing required field: athenzService")
	}
	if self.Conditions == nil {
		return fmt.Errorf("TransportPolicyMatch: Missing required field: conditions")
	}
	return nil
}

//
// TransportPolicyPeer - Source or destination for a transport policy
//
type TransportPolicyPeer struct {

	//
	// List of transport policy subjects
	//
	AthenzServices []*TransportPolicySubject `json:"athenzServices"`

	//
	// List of network traffic port part of this transport policy
	//
	Ports []*TransportPolicyPort `json:"ports"`
}

//
// NewTransportPolicyPeer - creates an initialized TransportPolicyPeer instance, returns a pointer to it
//
func NewTransportPolicyPeer(init ...*TransportPolicyPeer) *TransportPolicyPeer {
	var o *TransportPolicyPeer
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(TransportPolicyPeer)
	}
	return o.Init()
}

//
// Init - sets up the instance according to its default field values, if any
//
func (self *TransportPolicyPeer) Init() *TransportPolicyPeer {
	if self.AthenzServices == nil {
		self.AthenzServices = make([]*TransportPolicySubject, 0)
	}
	if self.Ports == nil {
		self.Ports = make([]*TransportPolicyPort, 0)
	}
	return self
}

type rawTransportPolicyPeer TransportPolicyPeer

//
// UnmarshalJSON is defined for proper JSON decoding of a TransportPolicyPeer
//
func (self *TransportPolicyPeer) UnmarshalJSON(b []byte) error {
	var m rawTransportPolicyPeer
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := TransportPolicyPeer(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (self *TransportPolicyPeer) Validate() error {
	if self.AthenzServices == nil {
		return fmt.Errorf("TransportPolicyPeer: Missing required field: athenzServices")
	}
	if self.Ports == nil {
		return fmt.Errorf("TransportPolicyPeer: Missing required field: ports")
	}
	return nil
}

//
// TransportPolicyEntitySelector - Entity to which a transport policy applies.
// Describes the subject and port(s) for a transport policy.
//
type TransportPolicyEntitySelector struct {

	//
	// Requirements for selecting the subject for this transport policy.
	//
	Match *TransportPolicyMatch `json:"match"`

	//
	// List of network traffic port of the subject eligible for the transport
	// policy
	//
	Ports []*TransportPolicyPort `json:"ports"`
}

//
// NewTransportPolicyEntitySelector - creates an initialized TransportPolicyEntitySelector instance, returns a pointer to it
//
func NewTransportPolicyEntitySelector(init ...*TransportPolicyEntitySelector) *TransportPolicyEntitySelector {
	var o *TransportPolicyEntitySelector
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(TransportPolicyEntitySelector)
	}
	return o.Init()
}

//
// Init - sets up the instance according to its default field values, if any
//
func (self *TransportPolicyEntitySelector) Init() *TransportPolicyEntitySelector {
	if self.Match == nil {
		self.Match = NewTransportPolicyMatch()
	}
	if self.Ports == nil {
		self.Ports = make([]*TransportPolicyPort, 0)
	}
	return self
}

type rawTransportPolicyEntitySelector TransportPolicyEntitySelector

//
// UnmarshalJSON is defined for proper JSON decoding of a TransportPolicyEntitySelector
//
func (self *TransportPolicyEntitySelector) UnmarshalJSON(b []byte) error {
	var m rawTransportPolicyEntitySelector
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := TransportPolicyEntitySelector(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (self *TransportPolicyEntitySelector) Validate() error {
	if self.Match == nil {
		return fmt.Errorf("TransportPolicyEntitySelector: Missing required field: match")
	}
	if self.Ports == nil {
		return fmt.Errorf("TransportPolicyEntitySelector: Missing required field: ports")
	}
	return nil
}

//
// TransportPolicyIngressRule - Transport policy ingress rule
//
type TransportPolicyIngressRule struct {

	//
	// Assertion id associated with this transport policy
	//
	Id int64 `json:"id"`

	//
	// Last modification timestamp of this transport policy
	//
	LastModified rdl.Timestamp `json:"lastModified"`

	//
	// Describes the entity to which this transport policy applies
	//
	EntitySelector *TransportPolicyEntitySelector `json:"entitySelector"`

	//
	// Source of network traffic
	//
	From *TransportPolicyPeer `json:"from"`
}

//
// NewTransportPolicyIngressRule - creates an initialized TransportPolicyIngressRule instance, returns a pointer to it
//
func NewTransportPolicyIngressRule(init ...*TransportPolicyIngressRule) *TransportPolicyIngressRule {
	var o *TransportPolicyIngressRule
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(TransportPolicyIngressRule)
	}
	return o.Init()
}

//
// Init - sets up the instance according to its default field values, if any
//
func (self *TransportPolicyIngressRule) Init() *TransportPolicyIngressRule {
	if self.EntitySelector == nil {
		self.EntitySelector = NewTransportPolicyEntitySelector()
	}
	if self.From == nil {
		self.From = NewTransportPolicyPeer()
	}
	return self
}

type rawTransportPolicyIngressRule TransportPolicyIngressRule

//
// UnmarshalJSON is defined for proper JSON decoding of a TransportPolicyIngressRule
//
func (self *TransportPolicyIngressRule) UnmarshalJSON(b []byte) error {
	var m rawTransportPolicyIngressRule
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := TransportPolicyIngressRule(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (self *TransportPolicyIngressRule) Validate() error {
	if self.LastModified.IsZero() {
		return fmt.Errorf("TransportPolicyIngressRule: Missing required field: lastModified")
	}
	if self.EntitySelector == nil {
		return fmt.Errorf("TransportPolicyIngressRule: Missing required field: entitySelector")
	}
	if self.From == nil {
		return fmt.Errorf("TransportPolicyIngressRule: Missing required field: from")
	}
	return nil
}

//
// TransportPolicyEgressRule - Transport policy egress rule
//
type TransportPolicyEgressRule struct {

	//
	// Assertion id associated with this transport policy
	//
	Id int64 `json:"id"`

	//
	// Last modification timestamp of this transport policy
	//
	LastModified rdl.Timestamp `json:"lastModified"`

	//
	// Entity to which this transport policy applies
	//
	EntitySelector *TransportPolicyEntitySelector `json:"entitySelector"`

	//
	// Destination of network traffic
	//
	To *TransportPolicyPeer `json:"to"`
}

//
// NewTransportPolicyEgressRule - creates an initialized TransportPolicyEgressRule instance, returns a pointer to it
//
func NewTransportPolicyEgressRule(init ...*TransportPolicyEgressRule) *TransportPolicyEgressRule {
	var o *TransportPolicyEgressRule
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(TransportPolicyEgressRule)
	}
	return o.Init()
}

//
// Init - sets up the instance according to its default field values, if any
//
func (self *TransportPolicyEgressRule) Init() *TransportPolicyEgressRule {
	if self.EntitySelector == nil {
		self.EntitySelector = NewTransportPolicyEntitySelector()
	}
	if self.To == nil {
		self.To = NewTransportPolicyPeer()
	}
	return self
}

type rawTransportPolicyEgressRule TransportPolicyEgressRule

//
// UnmarshalJSON is defined for proper JSON decoding of a TransportPolicyEgressRule
//
func (self *TransportPolicyEgressRule) UnmarshalJSON(b []byte) error {
	var m rawTransportPolicyEgressRule
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := TransportPolicyEgressRule(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (self *TransportPolicyEgressRule) Validate() error {
	if self.LastModified.IsZero() {
		return fmt.Errorf("TransportPolicyEgressRule: Missing required field: lastModified")
	}
	if self.EntitySelector == nil {
		return fmt.Errorf("TransportPolicyEgressRule: Missing required field: entitySelector")
	}
	if self.To == nil {
		return fmt.Errorf("TransportPolicyEgressRule: Missing required field: to")
	}
	return nil
}

//
// TransportPolicyRules - Transport policy containing ingress and egress rules
//
type TransportPolicyRules struct {

	//
	// List of ingress rules
	//
	Ingress []*TransportPolicyIngressRule `json:"ingress"`

	//
	// List of egress rules
	//
	Egress []*TransportPolicyEgressRule `json:"egress"`
}

//
// NewTransportPolicyRules - creates an initialized TransportPolicyRules instance, returns a pointer to it
//
func NewTransportPolicyRules(init ...*TransportPolicyRules) *TransportPolicyRules {
	var o *TransportPolicyRules
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(TransportPolicyRules)
	}
	return o.Init()
}

//
// Init - sets up the instance according to its default field values, if any
//
func (self *TransportPolicyRules) Init() *TransportPolicyRules {
	if self.Ingress == nil {
		self.Ingress = make([]*TransportPolicyIngressRule, 0)
	}
	if self.Egress == nil {
		self.Egress = make([]*TransportPolicyEgressRule, 0)
	}
	return self
}

type rawTransportPolicyRules TransportPolicyRules

//
// UnmarshalJSON is defined for proper JSON decoding of a TransportPolicyRules
//
func (self *TransportPolicyRules) UnmarshalJSON(b []byte) error {
	var m rawTransportPolicyRules
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := TransportPolicyRules(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (self *TransportPolicyRules) Validate() error {
	if self.Ingress == nil {
		return fmt.Errorf("TransportPolicyRules: Missing required field: ingress")
	}
	if self.Egress == nil {
		return fmt.Errorf("TransportPolicyRules: Missing required field: egress")
	}
	return nil
}

//
// TransportPolicyValidationRequest - Transport policy request object to be
// validated
//
type TransportPolicyValidationRequest struct {

	//
	// Describes the entity to which this transport policy applies
	//
	EntitySelector *TransportPolicyEntitySelector `json:"entitySelector"`

	//
	// source or destination of the network traffic depending on direction
	//
	Peer *TransportPolicyPeer `json:"peer"`

	//
	// If present, assertion id associated with this transport policy
	//
	Id               *int64                          `json:"id,omitempty" rdl:"optional" yaml:",omitempty"`
	TrafficDirection TransportPolicyTrafficDirection `json:"trafficDirection"`
}

//
// NewTransportPolicyValidationRequest - creates an initialized TransportPolicyValidationRequest instance, returns a pointer to it
//
func NewTransportPolicyValidationRequest(init ...*TransportPolicyValidationRequest) *TransportPolicyValidationRequest {
	var o *TransportPolicyValidationRequest
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(TransportPolicyValidationRequest)
	}
	return o.Init()
}

//
// Init - sets up the instance according to its default field values, if any
//
func (self *TransportPolicyValidationRequest) Init() *TransportPolicyValidationRequest {
	if self.EntitySelector == nil {
		self.EntitySelector = NewTransportPolicyEntitySelector()
	}
	if self.Peer == nil {
		self.Peer = NewTransportPolicyPeer()
	}
	return self
}

type rawTransportPolicyValidationRequest TransportPolicyValidationRequest

//
// UnmarshalJSON is defined for proper JSON decoding of a TransportPolicyValidationRequest
//
func (self *TransportPolicyValidationRequest) UnmarshalJSON(b []byte) error {
	var m rawTransportPolicyValidationRequest
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := TransportPolicyValidationRequest(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (self *TransportPolicyValidationRequest) Validate() error {
	if self.EntitySelector == nil {
		return fmt.Errorf("TransportPolicyValidationRequest: Missing required field: entitySelector")
	}
	if self.Peer == nil {
		return fmt.Errorf("TransportPolicyValidationRequest: Missing required field: peer")
	}
	return nil
}

//
// TransportPolicyValidationResponse - Response object of transport policy rule
// validation
//
type TransportPolicyValidationResponse struct {
	Status TransportPolicyValidationStatus `json:"status"`
	Errors []string                        `json:"errors,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// most recent update timestamp in the backend
	//
	UpdateTime *rdl.Timestamp `json:"updateTime,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// If present, assertion id associated with the transport policy
	//
	Id *int64 `json:"id,omitempty" rdl:"optional" yaml:",omitempty"`
}

//
// NewTransportPolicyValidationResponse - creates an initialized TransportPolicyValidationResponse instance, returns a pointer to it
//
func NewTransportPolicyValidationResponse(init ...*TransportPolicyValidationResponse) *TransportPolicyValidationResponse {
	var o *TransportPolicyValidationResponse
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(TransportPolicyValidationResponse)
	}
	return o
}

type rawTransportPolicyValidationResponse TransportPolicyValidationResponse

//
// UnmarshalJSON is defined for proper JSON decoding of a TransportPolicyValidationResponse
//
func (self *TransportPolicyValidationResponse) UnmarshalJSON(b []byte) error {
	var m rawTransportPolicyValidationResponse
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := TransportPolicyValidationResponse(m)
		*self = o
		err = self.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (self *TransportPolicyValidationResponse) Validate() error {
	return nil
}

//
// TransportPolicyValidationResponseList - List of
// TransportPolicyValidationResponse
//
type TransportPolicyValidationResponseList struct {

	//
	// list of transport policy validation response
	//
	ResponseList []*TransportPolicyValidationResponse `json:"responseList"`
}

//
// NewTransportPolicyValidationResponseList - creates an initialized TransportPolicyValidationResponseList instance, returns a pointer to it
//
func NewTransportPolicyValidationResponseList(init ...*TransportPolicyValidationResponseList) *TransportPolicyValidationResponseList {
	var o *TransportPolicyValidationResponseList
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(TransportPolicyValidationResponseList)
	}
	return o.Init()
}

//
// Init - sets up the instance according to its default field values, if any
//
func (self *TransportPolicyValidationResponseList) Init() *TransportPolicyValidationResponseList {
	if self.ResponseList == nil {
		self.ResponseList = make([]*TransportPolicyValidationResponse, 0)
	}
	return self
}

type rawTransportPolicyValidationResponseList TransportPolicyValidationResponseList

//
// UnmarshalJSON is defined for proper JSON decoding of a TransportPolicyValidationResponseList
//
func (self *TransportPolicyValidationResponseList) UnmarshalJSON(b []byte) error {
	var m rawTransportPolicyValidationResponseList
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := TransportPolicyValidationResponseList(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (self *TransportPolicyValidationResponseList) Validate() error {
	if self.ResponseList == nil {
		return fmt.Errorf("TransportPolicyValidationResponseList: Missing required field: responseList")
	}
	return nil
}

//
// StaticWorkloadType - Enum representing defined types of static workloads.
//
type StaticWorkloadType int

//
// StaticWorkloadType constants
//
const (
	_ StaticWorkloadType = iota
	VIP
	ENTERPRISE_APPLIANCE
	CLOUD_LB
	CLOUD_NAT
	EXTERNAL_APPLIANCE
	VIP_LB
)

var namesStaticWorkloadType = []string{
	VIP:                  "VIP",
	ENTERPRISE_APPLIANCE: "ENTERPRISE_APPLIANCE",
	CLOUD_LB:             "CLOUD_LB",
	CLOUD_NAT:            "CLOUD_NAT",
	EXTERNAL_APPLIANCE:   "EXTERNAL_APPLIANCE",
	VIP_LB:               "VIP_LB",
}

//
// NewStaticWorkloadType - return a string representation of the enum
//
func NewStaticWorkloadType(init ...interface{}) StaticWorkloadType {
	if len(init) == 1 {
		switch v := init[0].(type) {
		case StaticWorkloadType:
			return v
		case int:
			return StaticWorkloadType(v)
		case int32:
			return StaticWorkloadType(v)
		case string:
			for i, s := range namesStaticWorkloadType {
				if s == v {
					return StaticWorkloadType(i)
				}
			}
		default:
			panic("Bad init value for StaticWorkloadType enum")
		}
	}
	return StaticWorkloadType(0) //default to the first enum value
}

//
// String - return a string representation of the enum
//
func (e StaticWorkloadType) String() string {
	return namesStaticWorkloadType[e]
}

//
// SymbolSet - return an array of all valid string representations (symbols) of the enum
//
func (e StaticWorkloadType) SymbolSet() []string {
	return namesStaticWorkloadType
}

//
// MarshalJSON is defined for proper JSON encoding of a StaticWorkloadType
//
func (e StaticWorkloadType) MarshalJSON() ([]byte, error) {
	return json.Marshal(e.String())
}

//
// UnmarshalJSON is defined for proper JSON decoding of a StaticWorkloadType
//
func (e *StaticWorkloadType) UnmarshalJSON(b []byte) error {
	var j string
	err := json.Unmarshal(b, &j)
	if err == nil {
		s := string(j)
		for v, s2 := range namesStaticWorkloadType {
			if s == s2 {
				*e = StaticWorkloadType(v)
				return nil
			}
		}
		err = fmt.Errorf("Bad enum symbol for type StaticWorkloadType: %s", s)
	}
	return err
}

//
// DynamicWorkload - workload type describing workload bootstrapped with an
// identity
//
type DynamicWorkload struct {

	//
	// name of the domain
	//
	DomainName DomainName `json:"domainName"`

	//
	// name of the service
	//
	ServiceName EntityName `json:"serviceName"`

	//
	// unique identifier for the workload, usually defined by provider
	//
	Uuid string `json:"uuid"`

	//
	// list of IP addresses associated with the workload, optional for
	// getWorkloadsByIP API call
	//
	IpAddresses []string `json:"ipAddresses"`

	//
	// hostname associated with the workload
	//
	Hostname string `json:"hostname"`

	//
	// infrastructure provider e.g. Kubernetes, AWS, Azure, openstack etc.
	//
	Provider string `json:"provider"`

	//
	// most recent update timestamp in the backend
	//
	UpdateTime rdl.Timestamp `json:"updateTime"`

	//
	// certificate expiry time (ex: getNotAfter)
	//
	CertExpiryTime rdl.Timestamp `json:"certExpiryTime"`

	//
	// certificate issue time (ex: getNotBefore)
	//
	CertIssueTime *rdl.Timestamp `json:"certIssueTime,omitempty" rdl:"optional" yaml:",omitempty"`
}

//
// NewDynamicWorkload - creates an initialized DynamicWorkload instance, returns a pointer to it
//
func NewDynamicWorkload(init ...*DynamicWorkload) *DynamicWorkload {
	var o *DynamicWorkload
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(DynamicWorkload)
	}
	return o.Init()
}

//
// Init - sets up the instance according to its default field values, if any
//
func (self *DynamicWorkload) Init() *DynamicWorkload {
	if self.IpAddresses == nil {
		self.IpAddresses = make([]string, 0)
	}
	return self
}

type rawDynamicWorkload DynamicWorkload

//
// UnmarshalJSON is defined for proper JSON decoding of a DynamicWorkload
//
func (self *DynamicWorkload) UnmarshalJSON(b []byte) error {
	var m rawDynamicWorkload
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := DynamicWorkload(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (self *DynamicWorkload) Validate() error {
	if self.DomainName == "" {
		return fmt.Errorf("DynamicWorkload.domainName is missing but is a required field")
	} else {
		val := rdl.Validate(MSDSchema(), "DomainName", self.DomainName)
		if !val.Valid {
			return fmt.Errorf("DynamicWorkload.domainName does not contain a valid DomainName (%v)", val.Error)
		}
	}
	if self.ServiceName == "" {
		return fmt.Errorf("DynamicWorkload.serviceName is missing but is a required field")
	} else {
		val := rdl.Validate(MSDSchema(), "EntityName", self.ServiceName)
		if !val.Valid {
			return fmt.Errorf("DynamicWorkload.serviceName does not contain a valid EntityName (%v)", val.Error)
		}
	}
	if self.Uuid == "" {
		return fmt.Errorf("DynamicWorkload.uuid is missing but is a required field")
	} else {
		val := rdl.Validate(MSDSchema(), "String", self.Uuid)
		if !val.Valid {
			return fmt.Errorf("DynamicWorkload.uuid does not contain a valid String (%v)", val.Error)
		}
	}
	if self.IpAddresses == nil {
		return fmt.Errorf("DynamicWorkload: Missing required field: ipAddresses")
	}
	if self.Hostname == "" {
		return fmt.Errorf("DynamicWorkload.hostname is missing but is a required field")
	} else {
		val := rdl.Validate(MSDSchema(), "String", self.Hostname)
		if !val.Valid {
			return fmt.Errorf("DynamicWorkload.hostname does not contain a valid String (%v)", val.Error)
		}
	}
	if self.Provider == "" {
		return fmt.Errorf("DynamicWorkload.provider is missing but is a required field")
	} else {
		val := rdl.Validate(MSDSchema(), "String", self.Provider)
		if !val.Valid {
			return fmt.Errorf("DynamicWorkload.provider does not contain a valid String (%v)", val.Error)
		}
	}
	if self.UpdateTime.IsZero() {
		return fmt.Errorf("DynamicWorkload: Missing required field: updateTime")
	}
	if self.CertExpiryTime.IsZero() {
		return fmt.Errorf("DynamicWorkload: Missing required field: certExpiryTime")
	}
	return nil
}

//
// Workload - kept for backward compatibility sake. Will be eventually
// deprecated in favor of DynamicWorkload
//
type Workload struct {

	//
	// name of the domain
	//
	DomainName DomainName `json:"domainName"`

	//
	// name of the service
	//
	ServiceName EntityName `json:"serviceName"`

	//
	// unique identifier for the workload, usually defined by provider
	//
	Uuid string `json:"uuid"`

	//
	// list of IP addresses associated with the workload, optional for
	// getWorkloadsByIP API call
	//
	IpAddresses []string `json:"ipAddresses"`

	//
	// hostname associated with the workload
	//
	Hostname string `json:"hostname"`

	//
	// infrastructure provider e.g. Kubernetes, AWS, Azure, openstack etc.
	//
	Provider string `json:"provider"`

	//
	// most recent update timestamp in the backend
	//
	UpdateTime rdl.Timestamp `json:"updateTime"`

	//
	// certificate expiry time (ex: getNotAfter)
	//
	CertExpiryTime rdl.Timestamp `json:"certExpiryTime"`

	//
	// certificate issue time (ex: getNotBefore)
	//
	CertIssueTime *rdl.Timestamp `json:"certIssueTime,omitempty" rdl:"optional" yaml:",omitempty"`
}

//
// NewWorkload - creates an initialized Workload instance, returns a pointer to it
//
func NewWorkload(init ...*Workload) *Workload {
	var o *Workload
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(Workload)
	}
	return o.Init()
}

//
// Init - sets up the instance according to its default field values, if any
//
func (self *Workload) Init() *Workload {
	if self.IpAddresses == nil {
		self.IpAddresses = make([]string, 0)
	}
	return self
}

type rawWorkload Workload

//
// UnmarshalJSON is defined for proper JSON decoding of a Workload
//
func (self *Workload) UnmarshalJSON(b []byte) error {
	var m rawWorkload
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := Workload(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (self *Workload) Validate() error {
	if self.DomainName == "" {
		return fmt.Errorf("Workload.domainName is missing but is a required field")
	} else {
		val := rdl.Validate(MSDSchema(), "DomainName", self.DomainName)
		if !val.Valid {
			return fmt.Errorf("Workload.domainName does not contain a valid DomainName (%v)", val.Error)
		}
	}
	if self.ServiceName == "" {
		return fmt.Errorf("Workload.serviceName is missing but is a required field")
	} else {
		val := rdl.Validate(MSDSchema(), "EntityName", self.ServiceName)
		if !val.Valid {
			return fmt.Errorf("Workload.serviceName does not contain a valid EntityName (%v)", val.Error)
		}
	}
	if self.Uuid == "" {
		return fmt.Errorf("Workload.uuid is missing but is a required field")
	} else {
		val := rdl.Validate(MSDSchema(), "String", self.Uuid)
		if !val.Valid {
			return fmt.Errorf("Workload.uuid does not contain a valid String (%v)", val.Error)
		}
	}
	if self.IpAddresses == nil {
		return fmt.Errorf("Workload: Missing required field: ipAddresses")
	}
	if self.Hostname == "" {
		return fmt.Errorf("Workload.hostname is missing but is a required field")
	} else {
		val := rdl.Validate(MSDSchema(), "String", self.Hostname)
		if !val.Valid {
			return fmt.Errorf("Workload.hostname does not contain a valid String (%v)", val.Error)
		}
	}
	if self.Provider == "" {
		return fmt.Errorf("Workload.provider is missing but is a required field")
	} else {
		val := rdl.Validate(MSDSchema(), "String", self.Provider)
		if !val.Valid {
			return fmt.Errorf("Workload.provider does not contain a valid String (%v)", val.Error)
		}
	}
	if self.UpdateTime.IsZero() {
		return fmt.Errorf("Workload: Missing required field: updateTime")
	}
	if self.CertExpiryTime.IsZero() {
		return fmt.Errorf("Workload: Missing required field: certExpiryTime")
	}
	return nil
}

//
// StaticWorkload - workload type describing workload indirectly associated
// with an identity ( without bootstrap )
//
type StaticWorkload struct {

	//
	// name of the domain
	//
	DomainName DomainName `json:"domainName"`

	//
	// name of the service
	//
	ServiceName EntityName `json:"serviceName"`

	//
	// value representing one of the StaticWorkloadType enum
	//
	Type StaticWorkloadType `json:"type"`

	//
	// list of IP addresses associated with the workload, optional for
	// getWorkloadsByIP API call
	//
	IpAddresses []string `json:"ipAddresses,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// name associated with the workload. In most cases will be a FQDN
	//
	Name string `json:"name" rdl:"optional" yaml:",omitempty"`

	//
	// most recent update timestamp in the backend
	//
	UpdateTime *rdl.Timestamp `json:"updateTime,omitempty" rdl:"optional" yaml:",omitempty"`
}

//
// NewStaticWorkload - creates an initialized StaticWorkload instance, returns a pointer to it
//
func NewStaticWorkload(init ...*StaticWorkload) *StaticWorkload {
	var o *StaticWorkload
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(StaticWorkload)
	}
	return o
}

type rawStaticWorkload StaticWorkload

//
// UnmarshalJSON is defined for proper JSON decoding of a StaticWorkload
//
func (self *StaticWorkload) UnmarshalJSON(b []byte) error {
	var m rawStaticWorkload
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := StaticWorkload(m)
		*self = o
		err = self.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (self *StaticWorkload) Validate() error {
	if self.DomainName == "" {
		return fmt.Errorf("StaticWorkload.domainName is missing but is a required field")
	} else {
		val := rdl.Validate(MSDSchema(), "DomainName", self.DomainName)
		if !val.Valid {
			return fmt.Errorf("StaticWorkload.domainName does not contain a valid DomainName (%v)", val.Error)
		}
	}
	if self.ServiceName == "" {
		return fmt.Errorf("StaticWorkload.serviceName is missing but is a required field")
	} else {
		val := rdl.Validate(MSDSchema(), "EntityName", self.ServiceName)
		if !val.Valid {
			return fmt.Errorf("StaticWorkload.serviceName does not contain a valid EntityName (%v)", val.Error)
		}
	}
	if self.Name != "" {
		val := rdl.Validate(MSDSchema(), "String", self.Name)
		if !val.Valid {
			return fmt.Errorf("StaticWorkload.name does not contain a valid String (%v)", val.Error)
		}
	}
	return nil
}

//
// WorkloadOptions -
//
type WorkloadOptions struct {

	//
	// boolean flag to signal a change in IP state
	//
	IpChanged bool `json:"ipChanged"`
}

//
// NewWorkloadOptions - creates an initialized WorkloadOptions instance, returns a pointer to it
//
func NewWorkloadOptions(init ...*WorkloadOptions) *WorkloadOptions {
	var o *WorkloadOptions
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(WorkloadOptions)
	}
	return o
}

type rawWorkloadOptions WorkloadOptions

//
// UnmarshalJSON is defined for proper JSON decoding of a WorkloadOptions
//
func (self *WorkloadOptions) UnmarshalJSON(b []byte) error {
	var m rawWorkloadOptions
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := WorkloadOptions(m)
		*self = o
		err = self.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (self *WorkloadOptions) Validate() error {
	return nil
}

//
// Workloads - list of workloads
//
type Workloads struct {

	//
	// list of workloads
	//
	WorkloadList []*Workload `json:"workloadList"`

	//
	// list of dynamic workloads
	//
	DynamicWorkloadList []*DynamicWorkload `json:"dynamicWorkloadList,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// list of static workloads
	//
	StaticWorkloadList []*StaticWorkload `json:"staticWorkloadList,omitempty" rdl:"optional" yaml:",omitempty"`
}

//
// NewWorkloads - creates an initialized Workloads instance, returns a pointer to it
//
func NewWorkloads(init ...*Workloads) *Workloads {
	var o *Workloads
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(Workloads)
	}
	return o.Init()
}

//
// Init - sets up the instance according to its default field values, if any
//
func (self *Workloads) Init() *Workloads {
	if self.WorkloadList == nil {
		self.WorkloadList = make([]*Workload, 0)
	}
	return self
}

type rawWorkloads Workloads

//
// UnmarshalJSON is defined for proper JSON decoding of a Workloads
//
func (self *Workloads) UnmarshalJSON(b []byte) error {
	var m rawWorkloads
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := Workloads(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (self *Workloads) Validate() error {
	if self.WorkloadList == nil {
		return fmt.Errorf("Workloads: Missing required field: workloadList")
	}
	return nil
}

//
// NetworkPolicyChangeEffect - IMPACT indicates that a change in network policy
// will interfere with workings of one or more transport policies NO_IMAPCT
// indicates that a change in network policy will not interfere with workings of
// any transport policy
//
type NetworkPolicyChangeEffect int

//
// NetworkPolicyChangeEffect constants
//
const (
	_ NetworkPolicyChangeEffect = iota
	IMPACT
	NO_IMPACT
)

var namesNetworkPolicyChangeEffect = []string{
	IMPACT:    "IMPACT",
	NO_IMPACT: "NO_IMPACT",
}

//
// NewNetworkPolicyChangeEffect - return a string representation of the enum
//
func NewNetworkPolicyChangeEffect(init ...interface{}) NetworkPolicyChangeEffect {
	if len(init) == 1 {
		switch v := init[0].(type) {
		case NetworkPolicyChangeEffect:
			return v
		case int:
			return NetworkPolicyChangeEffect(v)
		case int32:
			return NetworkPolicyChangeEffect(v)
		case string:
			for i, s := range namesNetworkPolicyChangeEffect {
				if s == v {
					return NetworkPolicyChangeEffect(i)
				}
			}
		default:
			panic("Bad init value for NetworkPolicyChangeEffect enum")
		}
	}
	return NetworkPolicyChangeEffect(0) //default to the first enum value
}

//
// String - return a string representation of the enum
//
func (e NetworkPolicyChangeEffect) String() string {
	return namesNetworkPolicyChangeEffect[e]
}

//
// SymbolSet - return an array of all valid string representations (symbols) of the enum
//
func (e NetworkPolicyChangeEffect) SymbolSet() []string {
	return namesNetworkPolicyChangeEffect
}

//
// MarshalJSON is defined for proper JSON encoding of a NetworkPolicyChangeEffect
//
func (e NetworkPolicyChangeEffect) MarshalJSON() ([]byte, error) {
	return json.Marshal(e.String())
}

//
// UnmarshalJSON is defined for proper JSON decoding of a NetworkPolicyChangeEffect
//
func (e *NetworkPolicyChangeEffect) UnmarshalJSON(b []byte) error {
	var j string
	err := json.Unmarshal(b, &j)
	if err == nil {
		s := string(j)
		for v, s2 := range namesNetworkPolicyChangeEffect {
			if s == s2 {
				*e = NetworkPolicyChangeEffect(v)
				return nil
			}
		}
		err = fmt.Errorf("Bad enum symbol for type NetworkPolicyChangeEffect: %s", s)
	}
	return err
}

//
// IPBlock - Struct representing ip blocks used by network policy in CIDR
// (Classless inter-domain routing) format
//
type IPBlock struct {

	//
	// cidr notation. can be used for ipv4 or ipv6
	//
	Cidr string `json:"cidr"`
}

//
// NewIPBlock - creates an initialized IPBlock instance, returns a pointer to it
//
func NewIPBlock(init ...*IPBlock) *IPBlock {
	var o *IPBlock
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(IPBlock)
	}
	return o
}

type rawIPBlock IPBlock

//
// UnmarshalJSON is defined for proper JSON decoding of a IPBlock
//
func (self *IPBlock) UnmarshalJSON(b []byte) error {
	var m rawIPBlock
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := IPBlock(m)
		*self = o
		err = self.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (self *IPBlock) Validate() error {
	if self.Cidr == "" {
		return fmt.Errorf("IPBlock.cidr is missing but is a required field")
	} else {
		val := rdl.Validate(MSDSchema(), "String", self.Cidr)
		if !val.Valid {
			return fmt.Errorf("IPBlock.cidr does not contain a valid String (%v)", val.Error)
		}
	}
	return nil
}

//
// NetworkPolicyPort - network policy port.
//
type NetworkPolicyPort struct {

	//
	// Start port of the port range. port and endPort will have same values for a
	// single port definition.
	//
	Port int32 `json:"port"`

	//
	// End port of the port range. port and endPort will have same values for a
	// single port definition.
	//
	EndPort int32 `json:"endPort"`

	//
	// protocol used by the network policy
	//
	Protocol TransportPolicyProtocol `json:"protocol"`
}

//
// NewNetworkPolicyPort - creates an initialized NetworkPolicyPort instance, returns a pointer to it
//
func NewNetworkPolicyPort(init ...*NetworkPolicyPort) *NetworkPolicyPort {
	var o *NetworkPolicyPort
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(NetworkPolicyPort)
	}
	return o
}

type rawNetworkPolicyPort NetworkPolicyPort

//
// UnmarshalJSON is defined for proper JSON decoding of a NetworkPolicyPort
//
func (self *NetworkPolicyPort) UnmarshalJSON(b []byte) error {
	var m rawNetworkPolicyPort
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := NetworkPolicyPort(m)
		*self = o
		err = self.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (self *NetworkPolicyPort) Validate() error {
	return nil
}

//
// NetworkPolicyChangeImpactRequest - struct representing input details for
// evaluating network policies change impact on transport policies
//
type NetworkPolicyChangeImpactRequest struct {

	//
	// from ip address range list in cidr format
	//
	From []*IPBlock `json:"from"`

	//
	// to ip address range list in cidr format
	//
	To []*IPBlock `json:"to"`

	//
	// list of source ports
	//
	SourcePorts []*NetworkPolicyPort `json:"sourcePorts"`

	//
	// list of destination ports
	//
	DestinationPorts []*NetworkPolicyPort `json:"destinationPorts"`
}

//
// NewNetworkPolicyChangeImpactRequest - creates an initialized NetworkPolicyChangeImpactRequest instance, returns a pointer to it
//
func NewNetworkPolicyChangeImpactRequest(init ...*NetworkPolicyChangeImpactRequest) *NetworkPolicyChangeImpactRequest {
	var o *NetworkPolicyChangeImpactRequest
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(NetworkPolicyChangeImpactRequest)
	}
	return o.Init()
}

//
// Init - sets up the instance according to its default field values, if any
//
func (self *NetworkPolicyChangeImpactRequest) Init() *NetworkPolicyChangeImpactRequest {
	if self.From == nil {
		self.From = make([]*IPBlock, 0)
	}
	if self.To == nil {
		self.To = make([]*IPBlock, 0)
	}
	if self.SourcePorts == nil {
		self.SourcePorts = make([]*NetworkPolicyPort, 0)
	}
	if self.DestinationPorts == nil {
		self.DestinationPorts = make([]*NetworkPolicyPort, 0)
	}
	return self
}

type rawNetworkPolicyChangeImpactRequest NetworkPolicyChangeImpactRequest

//
// UnmarshalJSON is defined for proper JSON decoding of a NetworkPolicyChangeImpactRequest
//
func (self *NetworkPolicyChangeImpactRequest) UnmarshalJSON(b []byte) error {
	var m rawNetworkPolicyChangeImpactRequest
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := NetworkPolicyChangeImpactRequest(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (self *NetworkPolicyChangeImpactRequest) Validate() error {
	if self.From == nil {
		return fmt.Errorf("NetworkPolicyChangeImpactRequest: Missing required field: from")
	}
	if self.To == nil {
		return fmt.Errorf("NetworkPolicyChangeImpactRequest: Missing required field: to")
	}
	if self.SourcePorts == nil {
		return fmt.Errorf("NetworkPolicyChangeImpactRequest: Missing required field: sourcePorts")
	}
	if self.DestinationPorts == nil {
		return fmt.Errorf("NetworkPolicyChangeImpactRequest: Missing required field: destinationPorts")
	}
	return nil
}

//
// NetworkPolicyChangeImpactDetail -
//
type NetworkPolicyChangeImpactDetail struct {

	//
	// Name of the domain of the corresponding transport policy
	//
	Domain DomainName `json:"domain"`

	//
	// Name of the Athenz policy corresponding to transport policy
	//
	Policy EntityName `json:"policy"`

	//
	// Unique id of the transport policy
	//
	TransportPolicyId int64 `json:"transportPolicyId"`
}

//
// NewNetworkPolicyChangeImpactDetail - creates an initialized NetworkPolicyChangeImpactDetail instance, returns a pointer to it
//
func NewNetworkPolicyChangeImpactDetail(init ...*NetworkPolicyChangeImpactDetail) *NetworkPolicyChangeImpactDetail {
	var o *NetworkPolicyChangeImpactDetail
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(NetworkPolicyChangeImpactDetail)
	}
	return o
}

type rawNetworkPolicyChangeImpactDetail NetworkPolicyChangeImpactDetail

//
// UnmarshalJSON is defined for proper JSON decoding of a NetworkPolicyChangeImpactDetail
//
func (self *NetworkPolicyChangeImpactDetail) UnmarshalJSON(b []byte) error {
	var m rawNetworkPolicyChangeImpactDetail
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := NetworkPolicyChangeImpactDetail(m)
		*self = o
		err = self.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (self *NetworkPolicyChangeImpactDetail) Validate() error {
	if self.Domain == "" {
		return fmt.Errorf("NetworkPolicyChangeImpactDetail.domain is missing but is a required field")
	} else {
		val := rdl.Validate(MSDSchema(), "DomainName", self.Domain)
		if !val.Valid {
			return fmt.Errorf("NetworkPolicyChangeImpactDetail.domain does not contain a valid DomainName (%v)", val.Error)
		}
	}
	if self.Policy == "" {
		return fmt.Errorf("NetworkPolicyChangeImpactDetail.policy is missing but is a required field")
	} else {
		val := rdl.Validate(MSDSchema(), "EntityName", self.Policy)
		if !val.Valid {
			return fmt.Errorf("NetworkPolicyChangeImpactDetail.policy does not contain a valid EntityName (%v)", val.Error)
		}
	}
	return nil
}

//
// NetworkPolicyChangeImpactResponse - struct representing response of
// evaluating network policies change impact on transport policies
//
type NetworkPolicyChangeImpactResponse struct {

	//
	// enum indicating effect of network policy change on one or more transport
	// policies
	//
	Effect NetworkPolicyChangeEffect `json:"effect"`

	//
	// if the above enum value is IMPACT then this optional object contains more
	// details about the impacted transport policies
	//
	Details []*NetworkPolicyChangeImpactDetail `json:"details,omitempty" rdl:"optional" yaml:",omitempty"`
}

//
// NewNetworkPolicyChangeImpactResponse - creates an initialized NetworkPolicyChangeImpactResponse instance, returns a pointer to it
//
func NewNetworkPolicyChangeImpactResponse(init ...*NetworkPolicyChangeImpactResponse) *NetworkPolicyChangeImpactResponse {
	var o *NetworkPolicyChangeImpactResponse
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(NetworkPolicyChangeImpactResponse)
	}
	return o
}

type rawNetworkPolicyChangeImpactResponse NetworkPolicyChangeImpactResponse

//
// UnmarshalJSON is defined for proper JSON decoding of a NetworkPolicyChangeImpactResponse
//
func (self *NetworkPolicyChangeImpactResponse) UnmarshalJSON(b []byte) error {
	var m rawNetworkPolicyChangeImpactResponse
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := NetworkPolicyChangeImpactResponse(m)
		*self = o
		err = self.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (self *NetworkPolicyChangeImpactResponse) Validate() error {
	return nil
}
