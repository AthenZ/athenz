// Code generated by rdl 1.5.2 DO NOT EDIT.

package msd

import (
	"encoding/json"
	"fmt"
	rdl "github.com/ardielle/ardielle-go/rdl"
)

var _ = rdl.Version
var _ = json.Marshal
var _ = fmt.Printf

// SimpleName - Copyright The Athenz Authors Licensed under the terms of the
// Apache version 2.0 license. See LICENSE file for terms. Common name types
// used by several API definitions A simple identifier, an element of compound
// name.
type SimpleName string

// CompoundName - A compound name. Most names in this API are compound names.
type CompoundName string

// DomainName - A domain name is the general qualifier prefix, as its
// uniqueness is managed.
type DomainName string

// EntityName - An entity name is a short form of a resource name, including
// only the domain and entity.
type EntityName string

// EntityList - An Entity list is comma separated compound Names
type EntityList string

// ServiceName - A service name will generally be a unique subdomain.
type ServiceName string

// ActionName - An action (operation) name.
type ActionName string

// ResourceName - A resource name Note that the EntityName part is optional,
// that is, a domain name followed by a colon is valid resource name.
type ResourceName string

// YBase64 - The Y-specific URL-safe Base64 variant.
type YBase64 string

// YEncoded - YEncoded includes ybase64 chars, as well as = and %. This can
// represent a user cookie and URL-encoded values.
type YEncoded string

// AuthorityName - Used as the prefix in a signed assertion. This uniquely
// identifies a signing authority.
type AuthorityName string

// PathElement - A uri-safe path element
type PathElement string

// TransportPolicySubjectDomainName - DomainName in TransportPolicySubject
// should allow * to indicate ANY
type TransportPolicySubjectDomainName string

// TransportPolicySubjectServiceName - ServiceName in TransportPolicySubject
// should allow * to indicate ANY
type TransportPolicySubjectServiceName string

// StaticWorkloadComponent -
type StaticWorkloadComponent string

// StaticWorkloadFQDN -
type StaticWorkloadFQDN string

// StaticWorkloadName -
type StaticWorkloadName string

// TransportPolicySubjectExternal -
type TransportPolicySubjectExternal string

// TransportPolicyEnforcementState - Types of transport policy enforcement
// states
type TransportPolicyEnforcementState int

// TransportPolicyEnforcementState constants
const (
	_ TransportPolicyEnforcementState = iota
	ENFORCE
	REPORT
)

var namesTransportPolicyEnforcementState = []string{
	ENFORCE: "ENFORCE",
	REPORT:  "REPORT",
}

// NewTransportPolicyEnforcementState - return a string representation of the enum
func NewTransportPolicyEnforcementState(init ...interface{}) TransportPolicyEnforcementState {
	if len(init) == 1 {
		switch v := init[0].(type) {
		case TransportPolicyEnforcementState:
			return v
		case int:
			return TransportPolicyEnforcementState(v)
		case int32:
			return TransportPolicyEnforcementState(v)
		case string:
			for i, s := range namesTransportPolicyEnforcementState {
				if s == v {
					return TransportPolicyEnforcementState(i)
				}
			}
		default:
			panic("Bad init value for TransportPolicyEnforcementState enum")
		}
	}
	return TransportPolicyEnforcementState(0) //default to the first enum value
}

// String - return a string representation of the enum
func (e TransportPolicyEnforcementState) String() string {
	return namesTransportPolicyEnforcementState[e]
}

// SymbolSet - return an array of all valid string representations (symbols) of the enum
func (e TransportPolicyEnforcementState) SymbolSet() []string {
	return namesTransportPolicyEnforcementState
}

// MarshalJSON is defined for proper JSON encoding of a TransportPolicyEnforcementState
func (e TransportPolicyEnforcementState) MarshalJSON() ([]byte, error) {
	return json.Marshal(e.String())
}

// UnmarshalJSON is defined for proper JSON decoding of a TransportPolicyEnforcementState
func (e *TransportPolicyEnforcementState) UnmarshalJSON(b []byte) error {
	var j string
	err := json.Unmarshal(b, &j)
	if err == nil {
		s := string(j)
		for v, s2 := range namesTransportPolicyEnforcementState {
			if s == s2 {
				*e = TransportPolicyEnforcementState(v)
				return nil
			}
		}
		err = fmt.Errorf("Bad enum symbol for type TransportPolicyEnforcementState: %s", s)
	}
	return err
}

// TransportPolicyProtocol - Types of transport policy protocols
type TransportPolicyProtocol int

// TransportPolicyProtocol constants
const (
	_ TransportPolicyProtocol = iota
	TCP
	UDP
)

var namesTransportPolicyProtocol = []string{
	TCP: "TCP",
	UDP: "UDP",
}

// NewTransportPolicyProtocol - return a string representation of the enum
func NewTransportPolicyProtocol(init ...interface{}) TransportPolicyProtocol {
	if len(init) == 1 {
		switch v := init[0].(type) {
		case TransportPolicyProtocol:
			return v
		case int:
			return TransportPolicyProtocol(v)
		case int32:
			return TransportPolicyProtocol(v)
		case string:
			for i, s := range namesTransportPolicyProtocol {
				if s == v {
					return TransportPolicyProtocol(i)
				}
			}
		default:
			panic("Bad init value for TransportPolicyProtocol enum")
		}
	}
	return TransportPolicyProtocol(0) //default to the first enum value
}

// String - return a string representation of the enum
func (e TransportPolicyProtocol) String() string {
	return namesTransportPolicyProtocol[e]
}

// SymbolSet - return an array of all valid string representations (symbols) of the enum
func (e TransportPolicyProtocol) SymbolSet() []string {
	return namesTransportPolicyProtocol
}

// MarshalJSON is defined for proper JSON encoding of a TransportPolicyProtocol
func (e TransportPolicyProtocol) MarshalJSON() ([]byte, error) {
	return json.Marshal(e.String())
}

// UnmarshalJSON is defined for proper JSON decoding of a TransportPolicyProtocol
func (e *TransportPolicyProtocol) UnmarshalJSON(b []byte) error {
	var j string
	err := json.Unmarshal(b, &j)
	if err == nil {
		s := string(j)
		for v, s2 := range namesTransportPolicyProtocol {
			if s == s2 {
				*e = TransportPolicyProtocol(v)
				return nil
			}
		}
		err = fmt.Errorf("Bad enum symbol for type TransportPolicyProtocol: %s", s)
	}
	return err
}

// TransportPolicyValidationStatus - Validation Status of transport policy vs
// network policy
type TransportPolicyValidationStatus int

// TransportPolicyValidationStatus constants
const (
	_ TransportPolicyValidationStatus = iota
	VALID
	INVALID
	PARTIAL
)

var namesTransportPolicyValidationStatus = []string{
	VALID:   "VALID",
	INVALID: "INVALID",
	PARTIAL: "PARTIAL",
}

// NewTransportPolicyValidationStatus - return a string representation of the enum
func NewTransportPolicyValidationStatus(init ...interface{}) TransportPolicyValidationStatus {
	if len(init) == 1 {
		switch v := init[0].(type) {
		case TransportPolicyValidationStatus:
			return v
		case int:
			return TransportPolicyValidationStatus(v)
		case int32:
			return TransportPolicyValidationStatus(v)
		case string:
			for i, s := range namesTransportPolicyValidationStatus {
				if s == v {
					return TransportPolicyValidationStatus(i)
				}
			}
		default:
			panic("Bad init value for TransportPolicyValidationStatus enum")
		}
	}
	return TransportPolicyValidationStatus(0) //default to the first enum value
}

// String - return a string representation of the enum
func (e TransportPolicyValidationStatus) String() string {
	return namesTransportPolicyValidationStatus[e]
}

// SymbolSet - return an array of all valid string representations (symbols) of the enum
func (e TransportPolicyValidationStatus) SymbolSet() []string {
	return namesTransportPolicyValidationStatus
}

// MarshalJSON is defined for proper JSON encoding of a TransportPolicyValidationStatus
func (e TransportPolicyValidationStatus) MarshalJSON() ([]byte, error) {
	return json.Marshal(e.String())
}

// UnmarshalJSON is defined for proper JSON decoding of a TransportPolicyValidationStatus
func (e *TransportPolicyValidationStatus) UnmarshalJSON(b []byte) error {
	var j string
	err := json.Unmarshal(b, &j)
	if err == nil {
		s := string(j)
		for v, s2 := range namesTransportPolicyValidationStatus {
			if s == s2 {
				*e = TransportPolicyValidationStatus(v)
				return nil
			}
		}
		err = fmt.Errorf("Bad enum symbol for type TransportPolicyValidationStatus: %s", s)
	}
	return err
}

// TransportPolicyTrafficDirection - Types of transport policy traffic
// direction
type TransportPolicyTrafficDirection int

// TransportPolicyTrafficDirection constants
const (
	_ TransportPolicyTrafficDirection = iota
	INGRESS
	EGRESS
)

var namesTransportPolicyTrafficDirection = []string{
	INGRESS: "INGRESS",
	EGRESS:  "EGRESS",
}

// NewTransportPolicyTrafficDirection - return a string representation of the enum
func NewTransportPolicyTrafficDirection(init ...interface{}) TransportPolicyTrafficDirection {
	if len(init) == 1 {
		switch v := init[0].(type) {
		case TransportPolicyTrafficDirection:
			return v
		case int:
			return TransportPolicyTrafficDirection(v)
		case int32:
			return TransportPolicyTrafficDirection(v)
		case string:
			for i, s := range namesTransportPolicyTrafficDirection {
				if s == v {
					return TransportPolicyTrafficDirection(i)
				}
			}
		default:
			panic("Bad init value for TransportPolicyTrafficDirection enum")
		}
	}
	return TransportPolicyTrafficDirection(0) //default to the first enum value
}

// String - return a string representation of the enum
func (e TransportPolicyTrafficDirection) String() string {
	return namesTransportPolicyTrafficDirection[e]
}

// SymbolSet - return an array of all valid string representations (symbols) of the enum
func (e TransportPolicyTrafficDirection) SymbolSet() []string {
	return namesTransportPolicyTrafficDirection
}

// MarshalJSON is defined for proper JSON encoding of a TransportPolicyTrafficDirection
func (e TransportPolicyTrafficDirection) MarshalJSON() ([]byte, error) {
	return json.Marshal(e.String())
}

// UnmarshalJSON is defined for proper JSON decoding of a TransportPolicyTrafficDirection
func (e *TransportPolicyTrafficDirection) UnmarshalJSON(b []byte) error {
	var j string
	err := json.Unmarshal(b, &j)
	if err == nil {
		s := string(j)
		for v, s2 := range namesTransportPolicyTrafficDirection {
			if s == s2 {
				*e = TransportPolicyTrafficDirection(v)
				return nil
			}
		}
		err = fmt.Errorf("Bad enum symbol for type TransportPolicyTrafficDirection: %s", s)
	}
	return err
}

// TransportPolicyScope - Scope of transport policy
type TransportPolicyScope int

// TransportPolicyScope constants
const (
	_ TransportPolicyScope = iota
	ALL
	ONPREM
	AWS
	GCP
)

var namesTransportPolicyScope = []string{
	ALL:    "ALL",
	ONPREM: "ONPREM",
	AWS:    "AWS",
	GCP:    "GCP",
}

// NewTransportPolicyScope - return a string representation of the enum
func NewTransportPolicyScope(init ...interface{}) TransportPolicyScope {
	if len(init) == 1 {
		switch v := init[0].(type) {
		case TransportPolicyScope:
			return v
		case int:
			return TransportPolicyScope(v)
		case int32:
			return TransportPolicyScope(v)
		case string:
			for i, s := range namesTransportPolicyScope {
				if s == v {
					return TransportPolicyScope(i)
				}
			}
		default:
			panic("Bad init value for TransportPolicyScope enum")
		}
	}
	return TransportPolicyScope(0) //default to the first enum value
}

// String - return a string representation of the enum
func (e TransportPolicyScope) String() string {
	return namesTransportPolicyScope[e]
}

// SymbolSet - return an array of all valid string representations (symbols) of the enum
func (e TransportPolicyScope) SymbolSet() []string {
	return namesTransportPolicyScope
}

// MarshalJSON is defined for proper JSON encoding of a TransportPolicyScope
func (e TransportPolicyScope) MarshalJSON() ([]byte, error) {
	return json.Marshal(e.String())
}

// UnmarshalJSON is defined for proper JSON decoding of a TransportPolicyScope
func (e *TransportPolicyScope) UnmarshalJSON(b []byte) error {
	var j string
	err := json.Unmarshal(b, &j)
	if err == nil {
		s := string(j)
		for v, s2 := range namesTransportPolicyScope {
			if s == s2 {
				*e = TransportPolicyScope(v)
				return nil
			}
		}
		err = fmt.Errorf("Bad enum symbol for type TransportPolicyScope: %s", s)
	}
	return err
}

// TransportPolicySubject - Subject for a transport policy
type TransportPolicySubject struct {

	//
	// Name of the domain
	//
	DomainName TransportPolicySubjectDomainName `json:"domainName"`

	//
	// Name of the service
	//
	ServiceName TransportPolicySubjectServiceName `json:"serviceName"`

	//
	// External peer ( not in Athenz )
	//
	ExternalPeer TransportPolicySubjectExternal `json:"externalPeer,omitempty" rdl:"optional" yaml:",omitempty"`
}

// NewTransportPolicySubject - creates an initialized TransportPolicySubject instance, returns a pointer to it
func NewTransportPolicySubject(init ...*TransportPolicySubject) *TransportPolicySubject {
	var o *TransportPolicySubject
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(TransportPolicySubject)
	}
	return o
}

type rawTransportPolicySubject TransportPolicySubject

// UnmarshalJSON is defined for proper JSON decoding of a TransportPolicySubject
func (self *TransportPolicySubject) UnmarshalJSON(b []byte) error {
	var m rawTransportPolicySubject
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := TransportPolicySubject(m)
		*self = o
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *TransportPolicySubject) Validate() error {
	if self.DomainName == "" {
		return fmt.Errorf("TransportPolicySubject.domainName is missing but is a required field")
	} else {
		val := rdl.Validate(MSDSchema(), "TransportPolicySubjectDomainName", self.DomainName)
		if !val.Valid {
			return fmt.Errorf("TransportPolicySubject.domainName does not contain a valid TransportPolicySubjectDomainName (%v)", val.Error)
		}
	}
	if self.ServiceName == "" {
		return fmt.Errorf("TransportPolicySubject.serviceName is missing but is a required field")
	} else {
		val := rdl.Validate(MSDSchema(), "TransportPolicySubjectServiceName", self.ServiceName)
		if !val.Valid {
			return fmt.Errorf("TransportPolicySubject.serviceName does not contain a valid TransportPolicySubjectServiceName (%v)", val.Error)
		}
	}
	if self.ExternalPeer != "" {
		val := rdl.Validate(MSDSchema(), "TransportPolicySubjectExternal", self.ExternalPeer)
		if !val.Valid {
			return fmt.Errorf("TransportPolicySubject.externalPeer does not contain a valid TransportPolicySubjectExternal (%v)", val.Error)
		}
	}
	return nil
}

// TransportPolicySubjectSelectorRequirement - A subject selector requirement
// is a selector that contains value, a key, and an operator that relates the
// key and value.
type TransportPolicySubjectSelectorRequirement struct {

	//
	// key that the selector applies to
	//
	Key string `json:"key"`

	//
	// Operator that is applied to the key and value
	//
	Operator string `json:"operator"`

	//
	// Value that the selector applies to
	//
	Value string `json:"value"`
}

// NewTransportPolicySubjectSelectorRequirement - creates an initialized TransportPolicySubjectSelectorRequirement instance, returns a pointer to it
func NewTransportPolicySubjectSelectorRequirement(init ...*TransportPolicySubjectSelectorRequirement) *TransportPolicySubjectSelectorRequirement {
	var o *TransportPolicySubjectSelectorRequirement
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(TransportPolicySubjectSelectorRequirement)
	}
	return o
}

type rawTransportPolicySubjectSelectorRequirement TransportPolicySubjectSelectorRequirement

// UnmarshalJSON is defined for proper JSON decoding of a TransportPolicySubjectSelectorRequirement
func (self *TransportPolicySubjectSelectorRequirement) UnmarshalJSON(b []byte) error {
	var m rawTransportPolicySubjectSelectorRequirement
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := TransportPolicySubjectSelectorRequirement(m)
		*self = o
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *TransportPolicySubjectSelectorRequirement) Validate() error {
	if self.Key == "" {
		return fmt.Errorf("TransportPolicySubjectSelectorRequirement.key is missing but is a required field")
	} else {
		val := rdl.Validate(MSDSchema(), "String", self.Key)
		if !val.Valid {
			return fmt.Errorf("TransportPolicySubjectSelectorRequirement.key does not contain a valid String (%v)", val.Error)
		}
	}
	if self.Operator == "" {
		return fmt.Errorf("TransportPolicySubjectSelectorRequirement.operator is missing but is a required field")
	} else {
		val := rdl.Validate(MSDSchema(), "String", self.Operator)
		if !val.Valid {
			return fmt.Errorf("TransportPolicySubjectSelectorRequirement.operator does not contain a valid String (%v)", val.Error)
		}
	}
	if self.Value == "" {
		return fmt.Errorf("TransportPolicySubjectSelectorRequirement.value is missing but is a required field")
	} else {
		val := rdl.Validate(MSDSchema(), "String", self.Value)
		if !val.Valid {
			return fmt.Errorf("TransportPolicySubjectSelectorRequirement.value does not contain a valid String (%v)", val.Error)
		}
	}
	return nil
}

// TransportPolicyCondition - Transport policy condition. Used to specify
// additional restrictions for the subject of a transport policy
type TransportPolicyCondition struct {

	//
	// State of transport policy enforcement ( ENFORCE / REPORT )
	//
	EnforcementState TransportPolicyEnforcementState `json:"enforcementState"`

	//
	// Acts as restrictions. If present, this transport policy should be
	// restricted to only mentioned instances.
	//
	Instances []string `json:"instances,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// Scope of transport policy
	//
	Scope []TransportPolicyScope `json:"scope,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// List of any additional conditions
	//
	AdditionalConditions []*TransportPolicySubjectSelectorRequirement `json:"additionalConditions,omitempty" rdl:"optional" yaml:",omitempty"`
}

// NewTransportPolicyCondition - creates an initialized TransportPolicyCondition instance, returns a pointer to it
func NewTransportPolicyCondition(init ...*TransportPolicyCondition) *TransportPolicyCondition {
	var o *TransportPolicyCondition
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(TransportPolicyCondition)
	}
	return o
}

type rawTransportPolicyCondition TransportPolicyCondition

// UnmarshalJSON is defined for proper JSON decoding of a TransportPolicyCondition
func (self *TransportPolicyCondition) UnmarshalJSON(b []byte) error {
	var m rawTransportPolicyCondition
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := TransportPolicyCondition(m)
		*self = o
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *TransportPolicyCondition) Validate() error {
	return nil
}

// PolicyPort - generic policy port. Will be used by TransportPolicyPort and
// NetworkPolicyPort structs
type PolicyPort struct {

	//
	// Start port of the port range. port and endPort will have same values for a
	// single port definition.
	//
	Port int32 `json:"port"`

	//
	// End port of the port range. port and endPort will have same values for a
	// single port definition.
	//
	EndPort int32 `json:"endPort"`
}

// NewPolicyPort - creates an initialized PolicyPort instance, returns a pointer to it
func NewPolicyPort(init ...*PolicyPort) *PolicyPort {
	var o *PolicyPort
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(PolicyPort)
	}
	return o
}

type rawPolicyPort PolicyPort

// UnmarshalJSON is defined for proper JSON decoding of a PolicyPort
func (self *PolicyPort) UnmarshalJSON(b []byte) error {
	var m rawPolicyPort
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := PolicyPort(m)
		*self = o
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *PolicyPort) Validate() error {
	return nil
}

// TransportPolicyPort - Transport policy port
type TransportPolicyPort struct {

	//
	// Start port of the port range. port and endPort will have same values for a
	// single port definition.
	//
	Port int32 `json:"port"`

	//
	// End port of the port range. port and endPort will have same values for a
	// single port definition.
	//
	EndPort int32 `json:"endPort"`

	//
	// Protocol for this transport policy
	//
	Protocol TransportPolicyProtocol `json:"protocol"`
}

// NewTransportPolicyPort - creates an initialized TransportPolicyPort instance, returns a pointer to it
func NewTransportPolicyPort(init ...*TransportPolicyPort) *TransportPolicyPort {
	var o *TransportPolicyPort
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(TransportPolicyPort)
	}
	return o
}

type rawTransportPolicyPort TransportPolicyPort

// UnmarshalJSON is defined for proper JSON decoding of a TransportPolicyPort
func (self *TransportPolicyPort) UnmarshalJSON(b []byte) error {
	var m rawTransportPolicyPort
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := TransportPolicyPort(m)
		*self = o
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *TransportPolicyPort) Validate() error {
	return nil
}

// TransportPolicyMatch - Selector for the subject of a transport policy
type TransportPolicyMatch struct {

	//
	// Subject where this transport policy applies
	//
	AthenzService *TransportPolicySubject `json:"athenzService"`

	//
	// List of additional requirements for restrictions. Requirements are ANDed.
	//
	Conditions []*TransportPolicyCondition `json:"conditions"`
}

// NewTransportPolicyMatch - creates an initialized TransportPolicyMatch instance, returns a pointer to it
func NewTransportPolicyMatch(init ...*TransportPolicyMatch) *TransportPolicyMatch {
	var o *TransportPolicyMatch
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(TransportPolicyMatch)
	}
	return o.Init()
}

// Init - sets up the instance according to its default field values, if any
func (self *TransportPolicyMatch) Init() *TransportPolicyMatch {
	if self.AthenzService == nil {
		self.AthenzService = NewTransportPolicySubject()
	}
	if self.Conditions == nil {
		self.Conditions = make([]*TransportPolicyCondition, 0)
	}
	return self
}

type rawTransportPolicyMatch TransportPolicyMatch

// UnmarshalJSON is defined for proper JSON decoding of a TransportPolicyMatch
func (self *TransportPolicyMatch) UnmarshalJSON(b []byte) error {
	var m rawTransportPolicyMatch
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := TransportPolicyMatch(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *TransportPolicyMatch) Validate() error {
	if self.AthenzService == nil {
		return fmt.Errorf("TransportPolicyMatch: Missing required field: athenzService")
	}
	if self.Conditions == nil {
		return fmt.Errorf("TransportPolicyMatch: Missing required field: conditions")
	}
	return nil
}

// TransportPolicyPeer - Source or destination for a transport policy
type TransportPolicyPeer struct {

	//
	// List of transport policy subjects
	//
	AthenzServices []*TransportPolicySubject `json:"athenzServices"`

	//
	// List of network traffic port part of this transport policy
	//
	Ports []*TransportPolicyPort `json:"ports"`
}

// NewTransportPolicyPeer - creates an initialized TransportPolicyPeer instance, returns a pointer to it
func NewTransportPolicyPeer(init ...*TransportPolicyPeer) *TransportPolicyPeer {
	var o *TransportPolicyPeer
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(TransportPolicyPeer)
	}
	return o.Init()
}

// Init - sets up the instance according to its default field values, if any
func (self *TransportPolicyPeer) Init() *TransportPolicyPeer {
	if self.AthenzServices == nil {
		self.AthenzServices = make([]*TransportPolicySubject, 0)
	}
	if self.Ports == nil {
		self.Ports = make([]*TransportPolicyPort, 0)
	}
	return self
}

type rawTransportPolicyPeer TransportPolicyPeer

// UnmarshalJSON is defined for proper JSON decoding of a TransportPolicyPeer
func (self *TransportPolicyPeer) UnmarshalJSON(b []byte) error {
	var m rawTransportPolicyPeer
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := TransportPolicyPeer(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *TransportPolicyPeer) Validate() error {
	if self.AthenzServices == nil {
		return fmt.Errorf("TransportPolicyPeer: Missing required field: athenzServices")
	}
	if self.Ports == nil {
		return fmt.Errorf("TransportPolicyPeer: Missing required field: ports")
	}
	return nil
}

// TransportPolicyEntitySelector - Entity to which a transport policy applies.
// Describes the subject and port(s) for a transport policy.
type TransportPolicyEntitySelector struct {

	//
	// Requirements for selecting the subject for this transport policy.
	//
	Match *TransportPolicyMatch `json:"match"`

	//
	// List of network traffic port of the subject eligible for the transport
	// policy
	//
	Ports []*TransportPolicyPort `json:"ports"`
}

// NewTransportPolicyEntitySelector - creates an initialized TransportPolicyEntitySelector instance, returns a pointer to it
func NewTransportPolicyEntitySelector(init ...*TransportPolicyEntitySelector) *TransportPolicyEntitySelector {
	var o *TransportPolicyEntitySelector
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(TransportPolicyEntitySelector)
	}
	return o.Init()
}

// Init - sets up the instance according to its default field values, if any
func (self *TransportPolicyEntitySelector) Init() *TransportPolicyEntitySelector {
	if self.Match == nil {
		self.Match = NewTransportPolicyMatch()
	}
	if self.Ports == nil {
		self.Ports = make([]*TransportPolicyPort, 0)
	}
	return self
}

type rawTransportPolicyEntitySelector TransportPolicyEntitySelector

// UnmarshalJSON is defined for proper JSON decoding of a TransportPolicyEntitySelector
func (self *TransportPolicyEntitySelector) UnmarshalJSON(b []byte) error {
	var m rawTransportPolicyEntitySelector
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := TransportPolicyEntitySelector(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *TransportPolicyEntitySelector) Validate() error {
	if self.Match == nil {
		return fmt.Errorf("TransportPolicyEntitySelector: Missing required field: match")
	}
	if self.Ports == nil {
		return fmt.Errorf("TransportPolicyEntitySelector: Missing required field: ports")
	}
	return nil
}

// TransportPolicyIngressRule - Transport policy ingress rule
type TransportPolicyIngressRule struct {

	//
	// Assertion id associated with this transport policy
	//
	Id int64 `json:"id"`

	//
	// Last modification timestamp of this transport policy
	//
	LastModified rdl.Timestamp `json:"lastModified"`

	//
	// Entity to which this transport policy applies
	//
	EntitySelector *TransportPolicyEntitySelector `json:"entitySelector"`

	//
	// Source of network traffic
	//
	From *TransportPolicyPeer `json:"from,omitempty" rdl:"optional" yaml:",omitempty"`
}

// NewTransportPolicyIngressRule - creates an initialized TransportPolicyIngressRule instance, returns a pointer to it
func NewTransportPolicyIngressRule(init ...*TransportPolicyIngressRule) *TransportPolicyIngressRule {
	var o *TransportPolicyIngressRule
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(TransportPolicyIngressRule)
	}
	return o.Init()
}

// Init - sets up the instance according to its default field values, if any
func (self *TransportPolicyIngressRule) Init() *TransportPolicyIngressRule {
	if self.EntitySelector == nil {
		self.EntitySelector = NewTransportPolicyEntitySelector()
	}
	return self
}

type rawTransportPolicyIngressRule TransportPolicyIngressRule

// UnmarshalJSON is defined for proper JSON decoding of a TransportPolicyIngressRule
func (self *TransportPolicyIngressRule) UnmarshalJSON(b []byte) error {
	var m rawTransportPolicyIngressRule
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := TransportPolicyIngressRule(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *TransportPolicyIngressRule) Validate() error {
	if self.LastModified.IsZero() {
		return fmt.Errorf("TransportPolicyIngressRule: Missing required field: lastModified")
	}
	if self.EntitySelector == nil {
		return fmt.Errorf("TransportPolicyIngressRule: Missing required field: entitySelector")
	}
	return nil
}

// TransportPolicyEgressRule - Transport policy egress rule
type TransportPolicyEgressRule struct {

	//
	// Assertion id associated with this transport policy
	//
	Id int64 `json:"id"`

	//
	// Last modification timestamp of this transport policy
	//
	LastModified rdl.Timestamp `json:"lastModified"`

	//
	// Entity to which this transport policy applies
	//
	EntitySelector *TransportPolicyEntitySelector `json:"entitySelector"`

	//
	// Destination of network traffic
	//
	To *TransportPolicyPeer `json:"to,omitempty" rdl:"optional" yaml:",omitempty"`
}

// NewTransportPolicyEgressRule - creates an initialized TransportPolicyEgressRule instance, returns a pointer to it
func NewTransportPolicyEgressRule(init ...*TransportPolicyEgressRule) *TransportPolicyEgressRule {
	var o *TransportPolicyEgressRule
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(TransportPolicyEgressRule)
	}
	return o.Init()
}

// Init - sets up the instance according to its default field values, if any
func (self *TransportPolicyEgressRule) Init() *TransportPolicyEgressRule {
	if self.EntitySelector == nil {
		self.EntitySelector = NewTransportPolicyEntitySelector()
	}
	return self
}

type rawTransportPolicyEgressRule TransportPolicyEgressRule

// UnmarshalJSON is defined for proper JSON decoding of a TransportPolicyEgressRule
func (self *TransportPolicyEgressRule) UnmarshalJSON(b []byte) error {
	var m rawTransportPolicyEgressRule
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := TransportPolicyEgressRule(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *TransportPolicyEgressRule) Validate() error {
	if self.LastModified.IsZero() {
		return fmt.Errorf("TransportPolicyEgressRule: Missing required field: lastModified")
	}
	if self.EntitySelector == nil {
		return fmt.Errorf("TransportPolicyEgressRule: Missing required field: entitySelector")
	}
	return nil
}

// TransportPolicyRules - Transport policy containing ingress and egress rules
type TransportPolicyRules struct {

	//
	// List of ingress rules
	//
	Ingress []*TransportPolicyIngressRule `json:"ingress"`

	//
	// List of egress rules
	//
	Egress []*TransportPolicyEgressRule `json:"egress"`
}

// NewTransportPolicyRules - creates an initialized TransportPolicyRules instance, returns a pointer to it
func NewTransportPolicyRules(init ...*TransportPolicyRules) *TransportPolicyRules {
	var o *TransportPolicyRules
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(TransportPolicyRules)
	}
	return o.Init()
}

// Init - sets up the instance according to its default field values, if any
func (self *TransportPolicyRules) Init() *TransportPolicyRules {
	if self.Ingress == nil {
		self.Ingress = make([]*TransportPolicyIngressRule, 0)
	}
	if self.Egress == nil {
		self.Egress = make([]*TransportPolicyEgressRule, 0)
	}
	return self
}

type rawTransportPolicyRules TransportPolicyRules

// UnmarshalJSON is defined for proper JSON decoding of a TransportPolicyRules
func (self *TransportPolicyRules) UnmarshalJSON(b []byte) error {
	var m rawTransportPolicyRules
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := TransportPolicyRules(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *TransportPolicyRules) Validate() error {
	if self.Ingress == nil {
		return fmt.Errorf("TransportPolicyRules: Missing required field: ingress")
	}
	if self.Egress == nil {
		return fmt.Errorf("TransportPolicyRules: Missing required field: egress")
	}
	return nil
}

// TransportPolicyValidationRequest - Transport policy request object to be
// validated
type TransportPolicyValidationRequest struct {

	//
	// Describes the entity to which this transport policy applies
	//
	EntitySelector *TransportPolicyEntitySelector `json:"entitySelector"`

	//
	// source or destination of the network traffic depending on direction
	//
	Peer *TransportPolicyPeer `json:"peer"`

	//
	// If present, assertion id associated with this transport policy
	//
	Id               *int64                          `json:"id,omitempty" rdl:"optional" yaml:",omitempty"`
	TrafficDirection TransportPolicyTrafficDirection `json:"trafficDirection"`
}

// NewTransportPolicyValidationRequest - creates an initialized TransportPolicyValidationRequest instance, returns a pointer to it
func NewTransportPolicyValidationRequest(init ...*TransportPolicyValidationRequest) *TransportPolicyValidationRequest {
	var o *TransportPolicyValidationRequest
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(TransportPolicyValidationRequest)
	}
	return o.Init()
}

// Init - sets up the instance according to its default field values, if any
func (self *TransportPolicyValidationRequest) Init() *TransportPolicyValidationRequest {
	if self.EntitySelector == nil {
		self.EntitySelector = NewTransportPolicyEntitySelector()
	}
	if self.Peer == nil {
		self.Peer = NewTransportPolicyPeer()
	}
	return self
}

type rawTransportPolicyValidationRequest TransportPolicyValidationRequest

// UnmarshalJSON is defined for proper JSON decoding of a TransportPolicyValidationRequest
func (self *TransportPolicyValidationRequest) UnmarshalJSON(b []byte) error {
	var m rawTransportPolicyValidationRequest
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := TransportPolicyValidationRequest(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *TransportPolicyValidationRequest) Validate() error {
	if self.EntitySelector == nil {
		return fmt.Errorf("TransportPolicyValidationRequest: Missing required field: entitySelector")
	}
	if self.Peer == nil {
		return fmt.Errorf("TransportPolicyValidationRequest: Missing required field: peer")
	}
	return nil
}

// TransportPolicyValidationResponse - Response object of transport policy rule
// validation
type TransportPolicyValidationResponse struct {
	Status TransportPolicyValidationStatus `json:"status"`
	Errors []string                        `json:"errors,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// most recent update timestamp in the backend
	//
	UpdateTime *rdl.Timestamp `json:"updateTime,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// If present, assertion id associated with the transport policy
	//
	Id *int64 `json:"id,omitempty" rdl:"optional" yaml:",omitempty"`
}

// NewTransportPolicyValidationResponse - creates an initialized TransportPolicyValidationResponse instance, returns a pointer to it
func NewTransportPolicyValidationResponse(init ...*TransportPolicyValidationResponse) *TransportPolicyValidationResponse {
	var o *TransportPolicyValidationResponse
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(TransportPolicyValidationResponse)
	}
	return o
}

type rawTransportPolicyValidationResponse TransportPolicyValidationResponse

// UnmarshalJSON is defined for proper JSON decoding of a TransportPolicyValidationResponse
func (self *TransportPolicyValidationResponse) UnmarshalJSON(b []byte) error {
	var m rawTransportPolicyValidationResponse
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := TransportPolicyValidationResponse(m)
		*self = o
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *TransportPolicyValidationResponse) Validate() error {
	return nil
}

// TransportPolicyValidationResponseList - List of
// TransportPolicyValidationResponse
type TransportPolicyValidationResponseList struct {

	//
	// list of transport policy validation response
	//
	ResponseList []*TransportPolicyValidationResponse `json:"responseList"`
}

// NewTransportPolicyValidationResponseList - creates an initialized TransportPolicyValidationResponseList instance, returns a pointer to it
func NewTransportPolicyValidationResponseList(init ...*TransportPolicyValidationResponseList) *TransportPolicyValidationResponseList {
	var o *TransportPolicyValidationResponseList
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(TransportPolicyValidationResponseList)
	}
	return o.Init()
}

// Init - sets up the instance according to its default field values, if any
func (self *TransportPolicyValidationResponseList) Init() *TransportPolicyValidationResponseList {
	if self.ResponseList == nil {
		self.ResponseList = make([]*TransportPolicyValidationResponse, 0)
	}
	return self
}

type rawTransportPolicyValidationResponseList TransportPolicyValidationResponseList

// UnmarshalJSON is defined for proper JSON decoding of a TransportPolicyValidationResponseList
func (self *TransportPolicyValidationResponseList) UnmarshalJSON(b []byte) error {
	var m rawTransportPolicyValidationResponseList
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := TransportPolicyValidationResponseList(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *TransportPolicyValidationResponseList) Validate() error {
	if self.ResponseList == nil {
		return fmt.Errorf("TransportPolicyValidationResponseList: Missing required field: responseList")
	}
	return nil
}

// TransportPolicyRequest - Input to create a transport policy
type TransportPolicyRequest struct {

	//
	// Direction of network traffic
	//
	Direction TransportPolicyTrafficDirection `json:"direction"`

	//
	// Policy Identifier
	//
	Identifier EntityName `json:"identifier"`

	//
	// Subject for the policy
	//
	Subject *TransportPolicySubject `json:"subject"`

	//
	// List of transport policy conditions
	//
	Conditions []*TransportPolicyCondition `json:"conditions,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// List of source network traffic ports
	//
	SourcePorts []*TransportPolicyPort `json:"sourcePorts"`

	//
	// List of destination network traffic ports
	//
	DestinationPorts []*TransportPolicyPort `json:"destinationPorts"`

	//
	// Source or destination of the policy depending on direction
	//
	Peers []*TransportPolicySubject `json:"peers,omitempty" rdl:"optional" yaml:",omitempty"`
}

// NewTransportPolicyRequest - creates an initialized TransportPolicyRequest instance, returns a pointer to it
func NewTransportPolicyRequest(init ...*TransportPolicyRequest) *TransportPolicyRequest {
	var o *TransportPolicyRequest
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(TransportPolicyRequest)
	}
	return o.Init()
}

// Init - sets up the instance according to its default field values, if any
func (self *TransportPolicyRequest) Init() *TransportPolicyRequest {
	if self.Subject == nil {
		self.Subject = NewTransportPolicySubject()
	}
	if self.SourcePorts == nil {
		self.SourcePorts = make([]*TransportPolicyPort, 0)
	}
	if self.DestinationPorts == nil {
		self.DestinationPorts = make([]*TransportPolicyPort, 0)
	}
	return self
}

type rawTransportPolicyRequest TransportPolicyRequest

// UnmarshalJSON is defined for proper JSON decoding of a TransportPolicyRequest
func (self *TransportPolicyRequest) UnmarshalJSON(b []byte) error {
	var m rawTransportPolicyRequest
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := TransportPolicyRequest(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *TransportPolicyRequest) Validate() error {
	if self.Identifier == "" {
		return fmt.Errorf("TransportPolicyRequest.identifier is missing but is a required field")
	} else {
		val := rdl.Validate(MSDSchema(), "EntityName", self.Identifier)
		if !val.Valid {
			return fmt.Errorf("TransportPolicyRequest.identifier does not contain a valid EntityName (%v)", val.Error)
		}
	}
	if self.Subject == nil {
		return fmt.Errorf("TransportPolicyRequest: Missing required field: subject")
	}
	if self.SourcePorts == nil {
		return fmt.Errorf("TransportPolicyRequest: Missing required field: sourcePorts")
	}
	if self.DestinationPorts == nil {
		return fmt.Errorf("TransportPolicyRequest: Missing required field: destinationPorts")
	}
	return nil
}

// StaticWorkloadType - Enum representing defined types of static workloads.
type StaticWorkloadType int

// StaticWorkloadType constants
const (
	_ StaticWorkloadType = iota
	VIP
	ENTERPRISE_APPLIANCE
	CLOUD_LB
	CLOUD_NAT
	EXTERNAL_APPLIANCE
	VIP_LB
	CLOUD_MANAGED
	SERVICE_SUBNET
)

var namesStaticWorkloadType = []string{
	VIP:                  "VIP",
	ENTERPRISE_APPLIANCE: "ENTERPRISE_APPLIANCE",
	CLOUD_LB:             "CLOUD_LB",
	CLOUD_NAT:            "CLOUD_NAT",
	EXTERNAL_APPLIANCE:   "EXTERNAL_APPLIANCE",
	VIP_LB:               "VIP_LB",
	CLOUD_MANAGED:        "CLOUD_MANAGED",
	SERVICE_SUBNET:       "SERVICE_SUBNET",
}

// NewStaticWorkloadType - return a string representation of the enum
func NewStaticWorkloadType(init ...interface{}) StaticWorkloadType {
	if len(init) == 1 {
		switch v := init[0].(type) {
		case StaticWorkloadType:
			return v
		case int:
			return StaticWorkloadType(v)
		case int32:
			return StaticWorkloadType(v)
		case string:
			for i, s := range namesStaticWorkloadType {
				if s == v {
					return StaticWorkloadType(i)
				}
			}
		default:
			panic("Bad init value for StaticWorkloadType enum")
		}
	}
	return StaticWorkloadType(0) //default to the first enum value
}

// String - return a string representation of the enum
func (e StaticWorkloadType) String() string {
	return namesStaticWorkloadType[e]
}

// SymbolSet - return an array of all valid string representations (symbols) of the enum
func (e StaticWorkloadType) SymbolSet() []string {
	return namesStaticWorkloadType
}

// MarshalJSON is defined for proper JSON encoding of a StaticWorkloadType
func (e StaticWorkloadType) MarshalJSON() ([]byte, error) {
	return json.Marshal(e.String())
}

// UnmarshalJSON is defined for proper JSON decoding of a StaticWorkloadType
func (e *StaticWorkloadType) UnmarshalJSON(b []byte) error {
	var j string
	err := json.Unmarshal(b, &j)
	if err == nil {
		s := string(j)
		for v, s2 := range namesStaticWorkloadType {
			if s == s2 {
				*e = StaticWorkloadType(v)
				return nil
			}
		}
		err = fmt.Errorf("Bad enum symbol for type StaticWorkloadType: %s", s)
	}
	return err
}

// DynamicWorkload - workload type describing workload bootstrapped with an
// identity
type DynamicWorkload struct {

	//
	// name of the domain
	//
	DomainName DomainName `json:"domainName"`

	//
	// name of the service
	//
	ServiceName EntityName `json:"serviceName"`

	//
	// unique identifier for the workload, usually defined by provider
	//
	Uuid string `json:"uuid"`

	//
	// list of IP addresses associated with the workload, optional for
	// getWorkloadsByIP API call
	//
	IpAddresses []string `json:"ipAddresses"`

	//
	// hostname associated with the workload
	//
	Hostname string `json:"hostname"`

	//
	// infrastructure provider e.g. Kubernetes, AWS, Azure, openstack etc.
	//
	Provider string `json:"provider"`

	//
	// most recent update timestamp in the backend
	//
	UpdateTime rdl.Timestamp `json:"updateTime"`

	//
	// certificate expiry time (ex: getNotAfter)
	//
	CertExpiryTime rdl.Timestamp `json:"certExpiryTime"`

	//
	// certificate issue time (ex: getNotBefore)
	//
	CertIssueTime *rdl.Timestamp `json:"certIssueTime,omitempty" rdl:"optional" yaml:",omitempty"`
}

// NewDynamicWorkload - creates an initialized DynamicWorkload instance, returns a pointer to it
func NewDynamicWorkload(init ...*DynamicWorkload) *DynamicWorkload {
	var o *DynamicWorkload
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(DynamicWorkload)
	}
	return o.Init()
}

// Init - sets up the instance according to its default field values, if any
func (self *DynamicWorkload) Init() *DynamicWorkload {
	if self.IpAddresses == nil {
		self.IpAddresses = make([]string, 0)
	}
	return self
}

type rawDynamicWorkload DynamicWorkload

// UnmarshalJSON is defined for proper JSON decoding of a DynamicWorkload
func (self *DynamicWorkload) UnmarshalJSON(b []byte) error {
	var m rawDynamicWorkload
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := DynamicWorkload(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *DynamicWorkload) Validate() error {
	if self.DomainName == "" {
		return fmt.Errorf("DynamicWorkload.domainName is missing but is a required field")
	} else {
		val := rdl.Validate(MSDSchema(), "DomainName", self.DomainName)
		if !val.Valid {
			return fmt.Errorf("DynamicWorkload.domainName does not contain a valid DomainName (%v)", val.Error)
		}
	}
	if self.ServiceName == "" {
		return fmt.Errorf("DynamicWorkload.serviceName is missing but is a required field")
	} else {
		val := rdl.Validate(MSDSchema(), "EntityName", self.ServiceName)
		if !val.Valid {
			return fmt.Errorf("DynamicWorkload.serviceName does not contain a valid EntityName (%v)", val.Error)
		}
	}
	if self.Uuid == "" {
		return fmt.Errorf("DynamicWorkload.uuid is missing but is a required field")
	} else {
		val := rdl.Validate(MSDSchema(), "String", self.Uuid)
		if !val.Valid {
			return fmt.Errorf("DynamicWorkload.uuid does not contain a valid String (%v)", val.Error)
		}
	}
	if self.IpAddresses == nil {
		return fmt.Errorf("DynamicWorkload: Missing required field: ipAddresses")
	}
	if self.Hostname == "" {
		return fmt.Errorf("DynamicWorkload.hostname is missing but is a required field")
	} else {
		val := rdl.Validate(MSDSchema(), "String", self.Hostname)
		if !val.Valid {
			return fmt.Errorf("DynamicWorkload.hostname does not contain a valid String (%v)", val.Error)
		}
	}
	if self.Provider == "" {
		return fmt.Errorf("DynamicWorkload.provider is missing but is a required field")
	} else {
		val := rdl.Validate(MSDSchema(), "String", self.Provider)
		if !val.Valid {
			return fmt.Errorf("DynamicWorkload.provider does not contain a valid String (%v)", val.Error)
		}
	}
	if self.UpdateTime.IsZero() {
		return fmt.Errorf("DynamicWorkload: Missing required field: updateTime")
	}
	if self.CertExpiryTime.IsZero() {
		return fmt.Errorf("DynamicWorkload: Missing required field: certExpiryTime")
	}
	return nil
}

// Workload - kept for backward compatibility sake. Will be eventually
// deprecated in favor of DynamicWorkload
type Workload struct {

	//
	// name of the domain
	//
	DomainName DomainName `json:"domainName"`

	//
	// name of the service
	//
	ServiceName EntityName `json:"serviceName"`

	//
	// unique identifier for the workload, usually defined by provider
	//
	Uuid string `json:"uuid"`

	//
	// list of IP addresses associated with the workload, optional for
	// getWorkloadsByIP API call
	//
	IpAddresses []string `json:"ipAddresses"`

	//
	// hostname associated with the workload
	//
	Hostname string `json:"hostname"`

	//
	// infrastructure provider e.g. Kubernetes, AWS, Azure, openstack etc.
	//
	Provider string `json:"provider"`

	//
	// most recent update timestamp in the backend
	//
	UpdateTime rdl.Timestamp `json:"updateTime"`

	//
	// certificate expiry time (ex: getNotAfter)
	//
	CertExpiryTime rdl.Timestamp `json:"certExpiryTime"`

	//
	// certificate issue time (ex: getNotBefore)
	//
	CertIssueTime *rdl.Timestamp `json:"certIssueTime,omitempty" rdl:"optional" yaml:",omitempty"`
}

// NewWorkload - creates an initialized Workload instance, returns a pointer to it
func NewWorkload(init ...*Workload) *Workload {
	var o *Workload
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(Workload)
	}
	return o.Init()
}

// Init - sets up the instance according to its default field values, if any
func (self *Workload) Init() *Workload {
	if self.IpAddresses == nil {
		self.IpAddresses = make([]string, 0)
	}
	return self
}

type rawWorkload Workload

// UnmarshalJSON is defined for proper JSON decoding of a Workload
func (self *Workload) UnmarshalJSON(b []byte) error {
	var m rawWorkload
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := Workload(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *Workload) Validate() error {
	if self.DomainName == "" {
		return fmt.Errorf("Workload.domainName is missing but is a required field")
	} else {
		val := rdl.Validate(MSDSchema(), "DomainName", self.DomainName)
		if !val.Valid {
			return fmt.Errorf("Workload.domainName does not contain a valid DomainName (%v)", val.Error)
		}
	}
	if self.ServiceName == "" {
		return fmt.Errorf("Workload.serviceName is missing but is a required field")
	} else {
		val := rdl.Validate(MSDSchema(), "EntityName", self.ServiceName)
		if !val.Valid {
			return fmt.Errorf("Workload.serviceName does not contain a valid EntityName (%v)", val.Error)
		}
	}
	if self.Uuid == "" {
		return fmt.Errorf("Workload.uuid is missing but is a required field")
	} else {
		val := rdl.Validate(MSDSchema(), "String", self.Uuid)
		if !val.Valid {
			return fmt.Errorf("Workload.uuid does not contain a valid String (%v)", val.Error)
		}
	}
	if self.IpAddresses == nil {
		return fmt.Errorf("Workload: Missing required field: ipAddresses")
	}
	if self.Hostname == "" {
		return fmt.Errorf("Workload.hostname is missing but is a required field")
	} else {
		val := rdl.Validate(MSDSchema(), "String", self.Hostname)
		if !val.Valid {
			return fmt.Errorf("Workload.hostname does not contain a valid String (%v)", val.Error)
		}
	}
	if self.Provider == "" {
		return fmt.Errorf("Workload.provider is missing but is a required field")
	} else {
		val := rdl.Validate(MSDSchema(), "String", self.Provider)
		if !val.Valid {
			return fmt.Errorf("Workload.provider does not contain a valid String (%v)", val.Error)
		}
	}
	if self.UpdateTime.IsZero() {
		return fmt.Errorf("Workload: Missing required field: updateTime")
	}
	if self.CertExpiryTime.IsZero() {
		return fmt.Errorf("Workload: Missing required field: certExpiryTime")
	}
	return nil
}

// StaticWorkload - workload type describing workload indirectly associated
// with an identity ( without bootstrap )
type StaticWorkload struct {

	//
	// name of the domain
	//
	DomainName DomainName `json:"domainName"`

	//
	// name of the service
	//
	ServiceName EntityName `json:"serviceName"`

	//
	// value representing one of the StaticWorkloadType enum
	//
	Type StaticWorkloadType `json:"type"`

	//
	// list of IP addresses associated with the workload, optional for
	// getWorkloadsByIP API call
	//
	IpAddresses []string `json:"ipAddresses,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// name associated with the workload. In most cases will be a FQDN
	//
	Name StaticWorkloadName `json:"name,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// most recent update timestamp in the backend
	//
	UpdateTime *rdl.Timestamp `json:"updateTime,omitempty" rdl:"optional" yaml:",omitempty"`
}

// NewStaticWorkload - creates an initialized StaticWorkload instance, returns a pointer to it
func NewStaticWorkload(init ...*StaticWorkload) *StaticWorkload {
	var o *StaticWorkload
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(StaticWorkload)
	}
	return o
}

type rawStaticWorkload StaticWorkload

// UnmarshalJSON is defined for proper JSON decoding of a StaticWorkload
func (self *StaticWorkload) UnmarshalJSON(b []byte) error {
	var m rawStaticWorkload
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := StaticWorkload(m)
		*self = o
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *StaticWorkload) Validate() error {
	if self.DomainName == "" {
		return fmt.Errorf("StaticWorkload.domainName is missing but is a required field")
	} else {
		val := rdl.Validate(MSDSchema(), "DomainName", self.DomainName)
		if !val.Valid {
			return fmt.Errorf("StaticWorkload.domainName does not contain a valid DomainName (%v)", val.Error)
		}
	}
	if self.ServiceName == "" {
		return fmt.Errorf("StaticWorkload.serviceName is missing but is a required field")
	} else {
		val := rdl.Validate(MSDSchema(), "EntityName", self.ServiceName)
		if !val.Valid {
			return fmt.Errorf("StaticWorkload.serviceName does not contain a valid EntityName (%v)", val.Error)
		}
	}
	if self.Name != "" {
		val := rdl.Validate(MSDSchema(), "StaticWorkloadName", self.Name)
		if !val.Valid {
			return fmt.Errorf("StaticWorkload.name does not contain a valid StaticWorkloadName (%v)", val.Error)
		}
	}
	return nil
}

// WorkloadOptions -
type WorkloadOptions struct {

	//
	// boolean flag to signal a change in IP state
	//
	IpChanged bool `json:"ipChanged"`
}

// NewWorkloadOptions - creates an initialized WorkloadOptions instance, returns a pointer to it
func NewWorkloadOptions(init ...*WorkloadOptions) *WorkloadOptions {
	var o *WorkloadOptions
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(WorkloadOptions)
	}
	return o
}

type rawWorkloadOptions WorkloadOptions

// UnmarshalJSON is defined for proper JSON decoding of a WorkloadOptions
func (self *WorkloadOptions) UnmarshalJSON(b []byte) error {
	var m rawWorkloadOptions
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := WorkloadOptions(m)
		*self = o
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *WorkloadOptions) Validate() error {
	return nil
}

// Workloads - list of workloads
type Workloads struct {

	//
	// list of workloads
	//
	WorkloadList []*Workload `json:"workloadList"`

	//
	// list of dynamic workloads
	//
	DynamicWorkloadList []*DynamicWorkload `json:"dynamicWorkloadList,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// list of static workloads
	//
	StaticWorkloadList []*StaticWorkload `json:"staticWorkloadList,omitempty" rdl:"optional" yaml:",omitempty"`
}

// NewWorkloads - creates an initialized Workloads instance, returns a pointer to it
func NewWorkloads(init ...*Workloads) *Workloads {
	var o *Workloads
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(Workloads)
	}
	return o.Init()
}

// Init - sets up the instance according to its default field values, if any
func (self *Workloads) Init() *Workloads {
	if self.WorkloadList == nil {
		self.WorkloadList = make([]*Workload, 0)
	}
	return self
}

type rawWorkloads Workloads

// UnmarshalJSON is defined for proper JSON decoding of a Workloads
func (self *Workloads) UnmarshalJSON(b []byte) error {
	var m rawWorkloads
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := Workloads(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *Workloads) Validate() error {
	if self.WorkloadList == nil {
		return fmt.Errorf("Workloads: Missing required field: workloadList")
	}
	return nil
}

// StaticWorkloadService - static workload service
type StaticWorkloadService struct {

	//
	// value representing one of the StaticWorkloadType enum
	//
	Type StaticWorkloadType `json:"type"`

	//
	// name of the service
	//
	ServiceName EntityName `json:"serviceName"`

	//
	// service instance
	//
	Instance EntityName `json:"instance"`
}

// NewStaticWorkloadService - creates an initialized StaticWorkloadService instance, returns a pointer to it
func NewStaticWorkloadService(init ...*StaticWorkloadService) *StaticWorkloadService {
	var o *StaticWorkloadService
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(StaticWorkloadService)
	}
	return o
}

type rawStaticWorkloadService StaticWorkloadService

// UnmarshalJSON is defined for proper JSON decoding of a StaticWorkloadService
func (self *StaticWorkloadService) UnmarshalJSON(b []byte) error {
	var m rawStaticWorkloadService
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := StaticWorkloadService(m)
		*self = o
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *StaticWorkloadService) Validate() error {
	if self.ServiceName == "" {
		return fmt.Errorf("StaticWorkloadService.serviceName is missing but is a required field")
	} else {
		val := rdl.Validate(MSDSchema(), "EntityName", self.ServiceName)
		if !val.Valid {
			return fmt.Errorf("StaticWorkloadService.serviceName does not contain a valid EntityName (%v)", val.Error)
		}
	}
	if self.Instance == "" {
		return fmt.Errorf("StaticWorkloadService.instance is missing but is a required field")
	} else {
		val := rdl.Validate(MSDSchema(), "EntityName", self.Instance)
		if !val.Valid {
			return fmt.Errorf("StaticWorkloadService.instance does not contain a valid EntityName (%v)", val.Error)
		}
	}
	return nil
}

// StaticWorkloadServices - list of services
type StaticWorkloadServices struct {
	StaticWorkloadServices []*StaticWorkloadService `json:"staticWorkloadServices"`
}

// NewStaticWorkloadServices - creates an initialized StaticWorkloadServices instance, returns a pointer to it
func NewStaticWorkloadServices(init ...*StaticWorkloadServices) *StaticWorkloadServices {
	var o *StaticWorkloadServices
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(StaticWorkloadServices)
	}
	return o.Init()
}

// Init - sets up the instance according to its default field values, if any
func (self *StaticWorkloadServices) Init() *StaticWorkloadServices {
	if self.StaticWorkloadServices == nil {
		self.StaticWorkloadServices = make([]*StaticWorkloadService, 0)
	}
	return self
}

type rawStaticWorkloadServices StaticWorkloadServices

// UnmarshalJSON is defined for proper JSON decoding of a StaticWorkloadServices
func (self *StaticWorkloadServices) UnmarshalJSON(b []byte) error {
	var m rawStaticWorkloadServices
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := StaticWorkloadServices(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *StaticWorkloadServices) Validate() error {
	if self.StaticWorkloadServices == nil {
		return fmt.Errorf("StaticWorkloadServices: Missing required field: staticWorkloadServices")
	}
	return nil
}

// DomainServices - request type to search all workloads for a domain and
// selected list of its services
type DomainServices struct {

	//
	// name of the domain
	//
	DomainName DomainName `json:"domainName"`

	//
	// list of service names
	//
	ServiceNames []EntityName `json:"serviceNames"`
}

// NewDomainServices - creates an initialized DomainServices instance, returns a pointer to it
func NewDomainServices(init ...*DomainServices) *DomainServices {
	var o *DomainServices
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(DomainServices)
	}
	return o.Init()
}

// Init - sets up the instance according to its default field values, if any
func (self *DomainServices) Init() *DomainServices {
	if self.ServiceNames == nil {
		self.ServiceNames = make([]EntityName, 0)
	}
	return self
}

type rawDomainServices DomainServices

// UnmarshalJSON is defined for proper JSON decoding of a DomainServices
func (self *DomainServices) UnmarshalJSON(b []byte) error {
	var m rawDomainServices
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := DomainServices(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *DomainServices) Validate() error {
	if self.DomainName == "" {
		return fmt.Errorf("DomainServices.domainName is missing but is a required field")
	} else {
		val := rdl.Validate(MSDSchema(), "DomainName", self.DomainName)
		if !val.Valid {
			return fmt.Errorf("DomainServices.domainName does not contain a valid DomainName (%v)", val.Error)
		}
	}
	if self.ServiceNames == nil {
		return fmt.Errorf("DomainServices: Missing required field: serviceNames")
	}
	return nil
}

// BulkWorkloadRequest - request type to search all workloads for a list of
// services grouped by domains
type BulkWorkloadRequest struct {

	//
	// list of services, grouped by domain
	//
	DomainServices []*DomainServices `json:"domainServices"`

	//
	// whether to fetch static type workloads
	//
	FetchStaticTypeWorkloads *bool `json:"fetchStaticTypeWorkloads,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// whether to fetch dynamic type workloads
	//
	FetchDynamicTypeWorkloads *bool `json:"fetchDynamicTypeWorkloads,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// list of applicable static workload types, if not set then that means all.
	// Applicable only if fetchStaticTypeWorkloads is enabled
	//
	ApplicableStaticTypes []StaticWorkloadType `json:"applicableStaticTypes,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// resolve static workloads to IPs, if applicable
	//
	ResolveStaticWorkloads *bool `json:"resolveStaticWorkloads,omitempty" rdl:"optional" yaml:",omitempty"`
}

// NewBulkWorkloadRequest - creates an initialized BulkWorkloadRequest instance, returns a pointer to it
func NewBulkWorkloadRequest(init ...*BulkWorkloadRequest) *BulkWorkloadRequest {
	var o *BulkWorkloadRequest
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(BulkWorkloadRequest)
	}
	return o.Init()
}

// Init - sets up the instance according to its default field values, if any
func (self *BulkWorkloadRequest) Init() *BulkWorkloadRequest {
	if self.DomainServices == nil {
		self.DomainServices = make([]*DomainServices, 0)
	}
	if self.FetchStaticTypeWorkloads == nil {
		d := true
		self.FetchStaticTypeWorkloads = &d
	}
	if self.FetchDynamicTypeWorkloads == nil {
		d := true
		self.FetchDynamicTypeWorkloads = &d
	}
	if self.ResolveStaticWorkloads == nil {
		d := false
		self.ResolveStaticWorkloads = &d
	}
	return self
}

type rawBulkWorkloadRequest BulkWorkloadRequest

// UnmarshalJSON is defined for proper JSON decoding of a BulkWorkloadRequest
func (self *BulkWorkloadRequest) UnmarshalJSON(b []byte) error {
	var m rawBulkWorkloadRequest
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := BulkWorkloadRequest(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *BulkWorkloadRequest) Validate() error {
	if self.DomainServices == nil {
		return fmt.Errorf("BulkWorkloadRequest: Missing required field: domainServices")
	}
	return nil
}

// BulkWorkloadResponse - response of a bulk workload search request
type BulkWorkloadResponse struct {

	//
	// list of services grouped by domain, those are not changed since time stamp
	// in matchingTag
	//
	UnmodifiedServices []*DomainServices `json:"unmodifiedServices"`

	//
	// matching workloads
	//
	Workloads *Workloads `json:"workloads"`
}

// NewBulkWorkloadResponse - creates an initialized BulkWorkloadResponse instance, returns a pointer to it
func NewBulkWorkloadResponse(init ...*BulkWorkloadResponse) *BulkWorkloadResponse {
	var o *BulkWorkloadResponse
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(BulkWorkloadResponse)
	}
	return o.Init()
}

// Init - sets up the instance according to its default field values, if any
func (self *BulkWorkloadResponse) Init() *BulkWorkloadResponse {
	if self.UnmodifiedServices == nil {
		self.UnmodifiedServices = make([]*DomainServices, 0)
	}
	if self.Workloads == nil {
		self.Workloads = NewWorkloads()
	}
	return self
}

type rawBulkWorkloadResponse BulkWorkloadResponse

// UnmarshalJSON is defined for proper JSON decoding of a BulkWorkloadResponse
func (self *BulkWorkloadResponse) UnmarshalJSON(b []byte) error {
	var m rawBulkWorkloadResponse
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := BulkWorkloadResponse(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *BulkWorkloadResponse) Validate() error {
	if self.UnmodifiedServices == nil {
		return fmt.Errorf("BulkWorkloadResponse: Missing required field: unmodifiedServices")
	}
	if self.Workloads == nil {
		return fmt.Errorf("BulkWorkloadResponse: Missing required field: workloads")
	}
	return nil
}

// NetworkPolicyChangeEffect - IMPACT indicates that a change in network policy
// will interfere with workings of one or more transport policies NO_IMPACT
// indicates that a change in network policy will not interfere with workings of
// any transport policy
type NetworkPolicyChangeEffect int

// NetworkPolicyChangeEffect constants
const (
	_ NetworkPolicyChangeEffect = iota
	IMPACT
	NO_IMPACT
)

var namesNetworkPolicyChangeEffect = []string{
	IMPACT:    "IMPACT",
	NO_IMPACT: "NO_IMPACT",
}

// NewNetworkPolicyChangeEffect - return a string representation of the enum
func NewNetworkPolicyChangeEffect(init ...interface{}) NetworkPolicyChangeEffect {
	if len(init) == 1 {
		switch v := init[0].(type) {
		case NetworkPolicyChangeEffect:
			return v
		case int:
			return NetworkPolicyChangeEffect(v)
		case int32:
			return NetworkPolicyChangeEffect(v)
		case string:
			for i, s := range namesNetworkPolicyChangeEffect {
				if s == v {
					return NetworkPolicyChangeEffect(i)
				}
			}
		default:
			panic("Bad init value for NetworkPolicyChangeEffect enum")
		}
	}
	return NetworkPolicyChangeEffect(0) //default to the first enum value
}

// String - return a string representation of the enum
func (e NetworkPolicyChangeEffect) String() string {
	return namesNetworkPolicyChangeEffect[e]
}

// SymbolSet - return an array of all valid string representations (symbols) of the enum
func (e NetworkPolicyChangeEffect) SymbolSet() []string {
	return namesNetworkPolicyChangeEffect
}

// MarshalJSON is defined for proper JSON encoding of a NetworkPolicyChangeEffect
func (e NetworkPolicyChangeEffect) MarshalJSON() ([]byte, error) {
	return json.Marshal(e.String())
}

// UnmarshalJSON is defined for proper JSON decoding of a NetworkPolicyChangeEffect
func (e *NetworkPolicyChangeEffect) UnmarshalJSON(b []byte) error {
	var j string
	err := json.Unmarshal(b, &j)
	if err == nil {
		s := string(j)
		for v, s2 := range namesNetworkPolicyChangeEffect {
			if s == s2 {
				*e = NetworkPolicyChangeEffect(v)
				return nil
			}
		}
		err = fmt.Errorf("Bad enum symbol for type NetworkPolicyChangeEffect: %s", s)
	}
	return err
}

// IPBlock - Struct representing ip blocks used by network policy in CIDR
// (Classless inter-domain routing) format
type IPBlock struct {

	//
	// cidr notation. can be used for ipv4 or ipv6
	//
	Cidr string `json:"cidr"`
}

// NewIPBlock - creates an initialized IPBlock instance, returns a pointer to it
func NewIPBlock(init ...*IPBlock) *IPBlock {
	var o *IPBlock
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(IPBlock)
	}
	return o
}

type rawIPBlock IPBlock

// UnmarshalJSON is defined for proper JSON decoding of a IPBlock
func (self *IPBlock) UnmarshalJSON(b []byte) error {
	var m rawIPBlock
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := IPBlock(m)
		*self = o
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *IPBlock) Validate() error {
	if self.Cidr == "" {
		return fmt.Errorf("IPBlock.cidr is missing but is a required field")
	} else {
		val := rdl.Validate(MSDSchema(), "String", self.Cidr)
		if !val.Valid {
			return fmt.Errorf("IPBlock.cidr does not contain a valid String (%v)", val.Error)
		}
	}
	return nil
}

// NetworkPolicyPort - network policy port.
type NetworkPolicyPort struct {

	//
	// Start port of the port range. port and endPort will have same values for a
	// single port definition.
	//
	Port int32 `json:"port"`

	//
	// End port of the port range. port and endPort will have same values for a
	// single port definition.
	//
	EndPort int32 `json:"endPort"`

	//
	// protocol used by the network policy
	//
	Protocol TransportPolicyProtocol `json:"protocol"`
}

// NewNetworkPolicyPort - creates an initialized NetworkPolicyPort instance, returns a pointer to it
func NewNetworkPolicyPort(init ...*NetworkPolicyPort) *NetworkPolicyPort {
	var o *NetworkPolicyPort
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(NetworkPolicyPort)
	}
	return o
}

type rawNetworkPolicyPort NetworkPolicyPort

// UnmarshalJSON is defined for proper JSON decoding of a NetworkPolicyPort
func (self *NetworkPolicyPort) UnmarshalJSON(b []byte) error {
	var m rawNetworkPolicyPort
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := NetworkPolicyPort(m)
		*self = o
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *NetworkPolicyPort) Validate() error {
	return nil
}

// NetworkPolicyPorts - allows creating a unique tuple of source and
// destination ports
type NetworkPolicyPorts struct {

	//
	// list of source ports
	//
	SourcePorts []*NetworkPolicyPort `json:"sourcePorts"`

	//
	// list of destination ports
	//
	DestinationPorts []*NetworkPolicyPort `json:"destinationPorts"`
}

// NewNetworkPolicyPorts - creates an initialized NetworkPolicyPorts instance, returns a pointer to it
func NewNetworkPolicyPorts(init ...*NetworkPolicyPorts) *NetworkPolicyPorts {
	var o *NetworkPolicyPorts
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(NetworkPolicyPorts)
	}
	return o.Init()
}

// Init - sets up the instance according to its default field values, if any
func (self *NetworkPolicyPorts) Init() *NetworkPolicyPorts {
	if self.SourcePorts == nil {
		self.SourcePorts = make([]*NetworkPolicyPort, 0)
	}
	if self.DestinationPorts == nil {
		self.DestinationPorts = make([]*NetworkPolicyPort, 0)
	}
	return self
}

type rawNetworkPolicyPorts NetworkPolicyPorts

// UnmarshalJSON is defined for proper JSON decoding of a NetworkPolicyPorts
func (self *NetworkPolicyPorts) UnmarshalJSON(b []byte) error {
	var m rawNetworkPolicyPorts
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := NetworkPolicyPorts(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *NetworkPolicyPorts) Validate() error {
	if self.SourcePorts == nil {
		return fmt.Errorf("NetworkPolicyPorts: Missing required field: sourcePorts")
	}
	if self.DestinationPorts == nil {
		return fmt.Errorf("NetworkPolicyPorts: Missing required field: destinationPorts")
	}
	return nil
}

// NetworkPolicyChangeImpactRequest - struct representing input details for
// evaluating network policies change impact on transport policies
type NetworkPolicyChangeImpactRequest struct {

	//
	// from ip address range list in cidr format
	//
	From []*IPBlock `json:"from"`

	//
	// to ip address range list in cidr format
	//
	To []*IPBlock `json:"to"`

	//
	// list of ports. Facilitates multiple transports for the same source and
	// destinations.
	//
	Ports []*NetworkPolicyPorts `json:"ports"`
}

// NewNetworkPolicyChangeImpactRequest - creates an initialized NetworkPolicyChangeImpactRequest instance, returns a pointer to it
func NewNetworkPolicyChangeImpactRequest(init ...*NetworkPolicyChangeImpactRequest) *NetworkPolicyChangeImpactRequest {
	var o *NetworkPolicyChangeImpactRequest
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(NetworkPolicyChangeImpactRequest)
	}
	return o.Init()
}

// Init - sets up the instance according to its default field values, if any
func (self *NetworkPolicyChangeImpactRequest) Init() *NetworkPolicyChangeImpactRequest {
	if self.From == nil {
		self.From = make([]*IPBlock, 0)
	}
	if self.To == nil {
		self.To = make([]*IPBlock, 0)
	}
	if self.Ports == nil {
		self.Ports = make([]*NetworkPolicyPorts, 0)
	}
	return self
}

type rawNetworkPolicyChangeImpactRequest NetworkPolicyChangeImpactRequest

// UnmarshalJSON is defined for proper JSON decoding of a NetworkPolicyChangeImpactRequest
func (self *NetworkPolicyChangeImpactRequest) UnmarshalJSON(b []byte) error {
	var m rawNetworkPolicyChangeImpactRequest
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := NetworkPolicyChangeImpactRequest(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *NetworkPolicyChangeImpactRequest) Validate() error {
	if self.From == nil {
		return fmt.Errorf("NetworkPolicyChangeImpactRequest: Missing required field: from")
	}
	if self.To == nil {
		return fmt.Errorf("NetworkPolicyChangeImpactRequest: Missing required field: to")
	}
	if self.Ports == nil {
		return fmt.Errorf("NetworkPolicyChangeImpactRequest: Missing required field: ports")
	}
	return nil
}

// NetworkPolicyChangeImpactDetail -
type NetworkPolicyChangeImpactDetail struct {

	//
	// Name of the domain of the corresponding transport policy
	//
	Domain DomainName `json:"domain"`

	//
	// Name of the Athenz policy corresponding to transport policy
	//
	Policy EntityName `json:"policy"`

	//
	// Unique id of the transport policy
	//
	TransportPolicyId int64 `json:"transportPolicyId"`
}

// NewNetworkPolicyChangeImpactDetail - creates an initialized NetworkPolicyChangeImpactDetail instance, returns a pointer to it
func NewNetworkPolicyChangeImpactDetail(init ...*NetworkPolicyChangeImpactDetail) *NetworkPolicyChangeImpactDetail {
	var o *NetworkPolicyChangeImpactDetail
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(NetworkPolicyChangeImpactDetail)
	}
	return o
}

type rawNetworkPolicyChangeImpactDetail NetworkPolicyChangeImpactDetail

// UnmarshalJSON is defined for proper JSON decoding of a NetworkPolicyChangeImpactDetail
func (self *NetworkPolicyChangeImpactDetail) UnmarshalJSON(b []byte) error {
	var m rawNetworkPolicyChangeImpactDetail
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := NetworkPolicyChangeImpactDetail(m)
		*self = o
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *NetworkPolicyChangeImpactDetail) Validate() error {
	if self.Domain == "" {
		return fmt.Errorf("NetworkPolicyChangeImpactDetail.domain is missing but is a required field")
	} else {
		val := rdl.Validate(MSDSchema(), "DomainName", self.Domain)
		if !val.Valid {
			return fmt.Errorf("NetworkPolicyChangeImpactDetail.domain does not contain a valid DomainName (%v)", val.Error)
		}
	}
	if self.Policy == "" {
		return fmt.Errorf("NetworkPolicyChangeImpactDetail.policy is missing but is a required field")
	} else {
		val := rdl.Validate(MSDSchema(), "EntityName", self.Policy)
		if !val.Valid {
			return fmt.Errorf("NetworkPolicyChangeImpactDetail.policy does not contain a valid EntityName (%v)", val.Error)
		}
	}
	return nil
}

// NetworkPolicyChangeImpactResponse - struct representing response of
// evaluating network policies change impact on transport policies
type NetworkPolicyChangeImpactResponse struct {

	//
	// enum indicating effect of network policy change on one or more transport
	// policies
	//
	Effect NetworkPolicyChangeEffect `json:"effect"`

	//
	// if the above enum value is IMPACT then this optional object contains more
	// details about the impacted transport policies
	//
	Details []*NetworkPolicyChangeImpactDetail `json:"details,omitempty" rdl:"optional" yaml:",omitempty"`
}

// NewNetworkPolicyChangeImpactResponse - creates an initialized NetworkPolicyChangeImpactResponse instance, returns a pointer to it
func NewNetworkPolicyChangeImpactResponse(init ...*NetworkPolicyChangeImpactResponse) *NetworkPolicyChangeImpactResponse {
	var o *NetworkPolicyChangeImpactResponse
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(NetworkPolicyChangeImpactResponse)
	}
	return o
}

type rawNetworkPolicyChangeImpactResponse NetworkPolicyChangeImpactResponse

// UnmarshalJSON is defined for proper JSON decoding of a NetworkPolicyChangeImpactResponse
func (self *NetworkPolicyChangeImpactResponse) UnmarshalJSON(b []byte) error {
	var m rawNetworkPolicyChangeImpactResponse
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := NetworkPolicyChangeImpactResponse(m)
		*self = o
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *NetworkPolicyChangeImpactResponse) Validate() error {
	return nil
}

// KubernetesLabelSelectorRequirement - A label selector requirement is a
// selector that contains values, a key, and an operator that relates the key
// and values.
type KubernetesLabelSelectorRequirement struct {

	//
	// Label key that the selector applies to
	//
	Key string `json:"key"`

	//
	// Operator that is applied to the key. Valid operators are In, NotIn, Exists
	// and DoesNotExist.
	//
	Operator string `json:"operator"`

	//
	// Array of string values. If the operator is In or NotIn, the values array
	// must be non-empty. If the operator is Exists or DoesNotExist, the values
	// array must be empty.
	//
	Values []string `json:"values,omitempty" rdl:"optional" yaml:",omitempty"`
}

// NewKubernetesLabelSelectorRequirement - creates an initialized KubernetesLabelSelectorRequirement instance, returns a pointer to it
func NewKubernetesLabelSelectorRequirement(init ...*KubernetesLabelSelectorRequirement) *KubernetesLabelSelectorRequirement {
	var o *KubernetesLabelSelectorRequirement
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(KubernetesLabelSelectorRequirement)
	}
	return o
}

type rawKubernetesLabelSelectorRequirement KubernetesLabelSelectorRequirement

// UnmarshalJSON is defined for proper JSON decoding of a KubernetesLabelSelectorRequirement
func (self *KubernetesLabelSelectorRequirement) UnmarshalJSON(b []byte) error {
	var m rawKubernetesLabelSelectorRequirement
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := KubernetesLabelSelectorRequirement(m)
		*self = o
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *KubernetesLabelSelectorRequirement) Validate() error {
	if self.Key == "" {
		return fmt.Errorf("KubernetesLabelSelectorRequirement.key is missing but is a required field")
	} else {
		val := rdl.Validate(MSDSchema(), "String", self.Key)
		if !val.Valid {
			return fmt.Errorf("KubernetesLabelSelectorRequirement.key does not contain a valid String (%v)", val.Error)
		}
	}
	if self.Operator == "" {
		return fmt.Errorf("KubernetesLabelSelectorRequirement.operator is missing but is a required field")
	} else {
		val := rdl.Validate(MSDSchema(), "String", self.Operator)
		if !val.Valid {
			return fmt.Errorf("KubernetesLabelSelectorRequirement.operator does not contain a valid String (%v)", val.Error)
		}
	}
	return nil
}

// KubernetesLabelSelector - A label selector is a label query over a set of
// resources. The result of matchLabels and matchExpressions are ANDed. An empty
// label selector matches all objects. A null label selector matches no objects.
type KubernetesLabelSelector struct {

	//
	// Array of label selector requirements. The requirements are ANDed.
	//
	MatchExpressions []*KubernetesLabelSelectorRequirement `json:"matchExpressions"`

	//
	// Map of label key/value pairs
	//
	MatchLabels map[string]string `json:"matchLabels"`
}

// NewKubernetesLabelSelector - creates an initialized KubernetesLabelSelector instance, returns a pointer to it
func NewKubernetesLabelSelector(init ...*KubernetesLabelSelector) *KubernetesLabelSelector {
	var o *KubernetesLabelSelector
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(KubernetesLabelSelector)
	}
	return o.Init()
}

// Init - sets up the instance according to its default field values, if any
func (self *KubernetesLabelSelector) Init() *KubernetesLabelSelector {
	if self.MatchExpressions == nil {
		self.MatchExpressions = make([]*KubernetesLabelSelectorRequirement, 0)
	}
	if self.MatchLabels == nil {
		self.MatchLabels = make(map[string]string)
	}
	return self
}

type rawKubernetesLabelSelector KubernetesLabelSelector

// UnmarshalJSON is defined for proper JSON decoding of a KubernetesLabelSelector
func (self *KubernetesLabelSelector) UnmarshalJSON(b []byte) error {
	var m rawKubernetesLabelSelector
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := KubernetesLabelSelector(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *KubernetesLabelSelector) Validate() error {
	if self.MatchExpressions == nil {
		return fmt.Errorf("KubernetesLabelSelector: Missing required field: matchExpressions")
	}
	if self.MatchLabels == nil {
		return fmt.Errorf("KubernetesLabelSelector: Missing required field: matchLabels")
	}
	return nil
}

// KubernetesNetworkPolicyPort - Kubernetes network policy port range
type KubernetesNetworkPolicyPort struct {

	//
	// Start port of the port range. port and endPort will have same values for a
	// single port definition.
	//
	Port int32 `json:"port"`

	//
	// End port of the port range. port and endPort will have same values for a
	// single port definition.
	//
	EndPort int32 `json:"endPort"`

	//
	// Network policy protocol. Allowed values: TCP, UDP.
	//
	Protocol TransportPolicyProtocol `json:"protocol"`
}

// NewKubernetesNetworkPolicyPort - creates an initialized KubernetesNetworkPolicyPort instance, returns a pointer to it
func NewKubernetesNetworkPolicyPort(init ...*KubernetesNetworkPolicyPort) *KubernetesNetworkPolicyPort {
	var o *KubernetesNetworkPolicyPort
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(KubernetesNetworkPolicyPort)
	}
	return o
}

type rawKubernetesNetworkPolicyPort KubernetesNetworkPolicyPort

// UnmarshalJSON is defined for proper JSON decoding of a KubernetesNetworkPolicyPort
func (self *KubernetesNetworkPolicyPort) UnmarshalJSON(b []byte) error {
	var m rawKubernetesNetworkPolicyPort
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := KubernetesNetworkPolicyPort(m)
		*self = o
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *KubernetesNetworkPolicyPort) Validate() error {
	return nil
}

// KubernetesIPBlock - Kubernetes network policy IP block source/target
type KubernetesIPBlock struct {

	//
	// CIDR block representing IP range for source/target
	//
	Cidr string `json:"cidr"`

	//
	// Exception for CIDR blocks, if needed
	//
	Except []string `json:"except,omitempty" rdl:"optional" yaml:",omitempty"`
}

// NewKubernetesIPBlock - creates an initialized KubernetesIPBlock instance, returns a pointer to it
func NewKubernetesIPBlock(init ...*KubernetesIPBlock) *KubernetesIPBlock {
	var o *KubernetesIPBlock
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(KubernetesIPBlock)
	}
	return o
}

type rawKubernetesIPBlock KubernetesIPBlock

// UnmarshalJSON is defined for proper JSON decoding of a KubernetesIPBlock
func (self *KubernetesIPBlock) UnmarshalJSON(b []byte) error {
	var m rawKubernetesIPBlock
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := KubernetesIPBlock(m)
		*self = o
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *KubernetesIPBlock) Validate() error {
	if self.Cidr == "" {
		return fmt.Errorf("KubernetesIPBlock.cidr is missing but is a required field")
	} else {
		val := rdl.Validate(MSDSchema(), "String", self.Cidr)
		if !val.Valid {
			return fmt.Errorf("KubernetesIPBlock.cidr does not contain a valid String (%v)", val.Error)
		}
	}
	return nil
}

// KubernetesNetworkPolicyPeer - Kubernetes network policy peer (source/target)
type KubernetesNetworkPolicyPeer struct {

	//
	// Kubernetes pod selector for the network policy source/target
	//
	PodSelector *KubernetesLabelSelector `json:"podSelector,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// Kubernetes namespace selector for the network policy source/target
	//
	NamespaceSelector *KubernetesLabelSelector `json:"namespaceSelector,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// IP block for the network policy source/target
	//
	IpBlock *KubernetesIPBlock `json:"ipBlock,omitempty" rdl:"optional" yaml:",omitempty"`
}

// NewKubernetesNetworkPolicyPeer - creates an initialized KubernetesNetworkPolicyPeer instance, returns a pointer to it
func NewKubernetesNetworkPolicyPeer(init ...*KubernetesNetworkPolicyPeer) *KubernetesNetworkPolicyPeer {
	var o *KubernetesNetworkPolicyPeer
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(KubernetesNetworkPolicyPeer)
	}
	return o
}

type rawKubernetesNetworkPolicyPeer KubernetesNetworkPolicyPeer

// UnmarshalJSON is defined for proper JSON decoding of a KubernetesNetworkPolicyPeer
func (self *KubernetesNetworkPolicyPeer) UnmarshalJSON(b []byte) error {
	var m rawKubernetesNetworkPolicyPeer
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := KubernetesNetworkPolicyPeer(m)
		*self = o
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *KubernetesNetworkPolicyPeer) Validate() error {
	return nil
}

// KubernetesNetworkPolicyIngressRule - Kubernetes network policy ingress rule
type KubernetesNetworkPolicyIngressRule struct {

	//
	// Network policy source, when empty all sources are allowed
	//
	From []*KubernetesNetworkPolicyPeer `json:"from,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// Ingress port(s), when empty all ports are allowed
	//
	Ports []*KubernetesNetworkPolicyPort `json:"ports,omitempty" rdl:"optional" yaml:",omitempty"`
}

// NewKubernetesNetworkPolicyIngressRule - creates an initialized KubernetesNetworkPolicyIngressRule instance, returns a pointer to it
func NewKubernetesNetworkPolicyIngressRule(init ...*KubernetesNetworkPolicyIngressRule) *KubernetesNetworkPolicyIngressRule {
	var o *KubernetesNetworkPolicyIngressRule
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(KubernetesNetworkPolicyIngressRule)
	}
	return o
}

type rawKubernetesNetworkPolicyIngressRule KubernetesNetworkPolicyIngressRule

// UnmarshalJSON is defined for proper JSON decoding of a KubernetesNetworkPolicyIngressRule
func (self *KubernetesNetworkPolicyIngressRule) UnmarshalJSON(b []byte) error {
	var m rawKubernetesNetworkPolicyIngressRule
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := KubernetesNetworkPolicyIngressRule(m)
		*self = o
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *KubernetesNetworkPolicyIngressRule) Validate() error {
	return nil
}

// KubernetesNetworkPolicyEgressRule - Kubernetes network policy egress rule
type KubernetesNetworkPolicyEgressRule struct {

	//
	// Network policy target, when empty all sources are allowed
	//
	To []*KubernetesNetworkPolicyPeer `json:"to,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// Egress port(s), when empty all ports are allowed
	//
	Ports []*KubernetesNetworkPolicyPort `json:"ports,omitempty" rdl:"optional" yaml:",omitempty"`
}

// NewKubernetesNetworkPolicyEgressRule - creates an initialized KubernetesNetworkPolicyEgressRule instance, returns a pointer to it
func NewKubernetesNetworkPolicyEgressRule(init ...*KubernetesNetworkPolicyEgressRule) *KubernetesNetworkPolicyEgressRule {
	var o *KubernetesNetworkPolicyEgressRule
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(KubernetesNetworkPolicyEgressRule)
	}
	return o
}

type rawKubernetesNetworkPolicyEgressRule KubernetesNetworkPolicyEgressRule

// UnmarshalJSON is defined for proper JSON decoding of a KubernetesNetworkPolicyEgressRule
func (self *KubernetesNetworkPolicyEgressRule) UnmarshalJSON(b []byte) error {
	var m rawKubernetesNetworkPolicyEgressRule
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := KubernetesNetworkPolicyEgressRule(m)
		*self = o
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *KubernetesNetworkPolicyEgressRule) Validate() error {
	return nil
}

// KubernetesNetworkPolicySpec - Kubernetes network policy spec
type KubernetesNetworkPolicySpec struct {

	//
	// Kubernetes pod selector for the network policy target
	//
	PodSelector *KubernetesLabelSelector `json:"podSelector"`

	//
	// Network policy types - Ingress, Egress
	//
	PolicyTypes []string `json:"policyTypes"`

	//
	// Ingress network policy rules, if empty then all ingress traffic is blocked
	//
	Ingress []*KubernetesNetworkPolicyIngressRule `json:"ingress,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// Egress network policy rules, if empty then all egress traffic is blocked
	//
	Egress []*KubernetesNetworkPolicyEgressRule `json:"egress,omitempty" rdl:"optional" yaml:",omitempty"`
}

// NewKubernetesNetworkPolicySpec - creates an initialized KubernetesNetworkPolicySpec instance, returns a pointer to it
func NewKubernetesNetworkPolicySpec(init ...*KubernetesNetworkPolicySpec) *KubernetesNetworkPolicySpec {
	var o *KubernetesNetworkPolicySpec
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(KubernetesNetworkPolicySpec)
	}
	return o.Init()
}

// Init - sets up the instance according to its default field values, if any
func (self *KubernetesNetworkPolicySpec) Init() *KubernetesNetworkPolicySpec {
	if self.PodSelector == nil {
		self.PodSelector = NewKubernetesLabelSelector()
	}
	if self.PolicyTypes == nil {
		self.PolicyTypes = make([]string, 0)
	}
	return self
}

type rawKubernetesNetworkPolicySpec KubernetesNetworkPolicySpec

// UnmarshalJSON is defined for proper JSON decoding of a KubernetesNetworkPolicySpec
func (self *KubernetesNetworkPolicySpec) UnmarshalJSON(b []byte) error {
	var m rawKubernetesNetworkPolicySpec
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := KubernetesNetworkPolicySpec(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *KubernetesNetworkPolicySpec) Validate() error {
	if self.PodSelector == nil {
		return fmt.Errorf("KubernetesNetworkPolicySpec: Missing required field: podSelector")
	}
	if self.PolicyTypes == nil {
		return fmt.Errorf("KubernetesNetworkPolicySpec: Missing required field: policyTypes")
	}
	return nil
}

// KubernetesNetworkPolicyRequest - Request object containing Kubernetes
// network policy inputs
type KubernetesNetworkPolicyRequest struct {

	//
	// Label key name used on pods to identify Athenz domain
	//
	AthenzDomainLabel string `json:"athenzDomainLabel" rdl:"optional" yaml:",omitempty"`

	//
	// Label key name used on pods to identify Athenz service
	//
	AthenzServiceLabel string `json:"athenzServiceLabel"`

	//
	// Network policy type, default is vanilla Kubernetes
	//
	NetworkPolicyType string `json:"networkPolicyType" rdl:"optional" yaml:",omitempty"`

	//
	// Requested network policy apiVersion
	//
	RequestedApiVersion string `json:"requestedApiVersion" rdl:"optional" yaml:",omitempty"`

	//
	// Kubernetes namespace for the network policy object
	//
	NetworkPolicyNamespace string `json:"networkPolicyNamespace" rdl:"optional" yaml:",omitempty"`

	//
	// Use athenzDomainLabel as namespace selector
	//
	DomainLabelAsNamespaceSelector *bool `json:"domainLabelAsNamespaceSelector,omitempty" rdl:"optional" yaml:",omitempty"`

	//
	// Use Athenz domain name in service label
	//
	DomainInServiceLabel *bool `json:"domainInServiceLabel,omitempty" rdl:"optional" yaml:",omitempty"`
}

// NewKubernetesNetworkPolicyRequest - creates an initialized KubernetesNetworkPolicyRequest instance, returns a pointer to it
func NewKubernetesNetworkPolicyRequest(init ...*KubernetesNetworkPolicyRequest) *KubernetesNetworkPolicyRequest {
	var o *KubernetesNetworkPolicyRequest
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(KubernetesNetworkPolicyRequest)
	}
	return o
}

type rawKubernetesNetworkPolicyRequest KubernetesNetworkPolicyRequest

// UnmarshalJSON is defined for proper JSON decoding of a KubernetesNetworkPolicyRequest
func (self *KubernetesNetworkPolicyRequest) UnmarshalJSON(b []byte) error {
	var m rawKubernetesNetworkPolicyRequest
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := KubernetesNetworkPolicyRequest(m)
		*self = o
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *KubernetesNetworkPolicyRequest) Validate() error {
	if self.AthenzDomainLabel != "" {
		val := rdl.Validate(MSDSchema(), "String", self.AthenzDomainLabel)
		if !val.Valid {
			return fmt.Errorf("KubernetesNetworkPolicyRequest.athenzDomainLabel does not contain a valid String (%v)", val.Error)
		}
	}
	if self.AthenzServiceLabel == "" {
		return fmt.Errorf("KubernetesNetworkPolicyRequest.athenzServiceLabel is missing but is a required field")
	} else {
		val := rdl.Validate(MSDSchema(), "String", self.AthenzServiceLabel)
		if !val.Valid {
			return fmt.Errorf("KubernetesNetworkPolicyRequest.athenzServiceLabel does not contain a valid String (%v)", val.Error)
		}
	}
	if self.NetworkPolicyType != "" {
		val := rdl.Validate(MSDSchema(), "String", self.NetworkPolicyType)
		if !val.Valid {
			return fmt.Errorf("KubernetesNetworkPolicyRequest.networkPolicyType does not contain a valid String (%v)", val.Error)
		}
	}
	if self.RequestedApiVersion != "" {
		val := rdl.Validate(MSDSchema(), "String", self.RequestedApiVersion)
		if !val.Valid {
			return fmt.Errorf("KubernetesNetworkPolicyRequest.requestedApiVersion does not contain a valid String (%v)", val.Error)
		}
	}
	if self.NetworkPolicyNamespace != "" {
		val := rdl.Validate(MSDSchema(), "String", self.NetworkPolicyNamespace)
		if !val.Valid {
			return fmt.Errorf("KubernetesNetworkPolicyRequest.networkPolicyNamespace does not contain a valid String (%v)", val.Error)
		}
	}
	return nil
}

// KubernetesNetworkPolicyResponse - Response object containing Kubernetes
// network policy
type KubernetesNetworkPolicyResponse struct {

	//
	// Kubernetes network policy apiVersion
	//
	ApiVersion string `json:"apiVersion"`

	//
	// Kubernetes network policy kind
	//
	Kind string `json:"kind"`

	//
	// Kubernetes network policy metadata
	//
	Metadata map[string]string `json:"metadata"`

	//
	// Kubernetes network policy spec
	//
	Spec *KubernetesNetworkPolicySpec `json:"spec"`
}

// NewKubernetesNetworkPolicyResponse - creates an initialized KubernetesNetworkPolicyResponse instance, returns a pointer to it
func NewKubernetesNetworkPolicyResponse(init ...*KubernetesNetworkPolicyResponse) *KubernetesNetworkPolicyResponse {
	var o *KubernetesNetworkPolicyResponse
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(KubernetesNetworkPolicyResponse)
	}
	return o.Init()
}

// Init - sets up the instance according to its default field values, if any
func (self *KubernetesNetworkPolicyResponse) Init() *KubernetesNetworkPolicyResponse {
	if self.Metadata == nil {
		self.Metadata = make(map[string]string)
	}
	if self.Spec == nil {
		self.Spec = NewKubernetesNetworkPolicySpec()
	}
	return self
}

type rawKubernetesNetworkPolicyResponse KubernetesNetworkPolicyResponse

// UnmarshalJSON is defined for proper JSON decoding of a KubernetesNetworkPolicyResponse
func (self *KubernetesNetworkPolicyResponse) UnmarshalJSON(b []byte) error {
	var m rawKubernetesNetworkPolicyResponse
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := KubernetesNetworkPolicyResponse(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

// Validate - checks for missing required fields, etc
func (self *KubernetesNetworkPolicyResponse) Validate() error {
	if self.ApiVersion == "" {
		return fmt.Errorf("KubernetesNetworkPolicyResponse.apiVersion is missing but is a required field")
	} else {
		val := rdl.Validate(MSDSchema(), "String", self.ApiVersion)
		if !val.Valid {
			return fmt.Errorf("KubernetesNetworkPolicyResponse.apiVersion does not contain a valid String (%v)", val.Error)
		}
	}
	if self.Kind == "" {
		return fmt.Errorf("KubernetesNetworkPolicyResponse.kind is missing but is a required field")
	} else {
		val := rdl.Validate(MSDSchema(), "String", self.Kind)
		if !val.Valid {
			return fmt.Errorf("KubernetesNetworkPolicyResponse.kind does not contain a valid String (%v)", val.Error)
		}
	}
	if self.Metadata == nil {
		return fmt.Errorf("KubernetesNetworkPolicyResponse: Missing required field: metadata")
	}
	if self.Spec == nil {
		return fmt.Errorf("KubernetesNetworkPolicyResponse: Missing required field: spec")
	}
	return nil
}
