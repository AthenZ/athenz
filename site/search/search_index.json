{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Athenz is a set of services and libraries supporting role-based authorization (RBAC) for provisioning and configuration (centralized authorization) use cases as well as serving/runtime (decentralized authorization) use cases. Athenz authorization system utilizes two types of tokens: Principal Tokens (N-Tokens) and RoleTokens (Z-Tokens). The name \"Athenz\" is derived from \"Auth\" and the 'N' and 'Z' tokens. Main features Athenz provides both the functionality of a centralized system and a certificate and IP-based distributed system to handle on-box enforcement. You get the following advantages using Athenz: Service-based security profile: Security definitions that automatically trickle down to hosts within the service. Dynamic provisioning: Scale fast or move workloads around without manual intervention (IP-less configuration). Single source of truth: Consolidated service profile serving various downstream security implementations, including support for non-user entities. Self-Service: Real-time configuration and enforcement of resource-based access control (dynamic manageability). More importantly, we want engineers to use Athenz and not build their own role-based access control systems that have no central store and often rely on network ACLs and manual updating.","title":"About"},{"location":"#main-features","text":"Athenz provides both the functionality of a centralized system and a certificate and IP-based distributed system to handle on-box enforcement. You get the following advantages using Athenz: Service-based security profile: Security definitions that automatically trickle down to hosts within the service. Dynamic provisioning: Scale fast or move workloads around without manual intervention (IP-less configuration). Single source of truth: Consolidated service profile serving various downstream security implementations, including support for non-user entities. Self-Service: Real-time configuration and enforcement of resource-based access control (dynamic manageability). More importantly, we want engineers to use Athenz and not build their own role-based access control systems that have no central store and often rely on network ACLs and manual updating.","title":"Main features"},{"location":"auth_flow/","text":"Architecture - Authorization Flow Use Cases Manage Access Control / Permissions for Resources Real-Time Service Security Authorization Flow Centralized Access Control (Control-Plane) Principals Authenticated Service Decentralized Access Control (Data-Plane) Policy Engine Reserved Domains Management Scenarios Simple Centralized Scenario Multi-tenancy Scenario Service Authentication Use Cases Manage Access Control and Permissions for Resources Athenz allows you to manage access control and permissions to resources through the centralized authori z ation m anagement s ervice (ZMS) and domain configuration that defines resources, roles, and actions. The diagram below shows a simplification of the use case without domain configuration. Your domain configuration file gives you fine control over who can access resources and what actions can be taken. ZMS manages your domain files and provides a RESTful API that allows you to create and modify domain configurations. This gives you the ability to control user access , tenancy , and secure editorial content and infrastructure assets . Real-Time Service Security Athenz provides endpoint protection for services, so a service such as Sports in the diagram below doesn't need to set network ACLs for other services wanting to access data. Instead, services are authorized by Athenz to access resources from another service based on the permissions defined by the domain administrator. Authorization Flow Centralized Access Control (Control-Plane) A traditional centralized mechanism works as expected for services that are not dealing with the decentralized authorization: the server with resources can simply ask the ZMS directly about access, passing the service identity and resource/action information to get a simple boolean answer. This does not scale well enough for data-plane access, since a central service must be consulted, but requires no local installation of the ZPE and related storage and synchronization logic. It is suitable for provisioning and configuration use cases where the number of requests processed by the server are small and the latency for authorization checks is not important. Principals In Athenz, actors that can assume a role are called principals. Principals can be users or services, and users can be those looking for resources from a service or use the ZMS management console. In the following sections, we'll look at centralized authorization for the service principal we just discussed. Authenticated Service To contact Athenz Services (ZMS/ZTS) or other Athenz Enabled services, the client service must first obtain an Athenz CA issued X.509 certificate. The services establish standard mutual TLS communication with other Athenz Enabled Services. Once the mutual TLS authentication is established, the provider service contacts Athenz Management Service directly to determine if a specific authenticated service has been authorized to carry out the given action on the requested resource. The application receives a simple boolean answer whether or not the request should be processed or rejected. The domain administrator can create a separate service that only has access for the given provider, thus provider having access to the service's identity will not have access to any other resource. Refer Service Authentication for full details on X.509 certificate based authentication. Decentralized Access Control (Data-Plane) A more interesting scenario introduces the local policy engine (ZPE), and a few supporting changes. Rather than directly asking for an access check with a principal identity, the identity is instead used to get a ZToken, and that is presented to the target service until it expires. This mechanism allows a service to make a completely local access check against ZPE, given a ZToken and locally cached policies. Specifically, as shown in the diagram below, the client service/user presents an X.509 certificate from SIA Provider to get an authorization token (ZToken) from ZTS, and then presents the ZToken to a target service to access its resources. That service can make use of a local ZPE to validate the role assertions in the ZToken, and then correlate them to the asynchronously updated Policies for the domain involved. The ZPE can make the decision locally, without going off box. It has no knowledge about specific users, only roles, and because roles and policies are always in the domain, the amount of data to distribute to the machine is small. Policy Engine The Policy Engine (ZPE) only needs to deal with policies and their roles, actions, and resources. Concepts like groups would only affect how a principal can assume a role, so is involved in getting the ZToken, but not using it in the ZPE. When evaluating policies, the relevant assertions of all relevant policies must be considered. Assertions are treated like a big \"OR\" with the default effect of \"Allow\", whereas any single \"Deny\" will override any other assertions. The policies can have prefix-matching wildcards, so that glob-style matching needs to be part of the \"is this assertion relevant\" logic. The policies must be fetched from ZTS for the ZPE to operate. Additionally, the policies must be refreshed as they change. It is expected that policies will change at a much lower frequency than user/role assignments, so a daily pull may be fine for this. The policies are not sensitive (secret) information, but their integrity is important, so the policies fetched (per domain) is signed by both ZMS and ZTS servers. This requires a predictable serialization of the policy data structures. That will be fields in the order the schema specifies, serialized to JSON, then signed. The actual fetch is performed by a locally running distribution agent, which could be implemented as a cron job or other async fetching mechanism. The resulting policies could be atomically changed per domain. Because the ZPE only will have policies for the domains of services running on the same host/container, there will be relatively few of them. The API for getting signed policies actually gets many policies in a single list, which is signed as a whole according to the ordering rules above. Reserved Domains The following domains are reserved and are automatically provisioned during server startup: user - The reserved domain for authenticated users. sys - The reserved domain for managing system activities sys.auth - The Athenz domain itself, which is where policies governing the top level domains reside. Management Scenarios Simple Centralized Scenario In the simplest scenario, one would perform the following actions. Note that even in this case, the management calls themselves are protected by Athenz, so for example one property admin cannot modify another property's domain. Set up domains as a super admin Assign domain administrators for the domain Create services in the domain Create roles, as the domain admin, to model the expected activity. Assign users and services as needed. Create policies, with references to resources that are the target of various actions The services would implement the access check calls to enforce access based on the ZMS \"access check\" API. This may happen in a container or filter. Multi-tenancy Scenario Setting up a tenant in a provider requires the concepts of a cross-domain \"trust relation\". Such a trust relation can be implemented as follows: A Policy is set up in the group-defining domain (Domain-A) that asserts that one of its local Roles can \u201cassume\u201d a role in the target Domain. The role used in this policy is arbitrary, under the control of Domain-A, who can add/remove users from it as it needs. A Role is created in the target Domain-B, but instead of specifying users, the trusted domain is set to Domain-A. Domain-B can then set up whatever policies it needs to protect relevant resources, by referring to its special role as the principal At access check time, when the policy is encountered that indicates a role that is trusted, that role (in another Domain) must then be consulted to determine who can assume the role. Service Authentication Refer Service Authentication for full details on X.509 cerificate based authentication.","title":"Authorization Flow"},{"location":"auth_flow/#architecture-authorization-flow","text":"Use Cases Manage Access Control / Permissions for Resources Real-Time Service Security Authorization Flow Centralized Access Control (Control-Plane) Principals Authenticated Service Decentralized Access Control (Data-Plane) Policy Engine Reserved Domains Management Scenarios Simple Centralized Scenario Multi-tenancy Scenario Service Authentication","title":"Architecture - Authorization Flow"},{"location":"auth_flow/#use-cases","text":"","title":"Use Cases"},{"location":"auth_flow/#manage-access-control-and-permissions-for-resources","text":"Athenz allows you to manage access control and permissions to resources through the centralized authori z ation m anagement s ervice (ZMS) and domain configuration that defines resources, roles, and actions. The diagram below shows a simplification of the use case without domain configuration. Your domain configuration file gives you fine control over who can access resources and what actions can be taken. ZMS manages your domain files and provides a RESTful API that allows you to create and modify domain configurations. This gives you the ability to control user access , tenancy , and secure editorial content and infrastructure assets .","title":"Manage Access Control and Permissions for Resources"},{"location":"auth_flow/#real-time-service-security","text":"Athenz provides endpoint protection for services, so a service such as Sports in the diagram below doesn't need to set network ACLs for other services wanting to access data. Instead, services are authorized by Athenz to access resources from another service based on the permissions defined by the domain administrator.","title":"Real-Time Service Security"},{"location":"auth_flow/#authorization-flow","text":"","title":"Authorization Flow"},{"location":"auth_flow/#centralized-access-control-control-plane","text":"A traditional centralized mechanism works as expected for services that are not dealing with the decentralized authorization: the server with resources can simply ask the ZMS directly about access, passing the service identity and resource/action information to get a simple boolean answer. This does not scale well enough for data-plane access, since a central service must be consulted, but requires no local installation of the ZPE and related storage and synchronization logic. It is suitable for provisioning and configuration use cases where the number of requests processed by the server are small and the latency for authorization checks is not important.","title":"Centralized Access Control (Control-Plane)"},{"location":"auth_flow/#principals","text":"In Athenz, actors that can assume a role are called principals. Principals can be users or services, and users can be those looking for resources from a service or use the ZMS management console. In the following sections, we'll look at centralized authorization for the service principal we just discussed.","title":"Principals"},{"location":"auth_flow/#authenticated-service","text":"To contact Athenz Services (ZMS/ZTS) or other Athenz Enabled services, the client service must first obtain an Athenz CA issued X.509 certificate. The services establish standard mutual TLS communication with other Athenz Enabled Services. Once the mutual TLS authentication is established, the provider service contacts Athenz Management Service directly to determine if a specific authenticated service has been authorized to carry out the given action on the requested resource. The application receives a simple boolean answer whether or not the request should be processed or rejected. The domain administrator can create a separate service that only has access for the given provider, thus provider having access to the service's identity will not have access to any other resource. Refer Service Authentication for full details on X.509 certificate based authentication.","title":"Authenticated Service"},{"location":"auth_flow/#decentralized-access-control-data-plane","text":"A more interesting scenario introduces the local policy engine (ZPE), and a few supporting changes. Rather than directly asking for an access check with a principal identity, the identity is instead used to get a ZToken, and that is presented to the target service until it expires. This mechanism allows a service to make a completely local access check against ZPE, given a ZToken and locally cached policies. Specifically, as shown in the diagram below, the client service/user presents an X.509 certificate from SIA Provider to get an authorization token (ZToken) from ZTS, and then presents the ZToken to a target service to access its resources. That service can make use of a local ZPE to validate the role assertions in the ZToken, and then correlate them to the asynchronously updated Policies for the domain involved. The ZPE can make the decision locally, without going off box. It has no knowledge about specific users, only roles, and because roles and policies are always in the domain, the amount of data to distribute to the machine is small.","title":"Decentralized Access Control (Data-Plane)"},{"location":"auth_flow/#policy-engine","text":"The Policy Engine (ZPE) only needs to deal with policies and their roles, actions, and resources. Concepts like groups would only affect how a principal can assume a role, so is involved in getting the ZToken, but not using it in the ZPE. When evaluating policies, the relevant assertions of all relevant policies must be considered. Assertions are treated like a big \"OR\" with the default effect of \"Allow\", whereas any single \"Deny\" will override any other assertions. The policies can have prefix-matching wildcards, so that glob-style matching needs to be part of the \"is this assertion relevant\" logic. The policies must be fetched from ZTS for the ZPE to operate. Additionally, the policies must be refreshed as they change. It is expected that policies will change at a much lower frequency than user/role assignments, so a daily pull may be fine for this. The policies are not sensitive (secret) information, but their integrity is important, so the policies fetched (per domain) is signed by both ZMS and ZTS servers. This requires a predictable serialization of the policy data structures. That will be fields in the order the schema specifies, serialized to JSON, then signed. The actual fetch is performed by a locally running distribution agent, which could be implemented as a cron job or other async fetching mechanism. The resulting policies could be atomically changed per domain. Because the ZPE only will have policies for the domains of services running on the same host/container, there will be relatively few of them. The API for getting signed policies actually gets many policies in a single list, which is signed as a whole according to the ordering rules above.","title":"Policy Engine"},{"location":"auth_flow/#reserved-domains","text":"The following domains are reserved and are automatically provisioned during server startup: user - The reserved domain for authenticated users. sys - The reserved domain for managing system activities sys.auth - The Athenz domain itself, which is where policies governing the top level domains reside.","title":"Reserved Domains"},{"location":"auth_flow/#management-scenarios","text":"","title":"Management Scenarios"},{"location":"auth_flow/#simple-centralized-scenario","text":"In the simplest scenario, one would perform the following actions. Note that even in this case, the management calls themselves are protected by Athenz, so for example one property admin cannot modify another property's domain. Set up domains as a super admin Assign domain administrators for the domain Create services in the domain Create roles, as the domain admin, to model the expected activity. Assign users and services as needed. Create policies, with references to resources that are the target of various actions The services would implement the access check calls to enforce access based on the ZMS \"access check\" API. This may happen in a container or filter.","title":"Simple Centralized Scenario"},{"location":"auth_flow/#multi-tenancy-scenario","text":"Setting up a tenant in a provider requires the concepts of a cross-domain \"trust relation\". Such a trust relation can be implemented as follows: A Policy is set up in the group-defining domain (Domain-A) that asserts that one of its local Roles can \u201cassume\u201d a role in the target Domain. The role used in this policy is arbitrary, under the control of Domain-A, who can add/remove users from it as it needs. A Role is created in the target Domain-B, but instead of specifying users, the trusted domain is set to Domain-A. Domain-B can then set up whatever policies it needs to protect relevant resources, by referring to its special role as the principal At access check time, when the policy is encountered that indicates a role that is trusted, that role (in another Domain) must then be consulted to determine who can assume the role.","title":"Multi-tenancy Scenario"},{"location":"auth_flow/#service-authentication","text":"Refer Service Authentication for full details on X.509 cerificate based authentication.","title":"Service Authentication"},{"location":"aws_athenz_setup/","text":"Athenz Setup on AWS Build the Project ZMS Setup ZTS Setup UI Setup Build the Project mvn clean install Make sure to have the following tar files: aws-setup/zms-setup/tars/athenz-zms-bin.tar.gz aws-setup/zts-setup/tars/athenz-zts-bin.tar.gz aws-setup/ui-setup/tars/athenz-ui-bin.tar.gz ZMS Setup Refer AWS ZMS Setup for details ZTS Setup Refer AWS ZTS Setup for details UI Setup Refer AWS UI Setup for details","title":"Introduction"},{"location":"aws_athenz_setup/#athenz-setup-on-aws","text":"Build the Project ZMS Setup ZTS Setup UI Setup","title":"Athenz Setup on AWS"},{"location":"aws_athenz_setup/#build-the-project","text":"mvn clean install Make sure to have the following tar files: aws-setup/zms-setup/tars/athenz-zms-bin.tar.gz aws-setup/zts-setup/tars/athenz-zts-bin.tar.gz aws-setup/ui-setup/tars/athenz-ui-bin.tar.gz","title":"Build the Project"},{"location":"aws_athenz_setup/#zms-setup","text":"Refer AWS ZMS Setup for details","title":"ZMS Setup"},{"location":"aws_athenz_setup/#zts-setup","text":"Refer AWS ZTS Setup for details","title":"ZTS Setup"},{"location":"aws_athenz_setup/#ui-setup","text":"Refer AWS UI Setup for details","title":"UI Setup"},{"location":"aws_ui_setup/","text":"Setup UI on AWS IAM role setup VPC setup S3 bucket for UI data Generate and upload service private key Upload server X.509 cert and key Upload ZMS CA Certs Upload ZMS Public key Update ZMS DATA BUCKET Register UI Service Packer Packer VPC setup Build UI Image Deploy UI IAM role setup Create EC2 profile role for UI using cloudformation template . This template creates a role named athenz.ui-service VPC Setup Setup VPC using the cloudformation template and giving the following mandatory parameters: Route53HostedZoneName Route53RecordName S3AccessLogBucketName (Created during ZMS Setup) Environment The other parameters are set by default. Change them as per your requirement NOTE - Modifying the other defaults might require subsequent changes. Following resources will be created after executing the template 1. 2 availability zones 1. Public Private subnets for ui in each availability zone 1. 2 NAT gateways and elastic IPs 1. NACL's for the subnets 1. Internet gateways for all public subnets 1. Route tables for all subnets 1. Elastic load balancer 1. Route 53 DNS entry 1. UI server ELB security groups Create S3 bucket to store UI data Create S3 bucket for storing ui certificates keys with appropriate policy as follows: { Version : 2012-10-17 , Statement : [ { Sid : , Effect : Allow , Principal : { AWS : arn:aws:iam:: aws_account_id :role/athenz.ui-service }, Action : s3:GetObject , Resource : arn:aws:s3::: bucket-name /* } ] } Also enable Default Encryption for your bucket. NOTE - athenz.ui-service is the EC2 role created using IAM template above Generate and upload service private key Generate a unique private key that UI Server will use to sign user's authorized service tokens. The UI has already been authorized to be allowed to carry out the users' requested operations. openssl genrsa -out service_private_key 2048 openssl rsa -in service_private_key -pubout ui_service_x509_key_public Upload the service private key with name service_private_key onto the s3 bucket Upload server X.509 cert and key NOTE - For Athenz UI production server it is strongly recommended to purchase a certificate for HTTPS access from a well known certificate authority.Follow the instructions provided by the Certificate Authority to generate your private key and then the Certificate Request (CSR). However if you want to use the self signed certificate, you can generate a self signed certificate as below: openssl req -newkey rsa:2048 -nodes -keyout service_x509_key -x509 -days 365 -out service_x509_cer Verify your certs openssl x509 -in service_x509_cert -text -noout Once you have received your X509 certificate and key, Upload the certificate on s3 bucket with name service_x509_cert Upload the private key with name service_x509_key Upload ZMS CA Certs Upload ZMS CA Cert with key zms_service_x509_ca_certs . They will be needed so that UI can communicate securely with ZMS Upload ZMS Public key Upload ZMS public key with name zms_service_x509_key_public.pem It is required to generate athenz.conf file at /opt/athenz-ui/conf/athenz.conf to include the ZMS Server URL and the registered public keys that the athenz client libraries and utilities will use to establish connection and validate any data signed by the ZMS Server. Update ZMS Data Bucket Upload UI service public key to ZMS Data Bucket with key ui_service_x509_key_public.pem Register UI Service In order for UI to access ZMS domain data, it must identify itself as a registered service in ZMS. Use zms-cli utility to register a new service in athenz domain. If ZMS Servers are running with a X509 certificate from a well known certificate authority (not a self-signed one) we don't need to reference the CA cert like we are doing below for self signed certs. Login into your zms-server instance as domain admin you created during zms setup and run the below commands: - Download ZMS CA Certs(If using self signed certs) aws s3 cp s3:// zms_bucket_name /zms_service_x509_ca_certs /tmp/zms_service_x509_ca_certs - Download UI public key aws s3 cp s3:// zms_bucket_name /ui_service_x509_key_public.pem/tmp/ui_service_x509_key_public.pem - Add a new domain named `athenz` /opt/zms/bin/zms-cli -c /tmp/service_x509_ca_certs -z zms_url -add-domain athenz - Register Service using zms-cli /opt/zms/bin/zms-cli -c /tmp/service_x509_ca_certs -z zms_url -d athenz add-service ui 0 /tmp/ui_service_x509_key_public.pem For e.g. If your zms server is running at https://athenz.zms.com:4443 then pass https://athenz.zms.com:4443/zms/v1 . Packer Packer VPC Setup Packer VPC was set during zms setup, update packer.json accordingly: { subnet_id : packer_public_subnet_id , vpc_id : vpc_id , aws_region : aws-region where you created the resources , aws_ami_name : ui-aws-cd-image , aws_access_key : {{ env ` AWS_ACCESS_KEY_ID ` }} , aws_secret_key : {{ env ` AWS_SECRET_ACCESS_KEY ` }} , aws_session_token : {{ env ` AWS_SESSION_TOKEN ` }} , ssh_keypair_name : EC2_SSH_Key_Name , ssh_private_key_file : PATH_TO_SSH_KEYPAIR , source_ami : ami-02c71d7a } Build UI image Build the image with packer using the following command cd /aws-setup/ui-setup packer build packer/aws/packer.json Deploy UI Run cloudformation template to bring up the ui-instances in 2 availability zones. The imageID parameter should be set to the image created in above step. The UI Server is now up and running. NOTE - If using self-signed X509 certificates for Athenz ZMS and UI servers, the administrator must add exceptions when accessing Athenz UI or install the self-signed certificates for those two servers into his/her own web browser. The administrator must first access the ZMS Server endpoint in the browser to accept the exception since the Athenz UI contacts ZMS Server to get an authorized token for the user when logging in. Alternatively, the administrator may decide to install the self-signed certificates for the ZMS and UI servers in their browser.","title":"UI Server"},{"location":"aws_ui_setup/#setup-ui-on-aws","text":"IAM role setup VPC setup S3 bucket for UI data Generate and upload service private key Upload server X.509 cert and key Upload ZMS CA Certs Upload ZMS Public key Update ZMS DATA BUCKET Register UI Service Packer Packer VPC setup Build UI Image Deploy UI","title":"Setup UI on AWS"},{"location":"aws_ui_setup/#iam-role-setup","text":"Create EC2 profile role for UI using cloudformation template . This template creates a role named athenz.ui-service","title":"IAM role setup"},{"location":"aws_ui_setup/#vpc-setup","text":"Setup VPC using the cloudformation template and giving the following mandatory parameters: Route53HostedZoneName Route53RecordName S3AccessLogBucketName (Created during ZMS Setup) Environment The other parameters are set by default. Change them as per your requirement NOTE - Modifying the other defaults might require subsequent changes. Following resources will be created after executing the template 1. 2 availability zones 1. Public Private subnets for ui in each availability zone 1. 2 NAT gateways and elastic IPs 1. NACL's for the subnets 1. Internet gateways for all public subnets 1. Route tables for all subnets 1. Elastic load balancer 1. Route 53 DNS entry 1. UI server ELB security groups","title":"VPC Setup"},{"location":"aws_ui_setup/#create-s3-bucket-to-store-ui-data","text":"Create S3 bucket for storing ui certificates keys with appropriate policy as follows: { Version : 2012-10-17 , Statement : [ { Sid : , Effect : Allow , Principal : { AWS : arn:aws:iam:: aws_account_id :role/athenz.ui-service }, Action : s3:GetObject , Resource : arn:aws:s3::: bucket-name /* } ] } Also enable Default Encryption for your bucket. NOTE - athenz.ui-service is the EC2 role created using IAM template above","title":"Create S3 bucket to store UI data"},{"location":"aws_ui_setup/#generate-and-upload-service-private-key","text":"Generate a unique private key that UI Server will use to sign user's authorized service tokens. The UI has already been authorized to be allowed to carry out the users' requested operations. openssl genrsa -out service_private_key 2048 openssl rsa -in service_private_key -pubout ui_service_x509_key_public Upload the service private key with name service_private_key onto the s3 bucket","title":"Generate and upload service private key"},{"location":"aws_ui_setup/#upload-server-x509-cert-and-key","text":"NOTE - For Athenz UI production server it is strongly recommended to purchase a certificate for HTTPS access from a well known certificate authority.Follow the instructions provided by the Certificate Authority to generate your private key and then the Certificate Request (CSR). However if you want to use the self signed certificate, you can generate a self signed certificate as below: openssl req -newkey rsa:2048 -nodes -keyout service_x509_key -x509 -days 365 -out service_x509_cer Verify your certs openssl x509 -in service_x509_cert -text -noout Once you have received your X509 certificate and key, Upload the certificate on s3 bucket with name service_x509_cert Upload the private key with name service_x509_key","title":"Upload server X.509 cert and key"},{"location":"aws_ui_setup/#upload-zms-ca-certs","text":"Upload ZMS CA Cert with key zms_service_x509_ca_certs . They will be needed so that UI can communicate securely with ZMS","title":"Upload ZMS CA Certs"},{"location":"aws_ui_setup/#upload-zms-public-key","text":"Upload ZMS public key with name zms_service_x509_key_public.pem It is required to generate athenz.conf file at /opt/athenz-ui/conf/athenz.conf to include the ZMS Server URL and the registered public keys that the athenz client libraries and utilities will use to establish connection and validate any data signed by the ZMS Server.","title":"Upload ZMS Public key"},{"location":"aws_ui_setup/#update-zms-data-bucket","text":"Upload UI service public key to ZMS Data Bucket with key ui_service_x509_key_public.pem","title":"Update ZMS Data Bucket"},{"location":"aws_ui_setup/#register-ui-service","text":"In order for UI to access ZMS domain data, it must identify itself as a registered service in ZMS. Use zms-cli utility to register a new service in athenz domain. If ZMS Servers are running with a X509 certificate from a well known certificate authority (not a self-signed one) we don't need to reference the CA cert like we are doing below for self signed certs. Login into your zms-server instance as domain admin you created during zms setup and run the below commands: - Download ZMS CA Certs(If using self signed certs) aws s3 cp s3:// zms_bucket_name /zms_service_x509_ca_certs /tmp/zms_service_x509_ca_certs - Download UI public key aws s3 cp s3:// zms_bucket_name /ui_service_x509_key_public.pem/tmp/ui_service_x509_key_public.pem - Add a new domain named `athenz` /opt/zms/bin/zms-cli -c /tmp/service_x509_ca_certs -z zms_url -add-domain athenz - Register Service using zms-cli /opt/zms/bin/zms-cli -c /tmp/service_x509_ca_certs -z zms_url -d athenz add-service ui 0 /tmp/ui_service_x509_key_public.pem For e.g. If your zms server is running at https://athenz.zms.com:4443 then pass https://athenz.zms.com:4443/zms/v1 .","title":"Register UI Service"},{"location":"aws_ui_setup/#packer","text":"","title":"Packer"},{"location":"aws_ui_setup/#packer-vpc-setup","text":"Packer VPC was set during zms setup, update packer.json accordingly: { subnet_id : packer_public_subnet_id , vpc_id : vpc_id , aws_region : aws-region where you created the resources , aws_ami_name : ui-aws-cd-image , aws_access_key : {{ env ` AWS_ACCESS_KEY_ID ` }} , aws_secret_key : {{ env ` AWS_SECRET_ACCESS_KEY ` }} , aws_session_token : {{ env ` AWS_SESSION_TOKEN ` }} , ssh_keypair_name : EC2_SSH_Key_Name , ssh_private_key_file : PATH_TO_SSH_KEYPAIR , source_ami : ami-02c71d7a }","title":"Packer VPC Setup"},{"location":"aws_ui_setup/#build-ui-image","text":"Build the image with packer using the following command cd /aws-setup/ui-setup packer build packer/aws/packer.json","title":"Build UI image"},{"location":"aws_ui_setup/#deploy-ui","text":"Run cloudformation template to bring up the ui-instances in 2 availability zones. The imageID parameter should be set to the image created in above step. The UI Server is now up and running. NOTE - If using self-signed X509 certificates for Athenz ZMS and UI servers, the administrator must add exceptions when accessing Athenz UI or install the self-signed certificates for those two servers into his/her own web browser. The administrator must first access the ZMS Server endpoint in the browser to accept the exception since the Athenz UI contacts ZMS Server to get an authorized token for the user when logging in. Alternatively, the administrator may decide to install the self-signed certificates for the ZMS and UI servers in their browser.","title":"Deploy UI"},{"location":"aws_zms_setup/","text":"Setup ZMS on AWS IAM Role Setup S3 Bucket for ELB Access Logs VPC setup RDS Setup Create Aurora MySQL Cluster Schema Setup S3 Bucket to Store ZMS Data Generate and Upload Service Private Key Upload Server X.509 Cert and Key Upload RDS CA Certs Upload Truststore Password Upload ZMS DB User Password Create S3 Bucket for Audit logs Configure Variables and Properties aws_init.sh zms.properties Database Access User Authentication Domain Admins athenz.properties Truststore and Keystore Settings Packer Packer VPC setup Build ZMS Image Deploy ZMS IAM Role Setup Create an EC2 profile role for ZMS using the following cloudformation template . This template creates a role named athenz.zms-service . S3 Bucket for ELB Access Logs Create a S3 bucket needed to store ELB access logs with the following bucket policy: { Version : 2012-10-17 , Statement : [ { Sid : , Effect : Allow , Principal : { AWS : arn:aws:iam:: aws-account-id :root }, Action : s3:PutObject , Resource : arn:aws:s3::: your bucket name /*/AWSLogs/ aws-account-id /* } ] } Refer to AWS ELB Documentation for more details on bucket policy. VPC Setup Setup a VPC using the following cloudformation template by giving the these mandatory parameters: Route53HostedZoneName Route53RecordName S3AccessLogBucketName (Created in the previous step) Environment The other parameters are set by default. Change them as per your requirements. NOTE - Modifying the other defaults might require subsequent changes. Following resources will be created after executing the template: 1. 2 availability zones 1. Public Private subnets for each availability zone 1. 2 NAT gateways and elastic IPs 1. NACL's for the subnets 1. Internet gateways for all public subnets 1. Route tables for all subnets 1. Elastic load balancer 1. Route 53 DNS entry 1. ZMS Server and ELB security groups RDS Setup Create Aurora MySQL cluster Setup an Aurora MySQL compatible cluster using the following cloudformation template by giving the following mandatory parameters: Route53HostedZoneName Route53RecordName DatabaseUsername DatabasePassword Environment The other parameters are set by default. Change them as per your requirements. Schema Setup Create an EC2 instance in private subnet and ssh login into it. After logging in, install the mysql package and use the following command to connect to the cluster mysql -h RDS_CLUSTER_ENDPOINT -P 3306 -u DB_USER -p Copy the zms_server.sql file from the Athenz Git repository onto this host and create the database using the following command: mysql -h RDS_CLUSTER_ENDPOINT -P 3306 -u DB_USER -p zms_server.sql Create a user with full privileges on zms database created above. For e.g. if your ZMS Server will be running on zms1.athenz.com and the user to be created is athenz-zms having password athenz-pass : CREATE USER athenz-zms @ zms1.athenz.com IDENTIFIED BY athenz-pass ; GRANT ALL PRIVILEGES ON zms_server TO athenz-zms @ zms1.athenz.com ; FLUSH PRIVILEGES; Create S3 Bucket to Store ZMS Data Create a S3 bucket for storing zms certificates keys among other configuration data with an appropriate policy as follows: { Version : 2012-10-17 , Statement : [ { Sid : , Effect : Allow , Principal : { AWS : arn:aws:iam:: aws_account_id :role/athenz.zms-service }, Action : s3:GetObject , Resource : arn:aws:s3::: bucket-name /* } ] } Also enable Default Encryption for your bucket. NOTE - athenz.zms-service is the EC2 role created using IAM template above Generate and Upload Service Private Key and Id Generate a unique private key that ZMS Server will use to sign any NTokens it issues: openssl genrsa -out service_private_key 2048 openssl rsa -in service_private_key -pubout zms_service_x509_key_public Upload the service private key with name service_private_key onto the s3 bucket. Upload the service private key id with name service_private_key_id onto the s3 bucket. This file just contains the id of private key. It is not mandatory as the id defaults to 0 if not specified. Upload Server X.509 Cert and Key NOTE - While it is still possible to generate and use a self-signed X509 certificate for ZMS Server, it is recommended to purchase one for your production server from a well known certificate authority. Having such a certificate installed on your ZMS Servers will no longer require to distribute the server's CA certificate to other hosts (e.g. ZTS Servers, Hosts running ZPU). Follow the instructions provided by the Certificate Authority that you're going to purchase your certificate from to generate your private key and Certificate Request (CSR). Submit your CSR to your CA to generate a x.509 certificate for your ZMS server. If you are using self signed certs then run the following commands: openssl genrsa -des3 -out zms_ca_key 4096 (Create ZMS CA Key) openssl req -x509 -new -nodes -key zms_ca_key -sha256 -days 1024 -out service_x509_ca_certs (Generate CA Cert) openssl genrsa -out service_x509_key 2048 (Generate your private key) openssl req -new -key service_x509_key -out service_x509_csr (Generate your CSR) openssl x509 -req -in service_x509_csr -CA service_x509_ca_certs -CAkey zms_ca_key -CAcreateserial -out service_x509_cert -days 730 -sha256 (Generate your Certificate) Verify your certs openssl x509 -in service_x509_ca_certs -text -noout openssl x509 -in service_x509_cert -text -noout Once you have received your X509 certificate and key: - Upload the certificate to s3 bucket with name service_x509_cert - Upload the private key with name service_x509_key - Upload the Root CA cert with name service_x509_ca_certs Upload RDS CA Certs RDS Certs are needed if you have set athenz.zms.jdbc_use_ssl= property in zms.properties to true . By default it is set to false Upload the RDS CA Certs with a filename service_rds_ca_certs . For details on AWS RDS Certs, Please refer to RDS SSL Certificates in AWS Upload truststore password Upload password you want to use for truststore with a filename service_x509_store_pwd Upload ZMS DB User Password Create a file containing only the password for ZMS Database user( athenz-zms ) created above during RDS schema setup Upload the file to bucket with name db_user_data Create S3 Bucket for Audit Logs Create another bucket for audit logs having the following bucket policy: { Version : 2012-10-17 , Statement : [ { Sid : , Effect : Allow , Principal : { AWS : [ arn:aws:iam::488664618023:role/athenz.zms-service ] }, Action : [ s3:AbortMultipartUpload , s3:GetBucketLocation , s3:GetObject , s3:ListBucket , s3:ListBucketMultipartUploads , s3:PutObject ], Resource : [ arn:aws:s3::: audit_log_bucket_name , arn:aws:s3::: audit_log_bucket_name /* ] } ] } Configure Variables and Properties Edit aws_init.sh Update the bucket names, domain admin and RDS Endpoint in athenz/aws-setup/zms-setup/build/bin/aws_init.sh by editing the below lines: export ZMS_DATA_BUCKET_NAME= The name of your zms data bucket export ZMS_AUDIT_LOG_BUCKET_NAME= The name of your zms audit data bucket export DOMAIN_ADMINS= zms-admin-name export RDS_MASTER= zms-rds-database-cluster-endpoint When running the server very first time, ZMS Server automatically creates the required domains and sets the running user as the system administrator. The system administrators are the only ones authorized to create top level domains in Athenz. Before running the server very first time, you can configure the set of system administrators who are authorized to create top level domains in Athenz. Set DOMAIN_ADMINS to unix user id that you want to add as Athenz system administrator. The password for this user is uploaded to ZMS Data S3 Bucket created above with name admin_pass . Create a file containing password for ZMS Domain Admin Upload the file to bucket with name admin_pass The other variables are for truststore keystore setup. We recommend to use the defaults but if you change then update the corresponding values in athenz.properties file discussed later. Edit zms.properties file The following properties need to be edited in zms.properties file located at athenz/aws-setup/zms-setup/build/conf/zms.properties Database Access Modify the following settings if RDS username RDS password filename (stored on S3) are different from defaults suggested above. athenz.zms.object_store_factory_class=com.yahoo.athenz.zms.store.impl.JDBCObjectStoreFactory athenz.zms.jdbc_user=athenz-zms athenz.zms.jdbc_password=db_user_data User Authentication For a user to authenticate himself/herself in ZMS, the server must have the appropriate authentication authority implementation configured. By default, ZMS enables the following two authorities: Unix User Authority - using pam login profile to authenticate users Principal Authority - validating Principal Tokens that are issued when users authenticate using their unix login password. This is set using the following properties athenz.zms.authority_classes=com.yahoo.athenz.auth.impl.PrincipalAuthority,com.yahoo.athenz.auth.impl.UserAuthority The server also provides other authorities - e.g. Kerberos, TLS Certificate, that are not enabled by default. To add your own authentication authority modify the: athenz.zms.authority_classes=com.yahoo.athenz.auth.impl.PrincipalAuthority,com.yahoo.athenz.auth.impl.UserAuthority line in zms.properties file and include comma separated list of authority implementation classes to support. Domain Admins Modify the below setting and set it to unix user you passed as domain admin in aws_init_file in above steps. athenz.zms.domain_admin=user.zms-admin Edit athenz.properties file The following properties need to be edited in athenz.properties file located at athenz/aws-setup/zms-setup/build/conf/athenz.properties Truststore and Keystore Settings If you modified the truststore and keystore paths and password in the aws_init.sh file then change the below settings in athenz.properties file accordingly: athenz.ssl_key_store=/opt/zms/conf/zms_keystore.pkcs12 //path to the keystore file that contains the server's certificate athenz.ssl_key_store_type=PKCS12 //specifies the type for the keystore specified in the athenz.ssl_key_store_password=service_x509_store_pwd //S3 bucket key name for Password for the keystore specified in the athenz.ssl_key_store property athenz.ssl_trust_store=/opt/zms/conf/zms_truststore.jks //path to the trust store file that contains CA certificates trusted by this Jetty instance athenz.ssl_trust_store_type=JKS //specifies the type for the truststore specified athenz.ssl_trust_store_password=service_x509_store_pwd //password for the truststore Packer Packer VPC Setup Setup packer vpc by using the cloudformation template and update packer.json file accordingly. { subnet_id : packer_public_subnet_id , vpc_id : vpc_id , aws_region : aws-region where you created the resources , aws_ami_name : zms-aws-cd-image , aws_access_key : {{ env ` AWS_ACCESS_KEY_ID ` }} , aws_secret_key : {{ env ` AWS_SECRET_ACCESS_KEY ` }} , aws_session_token : {{ env ` AWS_SESSION_TOKEN ` }} , ssh_keypair_name : EC2_SSH_Key_Name , ssh_private_key_file : PATH_TO_SSH_KEYPAIR , source_ami : ami-02c71d7a } Build ZMS image Build the image with packer using the following command: cd /aws-setup/zms-setup packer build packer/aws/packer.json Deploy ZMS Run cloudformation template to bring up the zms-instances in 2 availability zones. The imageID parameter should be set to the image created in previous step. The ZMS Server is now up and running.","title":"ZMS Server"},{"location":"aws_zms_setup/#setup-zms-on-aws","text":"IAM Role Setup S3 Bucket for ELB Access Logs VPC setup RDS Setup Create Aurora MySQL Cluster Schema Setup S3 Bucket to Store ZMS Data Generate and Upload Service Private Key Upload Server X.509 Cert and Key Upload RDS CA Certs Upload Truststore Password Upload ZMS DB User Password Create S3 Bucket for Audit logs Configure Variables and Properties aws_init.sh zms.properties Database Access User Authentication Domain Admins athenz.properties Truststore and Keystore Settings Packer Packer VPC setup Build ZMS Image Deploy ZMS","title":"Setup ZMS on AWS"},{"location":"aws_zms_setup/#iam-role-setup","text":"Create an EC2 profile role for ZMS using the following cloudformation template . This template creates a role named athenz.zms-service .","title":"IAM Role Setup"},{"location":"aws_zms_setup/#s3-bucket-for-elb-access-logs","text":"Create a S3 bucket needed to store ELB access logs with the following bucket policy: { Version : 2012-10-17 , Statement : [ { Sid : , Effect : Allow , Principal : { AWS : arn:aws:iam:: aws-account-id :root }, Action : s3:PutObject , Resource : arn:aws:s3::: your bucket name /*/AWSLogs/ aws-account-id /* } ] } Refer to AWS ELB Documentation for more details on bucket policy.","title":"S3 Bucket for ELB Access Logs"},{"location":"aws_zms_setup/#vpc-setup","text":"Setup a VPC using the following cloudformation template by giving the these mandatory parameters: Route53HostedZoneName Route53RecordName S3AccessLogBucketName (Created in the previous step) Environment The other parameters are set by default. Change them as per your requirements. NOTE - Modifying the other defaults might require subsequent changes. Following resources will be created after executing the template: 1. 2 availability zones 1. Public Private subnets for each availability zone 1. 2 NAT gateways and elastic IPs 1. NACL's for the subnets 1. Internet gateways for all public subnets 1. Route tables for all subnets 1. Elastic load balancer 1. Route 53 DNS entry 1. ZMS Server and ELB security groups","title":"VPC Setup"},{"location":"aws_zms_setup/#rds-setup","text":"","title":"RDS Setup"},{"location":"aws_zms_setup/#create-aurora-mysql-cluster","text":"Setup an Aurora MySQL compatible cluster using the following cloudformation template by giving the following mandatory parameters: Route53HostedZoneName Route53RecordName DatabaseUsername DatabasePassword Environment The other parameters are set by default. Change them as per your requirements.","title":"Create Aurora MySQL cluster"},{"location":"aws_zms_setup/#schema-setup","text":"Create an EC2 instance in private subnet and ssh login into it. After logging in, install the mysql package and use the following command to connect to the cluster mysql -h RDS_CLUSTER_ENDPOINT -P 3306 -u DB_USER -p Copy the zms_server.sql file from the Athenz Git repository onto this host and create the database using the following command: mysql -h RDS_CLUSTER_ENDPOINT -P 3306 -u DB_USER -p zms_server.sql Create a user with full privileges on zms database created above. For e.g. if your ZMS Server will be running on zms1.athenz.com and the user to be created is athenz-zms having password athenz-pass : CREATE USER athenz-zms @ zms1.athenz.com IDENTIFIED BY athenz-pass ; GRANT ALL PRIVILEGES ON zms_server TO athenz-zms @ zms1.athenz.com ; FLUSH PRIVILEGES;","title":"Schema Setup"},{"location":"aws_zms_setup/#create-s3-bucket-to-store-zms-data","text":"Create a S3 bucket for storing zms certificates keys among other configuration data with an appropriate policy as follows: { Version : 2012-10-17 , Statement : [ { Sid : , Effect : Allow , Principal : { AWS : arn:aws:iam:: aws_account_id :role/athenz.zms-service }, Action : s3:GetObject , Resource : arn:aws:s3::: bucket-name /* } ] } Also enable Default Encryption for your bucket. NOTE - athenz.zms-service is the EC2 role created using IAM template above","title":"Create S3 Bucket to Store ZMS Data"},{"location":"aws_zms_setup/#generate-and-upload-service-private-key-and-id","text":"Generate a unique private key that ZMS Server will use to sign any NTokens it issues: openssl genrsa -out service_private_key 2048 openssl rsa -in service_private_key -pubout zms_service_x509_key_public Upload the service private key with name service_private_key onto the s3 bucket. Upload the service private key id with name service_private_key_id onto the s3 bucket. This file just contains the id of private key. It is not mandatory as the id defaults to 0 if not specified.","title":"Generate and Upload Service Private Key and Id"},{"location":"aws_zms_setup/#upload-server-x509-cert-and-key","text":"NOTE - While it is still possible to generate and use a self-signed X509 certificate for ZMS Server, it is recommended to purchase one for your production server from a well known certificate authority. Having such a certificate installed on your ZMS Servers will no longer require to distribute the server's CA certificate to other hosts (e.g. ZTS Servers, Hosts running ZPU). Follow the instructions provided by the Certificate Authority that you're going to purchase your certificate from to generate your private key and Certificate Request (CSR). Submit your CSR to your CA to generate a x.509 certificate for your ZMS server. If you are using self signed certs then run the following commands: openssl genrsa -des3 -out zms_ca_key 4096 (Create ZMS CA Key) openssl req -x509 -new -nodes -key zms_ca_key -sha256 -days 1024 -out service_x509_ca_certs (Generate CA Cert) openssl genrsa -out service_x509_key 2048 (Generate your private key) openssl req -new -key service_x509_key -out service_x509_csr (Generate your CSR) openssl x509 -req -in service_x509_csr -CA service_x509_ca_certs -CAkey zms_ca_key -CAcreateserial -out service_x509_cert -days 730 -sha256 (Generate your Certificate) Verify your certs openssl x509 -in service_x509_ca_certs -text -noout openssl x509 -in service_x509_cert -text -noout Once you have received your X509 certificate and key: - Upload the certificate to s3 bucket with name service_x509_cert - Upload the private key with name service_x509_key - Upload the Root CA cert with name service_x509_ca_certs","title":"Upload Server X.509 Cert and Key"},{"location":"aws_zms_setup/#upload-rds-ca-certs","text":"RDS Certs are needed if you have set athenz.zms.jdbc_use_ssl= property in zms.properties to true . By default it is set to false Upload the RDS CA Certs with a filename service_rds_ca_certs . For details on AWS RDS Certs, Please refer to RDS SSL Certificates in AWS","title":"Upload RDS CA Certs"},{"location":"aws_zms_setup/#upload-truststore-password","text":"Upload password you want to use for truststore with a filename service_x509_store_pwd","title":"Upload truststore password"},{"location":"aws_zms_setup/#upload-zms-db-user-password","text":"Create a file containing only the password for ZMS Database user( athenz-zms ) created above during RDS schema setup Upload the file to bucket with name db_user_data","title":"Upload ZMS DB User Password"},{"location":"aws_zms_setup/#create-s3-bucket-for-audit-logs","text":"Create another bucket for audit logs having the following bucket policy: { Version : 2012-10-17 , Statement : [ { Sid : , Effect : Allow , Principal : { AWS : [ arn:aws:iam::488664618023:role/athenz.zms-service ] }, Action : [ s3:AbortMultipartUpload , s3:GetBucketLocation , s3:GetObject , s3:ListBucket , s3:ListBucketMultipartUploads , s3:PutObject ], Resource : [ arn:aws:s3::: audit_log_bucket_name , arn:aws:s3::: audit_log_bucket_name /* ] } ] }","title":"Create S3 Bucket for Audit Logs"},{"location":"aws_zms_setup/#configure-variables-and-properties","text":"","title":"Configure Variables and Properties"},{"location":"aws_zms_setup/#edit-aws_initsh","text":"Update the bucket names, domain admin and RDS Endpoint in athenz/aws-setup/zms-setup/build/bin/aws_init.sh by editing the below lines: export ZMS_DATA_BUCKET_NAME= The name of your zms data bucket export ZMS_AUDIT_LOG_BUCKET_NAME= The name of your zms audit data bucket export DOMAIN_ADMINS= zms-admin-name export RDS_MASTER= zms-rds-database-cluster-endpoint When running the server very first time, ZMS Server automatically creates the required domains and sets the running user as the system administrator. The system administrators are the only ones authorized to create top level domains in Athenz. Before running the server very first time, you can configure the set of system administrators who are authorized to create top level domains in Athenz. Set DOMAIN_ADMINS to unix user id that you want to add as Athenz system administrator. The password for this user is uploaded to ZMS Data S3 Bucket created above with name admin_pass . Create a file containing password for ZMS Domain Admin Upload the file to bucket with name admin_pass The other variables are for truststore keystore setup. We recommend to use the defaults but if you change then update the corresponding values in athenz.properties file discussed later.","title":"Edit aws_init.sh"},{"location":"aws_zms_setup/#edit-zmsproperties-file","text":"The following properties need to be edited in zms.properties file located at athenz/aws-setup/zms-setup/build/conf/zms.properties","title":"Edit zms.properties file"},{"location":"aws_zms_setup/#database-access","text":"Modify the following settings if RDS username RDS password filename (stored on S3) are different from defaults suggested above. athenz.zms.object_store_factory_class=com.yahoo.athenz.zms.store.impl.JDBCObjectStoreFactory athenz.zms.jdbc_user=athenz-zms athenz.zms.jdbc_password=db_user_data","title":"Database Access"},{"location":"aws_zms_setup/#user-authentication","text":"For a user to authenticate himself/herself in ZMS, the server must have the appropriate authentication authority implementation configured. By default, ZMS enables the following two authorities: Unix User Authority - using pam login profile to authenticate users Principal Authority - validating Principal Tokens that are issued when users authenticate using their unix login password. This is set using the following properties athenz.zms.authority_classes=com.yahoo.athenz.auth.impl.PrincipalAuthority,com.yahoo.athenz.auth.impl.UserAuthority The server also provides other authorities - e.g. Kerberos, TLS Certificate, that are not enabled by default. To add your own authentication authority modify the: athenz.zms.authority_classes=com.yahoo.athenz.auth.impl.PrincipalAuthority,com.yahoo.athenz.auth.impl.UserAuthority line in zms.properties file and include comma separated list of authority implementation classes to support.","title":"User Authentication"},{"location":"aws_zms_setup/#domain-admins","text":"Modify the below setting and set it to unix user you passed as domain admin in aws_init_file in above steps. athenz.zms.domain_admin=user.zms-admin","title":"Domain Admins"},{"location":"aws_zms_setup/#edit-athenzproperties-file","text":"The following properties need to be edited in athenz.properties file located at athenz/aws-setup/zms-setup/build/conf/athenz.properties","title":"Edit athenz.properties file"},{"location":"aws_zms_setup/#truststore-and-keystore-settings","text":"If you modified the truststore and keystore paths and password in the aws_init.sh file then change the below settings in athenz.properties file accordingly: athenz.ssl_key_store=/opt/zms/conf/zms_keystore.pkcs12 //path to the keystore file that contains the server's certificate athenz.ssl_key_store_type=PKCS12 //specifies the type for the keystore specified in the athenz.ssl_key_store_password=service_x509_store_pwd //S3 bucket key name for Password for the keystore specified in the athenz.ssl_key_store property athenz.ssl_trust_store=/opt/zms/conf/zms_truststore.jks //path to the trust store file that contains CA certificates trusted by this Jetty instance athenz.ssl_trust_store_type=JKS //specifies the type for the truststore specified athenz.ssl_trust_store_password=service_x509_store_pwd //password for the truststore","title":"Truststore and Keystore Settings"},{"location":"aws_zms_setup/#packer","text":"","title":"Packer"},{"location":"aws_zms_setup/#packer-vpc-setup","text":"Setup packer vpc by using the cloudformation template and update packer.json file accordingly. { subnet_id : packer_public_subnet_id , vpc_id : vpc_id , aws_region : aws-region where you created the resources , aws_ami_name : zms-aws-cd-image , aws_access_key : {{ env ` AWS_ACCESS_KEY_ID ` }} , aws_secret_key : {{ env ` AWS_SECRET_ACCESS_KEY ` }} , aws_session_token : {{ env ` AWS_SESSION_TOKEN ` }} , ssh_keypair_name : EC2_SSH_Key_Name , ssh_private_key_file : PATH_TO_SSH_KEYPAIR , source_ami : ami-02c71d7a }","title":"Packer VPC Setup"},{"location":"aws_zms_setup/#build-zms-image","text":"Build the image with packer using the following command: cd /aws-setup/zms-setup packer build packer/aws/packer.json","title":"Build ZMS image"},{"location":"aws_zms_setup/#deploy-zms","text":"Run cloudformation template to bring up the zms-instances in 2 availability zones. The imageID parameter should be set to the image created in previous step. The ZMS Server is now up and running.","title":"Deploy ZMS"},{"location":"aws_zts_setup/","text":"Setup ZTS on AWS IAM role setup VPC setup RDS Setup Create Aurora Mysql cluster Schema setup S3 bucket for zts data Generate and upload service private key and Id Upload server X.509 cert and key Upload RDS CA Certs Upload truststore password Upload ZTS DB User Password Upload ZMS CA Certs Upload ZTS and ZMS Public keys Upload Self Cert Signer Key Update the policy for S3 bucket for Audit logs Update ZMS DATA BUCKET Register ZTS Service Configure Variables and Properties aws_init.sh Edit the properties file Database Access Athenz CA X.509 Certificate Issuing Truststore and Keystore Settings Packer Packer VPC setup Build ZTS Image Deploy ZTS IAM Role Setup Create an EC2 profile role for ZTS using cloudformation template . This template creates a role named athenz.zts-service VPC Setup Setup VPC using the cloudformation template and giving the following mandatory parameters: Route53HostedZoneName Route53RecordName S3AccessLogBucketName (Created during ZMS Setup) Environment The other parameters are set by default. Change them as per your requirements. NOTE - Modifying the other defaults might require subsequent changes. Following resources will be created after executing the template: 1. 2 availability zones 1. Public Private subnets for zts in each availability zone 1. Public Private subnets for cert signer in each availability zone 1. 4 NAT gateways and elastic IPs 1. NACL's for the subnets 1. Internet gateways for all public subnets 1. Route tables for all subnets 1. Elastic load balancer 1. Route 53 DNS entry 1. ZTS Server ELB security groups RDS Setup Create Aurora MySQL cluster Setup an Aurora MySQL cluster using cloudformation template by giving the following mandatory parameters: Route53HostedZoneName Route53RecordName DatabaseUsername DatabasePassword Environment The other parameters are set by default. Change them as per your requirements. Schema Setup Create an instance in your private subnet and ssh login into it. After logging in, install the mysql client and use the following command to connect to the cluster using Database Root Credentials: mysql -h RDS_CLUSTER_ENDPOINT -P 3306 -u DB_USER -p Copy the zts_server.sql file from the Athenz Git repository onto this host and create the database using the following command mysql -h RDS_CLUSTER_ENDPOINT -P 3306 -u DB_USER -p zts_server.sql Create a user with full privileges on zts database created above. For e.g. If your ZTS Server will be running on zts1.athenz.com and user to be created is athenz-zts having password athenz-zts : CREATE USER athenz-zts @ zts1.athenz.com IDENTIFIED BY athenz-zts ; GRANT ALL PRIVILEGES ON zts_store TO athenz-zts @ zts1.athenz.com ; FLUSH PRIVILEGES; Create S3 Bucket to Store ZTS Data Create a S3 bucket for storing ZTS certificates, keys and other configuration data with appropriate policy as follows: { Version : 2012-10-17 , Statement : [ { Sid : , Effect : Allow , Principal : { AWS : arn:aws:iam:: aws_account_id :role/athenz.zts-service }, Action : s3:GetObject , Resource : arn:aws:s3::: bucket-name /* } ] } Also enable Default Encryption for your bucket. NOTE - athenz.zts-service is the EC2 role created using IAM template above Generate and Upload Service Private Key and Id Generate a unique private key that ZTS Server will use to sign any Role Tokens it issues: openssl genrsa -out service_private_key 2048 openssl rsa -in service_private_key -pubout zts_service_x509_key_public Upload the service private key with name service_private_key onto the s3 bucket. Upload the service private key id with name service_private_key_id onto the s3 bucket. This file just contains the id of private key. It is not mandatory as the id defaults to 0 if not specified Upload Server X.509 Cert and Key NOTE - While it is still possible to generate and use a self-signed X.509 certificate for ZTS Servers, it is recommended to purchase one for your production server from a well known certificate authority. Having such a certificate installed on your ZTS Servers will no longer require to distribute the server's CA certificate to other hosts (e.g. Hosts running ZPU). Follow the instructions provided by the Certificate Authority that you're going to purchase your certificate from, to generate your private key and Certificate Request (CSR). Submit your CSR to your CA to generate a x.509 certificate for your ZMS server. If you are using self signed certs then run the following commands: openssl genrsa -des3 -out zts_ca_key 4096 (Create ZTS CA Key) openssl req -x509 -new -nodes -key zts_ca_key -sha256 -days 1024 -out service_x509_ca_certs (Generate CA Cert) openssl genrsa -out service_x509_key 2048 (Generate your private key) openssl req -new -key service_x509_key -out service_x509_csr (Generate your CSR) openssl x509 -req -in service_x509_csr -CA service_x509_ca_certs -CAkey zts_ca_key -CAcreateserial -out service_x509_cert -days 730 -sha256 (Generate your Certificate) Verify your certs openssl x509 -in service_x509_ca_certs -text -noout openssl x509 -in service_x509_cert -text -noout Once you have received your X509 certificate and key: - Upload the certificate with on s3 bucket with name service_x509_cert - Upload the private key with name service_x509_key - Upload the Root CA cert with name service_x509_ca_certs Upload RDS CA Certs Upload the RDS CA Certs with key service_rds_ca_certs For details on AWS RDS Certs, Please refer RDS SSL Certificates in AWS Upload truststore password Upload password you want to use for truststore with name service_x509_store_pwd Upload ZTS DB User Password Create a file containing only the password for ZTS Database user( athenz-zts ) created above during RDS schema setup Upload the file to bucket with name db_user_data Upload ZMS CA Certs Upload ZMS CA Cert with key zms_service_x509_ca_certs . They will be added to ZTS truststore so that ZTS can communicate securely with ZMS Upload ZTS and ZMS Public keys Upload ZTS public key with name zts_service_x509_key_public.pem Upload ZMS public key with name zms_service_x509_key_public.pem They are required to generate athenz.conf file at /opt/zts/conf to include the ZTS and ZMS Server URL and the registered public keys that the athenz client libraries and utilities will use to establish connections and validate any data signed by the ZTS and ZMS Server. Upload Self Cert Signer Key You can use SelfCertSigner or have your implementation of Cert Signer. Refer Certificate Signer for full details how to implement your cert signer. If you are using self cert signer then Generate a private key and upload it to s3 bucket with name self_cert_signer_key Update the policy for S3 bucket for Audit logs Update the bucket policy for S3 bucket created for audit logs during zms setup to allow athenz.zts-service role to read and write to it. { Version : 2012-10-17 , Statement : [ { Sid : , Effect : Allow , Principal : { AWS : [ arn:aws:iam:: aws_account_id :role/athenz.zms-service arn:aws:iam:: aws_account_id :role/athenz.zts-service ] }, ... ] } Update ZMS Data Bucket Upload zts service public key to ZMS Data Bucket with key zts_service_x509_key_public.pem Register ZTS Service In order for ZTS to access ZMS domain data, it must identify itself as a registered service in ZMS. Use zms-cli utility to register a new service in sys.auth domain. If ZMS Servers are running with a X509 certificate from a well know certificate authority (not a self-signed one) we don't need to reference the CA cert like we are doing below for self signed certs. Login into your zms-server instance as domain admin you created during zms setup and run the below commands: - Download ZMS CA Certs(If using self signed certs) aws s3 cp s3:// zms_bucket_name /zms_service_x509_ca_certs /tmp/zms_service_x509_ca_certs - Download ZTS public key aws s3 cp s3:// zms_bucket_name /zts_service_x509_key_public.pem /tmp/zts_service_x509_key_public.pem - Register Service using zms-cli /opt/zts/bin/zms-cli -c /tmp/service_x509_ca_certs -z zms_url -d sys.auth add-service zts 0 /tmp/zts_service_x509_key_public.pem NOTE - Append /zms/v1 to your url in the command above For e.g. if your zms server is running at https://zms.athenz.com:4443 then pass https://zms.athenz.com:4443/zms/v1 . Configure Variables and Properties Edit aws_init.sh Update the bucket names in athenz/aws-setup/zts-setup/build/bin/aws_init.sh by editing the below lines: export ZTS_DATA_BUCKET_NAME= The name of your zts data bucket export ZTS_AUDIT_LOG_BUCKET_NAME= The name of your zms audit data bucket export ZTS_URL= zts_url export ZMS_URL= zms_url export RDS_MASTER= zts-rds-databasecluster-endpoint The other variables are for trust store key store setup. We recommend to use the defaults but if you change then update the corresponding values in athenz.properties file discussed later. Edit the properties file Database Access Modify the following settings in zts.properties file located at athenz/aws-setup/zts-setup/build/conf/zts.properties if RDS username RDS password filename (stored on S3) are different from defaults suggested above. athenz.zts.cert_record_store_factory_class=com.yahoo.athenz.zts.cert.impl.JDBCCertRecordStoreFactory athenz.zts.cert_jdbc_user=athenz-zts athenz.zts.cert_jdbc_password=db_user_data Athenz CA X.509 Certificate Issuing For authenticating services using X509 certificates, ZTS Servers expect the configured cert signer factory class names in its athenz.zts.cert_signer_factory_class system property. Self Cert Signer com.yahoo.athenz.zts.cert.impl.SelfCertSignerFactory is a sample implementation of cert Signer we have for development environment. You can use SelfCertSigner or have your implementation of Cert Signer. If you are using self cert signer make the below changes: The self cert signer key you uploaded in above steps has to be downloaded on the box. The default is to download it to /opt/zts/conf/self_cert_signer_key . If you using the defaults, uncomment the below lines in initialize_zts.sh # echo Downloading self cert signer key # aws s3 cp s3://$bucket_name/self_cert_signer_key /opt/zts/conf/self_cert_signer_key Edit the below properties in zts.properties file accordingly: # athenz.zts.self_signer_private_key_fname=/opt/zts/conf/self_cert_signer_key # athenz.zts.self_signer_private_key_password= # athenz.zts.self_signer_cert_dn=C=US,ST=CA,L=Sunnyvale,O=Oath,OU=Athenz,CN=zts.aws.oath.cloud Truststore and Keystore Settings If you modified the truststore and keystore paths and password in the aws_init.sh file then change the below settings in athenz.properties file located at athenz/aws-setup/zts-setup/build/conf/athenz.properties : athenz.ssl_key_store=/opt/zts/conf/zts_keystore.pkcs12 //path to the keystore file that contains the server s certificate athenz.ssl_key_store_type=PKCS12 //specifies the type for the keystore specified in the athenz.ssl_key_store_password=service_x509_store_pwd //S3 bucket key name for Password for the keystore specified in the athenz.ssl_key_store property athenz.ssl_trust_store=/opt/zts/conf/zts_truststore.jks //path to the trust store file that contains CA certificates trusted by this Jetty instance athenz.ssl_trust_store_type=JKS //specifies the type for the truststore specified athenz.ssl_trust_store_password=service_x509_store_pwd //password for the truststore Update the following in zts.properties file: athenz.zts.ssl_key_store=/opt/zts/conf/zts_keystore.pkcs12 //path to the keystore file that contains the server s certificate athenz.zts.ssl_key_store_type=PKCS12 //specifies the type for the keystore specified in the athenz.zts.ssl_key_store_password=service_x509_store_pwd //S3 bucket key name for Password for the keystore specified in the athenz.ssl_key_store property athenz.zts.ssl_trust_store=/opt/zts/conf/zts_truststore.jks //path to the trust store file that contains CA certificates trusted by this Jetty instance athenz.zts.ssl_trust_store_type=JKS //specifies the type for the truststore specified athenz.zts.ssl_trust_store_password=service_x509_store_pwd //password for the truststore Packer Packer VPC Setup Packer VPC was set during zms setup, update packer.json accordingly: { subnet_id : packer_public_subnet_id , vpc_id : vpc_id , aws_region : aws-region where you created the resources , aws_ami_name : zts-aws-cd-image , aws_access_key : {{ env ` AWS_ACCESS_KEY_ID ` }} , aws_secret_key : {{ env ` AWS_SECRET_ACCESS_KEY ` }} , aws_session_token : {{ env ` AWS_SESSION_TOKEN ` }} , ssh_keypair_name : EC2_SSH_Key_Name , ssh_private_key_file : PATH_TO_SSH_KEYPAIR , source_ami : ami-02c71d7a } Build ZTS image Build the image with packer using the following command cd /aws-setup/zts-setup packer build packer/aws/packer.json Deploy ZTS Run cloudformation template to bring up the zts-instances in 2 availability zones. The imageID parameter should be set to the image created in above step. The ZTS Server is now up and running.","title":"ZTS Server"},{"location":"aws_zts_setup/#setup-zts-on-aws","text":"IAM role setup VPC setup RDS Setup Create Aurora Mysql cluster Schema setup S3 bucket for zts data Generate and upload service private key and Id Upload server X.509 cert and key Upload RDS CA Certs Upload truststore password Upload ZTS DB User Password Upload ZMS CA Certs Upload ZTS and ZMS Public keys Upload Self Cert Signer Key Update the policy for S3 bucket for Audit logs Update ZMS DATA BUCKET Register ZTS Service Configure Variables and Properties aws_init.sh Edit the properties file Database Access Athenz CA X.509 Certificate Issuing Truststore and Keystore Settings Packer Packer VPC setup Build ZTS Image Deploy ZTS","title":"Setup ZTS on AWS"},{"location":"aws_zts_setup/#iam-role-setup","text":"Create an EC2 profile role for ZTS using cloudformation template . This template creates a role named athenz.zts-service","title":"IAM Role Setup"},{"location":"aws_zts_setup/#vpc-setup","text":"Setup VPC using the cloudformation template and giving the following mandatory parameters: Route53HostedZoneName Route53RecordName S3AccessLogBucketName (Created during ZMS Setup) Environment The other parameters are set by default. Change them as per your requirements. NOTE - Modifying the other defaults might require subsequent changes. Following resources will be created after executing the template: 1. 2 availability zones 1. Public Private subnets for zts in each availability zone 1. Public Private subnets for cert signer in each availability zone 1. 4 NAT gateways and elastic IPs 1. NACL's for the subnets 1. Internet gateways for all public subnets 1. Route tables for all subnets 1. Elastic load balancer 1. Route 53 DNS entry 1. ZTS Server ELB security groups","title":"VPC Setup"},{"location":"aws_zts_setup/#rds-setup","text":"","title":"RDS Setup"},{"location":"aws_zts_setup/#create-aurora-mysql-cluster","text":"Setup an Aurora MySQL cluster using cloudformation template by giving the following mandatory parameters: Route53HostedZoneName Route53RecordName DatabaseUsername DatabasePassword Environment The other parameters are set by default. Change them as per your requirements.","title":"Create Aurora MySQL cluster"},{"location":"aws_zts_setup/#schema-setup","text":"Create an instance in your private subnet and ssh login into it. After logging in, install the mysql client and use the following command to connect to the cluster using Database Root Credentials: mysql -h RDS_CLUSTER_ENDPOINT -P 3306 -u DB_USER -p Copy the zts_server.sql file from the Athenz Git repository onto this host and create the database using the following command mysql -h RDS_CLUSTER_ENDPOINT -P 3306 -u DB_USER -p zts_server.sql Create a user with full privileges on zts database created above. For e.g. If your ZTS Server will be running on zts1.athenz.com and user to be created is athenz-zts having password athenz-zts : CREATE USER athenz-zts @ zts1.athenz.com IDENTIFIED BY athenz-zts ; GRANT ALL PRIVILEGES ON zts_store TO athenz-zts @ zts1.athenz.com ; FLUSH PRIVILEGES;","title":"Schema Setup"},{"location":"aws_zts_setup/#create-s3-bucket-to-store-zts-data","text":"Create a S3 bucket for storing ZTS certificates, keys and other configuration data with appropriate policy as follows: { Version : 2012-10-17 , Statement : [ { Sid : , Effect : Allow , Principal : { AWS : arn:aws:iam:: aws_account_id :role/athenz.zts-service }, Action : s3:GetObject , Resource : arn:aws:s3::: bucket-name /* } ] } Also enable Default Encryption for your bucket. NOTE - athenz.zts-service is the EC2 role created using IAM template above","title":"Create S3 Bucket to Store ZTS Data"},{"location":"aws_zts_setup/#generate-and-upload-service-private-key-and-id","text":"Generate a unique private key that ZTS Server will use to sign any Role Tokens it issues: openssl genrsa -out service_private_key 2048 openssl rsa -in service_private_key -pubout zts_service_x509_key_public Upload the service private key with name service_private_key onto the s3 bucket. Upload the service private key id with name service_private_key_id onto the s3 bucket. This file just contains the id of private key. It is not mandatory as the id defaults to 0 if not specified","title":"Generate and Upload Service Private Key and Id"},{"location":"aws_zts_setup/#upload-server-x509-cert-and-key","text":"NOTE - While it is still possible to generate and use a self-signed X.509 certificate for ZTS Servers, it is recommended to purchase one for your production server from a well known certificate authority. Having such a certificate installed on your ZTS Servers will no longer require to distribute the server's CA certificate to other hosts (e.g. Hosts running ZPU). Follow the instructions provided by the Certificate Authority that you're going to purchase your certificate from, to generate your private key and Certificate Request (CSR). Submit your CSR to your CA to generate a x.509 certificate for your ZMS server. If you are using self signed certs then run the following commands: openssl genrsa -des3 -out zts_ca_key 4096 (Create ZTS CA Key) openssl req -x509 -new -nodes -key zts_ca_key -sha256 -days 1024 -out service_x509_ca_certs (Generate CA Cert) openssl genrsa -out service_x509_key 2048 (Generate your private key) openssl req -new -key service_x509_key -out service_x509_csr (Generate your CSR) openssl x509 -req -in service_x509_csr -CA service_x509_ca_certs -CAkey zts_ca_key -CAcreateserial -out service_x509_cert -days 730 -sha256 (Generate your Certificate) Verify your certs openssl x509 -in service_x509_ca_certs -text -noout openssl x509 -in service_x509_cert -text -noout Once you have received your X509 certificate and key: - Upload the certificate with on s3 bucket with name service_x509_cert - Upload the private key with name service_x509_key - Upload the Root CA cert with name service_x509_ca_certs","title":"Upload Server X.509 Cert and Key"},{"location":"aws_zts_setup/#upload-rds-ca-certs","text":"Upload the RDS CA Certs with key service_rds_ca_certs For details on AWS RDS Certs, Please refer RDS SSL Certificates in AWS","title":"Upload RDS CA Certs"},{"location":"aws_zts_setup/#upload-truststore-password","text":"Upload password you want to use for truststore with name service_x509_store_pwd","title":"Upload truststore password"},{"location":"aws_zts_setup/#upload-zts-db-user-password","text":"Create a file containing only the password for ZTS Database user( athenz-zts ) created above during RDS schema setup Upload the file to bucket with name db_user_data","title":"Upload ZTS DB User Password"},{"location":"aws_zts_setup/#upload-zms-ca-certs","text":"Upload ZMS CA Cert with key zms_service_x509_ca_certs . They will be added to ZTS truststore so that ZTS can communicate securely with ZMS","title":"Upload ZMS CA Certs"},{"location":"aws_zts_setup/#upload-zts-and-zms-public-keys","text":"Upload ZTS public key with name zts_service_x509_key_public.pem Upload ZMS public key with name zms_service_x509_key_public.pem They are required to generate athenz.conf file at /opt/zts/conf to include the ZTS and ZMS Server URL and the registered public keys that the athenz client libraries and utilities will use to establish connections and validate any data signed by the ZTS and ZMS Server.","title":"Upload ZTS and ZMS Public keys"},{"location":"aws_zts_setup/#upload-self-cert-signer-key","text":"You can use SelfCertSigner or have your implementation of Cert Signer. Refer Certificate Signer for full details how to implement your cert signer. If you are using self cert signer then Generate a private key and upload it to s3 bucket with name self_cert_signer_key","title":"Upload Self Cert Signer Key"},{"location":"aws_zts_setup/#update-the-policy-for-s3-bucket-for-audit-logs","text":"Update the bucket policy for S3 bucket created for audit logs during zms setup to allow athenz.zts-service role to read and write to it. { Version : 2012-10-17 , Statement : [ { Sid : , Effect : Allow , Principal : { AWS : [ arn:aws:iam:: aws_account_id :role/athenz.zms-service arn:aws:iam:: aws_account_id :role/athenz.zts-service ] }, ... ] }","title":"Update the  policy for S3 bucket for Audit logs"},{"location":"aws_zts_setup/#update-zms-data-bucket","text":"Upload zts service public key to ZMS Data Bucket with key zts_service_x509_key_public.pem","title":"Update ZMS Data Bucket"},{"location":"aws_zts_setup/#register-zts-service","text":"In order for ZTS to access ZMS domain data, it must identify itself as a registered service in ZMS. Use zms-cli utility to register a new service in sys.auth domain. If ZMS Servers are running with a X509 certificate from a well know certificate authority (not a self-signed one) we don't need to reference the CA cert like we are doing below for self signed certs. Login into your zms-server instance as domain admin you created during zms setup and run the below commands: - Download ZMS CA Certs(If using self signed certs) aws s3 cp s3:// zms_bucket_name /zms_service_x509_ca_certs /tmp/zms_service_x509_ca_certs - Download ZTS public key aws s3 cp s3:// zms_bucket_name /zts_service_x509_key_public.pem /tmp/zts_service_x509_key_public.pem - Register Service using zms-cli /opt/zts/bin/zms-cli -c /tmp/service_x509_ca_certs -z zms_url -d sys.auth add-service zts 0 /tmp/zts_service_x509_key_public.pem NOTE - Append /zms/v1 to your url in the command above For e.g. if your zms server is running at https://zms.athenz.com:4443 then pass https://zms.athenz.com:4443/zms/v1 .","title":"Register ZTS Service"},{"location":"aws_zts_setup/#configure-variables-and-properties","text":"","title":"Configure Variables and Properties"},{"location":"aws_zts_setup/#edit-aws_initsh","text":"Update the bucket names in athenz/aws-setup/zts-setup/build/bin/aws_init.sh by editing the below lines: export ZTS_DATA_BUCKET_NAME= The name of your zts data bucket export ZTS_AUDIT_LOG_BUCKET_NAME= The name of your zms audit data bucket export ZTS_URL= zts_url export ZMS_URL= zms_url export RDS_MASTER= zts-rds-databasecluster-endpoint The other variables are for trust store key store setup. We recommend to use the defaults but if you change then update the corresponding values in athenz.properties file discussed later.","title":"Edit aws_init.sh"},{"location":"aws_zts_setup/#edit-the-properties-file","text":"","title":"Edit the properties file"},{"location":"aws_zts_setup/#database-access","text":"Modify the following settings in zts.properties file located at athenz/aws-setup/zts-setup/build/conf/zts.properties if RDS username RDS password filename (stored on S3) are different from defaults suggested above. athenz.zts.cert_record_store_factory_class=com.yahoo.athenz.zts.cert.impl.JDBCCertRecordStoreFactory athenz.zts.cert_jdbc_user=athenz-zts athenz.zts.cert_jdbc_password=db_user_data","title":"Database Access"},{"location":"aws_zts_setup/#athenz-ca-x509-certificate-issuing","text":"For authenticating services using X509 certificates, ZTS Servers expect the configured cert signer factory class names in its athenz.zts.cert_signer_factory_class system property. Self Cert Signer com.yahoo.athenz.zts.cert.impl.SelfCertSignerFactory is a sample implementation of cert Signer we have for development environment. You can use SelfCertSigner or have your implementation of Cert Signer. If you are using self cert signer make the below changes: The self cert signer key you uploaded in above steps has to be downloaded on the box. The default is to download it to /opt/zts/conf/self_cert_signer_key . If you using the defaults, uncomment the below lines in initialize_zts.sh # echo Downloading self cert signer key # aws s3 cp s3://$bucket_name/self_cert_signer_key /opt/zts/conf/self_cert_signer_key Edit the below properties in zts.properties file accordingly: # athenz.zts.self_signer_private_key_fname=/opt/zts/conf/self_cert_signer_key # athenz.zts.self_signer_private_key_password= # athenz.zts.self_signer_cert_dn=C=US,ST=CA,L=Sunnyvale,O=Oath,OU=Athenz,CN=zts.aws.oath.cloud","title":"Athenz CA X.509 Certificate Issuing"},{"location":"aws_zts_setup/#truststore-and-keystore-settings","text":"If you modified the truststore and keystore paths and password in the aws_init.sh file then change the below settings in athenz.properties file located at athenz/aws-setup/zts-setup/build/conf/athenz.properties : athenz.ssl_key_store=/opt/zts/conf/zts_keystore.pkcs12 //path to the keystore file that contains the server s certificate athenz.ssl_key_store_type=PKCS12 //specifies the type for the keystore specified in the athenz.ssl_key_store_password=service_x509_store_pwd //S3 bucket key name for Password for the keystore specified in the athenz.ssl_key_store property athenz.ssl_trust_store=/opt/zts/conf/zts_truststore.jks //path to the trust store file that contains CA certificates trusted by this Jetty instance athenz.ssl_trust_store_type=JKS //specifies the type for the truststore specified athenz.ssl_trust_store_password=service_x509_store_pwd //password for the truststore Update the following in zts.properties file: athenz.zts.ssl_key_store=/opt/zts/conf/zts_keystore.pkcs12 //path to the keystore file that contains the server s certificate athenz.zts.ssl_key_store_type=PKCS12 //specifies the type for the keystore specified in the athenz.zts.ssl_key_store_password=service_x509_store_pwd //S3 bucket key name for Password for the keystore specified in the athenz.ssl_key_store property athenz.zts.ssl_trust_store=/opt/zts/conf/zts_truststore.jks //path to the trust store file that contains CA certificates trusted by this Jetty instance athenz.zts.ssl_trust_store_type=JKS //specifies the type for the truststore specified athenz.zts.ssl_trust_store_password=service_x509_store_pwd //password for the truststore","title":"Truststore and Keystore Settings"},{"location":"aws_zts_setup/#packer","text":"","title":"Packer"},{"location":"aws_zts_setup/#packer-vpc-setup","text":"Packer VPC was set during zms setup, update packer.json accordingly: { subnet_id : packer_public_subnet_id , vpc_id : vpc_id , aws_region : aws-region where you created the resources , aws_ami_name : zts-aws-cd-image , aws_access_key : {{ env ` AWS_ACCESS_KEY_ID ` }} , aws_secret_key : {{ env ` AWS_SECRET_ACCESS_KEY ` }} , aws_session_token : {{ env ` AWS_SESSION_TOKEN ` }} , ssh_keypair_name : EC2_SSH_Key_Name , ssh_private_key_file : PATH_TO_SSH_KEYPAIR , source_ami : ami-02c71d7a }","title":"Packer VPC Setup"},{"location":"aws_zts_setup/#build-zts-image","text":"Build the image with packer using the following command cd /aws-setup/zts-setup packer build packer/aws/packer.json","title":"Build ZTS image"},{"location":"aws_zts_setup/#deploy-zts","text":"Run cloudformation template to bring up the zts-instances in 2 availability zones. The imageID parameter should be set to the image created in above step. The ZTS Server is now up and running.","title":"Deploy ZTS"},{"location":"cert_signer/","text":"Certificate Signer Cert Signer Interfaces Configuration Provided Implementations Self Cert Signer HTTP Cert Signer Athenz supports service authentication with X.509 certificates which is preferred approach over NTokens. The services receive X509 certificates from ZTS which requires a cert signer implementation to sign and issue X509 certificates for Athenz Services. This feature, commonly referred as Copper Argos, is described in the following section . Cert Signer Interfaces For ZTS servers to issue X509 certificates, the following two interfaces must be implemented: CertSignerFactory . The job of the CertSignerFactory class is to implement a single create() method which returns an instance of CertSigner class implementation. CertSigner . This class implements six methods listed below: generateX509Certificate(): This method generates a signed X509 Certificate based on the given request. It takes three parameters csr (Certificate request) , requested key usage keyUsage (null for both server and client, otherwise specified usage type: server or client) and expiryTime which specifies requested certificate expiration time in minutes and returns a X509 Certificate in PEM format getCACertificate(): This method is to retrieve the CA certificate in PEM format that will be returned along with the x509 certificate back to the client. generateSSHCertificate(): This method is to generate a SSH Certificate based on the given request. getSSHCertificate(): This method is to retrieve the SSH Signer certificate for the given type. getMaxCertExpiryTimeMins(): This method is to retrieve the certificate max expiry time supported by the given signer. close(): This method is for closing the certSigner signer object and release all allocated resources During server startup, ZTS servers will load the configured cert signer factory class and invoke the create method. Then it will use the CertSigner object returned to issue X509 certificates to requesting services. Configuration ZTS Servers expect the configured cert signer factory class name in its athenz.zts.cert_signer_factory_class system property. For example, -Dathenz.zts.cert_signer_factory_class=com.yahoo.athenz.zts.cert.impl.HttpCertSignerFactory If you're installing and running Athenz services using the binary packages provided, you can configure the cert signer factory class in the conf/zts_server/zts.properties file for ZTS server: athenz.zts.cert_signer_factory_class=com.yahoo.athenz.zts.cert.impl.HttpCertSignerFactory Provided Implementations Here is the list of Athenz provided certificate signer implementations with a brief description of each one. Self Cert Signer Class: com.yahoo.athenz.zts.cert.impl.SelfCertSignerFactory This factory class creates and returns an object of SelfCertSigner class com.yahoo.athenz.zts.cert.impl.SelfCertSignerFactory The private key file name, private key password and the DN for self signer can be configured by using the following system properties: Key File: athenz.zts.self_signer_private_key_fname Key password: athenz.zts.self_signer_private_key_password DN: athenz.zts.self_signer_cert_dn The key file must be a PEM encoded either RSA or EC private key. Http Cert Signer Class: com.yahoo.athenz.zts.cert.impl.HttpCertSignerFactory This factory class creates and returns a object of HttpCertSigner class com.yahoo.athenz.zts.cert.impl.SelfCertSignerFactory This signer assumes you have a certificate singing daemon that implements POST/GET REST /x509 and /ssh endpoints to sign and return x.509 certificates. The base uri of signer service and other settings can be configured by using the following system properties: Base Uri of Cert Signer Service: athenz.zts.certsign_base_uri Connect Timeout: athenz.zts.certsign_connect_timeout This setting specifies in seconds the connect timeout. We are setting it to 10. Request Timeout: athenz.zts.certsign_request_timeout This setting specifies in seconds the request timeout. We are setting it to 5. Retry count: athenz.zts.certsign_retry_count This setting specifies the number of times the request should be retried if it's not completed with the requested timeout value. We are setting it to 3.","title":"Certificate Signer"},{"location":"cert_signer/#certificate-signer","text":"Cert Signer Interfaces Configuration Provided Implementations Self Cert Signer HTTP Cert Signer Athenz supports service authentication with X.509 certificates which is preferred approach over NTokens. The services receive X509 certificates from ZTS which requires a cert signer implementation to sign and issue X509 certificates for Athenz Services. This feature, commonly referred as Copper Argos, is described in the following section .","title":"Certificate Signer"},{"location":"cert_signer/#cert-signer-interfaces","text":"For ZTS servers to issue X509 certificates, the following two interfaces must be implemented: CertSignerFactory . The job of the CertSignerFactory class is to implement a single create() method which returns an instance of CertSigner class implementation. CertSigner . This class implements six methods listed below: generateX509Certificate(): This method generates a signed X509 Certificate based on the given request. It takes three parameters csr (Certificate request) , requested key usage keyUsage (null for both server and client, otherwise specified usage type: server or client) and expiryTime which specifies requested certificate expiration time in minutes and returns a X509 Certificate in PEM format getCACertificate(): This method is to retrieve the CA certificate in PEM format that will be returned along with the x509 certificate back to the client. generateSSHCertificate(): This method is to generate a SSH Certificate based on the given request. getSSHCertificate(): This method is to retrieve the SSH Signer certificate for the given type. getMaxCertExpiryTimeMins(): This method is to retrieve the certificate max expiry time supported by the given signer. close(): This method is for closing the certSigner signer object and release all allocated resources During server startup, ZTS servers will load the configured cert signer factory class and invoke the create method. Then it will use the CertSigner object returned to issue X509 certificates to requesting services.","title":"Cert Signer Interfaces"},{"location":"cert_signer/#configuration","text":"ZTS Servers expect the configured cert signer factory class name in its athenz.zts.cert_signer_factory_class system property. For example, -Dathenz.zts.cert_signer_factory_class=com.yahoo.athenz.zts.cert.impl.HttpCertSignerFactory If you're installing and running Athenz services using the binary packages provided, you can configure the cert signer factory class in the conf/zts_server/zts.properties file for ZTS server: athenz.zts.cert_signer_factory_class=com.yahoo.athenz.zts.cert.impl.HttpCertSignerFactory","title":"Configuration"},{"location":"cert_signer/#provided-implementations","text":"Here is the list of Athenz provided certificate signer implementations with a brief description of each one.","title":"Provided Implementations"},{"location":"cert_signer/#self-cert-signer","text":"Class: com.yahoo.athenz.zts.cert.impl.SelfCertSignerFactory This factory class creates and returns an object of SelfCertSigner class com.yahoo.athenz.zts.cert.impl.SelfCertSignerFactory The private key file name, private key password and the DN for self signer can be configured by using the following system properties: Key File: athenz.zts.self_signer_private_key_fname Key password: athenz.zts.self_signer_private_key_password DN: athenz.zts.self_signer_cert_dn The key file must be a PEM encoded either RSA or EC private key.","title":"Self Cert Signer"},{"location":"cert_signer/#http-cert-signer","text":"Class: com.yahoo.athenz.zts.cert.impl.HttpCertSignerFactory This factory class creates and returns a object of HttpCertSigner class com.yahoo.athenz.zts.cert.impl.SelfCertSignerFactory This signer assumes you have a certificate singing daemon that implements POST/GET REST /x509 and /ssh endpoints to sign and return x.509 certificates. The base uri of signer service and other settings can be configured by using the following system properties: Base Uri of Cert Signer Service: athenz.zts.certsign_base_uri Connect Timeout: athenz.zts.certsign_connect_timeout This setting specifies in seconds the connect timeout. We are setting it to 10. Request Timeout: athenz.zts.certsign_request_timeout This setting specifies in seconds the request timeout. We are setting it to 5. Retry count: athenz.zts.certsign_retry_count This setting specifies the number of times the request should be retried if it's not completed with the requested timeout value. We are setting it to 3.","title":"Http Cert Signer"},{"location":"copper_argos/","text":"Copper Argos: Athenz Service Identity X.509 Certificates Introduction Copper Argos Provider Service Registration Instance Register Request Instance Refresh Request Conclusion Introduction Although the focus of Athenz is authorization it had to address service authentication since it depends on it heavily since there was no generic solution to register and authenticate services within an organization. Athenz introduced the concept of service identities where the service administrator would generate a public/private RSA or EC key pair, register the public key in Athenz, and then it could issue authentication tokens (NTokens) signed by its private key that could be presented to Athenz to authenticate the service. While this works well when services talk to Athenz services, it is not secure for server-to-server communication. A tenant service must not present its NToken to a provider service since, if compromised, the provider service may act as the tenant service while communicating with other services. Athenz solution was to use authorization role tokens (ZTokens) that were scoped for a specific role in the requested domain. Rather than having a service administrator generate a key pair and register in Athenz, a new solution called Copper Argos was designed and implemented that would allow the service to be identified by its X.509 certificate issued by Athenz: Athenz would integrate with a Certificate Signer Daemon that would store its private key in HSM (e.g. AWS CloudHSM) A Service Identity Agent (SIA) running on an instance would generate a key pair on the instance itself, generate a CSR and send along with its authentication details to ZTS Server to request a certificate for the service. Once the request is authorized and validated, ZTS would contact Certificate Signer Daemon to mint a certificate for the instance. It would be valid for 30 days and the SIA running on the instance will be responsible to refresh the certificate daily. The service running on host can use the generated private key and the X.509 certificate it received from ZTS to identify itself to other services running within the organization. This model provides a significant improvement over the use of NTokens since the services now have a secure way of identifying themselves without the use of role tokens. Copper Argos Copper Argos is Athenz generalized model for service providers to launch other service identities in an authorized way through a callback-based verification model. The high level requirements for Copper Argos are as follows: 1. Once authorized as a service launcher in Athenz, the Provider will launch the Service by providing it with a signed identity document. 2. SIA installed on the instance during bootstrap process or available as part of the base image that the service is deployed on will create a public/private key pair, generate a certificate request (CSR) and submit the identity document along with its CSR to Athenz ZTS Service. 3. Athenz ZTS Service would carry out 2 authorization checks: a. It verifies that the Provider is authorized to launch services. This prohibits any service act like a provider and attempt to launch other services. b. It verifies that the Service being launched has authorized the Provider as its launcher. This prohibits any authorized Provider to launch any other service without explicit authorization from the tenant service administrator. 4. Athenz ZTS contacts the Provider to validate the signed instance identity document. 5. Once verified, ZTS contacts Certificate Signer Daemon to generate a X.509 Certificate valid for 30 days for the given CSR and returns to instance. 6. SIA is responsible for contacting ZTS daily to refresh the service X.509 certificate. The next several section describe the for Copper Argos requirements in more detail. Provider Service Registration An important part of issuing X.509 certificates is trusting the Provider. The Provider must retrieve a TLS certificate for its own service from Athenz and use that as its Server Certificate. When ZTS contacts Provider Service to validate an instance document, it will require TLS authentication and verify that the certificate the service used for establish secure communication was issued for the expected provider service by ZTS itself. As part of its registration, the provider will also specify a unique registered dns suffix that would be combined with the service identity name and included as a dnsName attribute value in the X.509 certificate. For example, if an instance deployed is going to have an Athenz identity of sports.api and the Provider\u2019s dns suffix is sports.athenz.cloud, then the dnsName attribute in the generated X.509 certificate would be api.sports.sports.athenz.cloud. The official format for the dnsName attribute is . . . Instance Register Request Before a tenant service can be launched by a specific provider and issued a TLS certificate for, the tenant domain administrator must authorize a specific provider service to launch its services. The provider is expected to configure separate launcher services for each data center and/or region it supports. This allows the tenant the flexibility to authorize the provider to launch its service in specific data center/region (e.g. grant launch action to provider sys.auth.aws.us-west-2) or in all supported data centers/regions (e.g. grant launch action to provider sys.auth.aws.*). ZTS does not have knowledge of each provider\u2019s signed instance document details - what\u2019s included, what is the format or what crypto algorithm was used to sign the document. Although each provider is strongly recommended to represent their instance documents as signed Json Web Tokens, ZTS treats it as an opaque string and relies on the registered provider service callback verifier to validate the document. ZTS does impose specific requirements on the X.509 CSR generated by SIA: The Subject CN in the CSR must be the Athenz service identity name (e.g. sports.api - api service in sports domain) The CSR must include a SAN dnsName attribute with the format: . . . The provider-dnsname-suffix must be provided by the provider service to the SIA agent. * The provider must specify a unique identifier for the instance within the provider\u2019s namespace (this could be combination of multiple strings - e.g. instance-id.pod-id.cluster-id) and this information must be included in the CSR as another SAN dnsName attribute with the format: \u201c .instanceid.athenz. \u201d. The ZTS server will use this information along with the issued TLS Certificate Serial number to revoke specific instances if they\u2019re compromised (more details are provided in the Instance Refresh Request section below). Instance Refresh Request During instance refresh request, ZTS Server carries out additional checks in addition to contacting provider service for verification of the instance. It will first verify that the connection is using the previous TLS certificate issued for the service and provider and the service authorization policies are still in place. In case a host is compromised and the attacker obtains the private key and ZTS issued X.509 certificate corresponding to that key, Athenz has additional checks in place to prevent the attacker to continuously refresh the certificate. A requirement of Copper Argos is that the CSR that the SIA generates must include a unique id that the provider has assigned to that instance in the X509 v3 SAN Extension dnsName field. Since each certificate is uniquely identified by its Serial Number (defined as BigInteger - e.g. Serial Number: 7e:14:6f:a2:33:b4:49:84:cb:f1:1f:c5:9d:a8:38:cb) generated by Athenz CA, Athenz ZTS can use that information along with instance id to maintain list of all issued certificates for instances with their serial numbers, detect compromised certificate refresh requests and revoke specific hosts from the refresh requests. When processing refresh requests, Athenz ZTS Server: Validates that the instance id in the CSR matches to the instance id of the certificate that was used for authentication. Retrieve the Instance ID record from the Certificate Database. This database is updated when the initial and refresh certificates are issued. The current serial number of the certificate must match to the certificate serial number registered in the instance ID record. The server keeps track of last 2 (current and previous) serial numbers thus allowing a single retry operation in case the client failed to update its local filesystem after receiving refreshed certificates. So if both the instance and the attacker start using the same instance id for refreshing certificates, Athenz ZTS will detect a mismatch between serial numbers assigned and used in those refresh requests, thus will revoke the instance from refreshing its certificates. Conclusion Copper Argos provides a secure and generic way for service providers to launch other authorized services with Athenz issued service identity X.509 certificates. These certificates provide a more secure solution than private key generated NTokens since they can be used to communicate with other Athenz enabled services without exposing their identity tokens.","title":"Service Identity X.509 Certificates - Copper Argos"},{"location":"copper_argos/#copper-argos-athenz-service-identity-x509-certificates","text":"Introduction Copper Argos Provider Service Registration Instance Register Request Instance Refresh Request Conclusion","title":"Copper Argos: Athenz Service Identity X.509 Certificates"},{"location":"copper_argos/#introduction","text":"Although the focus of Athenz is authorization it had to address service authentication since it depends on it heavily since there was no generic solution to register and authenticate services within an organization. Athenz introduced the concept of service identities where the service administrator would generate a public/private RSA or EC key pair, register the public key in Athenz, and then it could issue authentication tokens (NTokens) signed by its private key that could be presented to Athenz to authenticate the service. While this works well when services talk to Athenz services, it is not secure for server-to-server communication. A tenant service must not present its NToken to a provider service since, if compromised, the provider service may act as the tenant service while communicating with other services. Athenz solution was to use authorization role tokens (ZTokens) that were scoped for a specific role in the requested domain. Rather than having a service administrator generate a key pair and register in Athenz, a new solution called Copper Argos was designed and implemented that would allow the service to be identified by its X.509 certificate issued by Athenz: Athenz would integrate with a Certificate Signer Daemon that would store its private key in HSM (e.g. AWS CloudHSM) A Service Identity Agent (SIA) running on an instance would generate a key pair on the instance itself, generate a CSR and send along with its authentication details to ZTS Server to request a certificate for the service. Once the request is authorized and validated, ZTS would contact Certificate Signer Daemon to mint a certificate for the instance. It would be valid for 30 days and the SIA running on the instance will be responsible to refresh the certificate daily. The service running on host can use the generated private key and the X.509 certificate it received from ZTS to identify itself to other services running within the organization. This model provides a significant improvement over the use of NTokens since the services now have a secure way of identifying themselves without the use of role tokens.","title":"Introduction"},{"location":"copper_argos/#copper-argos","text":"Copper Argos is Athenz generalized model for service providers to launch other service identities in an authorized way through a callback-based verification model. The high level requirements for Copper Argos are as follows: 1. Once authorized as a service launcher in Athenz, the Provider will launch the Service by providing it with a signed identity document. 2. SIA installed on the instance during bootstrap process or available as part of the base image that the service is deployed on will create a public/private key pair, generate a certificate request (CSR) and submit the identity document along with its CSR to Athenz ZTS Service. 3. Athenz ZTS Service would carry out 2 authorization checks: a. It verifies that the Provider is authorized to launch services. This prohibits any service act like a provider and attempt to launch other services. b. It verifies that the Service being launched has authorized the Provider as its launcher. This prohibits any authorized Provider to launch any other service without explicit authorization from the tenant service administrator. 4. Athenz ZTS contacts the Provider to validate the signed instance identity document. 5. Once verified, ZTS contacts Certificate Signer Daemon to generate a X.509 Certificate valid for 30 days for the given CSR and returns to instance. 6. SIA is responsible for contacting ZTS daily to refresh the service X.509 certificate. The next several section describe the for Copper Argos requirements in more detail.","title":"Copper Argos"},{"location":"copper_argos/#provider-service-registration","text":"An important part of issuing X.509 certificates is trusting the Provider. The Provider must retrieve a TLS certificate for its own service from Athenz and use that as its Server Certificate. When ZTS contacts Provider Service to validate an instance document, it will require TLS authentication and verify that the certificate the service used for establish secure communication was issued for the expected provider service by ZTS itself. As part of its registration, the provider will also specify a unique registered dns suffix that would be combined with the service identity name and included as a dnsName attribute value in the X.509 certificate. For example, if an instance deployed is going to have an Athenz identity of sports.api and the Provider\u2019s dns suffix is sports.athenz.cloud, then the dnsName attribute in the generated X.509 certificate would be api.sports.sports.athenz.cloud. The official format for the dnsName attribute is . . .","title":"Provider Service Registration"},{"location":"copper_argos/#instance-register-request","text":"Before a tenant service can be launched by a specific provider and issued a TLS certificate for, the tenant domain administrator must authorize a specific provider service to launch its services. The provider is expected to configure separate launcher services for each data center and/or region it supports. This allows the tenant the flexibility to authorize the provider to launch its service in specific data center/region (e.g. grant launch action to provider sys.auth.aws.us-west-2) or in all supported data centers/regions (e.g. grant launch action to provider sys.auth.aws.*). ZTS does not have knowledge of each provider\u2019s signed instance document details - what\u2019s included, what is the format or what crypto algorithm was used to sign the document. Although each provider is strongly recommended to represent their instance documents as signed Json Web Tokens, ZTS treats it as an opaque string and relies on the registered provider service callback verifier to validate the document. ZTS does impose specific requirements on the X.509 CSR generated by SIA: The Subject CN in the CSR must be the Athenz service identity name (e.g. sports.api - api service in sports domain) The CSR must include a SAN dnsName attribute with the format: . . . The provider-dnsname-suffix must be provided by the provider service to the SIA agent. * The provider must specify a unique identifier for the instance within the provider\u2019s namespace (this could be combination of multiple strings - e.g. instance-id.pod-id.cluster-id) and this information must be included in the CSR as another SAN dnsName attribute with the format: \u201c .instanceid.athenz. \u201d. The ZTS server will use this information along with the issued TLS Certificate Serial number to revoke specific instances if they\u2019re compromised (more details are provided in the Instance Refresh Request section below).","title":"Instance Register Request"},{"location":"copper_argos/#instance-refresh-request","text":"During instance refresh request, ZTS Server carries out additional checks in addition to contacting provider service for verification of the instance. It will first verify that the connection is using the previous TLS certificate issued for the service and provider and the service authorization policies are still in place. In case a host is compromised and the attacker obtains the private key and ZTS issued X.509 certificate corresponding to that key, Athenz has additional checks in place to prevent the attacker to continuously refresh the certificate. A requirement of Copper Argos is that the CSR that the SIA generates must include a unique id that the provider has assigned to that instance in the X509 v3 SAN Extension dnsName field. Since each certificate is uniquely identified by its Serial Number (defined as BigInteger - e.g. Serial Number: 7e:14:6f:a2:33:b4:49:84:cb:f1:1f:c5:9d:a8:38:cb) generated by Athenz CA, Athenz ZTS can use that information along with instance id to maintain list of all issued certificates for instances with their serial numbers, detect compromised certificate refresh requests and revoke specific hosts from the refresh requests. When processing refresh requests, Athenz ZTS Server: Validates that the instance id in the CSR matches to the instance id of the certificate that was used for authentication. Retrieve the Instance ID record from the Certificate Database. This database is updated when the initial and refresh certificates are issued. The current serial number of the certificate must match to the certificate serial number registered in the instance ID record. The server keeps track of last 2 (current and previous) serial numbers thus allowing a single retry operation in case the client failed to update its local filesystem after receiving refreshed certificates. So if both the instance and the attacker start using the same instance id for refreshing certificates, Athenz ZTS will detect a mismatch between serial numbers assigned and used in those refresh requests, thus will revoke the instance from refreshing its certificates.","title":"Instance Refresh Request"},{"location":"copper_argos/#conclusion","text":"Copper Argos provides a secure and generic way for service providers to launch other authorized services with Athenz issued service identity X.509 certificates. These certificates provide a more secure solution than private key generated NTokens since they can be used to communicate with other Athenz enabled services without exposing their identity tokens.","title":"Conclusion"},{"location":"copper_argos_dev/","text":"Copper Argos: Athenz Service Identity X.509 Certificates Development What is Copper Argos Provider Service Registration Tenant Service Launch Authorization Instance Register Request Instance Refresh Request Instance Revocation Request Athenz RDL Instance Register Request Instance Identity Response Instance Refresh Request Instance Revoke Request Instance Provider RDL Authorization Policies System Providers Provider Authorized DNS Suffix Service Authorized Providers Sample Implementation and Setup Tasks Athenz System Setup Provider Service Implementation and Registration Athenz Authorized Provider Registration Tenant Service Registration Provider Client Implementation What is Copper Argos Copper Argos is to extend Athenz with generalized model for service providers to launch other identities in an authorized way thru a callback-based verification model. With this model each provider is responsible for their instance document verification service instead of embedding that logic inside ZTS. Provider Service Registration Each provider is a registered service identity object in Athenz. As such, the provider domain administrator will create the service identity object in their domain and provide the following attributes using zms-cil utility or the REST API. (Athenz UI does not expose optional service attributes since they\u2019re not commonly used). * Provider Endpoint - A REST API endpoint that implements Provider RDL and ZTS will contact to validate the instance document (ServiceIdentity already has the providerEndpoint attribute) Domain administrator will then need to follow up with the Athenz Team to authorize Provider Service as an Instance Launcher Service in Athenz. The Provider will also specify the DNS suffix that will be used by its tenants. There will be a policy in sys.auth domain that grants launch action to instance resource to the providers role. Once approved, the Athenz System admin will add the provider service identity to the providers role in the sys.auth domain either using zms-cli or Athenz UI. There will be policy granting access to the specified Provider SAN dnsName attribute suffix to the list service provider. Requirements for Provider Service: It must retrieve a TLS certificate for its service (e.g. convert NToken into TLS Certificate) from Athenz and use that as its Service Certificate. When ZTS Contacts Provider Service to validate an instance document, it will require TLS authentication and verify that the certificate the service used for authentication was issued for the expected provider service by ZTS itself. * ZTS issues TLS certificates valid for 30 days only, so the Provider Service Admin must have the capability to periodically refresh its certificate by requesting a new one from ZTS Server (e.g. daily) and dynamically update its service to use the refreshed certificates. Tenant Service Launch Authorization Before a tenant service can be launched by a specific provider and issued a TLS certificate for, the tenant domain administrator must authorize a specific provider service to launch its services. This will require that a role and policy to be created in the tenant\u2019s domain. For example, if weather.api service wants to authorize athenz.aws provider to launch its services, it will need to create the following policy and role in their domain: Policy: grant launch to aws-provider on weather:service.api Role: aws-provider role member: athenz.aws.us-west-2 The change can be carried out with using zms-cli or Athenz UI. Instance Register Request Once the service admin creates the appropriate role and policy in its domain authorizing the provider service to bootstrap its instance, it can submit the launch request to the provider service. The steps of the bootstrap process pertaining Athenz integration would include: As part of the launch request, the admin will specify the Athenz domain and service that should be assigned to the instance. The provider service will generate an instance identity document, sign it with its private key and securely transfer this document along with its signature onto to the bootstrapped host. As part of the bootstrap process or possible as part of the image, the Service Identity Agent (SIA) will also be installed on the host. SIA will generate a public/private key pair on the host, generate a CSR using the newly generated private key. The CSR requirements are as follows: The Subject CN in the CSR must be the Athenz service identity name (e.g. weather.api - api service in weather domain) The CSR must include a SAN dnsName attribute with the format: service-with-domain . provider-dnsname-suffix . The provider-dnsname-suffix must match the value registered for the provider service. The service-with-domain part is left up to to the provider to define what format they want to use (e.g. service . domain or service . domain-with-dashes ). ZTS server will pass these hostnames to the provider as entries in the attribute field for validation. The provider must specify a unique identifier for the instance within the provider\u2019s namespace (this could be combination of multiple strings - e.g. instance-id.pod-id.cluster-id) and this information must be included in the CSR as another SAN dnsName attribute with the format: provider-unique-instance-id .instanceid.athenz. provider-dnsname-suffix . The ZTS server will use this information along with the issued TLS Certificate Serial number to revoke specific instances if they\u2019re compromised. SIA will generate an InstanceRegisterInformation object that will include attestation data (this would include the instance identity document, its signature and other attributes that will be necessary for the provider to validate and confirm the instance register request from ZTS) received from the provider and submit the post request to ZTS Server. ZTS Server will carry out the following authorization and verification checks before contacting provider service: The provider service in the info object has been authorized in Athenz to launch services (policy exists in sys.auth domain). Service specified in the info object (domain.service) has authorized provider service in the info object to launch itself (policy exists in the service\u2019s own domain). The provider service is registered in Athenz, has a providerEndpoint (verified as internal ip address) and providerDnsNameSuffix attributes defined. The cn in the CSR matches to the specific domain and service names. The CSR must include only 2 dnsName attributes with the expected format: service-with-domain . provider-dnsname-suffix provider-unique-instance-id .instanceid.athenz. provider-dnsname-suffix ZTS Server will contact Provider service at its configured endpoint and verify that the TLS certificate used for authentication by the provider service matches to the service name and was issued by ZTS server itself. ZTS Server will generate an InstanceConfirmation object and submit the post request to the Provider Service. In the InstanceConfirmation object, ZTS server will include the following entries in the optional attributes map: sanDNS: comma separated list of dnsNames attributes in the CSR - there will only be 2 as defined in 6(e) above sanIP - comma separated list of IP addresses in the CSR if any were specified clientIP - the IP address of the client cloudAccount - domain\u2019s account id if one is configured The Provider Service will be responsible for: Validating Signature Validating the instance id Validating the bootup time is within acceptable time period (e..g 5 mins) Validating hostnames included in the CSR Validating IP addresses (if available) included in the CSR Once ZTS service receives a successful response from the Provider Service, it will submit the CSR to Certsignd to generate a X.509 Certificate ZTS Server will retrieve the Serial number from the Certificate and register the certificate along with instanceid and provider service name in its certificate database. This will be used to monitor refresh certificate operations and, in case of a compromise, revoke specific instances from the capability to refresh their own certificates. If the instance has requested a NToken in addition to a TLS Certificate, one will be generated and returned to the instance. By default, the token will be valid for 24 hours. The client library should parse the token, extract the expiry time and set the next refresh time \u2153 of that value. So with default value of 24 hours, the expectation is that the instance will refresh the token in 8 hours. If the initial and the subsequent refresh operations fail, the client can dynamically increase its frequency of refresh requests to make sure it has multiple chances of renewing the ntoken before it expires. Instance Refresh Request During instance refresh request, ZTS Server again contacts provider service for verification of the instance. This is necessary in case the credentials have been compromised and the original instance is no longer running and will allow the provider to verify that the instance is indeed still running. ZTS will also verify that the connection is using the previous TLS certificate issued for the service and provider and the authorization policies are still in place. The steps would include: SIA will generate a public/private key pair on the host, generate a CSR using the newly generated private key. The CSR requirements are as follows: The Subject CN in the CSR must be the Athenz service identity name (e.g. weather.api - api service in weather domain) The CSR must include a SAN dnsName attribute with the format: service-with-domain . provider-dnsname-suffix that was used in the original register request. The provider must specify a unique identifier for the instance within the provider namespace (this could be combination of multiple strings - e.g. instance-id.pod-id.cluster-id) and this information must be included in the CSR as another SAN dnsName attribute with the format: provider-unique-instance-id .instanceid.athenz. provider-dnsname-suffix . The ZTS server will use this information along with the issued TLS Certificate Serial number to revoke specific instances if they\u2019re compromised. SIA will generate an InstanceRefreshInformation object including attestation data and submit the post request to ZTS Server. It will be required to use the TLS certificate that was issued to that instance previously by ZTS Server. ZTS Server will carry out the following authorization and verification checks before contacting provider service: The provider service in the info object has been authorized in Athenz to launch services (policy exists in sys.auth domain). Service specified in the info object (domain.service) has authorized provider service in the info object to launch itself (policy exists in the service\u2019s own domain). The cn in the CSR matches to the specific domain and service names. The TLS certificate SIA used to contact ZTS server must be for the same service. The TLS certificate SIA used to contact ZTS server must have the same provider and the 2 dnsName attributes as the CSR. ZTS Server will extract the instanceid from CSR and verify that the instance has not been revoked and the serial number matches to the registered entry in the certificate database. ZTS Server will contact Provider service at its configured endpoint and verify that the TLS certificate used for authentication by the provider service matches to the service name and was issued by ZTS server itself. ZTS Server will generate an InstanceConfirmation object and submit the post request to the Provider Service. In the InstanceConfirmation object, ZTS server will include the attestation data presented by instance. The Provider Service will be responsible for: Validating attestation data Validating hostnames included in the CSR Validating IP addresses (if available) included in the CSR Once ZTS service receives a successful response from the Provider Service, it will submit the CSR to Certsignd to generate a X.509 Certificate ZTS Server will retrieve the Serial number from the new Certificate and update the certificate database with the new serial number. Instance Revocation Request If necessary, the domain administrators must be able to revoke specific instances from having the capability to refresh their certificate. The steps would be: Domain Admin will issue a HTTP DELETE /instance/\u2026 request to ZTS Server. ZTS Server will authorize the request and update the serial number for the requested instance id in the certificate database to -1. This operation will revoke the instance from refreshing its certificates. Athenz RDL Instance Register Request InstanceRegisterInformation is the information a provider-hosted booting instance must provide to Athenz to authenticate: type InstanceRegisterInformation Struct { ServiceName provider; //the provider service name (i.e. aws.us-west-2 ) DomainName domain; //the domain of the instance SimpleName service; //the service this instance is supposed to run String attestationData;//signed identity document containing attributes //like IP address, instance-id, account#, signature, etc String csr; //the Certificate Signing Request for the expected //X.509 certificate in the response String ssh (optional); //if present, return an SSH host certificate. //Format is JSON. Bool token (optional); // if true, return a service token signed by //ZTS for this service } resource InstanceIdentity POST /instance { InstanceRegisterInformation info; String location (header= Location , out); //return location for subsequent operations expected CREATED; exceptions { ResourceError BAD_REQUEST; ResourceError FORBIDDEN; ResourceError UNAUTHORIZED; ResourceError INTERNAL_SERVER_ERROR; } } Instance Identity Response InstanceIdentity is returned on successful attestation. includes the certifictates, tokens, and any additional provider-specific derived attributes. type InstanceIdentity Struct { ServiceName provider; //the provider service name (i.e. aws.us-west-2 ) ServiceName name; //name of the identity, fully qualified, e.g weather.api PathElement instanceId; //unique instance id within provider\u2019s namespace String x509Certificate (optional); //an X.509 certificate usable for //both client and server in TLS connections String x509CertificateSigner (optional); //the CA certificate chain to //verify all generated X.509 certs String sshCertificate (optional); //the SSH certificate, signed by //the CA (user or host) String sshCertificateSigner (optional); //the SSH CA s public key //for the sshCertificate (user or host) SignedToken serviceToken (optional); //service token instead of TLS certificate Map String,String attributes (optional); //other config-like attributes //determined at boot time } Instance Refresh Request InstanceRefreshInformation is the information a provider-hosted booting instance must provide to Athenz to refresh the TLS certificate it was issued initially. The request must be done using the previously issued client TLS certificate. type InstanceRefreshInformation Struct { String attestationData (optional); //identity attestation data including //document with its signature containing attributes like IP //address, instance-id, account#, etc. String csr (optional); //the Certificate Signing Request for the expected //X.509 certificate in the response String ssh (optional); //if present, return an SSH host certificate. //Format is JSON. Bool token (optional); // if true, return a service token signed by //ZTS for this service } resource InstanceIdentity POST /instance/{provider}/{domain}/{service}/{instanceId} { ServiceName provider; //the provider service name (i.e. aws.us-west-2 ) DomainName domain; //the domain of the instance SimpleName service; //the service this instance is supposed to run PathElement instanceId; //the instance id that\u2019s unique within this provider InstanceRefreshInformation info; //the refresh request authenticate; //only TLS Certificate authentication is allowed expected OK; exceptions { ResourceError BAD_REQUEST; ResourceError FORBIDDEN; ResourceError NOT_FOUND; ResourceError UNAUTHORIZED; ResourceError INTERNAL_SERVER_ERROR; } } Instance Revoke Request resource InstanceIdentity DELETE /instance/{provider}/{domain}/{service}/{instanceId} { ServiceName provider ; // the provider service name ( i . e . aws.us-west-2 ) DomainName domain ; // the domain of the instance SimpleName service ; // the service this instance is supposed to run PathElement instanceId ; // the instance id that \u2019 s unique within this provider authorize ( \u201c delete \u201d , { domain }: instance . { instanceId }; expected NO_CONTENT ; exceptions { ResourceError BAD_REQUEST ; ResourceError FORBIDDEN ; ResourceError NOT_FOUND ; ResourceError UNAUTHORIZED ; ResourceError INTERNAL_SERVER_ERROR ; } } Instance Provider RDL This is the RDL that any provider that is authorized to create instances through Athenz must implement. This interface must be available over HTTPS only. type InstanceConfirmation Struct { ServiceName provider; //the provider service name DomainName domain; //the domain of the instance SimpleName service; //the service this instance is supposed to run String attestationData; //signed identity document containing attributes //like IP address, instance-id, account#, signature, etc. Map String,String attributes (optional); //additional non-signed attributes that assist //in attestation. I.e. instanceId\u201d, keyId , accessKey , etc } Confirm instance identity information and return appropriate response to ZTS Server. On return from the confirmation, the resulting InstanceConfirmation may have additional useful attributes added, for example attributes taken from the identity document like \"account\" number or a canonical value like \"network\" that gets identified differently with different providers. resource InstanceConfirmation POST /instance { InstanceConfirmation confirmation; authenticate; expected OK; exceptions { ResourceError BAD_REQUEST; ResourceError FORBIDDEN; ResourceError UNAUTHORIZED; } } resource InstanceConfirmation POST /refresh (name=PostRefreshConfirmation) { InstanceConfirmation confirmation; Authenticate; expected OK; exceptions { ResourceError BAD_REQUEST; ResourceError FORBIDDEN; ResourceError UNAUTHORIZED; } } Authorization Policies System Providers Athenz will maintain list of authorized provider services in sys.auth domain. If necessary, we can configure specific policies to grant additional users access over the roles/policies used to configure the list of provider. Domain : sys . auth Role : providers Members : provider - name ( s ) ( e . g . openstack . cluster1 ) Policy : providers Assertion : grant launch to providers on sys . auth : instance Provider Authorized DNS Suffix When generating a CSR to request a TLS certificate for a service, the sia agent must know what DNS Suffix is the provider authorized to use so it can include the dnsName attribute in the CSR in the expected form (e.g. service . domain-with-dashes . provider-dns-suffix ). ZTS must validate that the provider is authorized to launch a service with that DNS suffix. For now, this information will be authorized against a policy in special sys.auth domain. Domain : sys . auth Role : provider . provider - name ( e . g . provider . openstack . cluster1 ) Members : provider - name ( s ) ( e . g . openstack . cluster1 ) Policy : provider . provider - name Assertion : grant launch to provider . provider - name on sys . auth : dns . provider - suffix Service Authorized Providers Each service will have a role/policy in their own domain that they control whether or not authorize specific providers to launch their services. For example, service weather.api wants to authorize AWS services to launch its services: Domain : weather . api Role : api_providers Members : athenz . aws Policy : api_providers Assertion : grant launch to \u201c api_providers \u201d on \u201c weather : service . api \u201d Sample Implementation and Setup Tasks Athenz System Setup Create the provider\u2019s role: $ zms-cli -d sys.auth add-group-role providers Create the provider\u2019s policy: $ zms-cli -d sys.auth add-policy providers grant launch to providers on instance Provider Service Implementation and Registration Implement provider service that implements Instance Provider RDL. Register the provider service in Athenz in the provider\u2019s domain. For example, we\u2019ll be registering a provider service called openstack.cluster1. Generate private/public key pair for the service. $ openssl genrsa -out service_private.key 2048 $ openssl rsa -in service_private.key -pubout service_public.key Create the service identity in Athenz with public key id: v0 $ zms-cli -d openstack add-service cluster1 v0 ./service_public.key Determine the https endpoint for your service that ZTS will contact to verify instance information. For example, https://provider-cluster1.openstack.athenz.com:4443/hostsigner/v1 and set the endpoint for the service: $ zms-cli -d openstack set-service-endpoint cluster1 https://provider-cluster1.openstack.athenz.com:4443/hostsigner/v1 Obtain a TLS certificate from ZTS Server for the service to run with. If your service is Jetty based, then the private key and certificate must be added to a keystore using the openssl utility. The certificate is valid for 30 days, so you must setup a cron job that periodically retrieves an updated certificates and your service is refreshed to use to the new certificate. $ zts-svccert -domain openstack -service cluster1 -private-key ./service_private.key -key-version v0 -zts https:// zts-hostname :4443/zts/v1 -dns-domain athenz.com Determine the dns suffix for your provider service and submit a request to the Athenz system administrators to register the provider service with its dns suffix as an authorized provider service in Athenz Athenz Authorized Provider Registration Verify the dns suffix requested for the provider and, if valid, register the service in Athenz Add the service to the providers role: $ zms-cli -d sys.auth add-member providers openstack.cluster1 Register the dns suffix for the provider service. For example, cluster1.ostk.athenz.cloud $ zms-cli -d sys.auth add-group-role provider.openstack.providers openstack.cluster1 $ zms-cli -d sys.auth add-policy provider.openstack.providers grant launch to provider.openstack.providers on dns.cluster1.ostk.athenz.cloud Tenant Service Registration Authorize provider service to launch its instances. For example, weater domain wants to authorize its service api to be launched by openstack.cluster1 provider. $ zms-cli -d weather add-group-role openstack_providers openstack.cluster1 $ zms-cli -d weather add-policy openstack_providers grant launch to openstack_providers on weather:service.api Provider Client Implementation Provider must implement a client that will communicate with ZTS and execute Instance Register and Instance Refresh requests. When bootstrapping the the tenant instance, the Provider service must pass to the client the following details: the provider service name (e.g. openstack.cluster1) its dns suffix (e.g. cluster1.ostk.athenz.cloud) signed instance identity document The client will generate a CSR based on the details it received from its provider service, include the CSR in the InstanceRegisterInformation object and post it to ZTS. The client will be responsible for storing the certificate used from ZTS on the local host and use it for its subsequent requests to ZTS to refresh the certificate.","title":"Service Identity X.509 Certificate Support Requirements - Copper Argos"},{"location":"copper_argos_dev/#copper-argos-athenz-service-identity-x509-certificates-development","text":"What is Copper Argos Provider Service Registration Tenant Service Launch Authorization Instance Register Request Instance Refresh Request Instance Revocation Request Athenz RDL Instance Register Request Instance Identity Response Instance Refresh Request Instance Revoke Request Instance Provider RDL Authorization Policies System Providers Provider Authorized DNS Suffix Service Authorized Providers Sample Implementation and Setup Tasks Athenz System Setup Provider Service Implementation and Registration Athenz Authorized Provider Registration Tenant Service Registration Provider Client Implementation","title":"Copper Argos: Athenz Service Identity X.509 Certificates Development"},{"location":"copper_argos_dev/#what-is-copper-argos","text":"Copper Argos is to extend Athenz with generalized model for service providers to launch other identities in an authorized way thru a callback-based verification model. With this model each provider is responsible for their instance document verification service instead of embedding that logic inside ZTS.","title":"What is Copper Argos"},{"location":"copper_argos_dev/#provider-service-registration","text":"Each provider is a registered service identity object in Athenz. As such, the provider domain administrator will create the service identity object in their domain and provide the following attributes using zms-cil utility or the REST API. (Athenz UI does not expose optional service attributes since they\u2019re not commonly used). * Provider Endpoint - A REST API endpoint that implements Provider RDL and ZTS will contact to validate the instance document (ServiceIdentity already has the providerEndpoint attribute) Domain administrator will then need to follow up with the Athenz Team to authorize Provider Service as an Instance Launcher Service in Athenz. The Provider will also specify the DNS suffix that will be used by its tenants. There will be a policy in sys.auth domain that grants launch action to instance resource to the providers role. Once approved, the Athenz System admin will add the provider service identity to the providers role in the sys.auth domain either using zms-cli or Athenz UI. There will be policy granting access to the specified Provider SAN dnsName attribute suffix to the list service provider. Requirements for Provider Service: It must retrieve a TLS certificate for its service (e.g. convert NToken into TLS Certificate) from Athenz and use that as its Service Certificate. When ZTS Contacts Provider Service to validate an instance document, it will require TLS authentication and verify that the certificate the service used for authentication was issued for the expected provider service by ZTS itself. * ZTS issues TLS certificates valid for 30 days only, so the Provider Service Admin must have the capability to periodically refresh its certificate by requesting a new one from ZTS Server (e.g. daily) and dynamically update its service to use the refreshed certificates.","title":"Provider Service Registration"},{"location":"copper_argos_dev/#tenant-service-launch-authorization","text":"Before a tenant service can be launched by a specific provider and issued a TLS certificate for, the tenant domain administrator must authorize a specific provider service to launch its services. This will require that a role and policy to be created in the tenant\u2019s domain. For example, if weather.api service wants to authorize athenz.aws provider to launch its services, it will need to create the following policy and role in their domain: Policy: grant launch to aws-provider on weather:service.api Role: aws-provider role member: athenz.aws.us-west-2 The change can be carried out with using zms-cli or Athenz UI.","title":"Tenant Service Launch Authorization"},{"location":"copper_argos_dev/#instance-register-request","text":"Once the service admin creates the appropriate role and policy in its domain authorizing the provider service to bootstrap its instance, it can submit the launch request to the provider service. The steps of the bootstrap process pertaining Athenz integration would include: As part of the launch request, the admin will specify the Athenz domain and service that should be assigned to the instance. The provider service will generate an instance identity document, sign it with its private key and securely transfer this document along with its signature onto to the bootstrapped host. As part of the bootstrap process or possible as part of the image, the Service Identity Agent (SIA) will also be installed on the host. SIA will generate a public/private key pair on the host, generate a CSR using the newly generated private key. The CSR requirements are as follows: The Subject CN in the CSR must be the Athenz service identity name (e.g. weather.api - api service in weather domain) The CSR must include a SAN dnsName attribute with the format: service-with-domain . provider-dnsname-suffix . The provider-dnsname-suffix must match the value registered for the provider service. The service-with-domain part is left up to to the provider to define what format they want to use (e.g. service . domain or service . domain-with-dashes ). ZTS server will pass these hostnames to the provider as entries in the attribute field for validation. The provider must specify a unique identifier for the instance within the provider\u2019s namespace (this could be combination of multiple strings - e.g. instance-id.pod-id.cluster-id) and this information must be included in the CSR as another SAN dnsName attribute with the format: provider-unique-instance-id .instanceid.athenz. provider-dnsname-suffix . The ZTS server will use this information along with the issued TLS Certificate Serial number to revoke specific instances if they\u2019re compromised. SIA will generate an InstanceRegisterInformation object that will include attestation data (this would include the instance identity document, its signature and other attributes that will be necessary for the provider to validate and confirm the instance register request from ZTS) received from the provider and submit the post request to ZTS Server. ZTS Server will carry out the following authorization and verification checks before contacting provider service: The provider service in the info object has been authorized in Athenz to launch services (policy exists in sys.auth domain). Service specified in the info object (domain.service) has authorized provider service in the info object to launch itself (policy exists in the service\u2019s own domain). The provider service is registered in Athenz, has a providerEndpoint (verified as internal ip address) and providerDnsNameSuffix attributes defined. The cn in the CSR matches to the specific domain and service names. The CSR must include only 2 dnsName attributes with the expected format: service-with-domain . provider-dnsname-suffix provider-unique-instance-id .instanceid.athenz. provider-dnsname-suffix ZTS Server will contact Provider service at its configured endpoint and verify that the TLS certificate used for authentication by the provider service matches to the service name and was issued by ZTS server itself. ZTS Server will generate an InstanceConfirmation object and submit the post request to the Provider Service. In the InstanceConfirmation object, ZTS server will include the following entries in the optional attributes map: sanDNS: comma separated list of dnsNames attributes in the CSR - there will only be 2 as defined in 6(e) above sanIP - comma separated list of IP addresses in the CSR if any were specified clientIP - the IP address of the client cloudAccount - domain\u2019s account id if one is configured The Provider Service will be responsible for: Validating Signature Validating the instance id Validating the bootup time is within acceptable time period (e..g 5 mins) Validating hostnames included in the CSR Validating IP addresses (if available) included in the CSR Once ZTS service receives a successful response from the Provider Service, it will submit the CSR to Certsignd to generate a X.509 Certificate ZTS Server will retrieve the Serial number from the Certificate and register the certificate along with instanceid and provider service name in its certificate database. This will be used to monitor refresh certificate operations and, in case of a compromise, revoke specific instances from the capability to refresh their own certificates. If the instance has requested a NToken in addition to a TLS Certificate, one will be generated and returned to the instance. By default, the token will be valid for 24 hours. The client library should parse the token, extract the expiry time and set the next refresh time \u2153 of that value. So with default value of 24 hours, the expectation is that the instance will refresh the token in 8 hours. If the initial and the subsequent refresh operations fail, the client can dynamically increase its frequency of refresh requests to make sure it has multiple chances of renewing the ntoken before it expires.","title":"Instance Register Request"},{"location":"copper_argos_dev/#instance-refresh-request","text":"During instance refresh request, ZTS Server again contacts provider service for verification of the instance. This is necessary in case the credentials have been compromised and the original instance is no longer running and will allow the provider to verify that the instance is indeed still running. ZTS will also verify that the connection is using the previous TLS certificate issued for the service and provider and the authorization policies are still in place. The steps would include: SIA will generate a public/private key pair on the host, generate a CSR using the newly generated private key. The CSR requirements are as follows: The Subject CN in the CSR must be the Athenz service identity name (e.g. weather.api - api service in weather domain) The CSR must include a SAN dnsName attribute with the format: service-with-domain . provider-dnsname-suffix that was used in the original register request. The provider must specify a unique identifier for the instance within the provider namespace (this could be combination of multiple strings - e.g. instance-id.pod-id.cluster-id) and this information must be included in the CSR as another SAN dnsName attribute with the format: provider-unique-instance-id .instanceid.athenz. provider-dnsname-suffix . The ZTS server will use this information along with the issued TLS Certificate Serial number to revoke specific instances if they\u2019re compromised. SIA will generate an InstanceRefreshInformation object including attestation data and submit the post request to ZTS Server. It will be required to use the TLS certificate that was issued to that instance previously by ZTS Server. ZTS Server will carry out the following authorization and verification checks before contacting provider service: The provider service in the info object has been authorized in Athenz to launch services (policy exists in sys.auth domain). Service specified in the info object (domain.service) has authorized provider service in the info object to launch itself (policy exists in the service\u2019s own domain). The cn in the CSR matches to the specific domain and service names. The TLS certificate SIA used to contact ZTS server must be for the same service. The TLS certificate SIA used to contact ZTS server must have the same provider and the 2 dnsName attributes as the CSR. ZTS Server will extract the instanceid from CSR and verify that the instance has not been revoked and the serial number matches to the registered entry in the certificate database. ZTS Server will contact Provider service at its configured endpoint and verify that the TLS certificate used for authentication by the provider service matches to the service name and was issued by ZTS server itself. ZTS Server will generate an InstanceConfirmation object and submit the post request to the Provider Service. In the InstanceConfirmation object, ZTS server will include the attestation data presented by instance. The Provider Service will be responsible for: Validating attestation data Validating hostnames included in the CSR Validating IP addresses (if available) included in the CSR Once ZTS service receives a successful response from the Provider Service, it will submit the CSR to Certsignd to generate a X.509 Certificate ZTS Server will retrieve the Serial number from the new Certificate and update the certificate database with the new serial number.","title":"Instance Refresh Request"},{"location":"copper_argos_dev/#instance-revocation-request","text":"If necessary, the domain administrators must be able to revoke specific instances from having the capability to refresh their certificate. The steps would be: Domain Admin will issue a HTTP DELETE /instance/\u2026 request to ZTS Server. ZTS Server will authorize the request and update the serial number for the requested instance id in the certificate database to -1. This operation will revoke the instance from refreshing its certificates.","title":"Instance Revocation Request"},{"location":"copper_argos_dev/#athenz-rdl","text":"","title":"Athenz RDL"},{"location":"copper_argos_dev/#instance-register-request_1","text":"InstanceRegisterInformation is the information a provider-hosted booting instance must provide to Athenz to authenticate: type InstanceRegisterInformation Struct { ServiceName provider; //the provider service name (i.e. aws.us-west-2 ) DomainName domain; //the domain of the instance SimpleName service; //the service this instance is supposed to run String attestationData;//signed identity document containing attributes //like IP address, instance-id, account#, signature, etc String csr; //the Certificate Signing Request for the expected //X.509 certificate in the response String ssh (optional); //if present, return an SSH host certificate. //Format is JSON. Bool token (optional); // if true, return a service token signed by //ZTS for this service } resource InstanceIdentity POST /instance { InstanceRegisterInformation info; String location (header= Location , out); //return location for subsequent operations expected CREATED; exceptions { ResourceError BAD_REQUEST; ResourceError FORBIDDEN; ResourceError UNAUTHORIZED; ResourceError INTERNAL_SERVER_ERROR; } }","title":"Instance Register Request"},{"location":"copper_argos_dev/#instance-identity-response","text":"InstanceIdentity is returned on successful attestation. includes the certifictates, tokens, and any additional provider-specific derived attributes. type InstanceIdentity Struct { ServiceName provider; //the provider service name (i.e. aws.us-west-2 ) ServiceName name; //name of the identity, fully qualified, e.g weather.api PathElement instanceId; //unique instance id within provider\u2019s namespace String x509Certificate (optional); //an X.509 certificate usable for //both client and server in TLS connections String x509CertificateSigner (optional); //the CA certificate chain to //verify all generated X.509 certs String sshCertificate (optional); //the SSH certificate, signed by //the CA (user or host) String sshCertificateSigner (optional); //the SSH CA s public key //for the sshCertificate (user or host) SignedToken serviceToken (optional); //service token instead of TLS certificate Map String,String attributes (optional); //other config-like attributes //determined at boot time }","title":"Instance Identity Response"},{"location":"copper_argos_dev/#instance-refresh-request_1","text":"InstanceRefreshInformation is the information a provider-hosted booting instance must provide to Athenz to refresh the TLS certificate it was issued initially. The request must be done using the previously issued client TLS certificate. type InstanceRefreshInformation Struct { String attestationData (optional); //identity attestation data including //document with its signature containing attributes like IP //address, instance-id, account#, etc. String csr (optional); //the Certificate Signing Request for the expected //X.509 certificate in the response String ssh (optional); //if present, return an SSH host certificate. //Format is JSON. Bool token (optional); // if true, return a service token signed by //ZTS for this service } resource InstanceIdentity POST /instance/{provider}/{domain}/{service}/{instanceId} { ServiceName provider; //the provider service name (i.e. aws.us-west-2 ) DomainName domain; //the domain of the instance SimpleName service; //the service this instance is supposed to run PathElement instanceId; //the instance id that\u2019s unique within this provider InstanceRefreshInformation info; //the refresh request authenticate; //only TLS Certificate authentication is allowed expected OK; exceptions { ResourceError BAD_REQUEST; ResourceError FORBIDDEN; ResourceError NOT_FOUND; ResourceError UNAUTHORIZED; ResourceError INTERNAL_SERVER_ERROR; } }","title":"Instance Refresh Request"},{"location":"copper_argos_dev/#instance-revoke-request","text":"resource InstanceIdentity DELETE /instance/{provider}/{domain}/{service}/{instanceId} { ServiceName provider ; // the provider service name ( i . e . aws.us-west-2 ) DomainName domain ; // the domain of the instance SimpleName service ; // the service this instance is supposed to run PathElement instanceId ; // the instance id that \u2019 s unique within this provider authorize ( \u201c delete \u201d , { domain }: instance . { instanceId }; expected NO_CONTENT ; exceptions { ResourceError BAD_REQUEST ; ResourceError FORBIDDEN ; ResourceError NOT_FOUND ; ResourceError UNAUTHORIZED ; ResourceError INTERNAL_SERVER_ERROR ; } }","title":"Instance Revoke Request"},{"location":"copper_argos_dev/#instance-provider-rdl","text":"This is the RDL that any provider that is authorized to create instances through Athenz must implement. This interface must be available over HTTPS only. type InstanceConfirmation Struct { ServiceName provider; //the provider service name DomainName domain; //the domain of the instance SimpleName service; //the service this instance is supposed to run String attestationData; //signed identity document containing attributes //like IP address, instance-id, account#, signature, etc. Map String,String attributes (optional); //additional non-signed attributes that assist //in attestation. I.e. instanceId\u201d, keyId , accessKey , etc } Confirm instance identity information and return appropriate response to ZTS Server. On return from the confirmation, the resulting InstanceConfirmation may have additional useful attributes added, for example attributes taken from the identity document like \"account\" number or a canonical value like \"network\" that gets identified differently with different providers. resource InstanceConfirmation POST /instance { InstanceConfirmation confirmation; authenticate; expected OK; exceptions { ResourceError BAD_REQUEST; ResourceError FORBIDDEN; ResourceError UNAUTHORIZED; } } resource InstanceConfirmation POST /refresh (name=PostRefreshConfirmation) { InstanceConfirmation confirmation; Authenticate; expected OK; exceptions { ResourceError BAD_REQUEST; ResourceError FORBIDDEN; ResourceError UNAUTHORIZED; } }","title":"Instance Provider RDL"},{"location":"copper_argos_dev/#authorization-policies","text":"","title":"Authorization Policies"},{"location":"copper_argos_dev/#system-providers","text":"Athenz will maintain list of authorized provider services in sys.auth domain. If necessary, we can configure specific policies to grant additional users access over the roles/policies used to configure the list of provider. Domain : sys . auth Role : providers Members : provider - name ( s ) ( e . g . openstack . cluster1 ) Policy : providers Assertion : grant launch to providers on sys . auth : instance","title":"System Providers"},{"location":"copper_argos_dev/#provider-authorized-dns-suffix","text":"When generating a CSR to request a TLS certificate for a service, the sia agent must know what DNS Suffix is the provider authorized to use so it can include the dnsName attribute in the CSR in the expected form (e.g. service . domain-with-dashes . provider-dns-suffix ). ZTS must validate that the provider is authorized to launch a service with that DNS suffix. For now, this information will be authorized against a policy in special sys.auth domain. Domain : sys . auth Role : provider . provider - name ( e . g . provider . openstack . cluster1 ) Members : provider - name ( s ) ( e . g . openstack . cluster1 ) Policy : provider . provider - name Assertion : grant launch to provider . provider - name on sys . auth : dns . provider - suffix","title":"Provider Authorized DNS Suffix"},{"location":"copper_argos_dev/#service-authorized-providers","text":"Each service will have a role/policy in their own domain that they control whether or not authorize specific providers to launch their services. For example, service weather.api wants to authorize AWS services to launch its services: Domain : weather . api Role : api_providers Members : athenz . aws Policy : api_providers Assertion : grant launch to \u201c api_providers \u201d on \u201c weather : service . api \u201d","title":"Service Authorized Providers"},{"location":"copper_argos_dev/#sample-implementation-and-setup-tasks","text":"","title":"Sample Implementation and Setup Tasks"},{"location":"copper_argos_dev/#athenz-system-setup","text":"Create the provider\u2019s role: $ zms-cli -d sys.auth add-group-role providers Create the provider\u2019s policy: $ zms-cli -d sys.auth add-policy providers grant launch to providers on instance","title":"Athenz System Setup"},{"location":"copper_argos_dev/#provider-service-implementation-and-registration","text":"Implement provider service that implements Instance Provider RDL. Register the provider service in Athenz in the provider\u2019s domain. For example, we\u2019ll be registering a provider service called openstack.cluster1. Generate private/public key pair for the service. $ openssl genrsa -out service_private.key 2048 $ openssl rsa -in service_private.key -pubout service_public.key Create the service identity in Athenz with public key id: v0 $ zms-cli -d openstack add-service cluster1 v0 ./service_public.key Determine the https endpoint for your service that ZTS will contact to verify instance information. For example, https://provider-cluster1.openstack.athenz.com:4443/hostsigner/v1 and set the endpoint for the service: $ zms-cli -d openstack set-service-endpoint cluster1 https://provider-cluster1.openstack.athenz.com:4443/hostsigner/v1 Obtain a TLS certificate from ZTS Server for the service to run with. If your service is Jetty based, then the private key and certificate must be added to a keystore using the openssl utility. The certificate is valid for 30 days, so you must setup a cron job that periodically retrieves an updated certificates and your service is refreshed to use to the new certificate. $ zts-svccert -domain openstack -service cluster1 -private-key ./service_private.key -key-version v0 -zts https:// zts-hostname :4443/zts/v1 -dns-domain athenz.com Determine the dns suffix for your provider service and submit a request to the Athenz system administrators to register the provider service with its dns suffix as an authorized provider service in Athenz","title":"Provider Service Implementation and Registration"},{"location":"copper_argos_dev/#athenz-authorized-provider-registration","text":"Verify the dns suffix requested for the provider and, if valid, register the service in Athenz Add the service to the providers role: $ zms-cli -d sys.auth add-member providers openstack.cluster1 Register the dns suffix for the provider service. For example, cluster1.ostk.athenz.cloud $ zms-cli -d sys.auth add-group-role provider.openstack.providers openstack.cluster1 $ zms-cli -d sys.auth add-policy provider.openstack.providers grant launch to provider.openstack.providers on dns.cluster1.ostk.athenz.cloud","title":"Athenz Authorized Provider Registration"},{"location":"copper_argos_dev/#tenant-service-registration","text":"Authorize provider service to launch its instances. For example, weater domain wants to authorize its service api to be launched by openstack.cluster1 provider. $ zms-cli -d weather add-group-role openstack_providers openstack.cluster1 $ zms-cli -d weather add-policy openstack_providers grant launch to openstack_providers on weather:service.api","title":"Tenant Service Registration"},{"location":"copper_argos_dev/#provider-client-implementation","text":"Provider must implement a client that will communicate with ZTS and execute Instance Register and Instance Refresh requests. When bootstrapping the the tenant instance, the Provider service must pass to the client the following details: the provider service name (e.g. openstack.cluster1) its dns suffix (e.g. cluster1.ostk.athenz.cloud) signed instance identity document The client will generate a CSR based on the details it received from its provider service, include the CSR in the InstanceRegisterInformation object and post it to ZTS. The client will be responsible for storing the certificate used from ZTS on the local host and use it for its subsequent requests to ZTS to refresh the certificate.","title":"Provider Client Implementation"},{"location":"data_model/","text":"Architecture - Data Model Concepts Data Model Terminology Domains Resources Policies Roles Principals Users Services Tokens Principal Token - NToken Role Token - ZToken Having a firm grasp on some fundamental concepts will help you understand the Athenz architecture, the flow for both centralized and decentralized authorization, and how to set up role-based authorization. Concepts Role based Access Control (RBAC) system Symbolic names are used to identify the entities involved in authorization, so humans can read and understand the assertions Namespaces are strictly partitioned into Domains, which imply an ownership and control aspect to the names Enforcement can be factored such that it can be done in a distributed way, making possible data-plane checks that do not go off-box Administrative tasks can be delegated to created subdomains to avoid reliance on central \"super user\" administrative roles. Multi-tenancy relationships across domains can also take advantage of delegated administration Cryptographic signatures are used to ensure the fidelity of assertions and their lifecycle attributes Policy orientation, as opposed to Resource orientation, allows few assertions (in policies) to affect a potentially large number of resources, and also allows more flexible scoping via wildcarding over groups of resources. In Athenz, the authorization management server converts all incoming data to lowercase before any processing - this applies to all data types within Athenz (e.g. domain names, role names, policy names, resource group values, etc). Data Model Terminology Domain - a partition/namespace/account of control and isolation Role - an entity that takes action on resources, when assumed by a principal Resource - an entity to take action on, referred to by unique name Policy - a set of assertions that govern usage of resources Assertion - a quadruple of effect, role, action, resource Principal - an authenticated user or service that assumes one or more roles User - a user identity that is authenticate by a particular authority like Bouncer Service - An identity that exposes reusable resources, authenticated by an Athenz-aware container, reachable via an explicit endpoint. Provider - a type of service that participates in the multi-tenant provisioning protocol. Tenant - a Domain that is provisioned to access some Resources in a Provider Group - A group is a Role with explicit principal assignments Control Plane - operations done to provision or otherwise setup a system, outside its normal operation. Data Plane - operations done in the normal usage of a system, after it is set up. These operations are usually highly performance sensitive There are numerous domains, and domains can themselves \u201ccontain\u201d subdomains, from a creation/deletion perspective. However, all domains and subdomains, regardless of their administrative relationships, are independent and share no state. Relationships between them (i.e. quotas, billing roll ups, etc) must be explicitly introduced if desired. Roles, Policies and their Assertions, and Services are all defined in a Domain. Domains Domains are namespaces, strictly partitioned, providing a context for authoritative statements to be made about entities it contains. Only system administrators can create and destroy top level domains. Each such domain is assigned users in an administrative role. Those admins can, in turn, create and delete subdomains, that is, domains that start with the parent domain as a prefix, using a '.' as a domain delimiter. For example, \"media\" is a top level domain, and \"media.news\" is a subdomain of it. It is important to note that the only relation between these two domains involves creation and destruction of the domains -- the two domains share no state by default, and there is no inheritance or other relation between them other than that implied by their names. This allows all domains (whether top level or subdomains) to be completely partitioned from each other, and the ownership of the entities defined within a domain is clear. A domain is a place to group your resources and entities. All resources are partitioned across some set of domains Domains are given a symbolic name, so humans can easily understand a reference to them The domain name is used as a namespace for resource names Domains are similar the concept of an account, and provides a \u201cwalled garden\u201d in which to operate Resources Resources aren't explicitly modeled in Athenz, they are referred to by name. A resource is something that is \"owned\" and controlled in a specific domain. Concrete example: a machine Abstract example: a security policy Identified by a canonical name, so humans can comprehend references to it When referring to resources for authorization, a global naming system needs to be introduced to handle names in namespaces. A Resource Name is defined as follows: { Domain }:{ Entity } The Domain is the namespace mentioned above, and the Entity is an entity path (delimited by periods) within that namespace. The two are often used together to form a short resource name. For example, if the media.news property provisions a table in a db service, the resource name for the table may look like this: media.news:storage.db.table Policies To implement access control, we have policies in our domain that govern the use of our resources. A policy is a set of assertions (rules) about granting or denying an operation/action on a resource. For example, the assertion [grant, update, dev, storage.db.table] would grant the update operation/action to all the members in the dev role on the storage.db.table resource. Note that the assertion fields are declared as general strings, as they may contain \"globbing\" style wildcards, for example \"media.news:role.*\", which would apply to any entity that matched the pattern. Roles A role can be thought of as a group, anyone in the group can assume the role that takes a particular action. Every policy assertion describes what can be done by a role. A role can also delegate the determination of membership to another trusted domain. For example, a netops role managed outside a property domain. This is how we can model tenant relations between a provider domain and tenant domains. Because roles are defined in domains, they can be partitioned by domain, unlike users, which are global. This allows the distributed operation to be more easily scaled. Principals The actors in Athenz that can assume a role are called principals. These principals are authenticated and can be users (for example, authenticated by their Unix or Kerberos credentials). Principals can also be services that are authenticated by a service management system. Athenz currently provides service identity and authentication support. In either case, the identity is expressed as a resource name, and the proof of that identity is provided as a token, typically called an NToken (aka PrincipalToken). Users Users are actually defined in some external authority, e.g. Unix or Kerberos system. A special domain is reserved for the purpose of namespacing users, the name of that domain is user , so some example users are: user.john user.doe The credentials that the external system requires are exchanged for a NToken before operating on any data. Services The concept of a Service Identity is introduced as the identity of independent agents of execution. Services are defined as a subdomain of the managing domain, which provides a simple way of naming them. For example: media.news.msbe sports.storage The relationship of a service identity and its parent domain essentially means that the parent domain is an authority for the service itself, from a management perspective. A Service Identity may be used as a principal when specifying Roles, just like a User. Athenz provides support for registering such a Service Identity, in a domain, along with its public key that can be used to later verify an NToken that is presented by the service. Tokens Athenz authorization system utilizes 2 types of tokens: Principal Tokens (NTokens) and RoleTokens (ZTokens). Principal Token (NToken) The Principal token can be thought of an identity token because it identifies either a user or a service. Users submit their credentials to ZMS, which validates those credentials and generates, signs and returns principal tokens. A service generates its principal token using the service's private key. The principal token can then be used to access role tokens. A principal token is serialized as a string with following attributes: version (v) - the version of the token - U1 for user tokens and S1 for service tokens domain (d) - the domain of principal. For users this will always be \"user\" name (n) - the name of the principal host (h) - the FQDN of the host that issued this token salt (a) - a salt time (t) - the time the token was issued expires (e) - the time the token expires keyId (k) - the key identifier of the private key that was used to sign this token ip (i) - the IP address where the request to get this token was initiated from authorized-services (b) - the list of services authorized to use this user token signature (s) - the signature of the other items The single letter in parentheses is the key in the serialized string, where semicolons separate key value pairs, and the key and value are separated by an equals sign. For example: v=U1;d=user;n=joe;h=host.athenz.org;a=bb4e;t=1442255237;e=1442258837;k=0;i=10.72.42.32;s=Jw8SvYGYrk Note that requests that include a principal token should be protected to keep the token from being intercepted and reused (for the lifetime of the token). It is strongly recommended to always use HTTPS for such requests. Role Token (ZToken) Role tokens represent an authoritative statement that a given principal may assume some number of roles in a domain for a limited period of time. Like NTokens, they are signed to prevent tampering. In a sense, the ZTS is an authority except that it is an authority over Roles instead of Users. A role token is serialized as a string with following attributes: version (v) - the version of the token - Z1 domain (d) - the domain of role token roles (r) - a list of comma-separated role names principal (p) - the name of the principal (user/service) who requested this role token host (h) - the FQDN of the ZTS host that issued this token salt (a) - a salt time (t) - the time the token was issued expires (e) - the time the token expires keyId (k) - the key identifier of the ZTS private key that was used to sign this token ip (i) - the IP address where the request to get this token was initiated from signature (s) - the signature of the other items The single letter in parentheses is the key in the serialized string, where semicolons separate key value pairs, and the key and value are separated by an equals sign. For example: v=Z1;d=media.news;r=editor;p=user.joe;h=host.athenz.com;a=bb4e;t=1442255237;e=1442258837;k=0;i=10.72.42.32;s=P43Vp_LQh1 Note that requests that include a ZToken should be encrypted to keep the ZToken from being intercepted and reused (for the lifetime of the token). It is strongly recommended to always use HTTPS for such requests.","title":"Data Model"},{"location":"data_model/#architecture-data-model","text":"Concepts Data Model Terminology Domains Resources Policies Roles Principals Users Services Tokens Principal Token - NToken Role Token - ZToken Having a firm grasp on some fundamental concepts will help you understand the Athenz architecture, the flow for both centralized and decentralized authorization, and how to set up role-based authorization.","title":"Architecture - Data Model"},{"location":"data_model/#concepts","text":"Role based Access Control (RBAC) system Symbolic names are used to identify the entities involved in authorization, so humans can read and understand the assertions Namespaces are strictly partitioned into Domains, which imply an ownership and control aspect to the names Enforcement can be factored such that it can be done in a distributed way, making possible data-plane checks that do not go off-box Administrative tasks can be delegated to created subdomains to avoid reliance on central \"super user\" administrative roles. Multi-tenancy relationships across domains can also take advantage of delegated administration Cryptographic signatures are used to ensure the fidelity of assertions and their lifecycle attributes Policy orientation, as opposed to Resource orientation, allows few assertions (in policies) to affect a potentially large number of resources, and also allows more flexible scoping via wildcarding over groups of resources. In Athenz, the authorization management server converts all incoming data to lowercase before any processing - this applies to all data types within Athenz (e.g. domain names, role names, policy names, resource group values, etc).","title":"Concepts"},{"location":"data_model/#data-model","text":"","title":"Data Model"},{"location":"data_model/#terminology","text":"Domain - a partition/namespace/account of control and isolation Role - an entity that takes action on resources, when assumed by a principal Resource - an entity to take action on, referred to by unique name Policy - a set of assertions that govern usage of resources Assertion - a quadruple of effect, role, action, resource Principal - an authenticated user or service that assumes one or more roles User - a user identity that is authenticate by a particular authority like Bouncer Service - An identity that exposes reusable resources, authenticated by an Athenz-aware container, reachable via an explicit endpoint. Provider - a type of service that participates in the multi-tenant provisioning protocol. Tenant - a Domain that is provisioned to access some Resources in a Provider Group - A group is a Role with explicit principal assignments Control Plane - operations done to provision or otherwise setup a system, outside its normal operation. Data Plane - operations done in the normal usage of a system, after it is set up. These operations are usually highly performance sensitive There are numerous domains, and domains can themselves \u201ccontain\u201d subdomains, from a creation/deletion perspective. However, all domains and subdomains, regardless of their administrative relationships, are independent and share no state. Relationships between them (i.e. quotas, billing roll ups, etc) must be explicitly introduced if desired. Roles, Policies and their Assertions, and Services are all defined in a Domain.","title":"Terminology"},{"location":"data_model/#domains","text":"Domains are namespaces, strictly partitioned, providing a context for authoritative statements to be made about entities it contains. Only system administrators can create and destroy top level domains. Each such domain is assigned users in an administrative role. Those admins can, in turn, create and delete subdomains, that is, domains that start with the parent domain as a prefix, using a '.' as a domain delimiter. For example, \"media\" is a top level domain, and \"media.news\" is a subdomain of it. It is important to note that the only relation between these two domains involves creation and destruction of the domains -- the two domains share no state by default, and there is no inheritance or other relation between them other than that implied by their names. This allows all domains (whether top level or subdomains) to be completely partitioned from each other, and the ownership of the entities defined within a domain is clear. A domain is a place to group your resources and entities. All resources are partitioned across some set of domains Domains are given a symbolic name, so humans can easily understand a reference to them The domain name is used as a namespace for resource names Domains are similar the concept of an account, and provides a \u201cwalled garden\u201d in which to operate","title":"Domains"},{"location":"data_model/#resources","text":"Resources aren't explicitly modeled in Athenz, they are referred to by name. A resource is something that is \"owned\" and controlled in a specific domain. Concrete example: a machine Abstract example: a security policy Identified by a canonical name, so humans can comprehend references to it When referring to resources for authorization, a global naming system needs to be introduced to handle names in namespaces. A Resource Name is defined as follows: { Domain }:{ Entity } The Domain is the namespace mentioned above, and the Entity is an entity path (delimited by periods) within that namespace. The two are often used together to form a short resource name. For example, if the media.news property provisions a table in a db service, the resource name for the table may look like this: media.news:storage.db.table","title":"Resources"},{"location":"data_model/#policies","text":"To implement access control, we have policies in our domain that govern the use of our resources. A policy is a set of assertions (rules) about granting or denying an operation/action on a resource. For example, the assertion [grant, update, dev, storage.db.table] would grant the update operation/action to all the members in the dev role on the storage.db.table resource. Note that the assertion fields are declared as general strings, as they may contain \"globbing\" style wildcards, for example \"media.news:role.*\", which would apply to any entity that matched the pattern.","title":"Policies"},{"location":"data_model/#roles","text":"A role can be thought of as a group, anyone in the group can assume the role that takes a particular action. Every policy assertion describes what can be done by a role. A role can also delegate the determination of membership to another trusted domain. For example, a netops role managed outside a property domain. This is how we can model tenant relations between a provider domain and tenant domains. Because roles are defined in domains, they can be partitioned by domain, unlike users, which are global. This allows the distributed operation to be more easily scaled.","title":"Roles"},{"location":"data_model/#principals","text":"The actors in Athenz that can assume a role are called principals. These principals are authenticated and can be users (for example, authenticated by their Unix or Kerberos credentials). Principals can also be services that are authenticated by a service management system. Athenz currently provides service identity and authentication support. In either case, the identity is expressed as a resource name, and the proof of that identity is provided as a token, typically called an NToken (aka PrincipalToken).","title":"Principals"},{"location":"data_model/#users","text":"Users are actually defined in some external authority, e.g. Unix or Kerberos system. A special domain is reserved for the purpose of namespacing users, the name of that domain is user , so some example users are: user.john user.doe The credentials that the external system requires are exchanged for a NToken before operating on any data.","title":"Users"},{"location":"data_model/#services","text":"The concept of a Service Identity is introduced as the identity of independent agents of execution. Services are defined as a subdomain of the managing domain, which provides a simple way of naming them. For example: media.news.msbe sports.storage The relationship of a service identity and its parent domain essentially means that the parent domain is an authority for the service itself, from a management perspective. A Service Identity may be used as a principal when specifying Roles, just like a User. Athenz provides support for registering such a Service Identity, in a domain, along with its public key that can be used to later verify an NToken that is presented by the service.","title":"Services"},{"location":"data_model/#tokens","text":"Athenz authorization system utilizes 2 types of tokens: Principal Tokens (NTokens) and RoleTokens (ZTokens).","title":"Tokens"},{"location":"data_model/#principal-token-ntoken","text":"The Principal token can be thought of an identity token because it identifies either a user or a service. Users submit their credentials to ZMS, which validates those credentials and generates, signs and returns principal tokens. A service generates its principal token using the service's private key. The principal token can then be used to access role tokens. A principal token is serialized as a string with following attributes: version (v) - the version of the token - U1 for user tokens and S1 for service tokens domain (d) - the domain of principal. For users this will always be \"user\" name (n) - the name of the principal host (h) - the FQDN of the host that issued this token salt (a) - a salt time (t) - the time the token was issued expires (e) - the time the token expires keyId (k) - the key identifier of the private key that was used to sign this token ip (i) - the IP address where the request to get this token was initiated from authorized-services (b) - the list of services authorized to use this user token signature (s) - the signature of the other items The single letter in parentheses is the key in the serialized string, where semicolons separate key value pairs, and the key and value are separated by an equals sign. For example: v=U1;d=user;n=joe;h=host.athenz.org;a=bb4e;t=1442255237;e=1442258837;k=0;i=10.72.42.32;s=Jw8SvYGYrk Note that requests that include a principal token should be protected to keep the token from being intercepted and reused (for the lifetime of the token). It is strongly recommended to always use HTTPS for such requests.","title":"Principal Token (NToken)"},{"location":"data_model/#role-token-ztoken","text":"Role tokens represent an authoritative statement that a given principal may assume some number of roles in a domain for a limited period of time. Like NTokens, they are signed to prevent tampering. In a sense, the ZTS is an authority except that it is an authority over Roles instead of Users. A role token is serialized as a string with following attributes: version (v) - the version of the token - Z1 domain (d) - the domain of role token roles (r) - a list of comma-separated role names principal (p) - the name of the principal (user/service) who requested this role token host (h) - the FQDN of the ZTS host that issued this token salt (a) - a salt time (t) - the time the token was issued expires (e) - the time the token expires keyId (k) - the key identifier of the ZTS private key that was used to sign this token ip (i) - the IP address where the request to get this token was initiated from signature (s) - the signature of the other items The single letter in parentheses is the key in the serialized string, where semicolons separate key value pairs, and the key and value are separated by an equals sign. For example: v=Z1;d=media.news;r=editor;p=user.joe;h=host.athenz.com;a=bb4e;t=1442255237;e=1442258837;k=0;i=10.72.42.32;s=P43Vp_LQh1 Note that requests that include a ZToken should be encrypted to keep the ZToken from being intercepted and reused (for the lifetime of the token). It is strongly recommended to always use HTTPS for such requests.","title":"Role Token (ZToken)"},{"location":"dev_centralized_access/","text":"Developer Guide - Centralized Access Control Client - Obtaining NTokens from SIA Provider Server - Authorization Checks In the centralized access control model, the service as a principal requests its NToken from SIA Provider and then presents it to the target service which would perform an identical check with ZMS to confirm access. The required steps to setup the environment for provider and tenant services to support centralized access control are as follows: System administrator creates the provider and tenant domains. Tenant Domain administrator generates a public/private key pair and registers a service in its domain. Provider Domain administrator creates a role and policy that grants access to the given role with configured action and resource. Provider Domain administrator adds the Tenant Service to the role to grant access. Tenant Domain administrator installs the private key on the host that will be running the client/tenant service. One important security requirement for this model is that the service identity must be unique for each provider. If the same identity is used to access data from multiple providers, then the first target service provider, if compromised, might use the service's NToken to pretend to be that service and request data from the second target service provider. The next two sections describe the code changes that the developers must make to their services to support authorized access. Client - Obtaining NTokens from SIA Provider First you need to update your Java project pom.xml file to indicate the dependency on the Athenz auth_core Library: dependency groupId com.yahoo.athenz /groupId artifactId athenz-auth-core /artifactId version 1.X.Y /version /dependency repositories repository id bintray-yahoo-maven /id name bintray /name url http://yahoo.bintray.com/maven /url /repository /repositories The domain administrator must have already generated a public/private key pair for the service and registered public key in Athenz. The private key must be available on the host where the service will be running. // we re going to extract our private key from a given file File rsaPrivateKey = new File( /home/athenz/service/rsa_private.key ); PrivateKey privateKey = Crypto.loadPrivateKey(rsaPrivateKey); // setup the key identifier that the corresponding public key // has been registered in ZMS, and set the timeout to be 1 hour String keyId = v0 ; long tokenTimeout = TimeUnit.SECONDS.convert(1, TimeUnit.HOURS); // create our authority and sia provider object Authority authority = new PrincipalAuthority(); SimpleServiceIdentityProvider siaProvider = new SimpleServiceIdentityProvider(authority, privateKey, keyId, tokenTimeout); // generate a principal for our given domain and service Principal principal = siaProvider.getIdentity(domainName, serviceName); // include the principal.getSignedToken() string as the value for the // Athenz-Principal-Auth header Server - Authorization Checks On the server side the we just need to determine the specific requests action and the resource, extract the NToken string from the Athenz-Principal-Auth header value and contact ZMS to carry out the authorization check. First you need to update your Java project pom.xml file to indicate the dependency on the Athenz zms java client Library: dependency groupId com.yahoo.athenz /groupId artifactId athenz-zms-java-client /artifactId version 1.X.Y /version /dependency repositories repository id bintray-yahoo-maven /id name bintray /name url http://yahoo.bintray.com/maven /url /repository /repositories Now, the most important part of the rest of the required code is to determine the resource and action based on the given http request. Once you have those two values determined, then all that is left is to extract the NToken and contact ZMS for the authorization check. ``` HttpServletRequest req = (HttpServletRequest)servletRequest; // your method of extracting the resource value from the http // request. It might need to look at just the URI or possibly // the full body of the request. String resource = translateToMyServiceResource(req); // your method of extracting an action string from the http // request. String action = translateToMyServiceAction(req); // finally extract the ntoken from the header. String nToken = req.getHeader(\u201cAthenz-Principal-Auth\u201d); // create a zms authorizer and contact ZMS to carry out the check ZMSAuthorizer authorizer = new ZMSAuthorizer(serviceDomain); boolean access = authorizer.access(action, resource, nToken, null);","title":"Centralized Access Control"},{"location":"dev_centralized_access/#developer-guide-centralized-access-control","text":"Client - Obtaining NTokens from SIA Provider Server - Authorization Checks In the centralized access control model, the service as a principal requests its NToken from SIA Provider and then presents it to the target service which would perform an identical check with ZMS to confirm access. The required steps to setup the environment for provider and tenant services to support centralized access control are as follows: System administrator creates the provider and tenant domains. Tenant Domain administrator generates a public/private key pair and registers a service in its domain. Provider Domain administrator creates a role and policy that grants access to the given role with configured action and resource. Provider Domain administrator adds the Tenant Service to the role to grant access. Tenant Domain administrator installs the private key on the host that will be running the client/tenant service. One important security requirement for this model is that the service identity must be unique for each provider. If the same identity is used to access data from multiple providers, then the first target service provider, if compromised, might use the service's NToken to pretend to be that service and request data from the second target service provider. The next two sections describe the code changes that the developers must make to their services to support authorized access.","title":"Developer Guide - Centralized Access Control"},{"location":"dev_centralized_access/#client-obtaining-ntokens-from-sia-provider","text":"First you need to update your Java project pom.xml file to indicate the dependency on the Athenz auth_core Library: dependency groupId com.yahoo.athenz /groupId artifactId athenz-auth-core /artifactId version 1.X.Y /version /dependency repositories repository id bintray-yahoo-maven /id name bintray /name url http://yahoo.bintray.com/maven /url /repository /repositories The domain administrator must have already generated a public/private key pair for the service and registered public key in Athenz. The private key must be available on the host where the service will be running. // we re going to extract our private key from a given file File rsaPrivateKey = new File( /home/athenz/service/rsa_private.key ); PrivateKey privateKey = Crypto.loadPrivateKey(rsaPrivateKey); // setup the key identifier that the corresponding public key // has been registered in ZMS, and set the timeout to be 1 hour String keyId = v0 ; long tokenTimeout = TimeUnit.SECONDS.convert(1, TimeUnit.HOURS); // create our authority and sia provider object Authority authority = new PrincipalAuthority(); SimpleServiceIdentityProvider siaProvider = new SimpleServiceIdentityProvider(authority, privateKey, keyId, tokenTimeout); // generate a principal for our given domain and service Principal principal = siaProvider.getIdentity(domainName, serviceName); // include the principal.getSignedToken() string as the value for the // Athenz-Principal-Auth header","title":"Client - Obtaining NTokens from SIA Provider"},{"location":"dev_centralized_access/#server-authorization-checks","text":"On the server side the we just need to determine the specific requests action and the resource, extract the NToken string from the Athenz-Principal-Auth header value and contact ZMS to carry out the authorization check. First you need to update your Java project pom.xml file to indicate the dependency on the Athenz zms java client Library: dependency groupId com.yahoo.athenz /groupId artifactId athenz-zms-java-client /artifactId version 1.X.Y /version /dependency repositories repository id bintray-yahoo-maven /id name bintray /name url http://yahoo.bintray.com/maven /url /repository /repositories Now, the most important part of the rest of the required code is to determine the resource and action based on the given http request. Once you have those two values determined, then all that is left is to extract the NToken and contact ZMS for the authorization check. ``` HttpServletRequest req = (HttpServletRequest)servletRequest; // your method of extracting the resource value from the http // request. It might need to look at just the URI or possibly // the full body of the request. String resource = translateToMyServiceResource(req); // your method of extracting an action string from the http // request. String action = translateToMyServiceAction(req); // finally extract the ntoken from the header. String nToken = req.getHeader(\u201cAthenz-Principal-Auth\u201d); // create a zms authorizer and contact ZMS to carry out the check ZMSAuthorizer authorizer = new ZMSAuthorizer(serviceDomain); boolean access = authorizer.access(action, resource, nToken, null);","title":"Server - Authorization Checks"},{"location":"dev_decentralized_access/","text":"Developer guide - Decentralized Access Control Client - Obtaining RoleTokens from ZTS Server Obtaining ServiceIdentityProvider object ZTS Client Object Obtaining a Role Token ZTS getRoleToken Error Codes Token Caching Token Prefetch Caching Server - Authorization Checks In the decentralized access control model, the client service/user presents an authentication token (NToken) from SIA Provider to get an authorization token (ZToken) from ZTS, and then presents the ZToken to a target service to access its resources. The required steps to setup the environment for provider and tenant services to support decentralized access control are as follows: System administrator creates the provider and tenant domains. Tenant Domain administrator generates a public/private key pair and registers a service in its domain. Provider Domain administrator creates a role and policy that grants access to the given role with configured action and resource. Provider Domain administrator adds the Tenant Service to the role to grant access. Provider Domain administrator installs Athenz Policy Engine Updater (ZPU) on the hosts that will be running the provider service. ZPU must be configured with the provider domain name and setup to run as a cron job to periodically download the latest policy files for the server/provider domain. Tenant Domain administrator installs the private key on the host that will be running the client/tenant service. The next two sections describe the code changes that the developers must make to their services to support authorized access. Client - Obtaining RoleTokens from ZTS Server The client must carry out two major steps in order to retrieve a role token from ZTS Server. First, using the service's name and private key it needs to generate a ServiceIdentityProvider object which then it can use to retrieve a role token using ZTS Client Library. Obtaining ServiceIdentityProvider object First you need to update your Java project pom.xml file to indicate the dependency on the Athenz auth_core Library: dependency groupId com.yahoo.athenz /groupId artifactId athenz-auth-core /artifactId version 1.X.Y /version /dependency repositories repository id bintray-yahoo-maven /id name bintray /name url http://yahoo.bintray.com/maven /url /repository /repositories The domain administrator must have already generated a public/private key pair for the service and registered public key in Athenz. The private key must be available on the host where the service will be running. // we re going to extract our private key from a given file File rsaPrivateKey = new File( /home/athenz/service/rsa_private.key ); PrivateKey privateKey = Crypto.loadPrivateKey(rsaPrivateKey); // setup the key identifier that the corresponding public key // has been registered in ZMS, and set the timeout to be 1 hour String keyId = v0 ; long tokenTimeout = TimeUnit.SECONDS.convert(1, TimeUnit.HOURS); // create our authority and sia provider object Authority authority = new PrincipalAuthority(); SimpleServiceIdentityProvider siaProvider = new SimpleServiceIdentityProvider(authority, privateKey, keyId, tokenTimeout); ZTS Client Object First you need to update your Java project pom.xml file to indicate the dependency on the ZTS Java Client Library: dependency groupId com.yahoo.athenz /groupId artifactId athenz-zts-java-client /artifactId version 1.X.Y /version /dependency repositories repository id bintray-yahoo-maven /id name bintray /name url http://yahoo.bintray.com/maven /url /repository /repositories ZTS Client Library provides several constructors; however, the most commonly used one would be the constructor to create a client object based on a given domain and service identifier. /** * Constructs a new ZTSClient object with the given service identity * and media type set to application/json. The url for ZTS Server is * automatically retrieved from the athenz_config package s configuration * file (zts_url field). The service s principal token will be retrieved * from the SIA Provider. * Default read and connect timeout values are 30000ms (30sec). The application can * change these values by using the yahoo.zts_java_client.read_timeout and * yahoo.zts_java_client.connect_timeout system properties. The values specified * for timeouts must be in milliseconds. * @param domainName name of the domain * @param serviceName name of the service * @param siaProvider ServiceIdentityProvider object for the given service */ public ZTSClient(String domainName, String serviceName, ServiceIdentityProvider siaProvider); ZTSClient object must be closed to release any allocated resources. ZTSClient class implements Closeable interface. The client library automatically retrieves the URL of the ZTS server from its configuration file. For example, if you have already registered service called storage in the domain athenz , use the command below to instantiate a ZTS Client object: SimpleServiceIdentityProvider siaProvider = new SimpleServiceIdentityProvider(authority, privateKey, keyId, tokenTimeout); try (ZTSClient ztsClient = new ZTSClient( athenz , storage , siaProvider)) { // carry out requests against ZTS Server } If your application will only handle a single service, then rather than creating and destroying a ZTSClient object for every request, you can just create a single instance of the ZTSClient and use that instance by multiple threads to request role tokens: // in your service initialization method void initZTSClient(String domainName, String serviceName, String privateKeyPath, String keyId) { File rsaPrivateKey = new File( /home/athenz/service/rsa_private.key ); PrivateKey privateKey = Crypto.loadPrivateKey(rsaPrivateKey); // set the timeout to be 1 hour long tokenTimeout = TimeUnit.SECONDS.convert(1, TimeUnit.HOURS); // create our authority and sia provider object Authority authority = new PrincipalAuthority(); SimpleServiceIdentityProvider siaProvider = new SimpleServiceIdentityProvider(authority, privateKey, keyId, tokenTimeout); ztsClient = new ZTSClient(domainName, serviceName, siaProvider); } // then in our service processing code you can use the ztsClient // instance to retrieve role tokens for your requested domain and role RoleToken roleToken = ztsClient.getRoleToken(providerDomain, roleName); Obtaining a Role Token To obtain a Role Token, the application would use one the following methods from the ZTSClient class: /** * For the specified requester(user/service) return the corresponding Role Token that * includes the list of roles that the principal has access to in the specified domain. * The client will automatically fulfill the request from the cache, if possible. * The default minimum expiry time is 900 secs (15 mins). * @param domainName name of the domain * @return ZTS generated Role Token. ZTSClientException will be thrown in case of failure */ public RoleToken getRoleToken(String domainName); /** * For the specified requester(user/service) return the corresponding Role Token that * includes the specified role name that the principal has access to in the specified * domain. The client will automatically fulfill the request from the cache, if possible. * The default minimum expiry time is 900 secs (15 mins). * @param domainName name of the domain * @param roleName only interested in roles with this value * @return ZTS generated Role Token. ZTSClientException will be thrown in case of failure */ public RoleToken getRoleToken(String domainName, String roleName); In the simplest case, the method only requires the caller to specify the domain that the application will be accessing. Thus, it needs a Role Token for that domain. For example, if the athenz.storage service identifier is trying to access a resource from a domain weather , then the API call to retrieve the roleToken would be the following: RoleToken roleToken = null; try { roleToken = ztsClient.getRoleToken( weather ); } catch (ZTSClientException ex) { // log error using ex.getCode() and ex.getMessage() } Then the client will include the retrieved Role Token value as one of its headers when submitting its request to the provider service: ztsClient.getHeader(); // returns Header name: Athenz-Role-Auth roleToken.getToken() // returns header value However, the above method returns a RoleToken that includes all the roles the given principal has access to the provider domain. This may not be desirable as it violates the principle of least privilege. Instead, the caller should (in fact, the system administrator has the option to require this rather than making it possible) specify the roleName that it requires to complete its request.For example, if the athenz.storage service identifier is trying to access a resource from a domain weather and requires only read access which is granted to the service as being member of the readers role in the weather domain, then the API call to retrieve the roleToken would be the following: RoleToken roleToken = null; try { roleToken = ztsClient.getRoleToken( weather , readers ); } catch (ZTSClientException ex) { // log error using ex.getCode() and ex.getMessage() } ZTS getRoleToken Error Codes When communicating with ZTS Server to obtain a RoleToken, the ZTS Server will return the following 4xx error codes if it's unable to successfully process the request: 400 The domain name specified in the request to issue a RoleToken for contains invalid characters. 401 The request could not be successfully authenticated. This usually indicates that either the Service is not properly registered in ZMS or there is a mismatch between the registered public key and the private key that was used to generate the ServiceToken. 403 The service identity does not have access to any resources in the specified domain. 404 The domain specified in the request to issue a RoleToken for does not exist. Token Caching The ZTS Client Library automatically caches any tokens returned by the ZTS Server, so any subsequent requests for a Role Token for the same domain are fulfilled from the local cache as opposed to connecting to the ZTS Server every time. This provides better performance by reusing the same Role Token because they\u2019re valid for two hours by default. The client library will only return cached Role Tokens if they\u2019re valid for at least 15 minutes. If you want to change this default time, the application can set the following system property before starting their application: athenz.zts.client.token_min_expiry_time The value of this property must be specified in seconds. If for any reason you need to disable caching or have better control how long to cache tokens, the application can use the full getRoleToken API as shown below: /** * For the specified requester(user/service) return the corresponding * Role Token that includes the list of roles that the principal has * access to in the specified domain * @param domainName name of the domain * @param roleName (optional) only interested in the specified role * @param trustDomain (optional) only look for trusted roles in this domain * @param minExpiryTime (optional) specifies that the returned RoleToken * must be at least valid (min/lower bound) for specified number * of seconds, * @param maxExpiryTime (optional) specifies that the returned RoleToken * must be at most valid (max/upper bound) for specified number * of seconds. * @param ignoreCache ignore the cache and retrieve the token from ZTS Server * @return ZTS generated Role Token */ public RoleToken getRoleToken(String domainName, String roleName, Integer minExpiryTime, Integer maxExpiryTime, boolean ignoreCache); To completely disable caching, the ignoreCache argument (the last boolean argument) in the getRoleToken method can be passed true . For example, the following call disables caching: RoleToken roleToken = null; try { roleToken = ztsClient.getRoleToken( weather , readers , null, null, null, true); } catch (ZTSClientException ex) { // log error using ex.getCode() and ex.getMessage() } The code above will contact the ZTS Server every time the applications requests a role token for accessing resources in domain weather . The other two important arguments for token caching are the minExpiryTime and maxExpiryTime arguments. When passed null , the client library uses the default values, which as described above gets tokens that are valid for two hours and caches them until they\u2019re 15 minutes from expiration time. If your application wants to take advantage of longer caching, then it can request tokens from the ZTS Server with an expiration time longer than the default two hours. For example, the requirements for your server might be that you can use role tokens that must be at least 30 minutes from expiration and they can be valid for up to four hours. For example, the following would set up the API call that requests tokens from the Weather server that can only be used if they are 30 minutes from expiration and last four hours: RoleToken roleToken = null; try { roleToken = ztsClient.getRoleToken( weather , readers , null, 30 * 60, 4 * 60 * 60, true); } catch (ZTSClientException ex) { // log error using ex.getCode() and ex.getMessage() } With the above request configuration, your client library will only make a single connection to the ZTS Server to retrieve a new token once every three hours and 30 minutes. All other requests within that time frame will be fulfilled from the local cache. Token Prefetch Caching In addition to the caching described above, the cache can be kept fresh automatically by the ZTS Client library. The library detects when a token will expire within a short period of time and will actively retrieve a new token to replace it. In this way, the client will always get a usable token from the cache. With configuration, the prefetch mechanism can be triggered automatically upon calling any of the getRoleToken API. By default the feature is disabled, but can be enabled via a System Property. Here is an example of enabling automatic prefetch of tokens. athenz.zts.client.prefetch_auto_enable=true To use the prefetch caching feature with getRoleToken , specify the ignoreCache boolean argument with value false . Server - Authorization Checks In the Athenz enabled server the general processing of a client request goes as follows: Your service extracts the Role Token from the header ( Athenz-Role-Auth ) of the incoming request which it will pass it to the ZPE API. Your service determines the Action and Resource based on the client request. Then the service calls the ZPE API with the Action, Resource, and Role Token to determine authorization access. Additionally, the system administrator needs to make sure that ZPU (Athenz ZPE Policy Updater) utility is installed and configured to run on the server host. ZPU will download the configured domain policy data that is used by the ZPE library for authorization checks. First, you need to update your Java project pom.xml file to indicate your dependency on the ZPE Java Client Library: dependency groupId com.yahoo.athenz /groupId artifactId athenz-zpe-java-client /artifactId version 1.X.Y /version /dependency repositories repository id bintray-yahoo-maven /id name bintray /name url http://yahoo.bintray.com/maven /url /repository /repositories In your server startup code you must initialize the Athenz ZPE Client object which will process and load all the policy files configured and downloaded by ZPU on this host. AuthZpeClient.init(); Now, the most important part of the rest of the required code is to determine the resource and action based on the given http request. Once you have those two values determined, then all that is left is to extract the ZToken and call ZPE method for the authorization check. HttpServletRequest req = (HttpServletRequest)servletRequest; // your method of extracting the resource value from the http // request. It might need to look at just the URI or possibly // the full body of the request. String resource = translateToMyServiceResource(req); // your method of extracting an action string from the http // request. String action = translateToMyServiceAction(req); // finally extract the ntoken from the header. String zToken = req.getHeader(\u201cAthenz-Role-Auth\u201d); // this is a thread-safe call AccessCheckStatus status = AuthZpeClient.allowAccess(zToken, resource, action); if (status != AccessCheckStatus.ALLOW) { // status provides specific enum value for each reason // why the access check was denied. For example - here are // some of the possible values that are returned: // AccessCheckStatus.DENY - specific rule caused the deny effect // AccessCheckStatus.DENY_NO_MATCH - there was no match to any assertions // defined in the domain policy file so the default DENY effect was returned // AccessCheckStatus.DENY_ROLETOKEN_INVALID - The roletoken provided in the // request was either invalid or expired throw new Exception(\u201cAccess denied\u201d); } If you want to know which role caused the allow or deny a match to be returned by the API call, you can use the following API: StringBuilder matchRoleName = new StringBuilder(256); AccessCheckStatus status = AuthZpeClient.allowAccess(zToken, resource, action, matchRoleName); if (status != AccessCheckStatus.ALLOW) { throw new Exception(\u201cAccess denied\u201d); } The variable matchRoleName will include the name of the role from the assertion that matched the given action and resource.","title":"Decentralized Access Control"},{"location":"dev_decentralized_access/#developer-guide-decentralized-access-control","text":"Client - Obtaining RoleTokens from ZTS Server Obtaining ServiceIdentityProvider object ZTS Client Object Obtaining a Role Token ZTS getRoleToken Error Codes Token Caching Token Prefetch Caching Server - Authorization Checks In the decentralized access control model, the client service/user presents an authentication token (NToken) from SIA Provider to get an authorization token (ZToken) from ZTS, and then presents the ZToken to a target service to access its resources. The required steps to setup the environment for provider and tenant services to support decentralized access control are as follows: System administrator creates the provider and tenant domains. Tenant Domain administrator generates a public/private key pair and registers a service in its domain. Provider Domain administrator creates a role and policy that grants access to the given role with configured action and resource. Provider Domain administrator adds the Tenant Service to the role to grant access. Provider Domain administrator installs Athenz Policy Engine Updater (ZPU) on the hosts that will be running the provider service. ZPU must be configured with the provider domain name and setup to run as a cron job to periodically download the latest policy files for the server/provider domain. Tenant Domain administrator installs the private key on the host that will be running the client/tenant service. The next two sections describe the code changes that the developers must make to their services to support authorized access.","title":"Developer guide - Decentralized Access Control"},{"location":"dev_decentralized_access/#client-obtaining-roletokens-from-zts-server","text":"The client must carry out two major steps in order to retrieve a role token from ZTS Server. First, using the service's name and private key it needs to generate a ServiceIdentityProvider object which then it can use to retrieve a role token using ZTS Client Library.","title":"Client - Obtaining RoleTokens from ZTS Server"},{"location":"dev_decentralized_access/#obtaining-serviceidentityprovider-object","text":"First you need to update your Java project pom.xml file to indicate the dependency on the Athenz auth_core Library: dependency groupId com.yahoo.athenz /groupId artifactId athenz-auth-core /artifactId version 1.X.Y /version /dependency repositories repository id bintray-yahoo-maven /id name bintray /name url http://yahoo.bintray.com/maven /url /repository /repositories The domain administrator must have already generated a public/private key pair for the service and registered public key in Athenz. The private key must be available on the host where the service will be running. // we re going to extract our private key from a given file File rsaPrivateKey = new File( /home/athenz/service/rsa_private.key ); PrivateKey privateKey = Crypto.loadPrivateKey(rsaPrivateKey); // setup the key identifier that the corresponding public key // has been registered in ZMS, and set the timeout to be 1 hour String keyId = v0 ; long tokenTimeout = TimeUnit.SECONDS.convert(1, TimeUnit.HOURS); // create our authority and sia provider object Authority authority = new PrincipalAuthority(); SimpleServiceIdentityProvider siaProvider = new SimpleServiceIdentityProvider(authority, privateKey, keyId, tokenTimeout);","title":"Obtaining ServiceIdentityProvider object"},{"location":"dev_decentralized_access/#zts-client-object","text":"First you need to update your Java project pom.xml file to indicate the dependency on the ZTS Java Client Library: dependency groupId com.yahoo.athenz /groupId artifactId athenz-zts-java-client /artifactId version 1.X.Y /version /dependency repositories repository id bintray-yahoo-maven /id name bintray /name url http://yahoo.bintray.com/maven /url /repository /repositories ZTS Client Library provides several constructors; however, the most commonly used one would be the constructor to create a client object based on a given domain and service identifier. /** * Constructs a new ZTSClient object with the given service identity * and media type set to application/json. The url for ZTS Server is * automatically retrieved from the athenz_config package s configuration * file (zts_url field). The service s principal token will be retrieved * from the SIA Provider. * Default read and connect timeout values are 30000ms (30sec). The application can * change these values by using the yahoo.zts_java_client.read_timeout and * yahoo.zts_java_client.connect_timeout system properties. The values specified * for timeouts must be in milliseconds. * @param domainName name of the domain * @param serviceName name of the service * @param siaProvider ServiceIdentityProvider object for the given service */ public ZTSClient(String domainName, String serviceName, ServiceIdentityProvider siaProvider); ZTSClient object must be closed to release any allocated resources. ZTSClient class implements Closeable interface. The client library automatically retrieves the URL of the ZTS server from its configuration file. For example, if you have already registered service called storage in the domain athenz , use the command below to instantiate a ZTS Client object: SimpleServiceIdentityProvider siaProvider = new SimpleServiceIdentityProvider(authority, privateKey, keyId, tokenTimeout); try (ZTSClient ztsClient = new ZTSClient( athenz , storage , siaProvider)) { // carry out requests against ZTS Server } If your application will only handle a single service, then rather than creating and destroying a ZTSClient object for every request, you can just create a single instance of the ZTSClient and use that instance by multiple threads to request role tokens: // in your service initialization method void initZTSClient(String domainName, String serviceName, String privateKeyPath, String keyId) { File rsaPrivateKey = new File( /home/athenz/service/rsa_private.key ); PrivateKey privateKey = Crypto.loadPrivateKey(rsaPrivateKey); // set the timeout to be 1 hour long tokenTimeout = TimeUnit.SECONDS.convert(1, TimeUnit.HOURS); // create our authority and sia provider object Authority authority = new PrincipalAuthority(); SimpleServiceIdentityProvider siaProvider = new SimpleServiceIdentityProvider(authority, privateKey, keyId, tokenTimeout); ztsClient = new ZTSClient(domainName, serviceName, siaProvider); } // then in our service processing code you can use the ztsClient // instance to retrieve role tokens for your requested domain and role RoleToken roleToken = ztsClient.getRoleToken(providerDomain, roleName);","title":"ZTS Client Object"},{"location":"dev_decentralized_access/#obtaining-a-role-token","text":"To obtain a Role Token, the application would use one the following methods from the ZTSClient class: /** * For the specified requester(user/service) return the corresponding Role Token that * includes the list of roles that the principal has access to in the specified domain. * The client will automatically fulfill the request from the cache, if possible. * The default minimum expiry time is 900 secs (15 mins). * @param domainName name of the domain * @return ZTS generated Role Token. ZTSClientException will be thrown in case of failure */ public RoleToken getRoleToken(String domainName); /** * For the specified requester(user/service) return the corresponding Role Token that * includes the specified role name that the principal has access to in the specified * domain. The client will automatically fulfill the request from the cache, if possible. * The default minimum expiry time is 900 secs (15 mins). * @param domainName name of the domain * @param roleName only interested in roles with this value * @return ZTS generated Role Token. ZTSClientException will be thrown in case of failure */ public RoleToken getRoleToken(String domainName, String roleName); In the simplest case, the method only requires the caller to specify the domain that the application will be accessing. Thus, it needs a Role Token for that domain. For example, if the athenz.storage service identifier is trying to access a resource from a domain weather , then the API call to retrieve the roleToken would be the following: RoleToken roleToken = null; try { roleToken = ztsClient.getRoleToken( weather ); } catch (ZTSClientException ex) { // log error using ex.getCode() and ex.getMessage() } Then the client will include the retrieved Role Token value as one of its headers when submitting its request to the provider service: ztsClient.getHeader(); // returns Header name: Athenz-Role-Auth roleToken.getToken() // returns header value However, the above method returns a RoleToken that includes all the roles the given principal has access to the provider domain. This may not be desirable as it violates the principle of least privilege. Instead, the caller should (in fact, the system administrator has the option to require this rather than making it possible) specify the roleName that it requires to complete its request.For example, if the athenz.storage service identifier is trying to access a resource from a domain weather and requires only read access which is granted to the service as being member of the readers role in the weather domain, then the API call to retrieve the roleToken would be the following: RoleToken roleToken = null; try { roleToken = ztsClient.getRoleToken( weather , readers ); } catch (ZTSClientException ex) { // log error using ex.getCode() and ex.getMessage() }","title":"Obtaining a Role Token"},{"location":"dev_decentralized_access/#zts-getroletoken-error-codes","text":"When communicating with ZTS Server to obtain a RoleToken, the ZTS Server will return the following 4xx error codes if it's unable to successfully process the request: 400 The domain name specified in the request to issue a RoleToken for contains invalid characters. 401 The request could not be successfully authenticated. This usually indicates that either the Service is not properly registered in ZMS or there is a mismatch between the registered public key and the private key that was used to generate the ServiceToken. 403 The service identity does not have access to any resources in the specified domain. 404 The domain specified in the request to issue a RoleToken for does not exist.","title":"ZTS getRoleToken Error Codes"},{"location":"dev_decentralized_access/#token-caching","text":"The ZTS Client Library automatically caches any tokens returned by the ZTS Server, so any subsequent requests for a Role Token for the same domain are fulfilled from the local cache as opposed to connecting to the ZTS Server every time. This provides better performance by reusing the same Role Token because they\u2019re valid for two hours by default. The client library will only return cached Role Tokens if they\u2019re valid for at least 15 minutes. If you want to change this default time, the application can set the following system property before starting their application: athenz.zts.client.token_min_expiry_time The value of this property must be specified in seconds. If for any reason you need to disable caching or have better control how long to cache tokens, the application can use the full getRoleToken API as shown below: /** * For the specified requester(user/service) return the corresponding * Role Token that includes the list of roles that the principal has * access to in the specified domain * @param domainName name of the domain * @param roleName (optional) only interested in the specified role * @param trustDomain (optional) only look for trusted roles in this domain * @param minExpiryTime (optional) specifies that the returned RoleToken * must be at least valid (min/lower bound) for specified number * of seconds, * @param maxExpiryTime (optional) specifies that the returned RoleToken * must be at most valid (max/upper bound) for specified number * of seconds. * @param ignoreCache ignore the cache and retrieve the token from ZTS Server * @return ZTS generated Role Token */ public RoleToken getRoleToken(String domainName, String roleName, Integer minExpiryTime, Integer maxExpiryTime, boolean ignoreCache); To completely disable caching, the ignoreCache argument (the last boolean argument) in the getRoleToken method can be passed true . For example, the following call disables caching: RoleToken roleToken = null; try { roleToken = ztsClient.getRoleToken( weather , readers , null, null, null, true); } catch (ZTSClientException ex) { // log error using ex.getCode() and ex.getMessage() } The code above will contact the ZTS Server every time the applications requests a role token for accessing resources in domain weather . The other two important arguments for token caching are the minExpiryTime and maxExpiryTime arguments. When passed null , the client library uses the default values, which as described above gets tokens that are valid for two hours and caches them until they\u2019re 15 minutes from expiration time. If your application wants to take advantage of longer caching, then it can request tokens from the ZTS Server with an expiration time longer than the default two hours. For example, the requirements for your server might be that you can use role tokens that must be at least 30 minutes from expiration and they can be valid for up to four hours. For example, the following would set up the API call that requests tokens from the Weather server that can only be used if they are 30 minutes from expiration and last four hours: RoleToken roleToken = null; try { roleToken = ztsClient.getRoleToken( weather , readers , null, 30 * 60, 4 * 60 * 60, true); } catch (ZTSClientException ex) { // log error using ex.getCode() and ex.getMessage() } With the above request configuration, your client library will only make a single connection to the ZTS Server to retrieve a new token once every three hours and 30 minutes. All other requests within that time frame will be fulfilled from the local cache.","title":"Token Caching"},{"location":"dev_decentralized_access/#token-prefetch-caching","text":"In addition to the caching described above, the cache can be kept fresh automatically by the ZTS Client library. The library detects when a token will expire within a short period of time and will actively retrieve a new token to replace it. In this way, the client will always get a usable token from the cache. With configuration, the prefetch mechanism can be triggered automatically upon calling any of the getRoleToken API. By default the feature is disabled, but can be enabled via a System Property. Here is an example of enabling automatic prefetch of tokens. athenz.zts.client.prefetch_auto_enable=true To use the prefetch caching feature with getRoleToken , specify the ignoreCache boolean argument with value false .","title":"Token Prefetch Caching"},{"location":"dev_decentralized_access/#server-authorization-checks","text":"In the Athenz enabled server the general processing of a client request goes as follows: Your service extracts the Role Token from the header ( Athenz-Role-Auth ) of the incoming request which it will pass it to the ZPE API. Your service determines the Action and Resource based on the client request. Then the service calls the ZPE API with the Action, Resource, and Role Token to determine authorization access. Additionally, the system administrator needs to make sure that ZPU (Athenz ZPE Policy Updater) utility is installed and configured to run on the server host. ZPU will download the configured domain policy data that is used by the ZPE library for authorization checks. First, you need to update your Java project pom.xml file to indicate your dependency on the ZPE Java Client Library: dependency groupId com.yahoo.athenz /groupId artifactId athenz-zpe-java-client /artifactId version 1.X.Y /version /dependency repositories repository id bintray-yahoo-maven /id name bintray /name url http://yahoo.bintray.com/maven /url /repository /repositories In your server startup code you must initialize the Athenz ZPE Client object which will process and load all the policy files configured and downloaded by ZPU on this host. AuthZpeClient.init(); Now, the most important part of the rest of the required code is to determine the resource and action based on the given http request. Once you have those two values determined, then all that is left is to extract the ZToken and call ZPE method for the authorization check. HttpServletRequest req = (HttpServletRequest)servletRequest; // your method of extracting the resource value from the http // request. It might need to look at just the URI or possibly // the full body of the request. String resource = translateToMyServiceResource(req); // your method of extracting an action string from the http // request. String action = translateToMyServiceAction(req); // finally extract the ntoken from the header. String zToken = req.getHeader(\u201cAthenz-Role-Auth\u201d); // this is a thread-safe call AccessCheckStatus status = AuthZpeClient.allowAccess(zToken, resource, action); if (status != AccessCheckStatus.ALLOW) { // status provides specific enum value for each reason // why the access check was denied. For example - here are // some of the possible values that are returned: // AccessCheckStatus.DENY - specific rule caused the deny effect // AccessCheckStatus.DENY_NO_MATCH - there was no match to any assertions // defined in the domain policy file so the default DENY effect was returned // AccessCheckStatus.DENY_ROLETOKEN_INVALID - The roletoken provided in the // request was either invalid or expired throw new Exception(\u201cAccess denied\u201d); } If you want to know which role caused the allow or deny a match to be returned by the API call, you can use the following API: StringBuilder matchRoleName = new StringBuilder(256); AccessCheckStatus status = AuthZpeClient.allowAccess(zToken, resource, action, matchRoleName); if (status != AccessCheckStatus.ALLOW) { throw new Exception(\u201cAccess denied\u201d); } The variable matchRoleName will include the name of the role from the assertion that matched the given action and resource.","title":"Server - Authorization Checks"},{"location":"dev_environment/","text":"Development Environment Development Tools Java Platform JDK 8 Maven Git Client Go Node JS Build Steps Development Tools If you would like to build your own copy of Athenz rather than using the pre-built binary packages, then here is the list of development tools you need to have installed on your system. Java Platform JDK 8 To build Athenz components, you must have Java Platform JDK 8 installed on your machine. The main authorization services - ZMS and ZTS, are written in Java and using embedded Jetty. Oracle Java Platform JDK 8 Athenz has been developed and tested with Oracle Java Platform JDK 8. However, it should compile and run without any issues with OpenJDK 8 as well. Maven Download and install Apache Maven . Git Client If you don't have git client installed on your host, you can download one from Git website Go Install go by following the directions at Getting Started - The Go Programming Language . Node JS Install node by following the directions at Node.js JavaScript Runtime Verify that you have the required minimum version of node and nodemon binaries installed on your system and are included in your runtime path: $ node --version v6.9.4 $ npm install -g nodemon $ nodemon --version 1 .11.0 Build Steps To build Athenz components, change to the top level directory where Athenz code has been checked out and execute: $ git clone https://github.com/yahoo/athenz.git $ cd athenz $ mvn clean install The release packages will be created automatically in the assembly subdirectory.","title":"Development Environment"},{"location":"dev_environment/#development-environment","text":"Development Tools Java Platform JDK 8 Maven Git Client Go Node JS Build Steps","title":"Development Environment"},{"location":"dev_environment/#development-tools","text":"If you would like to build your own copy of Athenz rather than using the pre-built binary packages, then here is the list of development tools you need to have installed on your system.","title":"Development Tools"},{"location":"dev_environment/#java-platform-jdk-8","text":"To build Athenz components, you must have Java Platform JDK 8 installed on your machine. The main authorization services - ZMS and ZTS, are written in Java and using embedded Jetty. Oracle Java Platform JDK 8 Athenz has been developed and tested with Oracle Java Platform JDK 8. However, it should compile and run without any issues with OpenJDK 8 as well.","title":"Java Platform JDK 8"},{"location":"dev_environment/#maven","text":"Download and install Apache Maven .","title":"Maven"},{"location":"dev_environment/#git-client","text":"If you don't have git client installed on your host, you can download one from Git website","title":"Git Client"},{"location":"dev_environment/#go","text":"Install go by following the directions at Getting Started - The Go Programming Language .","title":"Go"},{"location":"dev_environment/#node-js","text":"Install node by following the directions at Node.js JavaScript Runtime Verify that you have the required minimum version of node and nodemon binaries installed on your system and are included in your runtime path: $ node --version v6.9.4 $ npm install -g nodemon $ nodemon --version 1 .11.0","title":"Node JS"},{"location":"dev_environment/#build-steps","text":"To build Athenz components, change to the top level directory where Athenz code has been checked out and execute: $ git clone https://github.com/yahoo/athenz.git $ cd athenz $ mvn clean install The release packages will be created automatically in the assembly subdirectory.","title":"Build Steps"},{"location":"example_go_centralized_access/","text":"Go Client/Server Example - Centralized Access Control Required Components Service Definition Resource Definition Athenz Management Setup Code Changes Client Changes Client Import Dependency Update Obtaining NTokens Build Go zms_svctoken Client Utility Servlet Changes Servlet Project Dependency Update Authorization Checks Build Servlet Deploying Example Servlet Test Cases Invalid Access Without ServiceToken Movie Editor Access TvShow Editor Access Site Editor Access Other Test Cases In the centralized access control model, the service as a principal requests its NToken from SIA Provider and then presents it to the target service which would perform an identical check with ZMS to confirm access. The required steps to setup the environment for provider and tenant services to support centralized access control are as follows: System administrator creates the provider and tenant domains. Tenant Domain administrator generates a public/private key pair and registers a service in its domain. Provider Domain administrator creates a role and policy that grants access to the given role with configured action and resource. Provider Domain administrator adds the Tenant Service to the role to grant access. Tenant Domain administrator installs the private key on the host that will be running the client/tenant service. Required Components To support centralized access control in your applications, you only need to install and configure the Athenz ZMS server along with the Athenz UI. Please follow these guides to make sure you have both of those components up and running in your environment: ZMS Server UI Server To build the client and server components of this example, you need to download and install Go and Git client if you don't already have these available on your box: The Go Programming Language Git client Make sure your GOPATH variable is set and the PATH variable includes the $(GOPATH)/bin to run the utilities. Service Definition Let's first define our service that needs to be Athenz protected. We have a simple recommendation service that returns either a movie or tv show for the caller. It has two endpoints: GET /rec/v1/movie GET /rec/v1/tvshow So in this first release we just want to protect access to these endpoints. The traffic is very low - we only expect a couple of requests an hour so we have decided to use Athenz' centralized authorization model. Resource Definition Defining resources and actions the principals are authorized to execute is one of the most important tasks in the authorization process. Based on our endpoints, it's expected that we'll have 2 general resources: movie tvshow The resources are referenced in their own domain namespace. So those are valid if your domain is specifically created to support this recommendation service only. But's lets assume we might add rental support later, so we need to make sure the policies are based on service specific resources. So we'll define our resources as: rec.movie rec.tvshow Support action for these resources would be read . We can extend our authorization policies later on if we need to introduce other actions - such as write or list as we add more functionality into our service. Athenz Management Setup Once we have defined what our resources and actions are, we can create their respective client and server (also commonly referred as tenant and provider) roles and policies in Athenz. Go to Athenz UI and login with your account which should have system administrator access. Follow the instructions in the following guide to setup the required access control: Access Control Setup Code Changes Both the client and server implementors need to make changes in their respective code bases to support centralized authorization checks. The client needs to make sure to submit its service identity as part of its request, while the service needs to carry out the authorization check based on that service identity to determine if it request should be processed or not. Client Changes While we'll use the curl client to make the http calls to our example service, we provide a sample client code that utilizes our zmssvctoken go library to generate service identity tokens. The full client source code is available from: https://github.com/yahoo/athenz/blob/master/utils/zms-svctoken/zms-svctoken.go Client Import Dependency Update First you need to update your go client to import the zms service token library. import ( github.com/yahoo/athenz/libs/go/zmssvctoken ) Obtaining NTokens The domain administrator must have already generated a public/private key pair for the service and registered public key in Athenz. The private key must be available on the host where the client will be running. // load private key bytes , err := ioutil . ReadFile ( privateKeyFile ) if err != nil { log . Fatalln ( err ) } // get token builder instance builder , err := zmssvctoken . NewTokenBuilder ( domain , service , bytes , keyVersion ) if err != nil { log . Fatalln ( err ) } // set optional attributes builder . SetExpiration ( 60 * time . Minute ) tok := builder . Token () // get a token for use ntoken , err := tok . Value () Once we have our ntoken value, the http client before contacting the provider service needs to add it as the value for the Athenz-Principal-Auth header: req , err := http . NewRequest ( GET , http://recommend-host/rec/v1/movie , nil ) // ... req . Header . Add ( Athenz-Principal-Auth , ntoken ) Build Go zms_svctoken Client Utility To download, compile and install zms_svctoken utility, execute the following command: $ go get github.com/yahoo/athenz/utils/zms-svctoken/... Server Changes The full server source code is available from: https://github.com/yahoo/athenz/tree/master/examples/go/centralized-use-case/server Server Import Dependency Update First you need to update your go client to import the zms client library. import ( github.com/yahoo/athenz/clients/go/zms ) Authorization Checks Before any authorization calls, we're going to check to make sure our request contains the Athenz principal token: const authHeader = Athenz-Principal-Auth func movieHandler ( w http . ResponseWriter , r * http . Request ) { // first let s verify that we have an ntoken if r . Header [ authHeader ] == nil { http . Error ( w , 403 - Missing NToken , 403 ) return } ... } } Next, the most important part is to determine the resource and action based on the given http request. Since we have a separate handler for each endpoint: http . HandleFunc ( /rec/v1/movie , movieHandler ) http . HandleFunc ( /rec/v1/tvshow , tvshowHandler ) each function knows exactly what the resource and the action is. Finally, we are going to contact ZMS for the authorization check. func movieHandler ( w http . ResponseWriter , r * http . Request ) { ... // let s generate our resource value which is the // provider domain : entity value resource := providerDomain + :rec.movie // let s check with ZMS if the principal is authorized if ! authorizeRequest ( r . Header [ authHeader ][ 0 ], resource , read ) { http . Error ( w , 403 - Unauthorized access , 403 ) return } io . WriteString ( w , Name: Slap Shot; Director: George Roy Hill\\n ) } func authorizeRequest ( ntoken , resource , action string ) bool { // for our test example we re just going to skip // validating self-signed certificates tr := http . Transport {} config := tls . Config {} config . InsecureSkipVerify = true tr . TLSClientConfig = config zmsClient := zms . ZMSClient { URL : zmsUrl , Transport : tr , } zmsClient . AddCredentials ( authHeader , ntoken ) access , err := zmsClient . GetAccess ( zms . ActionName ( action ), zms . ResourceName ( resource ), , ) if err != nil { fmt . Println ( Unable to verify access: %v , err ) return false } return access . Granted } Build Server Checkout and build the server component: $ go get github.com/yahoo/athenz/examples/go/centralized-use-case/server Deploying Example Server To run the Go server, you just need to specify the ZMS Server url. The server listens on port 8080: $ recommend -zms https:// zms-server :4443/zms/v1 Test Cases Run the following test cases to verify authorization access for specific services. We're running our go server on the local box so we're using localhost as the hostname. The zms_svctoken utility should already be built and installed on your host. cd to the directory that includes the private keys for the test services we created in the section Athenz Management Setup above. Invalid Access Without ServiceToken For this test case we'll just use the curl client directly: $ curl http://localhost:8080/rec/v1/movie 403 - Missing NToken Movie Editor Access Movie service can successfully access /rec/v1/movie endpoint. So let's first generate an NToken for this service and then contact our server: $ export NTOKEN = ` zms_svctoken -domain editors -service movie -private-key movie_private.pem -key-version v0 ` $ curl -H Athenz-Principal-Auth: $NTOKEN http://localhost:8080/rec/v1/movie Name: Slap Shot ; Director: George Roy Hill Movie service does not have access to /rec/v1/tvshow endpoint: $ export NTOKEN = ` zms_svctoken -domain editors -service movie -private-key movie_private.pem -key-version v0 ` $ curl -H Athenz-Principal-Auth: $NTOKEN http://localhost:8080/rec/v1/tvshow 403 - Unauthorized access TvShow Editor Access TvShow service can successfully access /rec/v1/tvshow endpoint. So let's first generate an NToken for this service and then contact our server: $ export NTOKEN = ` zms_svctoken -domain editors -service tvshow -private-key tvshow_private.pem -key-version v0 ` $ curl -H Athenz-Principal-Auth: $NTOKEN http://localhost:8080/rec/v1/tvshow Name: Middle ; Channel: ABC TvShow service does not have access to /rec/v1/movie endpoint: $ export NTOKEN = ` zms_svctoken -domain editors -service tvshow -private-key tvshow_private.pem -key-version v0 ` $ curl -H Athenz-Principal-Auth: $NTOKEN http://localhost:8080/rec/v1/movie 403 - Unauthorized access Site Editor Access Site service has access to both /rec/v1/tvshow and /rec/v1/movie endpoints: $ export NTOKEN = ` zms_svctoken -domain editors -service site -private-key site_private.pem -key-version v0 ` $ curl -H Athenz-Principal-Auth: $NTOKEN http://localhost:8080/rec/v1/movie Name: Slap Shot ; Director: George Roy Hill $ curl -H Athenz-Principal-Auth: $NTOKEN http://localhost:8080/rec/v1/tvshow Name: Middle ; Channel: ABC Other Test Cases Now you can modify the movie_editos, tvshow_editors, and site_editors roles in the recommend domain to add and remove the defined services and then run the corresponding test cases to verify your access change.","title":"Go Client/Server Example"},{"location":"example_go_centralized_access/#go-clientserver-example-centralized-access-control","text":"Required Components Service Definition Resource Definition Athenz Management Setup Code Changes Client Changes Client Import Dependency Update Obtaining NTokens Build Go zms_svctoken Client Utility Servlet Changes Servlet Project Dependency Update Authorization Checks Build Servlet Deploying Example Servlet Test Cases Invalid Access Without ServiceToken Movie Editor Access TvShow Editor Access Site Editor Access Other Test Cases In the centralized access control model, the service as a principal requests its NToken from SIA Provider and then presents it to the target service which would perform an identical check with ZMS to confirm access. The required steps to setup the environment for provider and tenant services to support centralized access control are as follows: System administrator creates the provider and tenant domains. Tenant Domain administrator generates a public/private key pair and registers a service in its domain. Provider Domain administrator creates a role and policy that grants access to the given role with configured action and resource. Provider Domain administrator adds the Tenant Service to the role to grant access. Tenant Domain administrator installs the private key on the host that will be running the client/tenant service.","title":"Go Client/Server Example - Centralized Access Control"},{"location":"example_go_centralized_access/#required-components","text":"To support centralized access control in your applications, you only need to install and configure the Athenz ZMS server along with the Athenz UI. Please follow these guides to make sure you have both of those components up and running in your environment: ZMS Server UI Server To build the client and server components of this example, you need to download and install Go and Git client if you don't already have these available on your box: The Go Programming Language Git client Make sure your GOPATH variable is set and the PATH variable includes the $(GOPATH)/bin to run the utilities.","title":"Required Components"},{"location":"example_go_centralized_access/#service-definition","text":"Let's first define our service that needs to be Athenz protected. We have a simple recommendation service that returns either a movie or tv show for the caller. It has two endpoints: GET /rec/v1/movie GET /rec/v1/tvshow So in this first release we just want to protect access to these endpoints. The traffic is very low - we only expect a couple of requests an hour so we have decided to use Athenz' centralized authorization model.","title":"Service Definition"},{"location":"example_go_centralized_access/#resource-definition","text":"Defining resources and actions the principals are authorized to execute is one of the most important tasks in the authorization process. Based on our endpoints, it's expected that we'll have 2 general resources: movie tvshow The resources are referenced in their own domain namespace. So those are valid if your domain is specifically created to support this recommendation service only. But's lets assume we might add rental support later, so we need to make sure the policies are based on service specific resources. So we'll define our resources as: rec.movie rec.tvshow Support action for these resources would be read . We can extend our authorization policies later on if we need to introduce other actions - such as write or list as we add more functionality into our service.","title":"Resource Definition"},{"location":"example_go_centralized_access/#athenz-management-setup","text":"Once we have defined what our resources and actions are, we can create their respective client and server (also commonly referred as tenant and provider) roles and policies in Athenz. Go to Athenz UI and login with your account which should have system administrator access. Follow the instructions in the following guide to setup the required access control: Access Control Setup","title":"Athenz Management Setup"},{"location":"example_go_centralized_access/#code-changes","text":"Both the client and server implementors need to make changes in their respective code bases to support centralized authorization checks. The client needs to make sure to submit its service identity as part of its request, while the service needs to carry out the authorization check based on that service identity to determine if it request should be processed or not.","title":"Code Changes"},{"location":"example_go_centralized_access/#client-changes","text":"While we'll use the curl client to make the http calls to our example service, we provide a sample client code that utilizes our zmssvctoken go library to generate service identity tokens. The full client source code is available from: https://github.com/yahoo/athenz/blob/master/utils/zms-svctoken/zms-svctoken.go","title":"Client Changes"},{"location":"example_go_centralized_access/#client-import-dependency-update","text":"First you need to update your go client to import the zms service token library. import ( github.com/yahoo/athenz/libs/go/zmssvctoken )","title":"Client Import Dependency Update"},{"location":"example_go_centralized_access/#obtaining-ntokens","text":"The domain administrator must have already generated a public/private key pair for the service and registered public key in Athenz. The private key must be available on the host where the client will be running. // load private key bytes , err := ioutil . ReadFile ( privateKeyFile ) if err != nil { log . Fatalln ( err ) } // get token builder instance builder , err := zmssvctoken . NewTokenBuilder ( domain , service , bytes , keyVersion ) if err != nil { log . Fatalln ( err ) } // set optional attributes builder . SetExpiration ( 60 * time . Minute ) tok := builder . Token () // get a token for use ntoken , err := tok . Value () Once we have our ntoken value, the http client before contacting the provider service needs to add it as the value for the Athenz-Principal-Auth header: req , err := http . NewRequest ( GET , http://recommend-host/rec/v1/movie , nil ) // ... req . Header . Add ( Athenz-Principal-Auth , ntoken )","title":"Obtaining NTokens"},{"location":"example_go_centralized_access/#build-go-zms_svctoken-client-utility","text":"To download, compile and install zms_svctoken utility, execute the following command: $ go get github.com/yahoo/athenz/utils/zms-svctoken/...","title":"Build Go zms_svctoken Client Utility"},{"location":"example_go_centralized_access/#server-changes","text":"The full server source code is available from: https://github.com/yahoo/athenz/tree/master/examples/go/centralized-use-case/server","title":"Server Changes"},{"location":"example_go_centralized_access/#server-import-dependency-update","text":"First you need to update your go client to import the zms client library. import ( github.com/yahoo/athenz/clients/go/zms )","title":"Server Import Dependency Update"},{"location":"example_go_centralized_access/#authorization-checks","text":"Before any authorization calls, we're going to check to make sure our request contains the Athenz principal token: const authHeader = Athenz-Principal-Auth func movieHandler ( w http . ResponseWriter , r * http . Request ) { // first let s verify that we have an ntoken if r . Header [ authHeader ] == nil { http . Error ( w , 403 - Missing NToken , 403 ) return } ... } } Next, the most important part is to determine the resource and action based on the given http request. Since we have a separate handler for each endpoint: http . HandleFunc ( /rec/v1/movie , movieHandler ) http . HandleFunc ( /rec/v1/tvshow , tvshowHandler ) each function knows exactly what the resource and the action is. Finally, we are going to contact ZMS for the authorization check. func movieHandler ( w http . ResponseWriter , r * http . Request ) { ... // let s generate our resource value which is the // provider domain : entity value resource := providerDomain + :rec.movie // let s check with ZMS if the principal is authorized if ! authorizeRequest ( r . Header [ authHeader ][ 0 ], resource , read ) { http . Error ( w , 403 - Unauthorized access , 403 ) return } io . WriteString ( w , Name: Slap Shot; Director: George Roy Hill\\n ) } func authorizeRequest ( ntoken , resource , action string ) bool { // for our test example we re just going to skip // validating self-signed certificates tr := http . Transport {} config := tls . Config {} config . InsecureSkipVerify = true tr . TLSClientConfig = config zmsClient := zms . ZMSClient { URL : zmsUrl , Transport : tr , } zmsClient . AddCredentials ( authHeader , ntoken ) access , err := zmsClient . GetAccess ( zms . ActionName ( action ), zms . ResourceName ( resource ), , ) if err != nil { fmt . Println ( Unable to verify access: %v , err ) return false } return access . Granted }","title":"Authorization Checks"},{"location":"example_go_centralized_access/#build-server","text":"Checkout and build the server component: $ go get github.com/yahoo/athenz/examples/go/centralized-use-case/server","title":"Build Server"},{"location":"example_go_centralized_access/#deploying-example-server","text":"To run the Go server, you just need to specify the ZMS Server url. The server listens on port 8080: $ recommend -zms https:// zms-server :4443/zms/v1","title":"Deploying Example Server"},{"location":"example_go_centralized_access/#test-cases","text":"Run the following test cases to verify authorization access for specific services. We're running our go server on the local box so we're using localhost as the hostname. The zms_svctoken utility should already be built and installed on your host. cd to the directory that includes the private keys for the test services we created in the section Athenz Management Setup above.","title":"Test Cases"},{"location":"example_go_centralized_access/#invalid-access-without-servicetoken","text":"For this test case we'll just use the curl client directly: $ curl http://localhost:8080/rec/v1/movie 403 - Missing NToken","title":"Invalid Access Without ServiceToken"},{"location":"example_go_centralized_access/#movie-editor-access","text":"Movie service can successfully access /rec/v1/movie endpoint. So let's first generate an NToken for this service and then contact our server: $ export NTOKEN = ` zms_svctoken -domain editors -service movie -private-key movie_private.pem -key-version v0 ` $ curl -H Athenz-Principal-Auth: $NTOKEN http://localhost:8080/rec/v1/movie Name: Slap Shot ; Director: George Roy Hill Movie service does not have access to /rec/v1/tvshow endpoint: $ export NTOKEN = ` zms_svctoken -domain editors -service movie -private-key movie_private.pem -key-version v0 ` $ curl -H Athenz-Principal-Auth: $NTOKEN http://localhost:8080/rec/v1/tvshow 403 - Unauthorized access","title":"Movie Editor Access"},{"location":"example_go_centralized_access/#tvshow-editor-access","text":"TvShow service can successfully access /rec/v1/tvshow endpoint. So let's first generate an NToken for this service and then contact our server: $ export NTOKEN = ` zms_svctoken -domain editors -service tvshow -private-key tvshow_private.pem -key-version v0 ` $ curl -H Athenz-Principal-Auth: $NTOKEN http://localhost:8080/rec/v1/tvshow Name: Middle ; Channel: ABC TvShow service does not have access to /rec/v1/movie endpoint: $ export NTOKEN = ` zms_svctoken -domain editors -service tvshow -private-key tvshow_private.pem -key-version v0 ` $ curl -H Athenz-Principal-Auth: $NTOKEN http://localhost:8080/rec/v1/movie 403 - Unauthorized access","title":"TvShow Editor Access"},{"location":"example_go_centralized_access/#site-editor-access","text":"Site service has access to both /rec/v1/tvshow and /rec/v1/movie endpoints: $ export NTOKEN = ` zms_svctoken -domain editors -service site -private-key site_private.pem -key-version v0 ` $ curl -H Athenz-Principal-Auth: $NTOKEN http://localhost:8080/rec/v1/movie Name: Slap Shot ; Director: George Roy Hill $ curl -H Athenz-Principal-Auth: $NTOKEN http://localhost:8080/rec/v1/tvshow Name: Middle ; Channel: ABC","title":"Site Editor Access"},{"location":"example_go_centralized_access/#other-test-cases","text":"Now you can modify the movie_editos, tvshow_editors, and site_editors roles in the recommend domain to add and remove the defined services and then run the corresponding test cases to verify your access change.","title":"Other Test Cases"},{"location":"example_java_centralized_access/","text":"Java Client/Servlet Example - Centralized Access Control Required Components Service Definition Resource Definition Athenz Management Setup Code Changes Client Changes Client Project Dependency Update Obtaining NTokens from SIA Provider Build Http Client Utility Servlet Changes Servlet Project Dependency Update Authorization Checks Build Servlet Deploying Example Servlet Test Cases Invalid Access Without ServiceToken Movie Editor Access TvShow Editor Access Site Editor Access Other Test Cases In the centralized access control model, the service as a principal requests its NToken from SIA Provider and then presents it to the target service which would perform an identical check with ZMS to confirm access. The required steps to setup the environment for provider and tenant services to support centralized access control are as follows: System administrator creates the provider and tenant domains. Tenant Domain administrator generates a public/private key pair and registers a service in its domain. Provider Domain administrator creates a role and policy that grants access to the given role with configured action and resource. Provider Domain administrator adds the Tenant Service to the role to grant access. Tenant Domain administrator installs the private key on the host that will be running the client/tenant service. Required Components To support centralized access control in your applications, you only need to install and configure the Athenz ZMS server along with the Athenz UI. Please follow these guides to make sure you have both of those components up and running in your environment: ZMS Server UI Server To build the client and servlet components of this example, you need to download and install Oracle JDK 8, Apache Maven and Git client if you don't already have these available on your box: Oracle Java Platform JDK 8 Apache Maven Git client Service Definition Let's first define our service that needs to be Athenz protected. We have a simple recommendation service that returns either a movie or tv show for the caller. It has two endpoints: GET /rec/v1/movie GET /rec/v1/tvshow So in this first release we just want to protect access to these endpoints. The traffic is very low - we only expect a couple of requests an hour so we have decided to use Athenz' centralized authorization model. Resource Definition Defining resources and actions the principals are authorized to execute is one of the most important tasks in the authorization process. Based on our endpoints, it's expected that we'll have 2 general resources: movie tvshow The resources are referenced in their own domain namespace. So those are valid if your domain is specifically created to support this recommendation service only. But's lets assume we might add rental support later, so we need to make sure the policies are based on service specific resources. So we'll define our resources as: rec.movie rec.tvshow Support action for these resources would be read . We can extend our authorization policies later on if we need to introduce other actions - such as write or list as we add more functionality into our service. Athenz Management Setup Once we have defined what our resources and actions are, we can create their respective client and server (also commonly referred as tenant and provider) roles and policies in Athenz. Go to Athenz UI and login with your account which should have system administrator access. Follow the instructions in the following guide to setup the required access control: Access Control Setup Code Changes Both the client and servlet implementors need to make changes in their respective code bases to support centralized authorization checks. The client needs to make sure to submit its service identity as part of its request, while the servlet needs to carry out the authorization check based on that service identity to determine if it request should be processed or not. Client Changes The full client source code is available from: https://github.com/yahoo/athenz/tree/master/examples/java/centralized-use-case/client Client Project Dependency Update First you need to update your Java project pom.xml file to indicate the dependency on the Athenz auth_core Library. Checkout the Bintray Auth-Core Package Page to make sure you're using the latest release version: dependency groupId com.yahoo.athenz /groupId artifactId athenz-auth-core /artifactId version 1.7.13 /version /dependency repositories repository id bintray-yahoo-maven /id name bintray /name url http://yahoo.bintray.com/maven /url /repository /repositories Obtaining NTokens from SIA Provider The domain administrator must have already generated a public/private key pair for the service and registered public key in Athenz. The private key must be available on the host where the client will be running. // the fields used in the following snippet of code // privateKeyPath - includes the path to the service s private key file // the corresponding public key is already registered in Athenz // domainName - editors // serviceName - movie , tvshow or site // keyId - v0 PrivateKey privateKey = Crypto . loadPrivateKey ( new File ( privateKeyPath )); ServiceIdentityProvider identityProvider = new SimpleServiceIdentityProvider ( domainName , serviceName , privateKey , keyId ); Principal principal = identityProvider . getIdentity ( domainName , serviceName ); Once we have our principal object, then the client before contacting the provider service needs to extract the service identity credentials and include them in the request as the value of Athenz principal header. // set our Athenz credentials. The authority in the principal provides // the header name (Athenz-Principal-Auth) that we must use for credentials // while the principal itself provides the credentials (ntoken). con . setRequestProperty ( principal . getAuthority (). getHeader (), principal . getCredentials ()); Build Http Client Utility Checkout and build the client component: $ git clone https://github.com/yahoo/athenz.git $ cd examples/java/centralized-use-case/client/ $ mvn clean package Verify that the client is built successfully: $ java -cp target/example-java-client-ntoken-1.0.jar com.yahoo.athenz.example.ntoken.HttpExampleClient Missing required options: d, s, p, k, u usage: http-example-client -d,--domain arg domain name -k,--keyid arg key identifier -p,--pkey arg private key path -s,--service arg service name -u,--url arg request url Servlet Changes The full servlet source code is available from: https://github.com/yahoo/athenz/tree/master/examples/java/centralized-use-case/servlet Servlet Project Dependency Update First you need to update your Java project pom.xml file to indicate the dependency on the Athenz ZMS Java Client Library. Checkout the Bintray ZMS Client Package Page to make sure you're using the latest release version: dependency groupId com.yahoo.athenz /groupId artifactId athenz-zms-java-client /artifactId version 1.7.13 /version /dependency repositories repository id bintray-yahoo-maven /id name bintray /name url http://yahoo.bintray.com/maven /url /repository /repositories Authorization Checks Before any authorization calls, we're going to check to make sure our request contains the Athenz principal token: static final String ATHENZ_HEADER = Athenz-Principal-Auth ; protected void doGet ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { // retrieve and verify that our request contains an Athenz // service authentication token String athenzServiceToken = request . getHeader ( ATHENZ_HEADER ); if ( athenzServiceToken == null ) { response . sendError ( 403 , Forbidden - No Athenz ServiceToken provided in request ); return ; } ... } Next, the most important part is to determine the resource and action based on the given http request. protected void doGet ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { ... switch ( reqUri ) { case /movie : responseText = Name: Slap Shot; Director: George Roy Hill ; athenzResource = rec.movie ; athenzAction = read ; break ; case /tvshow : responseText = Name: Middle; Channel: ABC ; athenzResource = rec.tvshow ; athenzAction = read ; break ; default : response . sendError ( 404 , Unknown endpoint ); return ; } ... } Once we have those two values determined, then all that is left is to contact ZMS for the authorization check. protected void doGet ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { ... // carry out the authorization check with the expected resource // and action values try ( ZMSAuthorizer authorizer = new ZMSAuthorizer ( zmsUrl , recommend )) { boolean authorized = authorizer . access ( athenzAction , athenzResource , athenzServiceToken , null ); if (! authorized ) { response . sendError ( 403 , Forbidden - Athenz Authorization Rejected ); return ; } } ... } Build Servlet Checkout and build the servlet component: $ git clone https://github.com/yahoo/athenz.git $ cd examples/java/centralized-use-case/servlet/ $ mvn clean package Deploying Example Servlet Download and install latest Jetty 9.3.x container Copy the athenz-control.war from the servlet/target directory to the Jetty distribution's webapps directory Configure ZMS Server's URL in the expected environment variable: export ZMS_SERVER_URL = https:// zms-server-hostname :4443/zms/v1 If the ZMS Server is running with a self-signed certificate, we need to generate a truststore for the java http client to use when communicating with the ZMS Server. From your ZMS Server installation, copy the zms_cert.pem file from the athenz-zms-X.Y/var/zms_server/certs directory to the jetty's etc subdirectory and execute the following commands: $ keytool -importcert -noprompt -alias zms -keystore zms_truststore.jks -file zms_cert.pem -storepass athenz $ export JAVA_OPTIONS = -Djavax.net.ssl.trustStore = full-path-to-jetty-basedir /etc/zms_truststore.jks Start the Jetty server by running the following command from Jetty's distribution base directory: bin/jetty.sh start Test Cases Run the following test cases to verify authorization access for specific services. We're running jetty server on the local box so we're using localhost as the hostname. Copy the example-java-client-ntoken-1.0.jar file from the client/target directory to the directory that includes the private keys for the test services we created in the section Athenz Management Setup above. Invalid Access Without ServiceToken For this test case we'll just use the curl client directly: $ curl http://localhost:8080/athenz-control/rec/v1/movie html ... title Error 403 Forbidden - No Athenz ServiceToken provided in request /title ... /html Movie Editor Access Movie service can successfully access /rec/v1/movie endpoint: $ java -cp ./example-java-client-ntoken-1.0.jar com.yahoo.athenz.example.ntoken.HttpExampleClient -d editors -s movie -p ./movie_private.pem -k v0 -u http://localhost:8080/athenz-control/rec/v1/movie Successful response: Name: Slap Shot ; Director: George Roy Hill Movie service does not have access to /rec/v1/tvshow endpoint: $ java -cp ./example-java-client-ntoken-1.0.jar com.yahoo.athenz.example.ntoken.HttpExampleClient -d editors -s movie -p ./movie_private.pem -k v0 -u http://localhost:8080/athenz-control/rec/v1/tvshow Request was forbidden - not authorized TvShow Editor Access TvShow service can successfully access /rec/v1/tvshow endpoint: $ java -cp ./example-java-client-ntoken-1.0.jar com.yahoo.athenz.example.ntoken.HttpExampleClient -d editors -s tvshow -p ./tvshow_private.pem -k v0 -u http://localhost:8080/athenz-control/rec/v1/tvshow Successful response: Name: Middle ; Channel: ABC TvShow service does not have access to /rec/v1/movie endpoint: $ java -cp ./example-java-client-ntoken-1.0.jar com.yahoo.athenz.example.ntoken.HttpExampleClient -d editors -s tvshow -p ./tvshow_private.pem -k v0 -u http://localhost:8080/athenz-control/rec/v1/movie Request was forbidden - not authorized Site Editor Access Site service has access to both /rec/v1/tvshow and /rec/v1/movie endpoints: $ java -cp ./example-java-client-ntoken-1.0.jar com.yahoo.athenz.example.ntoken.HttpExampleClient -d editors -s site -p ./site_private.pem -k v0 -u http://localhost:8080/athenz-control/rec/v1/movie Successful response: Name: Slap Shot ; Director: George Roy Hill $ java -cp ./example-java-client-ntoken-1.0.jar com.yahoo.athenz.example.ntoken.HttpExampleClient -d editors -s site -p ./site_private.pem -k v0 -u http://localhost:8080/athenz-control/rec/v1/tvshow Successful response: Name: Middle ; Channel: ABC Other Test Cases Now you can modify the movie_editos, tvshow_editors, and site_editors roles in the recommend domain to add and remove the defined services and then run the corresponding test cases to verify your access change.","title":"Java Client/Servlet Example"},{"location":"example_java_centralized_access/#java-clientservlet-example-centralized-access-control","text":"Required Components Service Definition Resource Definition Athenz Management Setup Code Changes Client Changes Client Project Dependency Update Obtaining NTokens from SIA Provider Build Http Client Utility Servlet Changes Servlet Project Dependency Update Authorization Checks Build Servlet Deploying Example Servlet Test Cases Invalid Access Without ServiceToken Movie Editor Access TvShow Editor Access Site Editor Access Other Test Cases In the centralized access control model, the service as a principal requests its NToken from SIA Provider and then presents it to the target service which would perform an identical check with ZMS to confirm access. The required steps to setup the environment for provider and tenant services to support centralized access control are as follows: System administrator creates the provider and tenant domains. Tenant Domain administrator generates a public/private key pair and registers a service in its domain. Provider Domain administrator creates a role and policy that grants access to the given role with configured action and resource. Provider Domain administrator adds the Tenant Service to the role to grant access. Tenant Domain administrator installs the private key on the host that will be running the client/tenant service.","title":"Java Client/Servlet Example - Centralized Access Control"},{"location":"example_java_centralized_access/#required-components","text":"To support centralized access control in your applications, you only need to install and configure the Athenz ZMS server along with the Athenz UI. Please follow these guides to make sure you have both of those components up and running in your environment: ZMS Server UI Server To build the client and servlet components of this example, you need to download and install Oracle JDK 8, Apache Maven and Git client if you don't already have these available on your box: Oracle Java Platform JDK 8 Apache Maven Git client","title":"Required Components"},{"location":"example_java_centralized_access/#service-definition","text":"Let's first define our service that needs to be Athenz protected. We have a simple recommendation service that returns either a movie or tv show for the caller. It has two endpoints: GET /rec/v1/movie GET /rec/v1/tvshow So in this first release we just want to protect access to these endpoints. The traffic is very low - we only expect a couple of requests an hour so we have decided to use Athenz' centralized authorization model.","title":"Service Definition"},{"location":"example_java_centralized_access/#resource-definition","text":"Defining resources and actions the principals are authorized to execute is one of the most important tasks in the authorization process. Based on our endpoints, it's expected that we'll have 2 general resources: movie tvshow The resources are referenced in their own domain namespace. So those are valid if your domain is specifically created to support this recommendation service only. But's lets assume we might add rental support later, so we need to make sure the policies are based on service specific resources. So we'll define our resources as: rec.movie rec.tvshow Support action for these resources would be read . We can extend our authorization policies later on if we need to introduce other actions - such as write or list as we add more functionality into our service.","title":"Resource Definition"},{"location":"example_java_centralized_access/#athenz-management-setup","text":"Once we have defined what our resources and actions are, we can create their respective client and server (also commonly referred as tenant and provider) roles and policies in Athenz. Go to Athenz UI and login with your account which should have system administrator access. Follow the instructions in the following guide to setup the required access control: Access Control Setup","title":"Athenz Management Setup"},{"location":"example_java_centralized_access/#code-changes","text":"Both the client and servlet implementors need to make changes in their respective code bases to support centralized authorization checks. The client needs to make sure to submit its service identity as part of its request, while the servlet needs to carry out the authorization check based on that service identity to determine if it request should be processed or not.","title":"Code Changes"},{"location":"example_java_centralized_access/#client-changes","text":"The full client source code is available from: https://github.com/yahoo/athenz/tree/master/examples/java/centralized-use-case/client","title":"Client Changes"},{"location":"example_java_centralized_access/#client-project-dependency-update","text":"First you need to update your Java project pom.xml file to indicate the dependency on the Athenz auth_core Library. Checkout the Bintray Auth-Core Package Page to make sure you're using the latest release version: dependency groupId com.yahoo.athenz /groupId artifactId athenz-auth-core /artifactId version 1.7.13 /version /dependency repositories repository id bintray-yahoo-maven /id name bintray /name url http://yahoo.bintray.com/maven /url /repository /repositories","title":"Client Project Dependency Update"},{"location":"example_java_centralized_access/#obtaining-ntokens-from-sia-provider","text":"The domain administrator must have already generated a public/private key pair for the service and registered public key in Athenz. The private key must be available on the host where the client will be running. // the fields used in the following snippet of code // privateKeyPath - includes the path to the service s private key file // the corresponding public key is already registered in Athenz // domainName - editors // serviceName - movie , tvshow or site // keyId - v0 PrivateKey privateKey = Crypto . loadPrivateKey ( new File ( privateKeyPath )); ServiceIdentityProvider identityProvider = new SimpleServiceIdentityProvider ( domainName , serviceName , privateKey , keyId ); Principal principal = identityProvider . getIdentity ( domainName , serviceName ); Once we have our principal object, then the client before contacting the provider service needs to extract the service identity credentials and include them in the request as the value of Athenz principal header. // set our Athenz credentials. The authority in the principal provides // the header name (Athenz-Principal-Auth) that we must use for credentials // while the principal itself provides the credentials (ntoken). con . setRequestProperty ( principal . getAuthority (). getHeader (), principal . getCredentials ());","title":"Obtaining NTokens from SIA Provider"},{"location":"example_java_centralized_access/#build-http-client-utility","text":"Checkout and build the client component: $ git clone https://github.com/yahoo/athenz.git $ cd examples/java/centralized-use-case/client/ $ mvn clean package Verify that the client is built successfully: $ java -cp target/example-java-client-ntoken-1.0.jar com.yahoo.athenz.example.ntoken.HttpExampleClient Missing required options: d, s, p, k, u usage: http-example-client -d,--domain arg domain name -k,--keyid arg key identifier -p,--pkey arg private key path -s,--service arg service name -u,--url arg request url","title":"Build Http Client Utility"},{"location":"example_java_centralized_access/#servlet-changes","text":"The full servlet source code is available from: https://github.com/yahoo/athenz/tree/master/examples/java/centralized-use-case/servlet","title":"Servlet Changes"},{"location":"example_java_centralized_access/#servlet-project-dependency-update","text":"First you need to update your Java project pom.xml file to indicate the dependency on the Athenz ZMS Java Client Library. Checkout the Bintray ZMS Client Package Page to make sure you're using the latest release version: dependency groupId com.yahoo.athenz /groupId artifactId athenz-zms-java-client /artifactId version 1.7.13 /version /dependency repositories repository id bintray-yahoo-maven /id name bintray /name url http://yahoo.bintray.com/maven /url /repository /repositories","title":"Servlet Project Dependency Update"},{"location":"example_java_centralized_access/#authorization-checks","text":"Before any authorization calls, we're going to check to make sure our request contains the Athenz principal token: static final String ATHENZ_HEADER = Athenz-Principal-Auth ; protected void doGet ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { // retrieve and verify that our request contains an Athenz // service authentication token String athenzServiceToken = request . getHeader ( ATHENZ_HEADER ); if ( athenzServiceToken == null ) { response . sendError ( 403 , Forbidden - No Athenz ServiceToken provided in request ); return ; } ... } Next, the most important part is to determine the resource and action based on the given http request. protected void doGet ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { ... switch ( reqUri ) { case /movie : responseText = Name: Slap Shot; Director: George Roy Hill ; athenzResource = rec.movie ; athenzAction = read ; break ; case /tvshow : responseText = Name: Middle; Channel: ABC ; athenzResource = rec.tvshow ; athenzAction = read ; break ; default : response . sendError ( 404 , Unknown endpoint ); return ; } ... } Once we have those two values determined, then all that is left is to contact ZMS for the authorization check. protected void doGet ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { ... // carry out the authorization check with the expected resource // and action values try ( ZMSAuthorizer authorizer = new ZMSAuthorizer ( zmsUrl , recommend )) { boolean authorized = authorizer . access ( athenzAction , athenzResource , athenzServiceToken , null ); if (! authorized ) { response . sendError ( 403 , Forbidden - Athenz Authorization Rejected ); return ; } } ... }","title":"Authorization Checks"},{"location":"example_java_centralized_access/#build-servlet","text":"Checkout and build the servlet component: $ git clone https://github.com/yahoo/athenz.git $ cd examples/java/centralized-use-case/servlet/ $ mvn clean package","title":"Build Servlet"},{"location":"example_java_centralized_access/#deploying-example-servlet","text":"Download and install latest Jetty 9.3.x container Copy the athenz-control.war from the servlet/target directory to the Jetty distribution's webapps directory Configure ZMS Server's URL in the expected environment variable: export ZMS_SERVER_URL = https:// zms-server-hostname :4443/zms/v1 If the ZMS Server is running with a self-signed certificate, we need to generate a truststore for the java http client to use when communicating with the ZMS Server. From your ZMS Server installation, copy the zms_cert.pem file from the athenz-zms-X.Y/var/zms_server/certs directory to the jetty's etc subdirectory and execute the following commands: $ keytool -importcert -noprompt -alias zms -keystore zms_truststore.jks -file zms_cert.pem -storepass athenz $ export JAVA_OPTIONS = -Djavax.net.ssl.trustStore = full-path-to-jetty-basedir /etc/zms_truststore.jks Start the Jetty server by running the following command from Jetty's distribution base directory: bin/jetty.sh start","title":"Deploying Example Servlet"},{"location":"example_java_centralized_access/#test-cases","text":"Run the following test cases to verify authorization access for specific services. We're running jetty server on the local box so we're using localhost as the hostname. Copy the example-java-client-ntoken-1.0.jar file from the client/target directory to the directory that includes the private keys for the test services we created in the section Athenz Management Setup above.","title":"Test Cases"},{"location":"example_java_centralized_access/#invalid-access-without-servicetoken","text":"For this test case we'll just use the curl client directly: $ curl http://localhost:8080/athenz-control/rec/v1/movie html ... title Error 403 Forbidden - No Athenz ServiceToken provided in request /title ... /html","title":"Invalid Access Without ServiceToken"},{"location":"example_java_centralized_access/#movie-editor-access","text":"Movie service can successfully access /rec/v1/movie endpoint: $ java -cp ./example-java-client-ntoken-1.0.jar com.yahoo.athenz.example.ntoken.HttpExampleClient -d editors -s movie -p ./movie_private.pem -k v0 -u http://localhost:8080/athenz-control/rec/v1/movie Successful response: Name: Slap Shot ; Director: George Roy Hill Movie service does not have access to /rec/v1/tvshow endpoint: $ java -cp ./example-java-client-ntoken-1.0.jar com.yahoo.athenz.example.ntoken.HttpExampleClient -d editors -s movie -p ./movie_private.pem -k v0 -u http://localhost:8080/athenz-control/rec/v1/tvshow Request was forbidden - not authorized","title":"Movie Editor Access"},{"location":"example_java_centralized_access/#tvshow-editor-access","text":"TvShow service can successfully access /rec/v1/tvshow endpoint: $ java -cp ./example-java-client-ntoken-1.0.jar com.yahoo.athenz.example.ntoken.HttpExampleClient -d editors -s tvshow -p ./tvshow_private.pem -k v0 -u http://localhost:8080/athenz-control/rec/v1/tvshow Successful response: Name: Middle ; Channel: ABC TvShow service does not have access to /rec/v1/movie endpoint: $ java -cp ./example-java-client-ntoken-1.0.jar com.yahoo.athenz.example.ntoken.HttpExampleClient -d editors -s tvshow -p ./tvshow_private.pem -k v0 -u http://localhost:8080/athenz-control/rec/v1/movie Request was forbidden - not authorized","title":"TvShow Editor Access"},{"location":"example_java_centralized_access/#site-editor-access","text":"Site service has access to both /rec/v1/tvshow and /rec/v1/movie endpoints: $ java -cp ./example-java-client-ntoken-1.0.jar com.yahoo.athenz.example.ntoken.HttpExampleClient -d editors -s site -p ./site_private.pem -k v0 -u http://localhost:8080/athenz-control/rec/v1/movie Successful response: Name: Slap Shot ; Director: George Roy Hill $ java -cp ./example-java-client-ntoken-1.0.jar com.yahoo.athenz.example.ntoken.HttpExampleClient -d editors -s site -p ./site_private.pem -k v0 -u http://localhost:8080/athenz-control/rec/v1/tvshow Successful response: Name: Middle ; Channel: ABC","title":"Site Editor Access"},{"location":"example_java_centralized_access/#other-test-cases","text":"Now you can modify the movie_editos, tvshow_editors, and site_editors roles in the recommend domain to add and remove the defined services and then run the corresponding test cases to verify your access change.","title":"Other Test Cases"},{"location":"example_java_decentralized_access/","text":"Java Client/Servlet Example - Decentralized Access Control Required Components Service Definition Resource Definition Athenz Management Setup Client (Tenant) Domain Movie Editors TvShow Editors Site Editors Service View Server (Provider) Domain Authorization Roles and Policies Movie Access TvShow Access Full Access Code Changes Client Changes Client Project Dependency Update Obtaining ZTokens from ZTS Server Build Http Client Utility Servlet Changes Servlet Project Dependency Update Authorization Checks Build Servlet Deploying Example Servlet Test Cases Invalid Access Without RoleToken Movie Editor Access TvShow Editor Access Site Editor Access Other Test Cases In the decentralized access control model, the client service/user presents an authentication token (NToken) from SIA Provider to get an authorization token (ZToken) from ZTS, and then presents the ZToken to a target service to access its resources. The required steps to setup the environment for provider and tenant services to support decentralized access control are as follows: System administrator creates the provider and tenant domains. Tenant Domain administrator generates a public/private key pair and registers a service in its domain. Provider Domain administrator creates a role and policy that grants access to the given role with configured action and resource. Provider Domain administrator adds the Tenant Service to the role to grant access. Provider Domain administrator installs Athenz Policy Engine Updater (ZPU) on the hosts that will be running the provider service. ZPU must be configured with the provider domain name and setup to run as a cron job to periodically download the latest policy files for the server/provider domain. Tenant Domain administrator installs the private key on the host that will be running the client/tenant service. Required Components To support centralized access control in your applications, you only need to install and configure all Athenz components: ZMS and ZTS servers along with the Athenz UI. ZPE Policy updater needs to be install on the target service host. Please follow these guides to make sure you have all of these components up and running in your environment: ZMS Server ZTS Server UI Server On the provider service's host only install ZPU: ZPU Utility To build the client and servlet components of this example, you need to download and install Oracle JDK 8, Apache Maven and Git client if you don't already have these available on your box: Oracle Java Platform JDK 8 Apache Maven Git client Service Definition Let's first define our service that needs to be Athenz protected. We have a simple recommendation service that returns either a movie or tv show for the caller. It has two endpoints: GET /rec/v1/movie GET /rec/v1/tvshow So in this first release we just want to protect access to these endpoints. We're going to get large number of requests per second so contacting ZMS server for centralized authorization checks is not an option. Instead, we have decided to use Athenz' decentralized authorization model. Resource Definition Defining resources and actions the principals are authorized to execute is one of the most important tasks in the authorization process. Based on our endpoints, it's expected that we'll have 2 general resources: movie tvshow The resources are referenced in their own domain namespace. So those are valid if your domain is specifically created to support this recommendation service only. But's lets assume we might add rental support later, so we need to make sure the policies are based on service specific resources. So we'll define our resources as: rec.movie rec.tvshow Support action for these resources would be read . We can extend our authorization policies later on if we need to introduce other actions - such as write or list as we add more functionality into our service. Athenz Management Setup Once we have defined what our resources and actions are, we can create their respective client and server (also commonly referred as tenant and provider) roles and policies in Athenz. Go to Athenz UI and login with your account which should have system administrator access. Follow the instructions in the following guide to setup the required access control: Access Control Setup Code Changes Both the client and servlet implementors need to make changes in their respective code bases to support decentralized authorization checks. The client needs to make sure to retrieve its role token from ZTS Service and submit that as part of its request, while the servlet needs to carry out the authorization check based on that role token to determine if it request should be processed or not. Client Changes The full client source code is available from: https://github.com/yahoo/athenz/tree/master/examples/java/decentralized-use-case/client Client Project Dependency Update First you need to update your Java project pom.xml file to indicate the dependency on the Athenz auth_core and zts java client libraries. Checkout the Bintray Auth-Core Package and Bintray ZTS Java Client Package pages to make sure you're using the latest release version: dependency groupId com.yahoo.athenz /groupId artifactId athenz-auth-core /artifactId version 1.7.13 /version /dependency dependency groupId com.yahoo.athenz /groupId artifactId athenz-zts-java-client /artifactId version 1.7.13 /version /dependency repositories repository id bintray-yahoo-maven /id name bintray /name url http://yahoo.bintray.com/maven /url /repository /repositories Obtaining ZTokens from ZTS Server The domain administrator must have already generated a public/private key pair for the service and registered public key in Athenz. The private key must be available on the host where the client will be running. First, we need generate our service identity provider: // the fields used in the following snippet of code // privateKeyPath - includes the path to the service s private key file // the corresponding public key is already registered in Athenz // domainName - editors // serviceName - movie , tvshow or site // keyId - v0 PrivateKey privateKey = Crypto . loadPrivateKey ( new File ( privateKeyPath )); ServiceIdentityProvider identityProvider = new SimpleServiceIdentityProvider ( domainName , serviceName , privateKey , keyId ); Then, we need to contact ZTS Server to retrieve a role token for the given service identity (provided by the ServiceIdentityProvider) accessing a target service domain: // the fields used in the following snippet of code // ztsUrl - ZTS Server Url // domainName - editors // serviceName - movie , tvshow or site // identityProvider - service identity provider created above // providerDomain - recommend // providerRole - movie_editors, tvshow_editors, full_access RoleToken roleToken = null ; try ( ZTSClient ztsClient = new ZTSClient ( ztsUrl , domainName , serviceName , identityProvider )) { roleToken = ztsClient . getRoleToken ( providerDomain , providerRole ); } Once we have our RoleToken object, then the client before contacting the provider service needs to include the retrieved token in the request as the value of Athenz-Role-Auth header. // set our Athenz credentials. The ZTSClient provides the header // name that we must use for authorization token while the role // token itself provides the token string (ztoken). con . setRequestProperty ( ZTSClient . getHeader (), roleToken . getToken ()); Build Http Client Utility Checkout and build the client component: $ git clone https://github.com/yahoo/athenz.git $ cd examples/java/decentralized-use-case/client/ $ mvn clean package Verify that the client is built successfully: $ java -cp target/example-java-client-ztoken-1.0.jar com.yahoo.athenz.example.ztoken.HttpExampleClient Missing required options: d, s, p, k, u, z, pd, pr usage: http-example-client -d,--domain arg domain name -k,--keyid arg key identifier -p,--pkey arg private key path -pd,--provider-domain arg Provider domain name -pr,--provider-role arg Provider role name -s,--service arg service name -u,--url arg request url -z,--ztsurl arg ZTS Server url Servlet Changes The full servlet source code is available from: https://github.com/yahoo/athenz/tree/master/examples/java/decentralized-use-case/servlet Servlet Project Dependency Update First you need to update your Java project pom.xml file to indicate the dependency on the Athenz ZPE Java Client Library. Checkout the Bintray ZPE Client Package Page to make sure you're using the latest release version: dependency groupId com.yahoo.athenz /groupId artifactId athenz-zpe-java-client /artifactId version 1.7.13 /version /dependency repositories repository id bintray-yahoo-maven /id name bintray /name url http://yahoo.bintray.com/maven /url /repository /repositories Authorization Checks First, we need to make sure the servlet initialization time, Athenz ZPE Client library is initialized so it can process and load any domain policy documents retrieved by ZPE Policy Updater. public void init () throws ServletException { // initialize Athenz ZPE client which will load // all policy files into memory AuthZpeClient . init (); } Before any authorization calls, we're going to check to make sure our request contains the Athenz role token: static final String ATHENZ_HEADER = Athenz-Role-Auth ; protected void doGet ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { // retrieve and verify that our request contains an Athenz // role authorization token String athenzRoleToken = request . getHeader ( ATHENZ_HEADER ); if ( athenzRoleToken == null ) { response . sendError ( 403 , Forbidden - No Athenz RoleToken provided in request ); return ; } ... } Next, the most important part is to determine the resource and action based on the given http request. protected void doGet ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { ... switch ( reqUri ) { case /movie : responseText = Name: Slap Shot; Director: George Roy Hill ; athenzResource = rec.movie ; athenzAction = read ; break ; case /tvshow : responseText = Name: Middle; Channel: ABC ; athenzResource = rec.tvshow ; athenzAction = read ; break ; default : response . sendError ( 404 , Unknown endpoint ); return ; } ... } Once we have those two values determined, then all that is left is to use ZPE client library for the authorization check. protected void doGet ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { ... // carry out the authorization check with the expected resource // and action values AccessCheckStatus status = AuthZpeClient . allowAccess ( athenzRoleToken , athenzResource , athenzAction ); if ( status != AccessCheckStatus . ALLOW ) { response . sendError ( 403 , Forbidden - Athenz Authorization Rejected ); return ; } ... } Build Servlet Checkout and build the servlet component: $ git clone https://github.com/yahoo/athenz.git $ cd examples/java/decentralized-use-case/servlet/ $ mvn clean package Deploying Example Servlet Download and install latest Jetty 9.3.x container Copy the athenz-data.war from the servlet/target directory to the Jetty distribution's webapps directory Configure ZPU to download the policy documents for domain recommend . $ vi zpu-install-directory /conf/zpe_policy_updater/zpu.conf In the json file, edit the value for the domains field to be set to recommend . Run the zpu utility to retrieve the policy documents from ZTS. $ zpu-directory /bin/zpu_run.sh $ ls -lat zpe-directory /var/zpe/recommend.pol Configure ZPE library to look for the policy file and the athenz.conf files in the expected directory: $ export JAVA_OPTIONS = -Dathenz.zpe.policy_dir= zpu-directory /var/zpe -Dathenz.athenz_conf= zpu-directory /conf/zpe_policy_updater/athenz.conf Start the Jetty server by running the following command from Jetty's distribution base directory: bin/jetty.sh start Test Cases Run the following test cases to verify authorization access for specific services. We're running jetty server on the local box so we're using localhost as the hostname. Copy the example-java-client-ztoken-1.0.jar file from the client/target directory to the directory that includes the private keys for the test services we created in the section Athenz Management Setup above. If the ZTS Server is running with a self-signed certificate, we need to generate a truststore for the java http client to use when communicating with the ZTS Server. From your ZTS Server installation, copy the zts_cert.pem file from the athenz-zts-X.Y/var/zts_server/certs directory into the same directory where the client ztoken utility is saved (previous step) and execute the following commands: $ keytool -importcert -noprompt -alias zts -keystore zts_truststore.jks -file zts_cert.pem -storepass athenz Invalid Access Without RoleToken For this test case we'll just use the curl client directly: $ curl http://localhost:8080/athenz-data/rec/v1/movie html ... title Error 403 Forbidden - No Athenz RoleToken provided in request /title ... /html Movie Editor Access Movie service can successfully access /rec/v1/movie endpoint: $ java -Djavax.net.ssl.trustStore = ./zts_truststore.jks -cp ./example-java-client-ztoken-1.0.jar com.yahoo.athenz.example.ztoken.HttpExampleClient -d editors -s movie -p ./movie_private.pem -k v0 -pd recommend -pr movie_editors -z https:// zts-server :8443/zts/v1 -u http://localhost:8080/athenz-data/rec/v1/movie Successful response: Name: Slap Shot ; Director: George Roy Hill Movie service does not have access to /rec/v1/tvshow endpoint: $ java -Djavax.net.ssl.trustStore = ./zts_truststore.jks -cp ./example-java-client-ztoken-1.0.jar com.yahoo.athenz.example.ztoken.HttpExampleClient -d editors -s movie -p ./movie_private.pem -k v0 -pd recommend -pr movie_editors -z https:// zts-server :8443/zts/v1 -u http://localhost:8080/athenz-data/rec/v1/tvshow Request was forbidden - not authorized TvShow Editor Access TvShow service can successfully access /rec/v1/tvshow endpoint: $ java -Djavax.net.ssl.trustStore = ./zts_truststore.jks -cp ./example-java-client-ztoken-1.0.jar com.yahoo.athenz.example.ztoken.HttpExampleClient -d editors -s tvshow -p ./tvshow_private.pem -k v0 -pd recommend -pr tvshow_editors -z https:// zts-server :8443/zts/v1 -u http://localhost:8080/athenz-data/rec/v1/tvshow Successful response: Name: Middle ; Channel: ABC TvShow service does not have access to /rec/v1/movie endpoint: $ java -Djavax.net.ssl.trustStore = ./zts_truststore.jks -cp ./example-java-client-ztoken-1.0.jar com.yahoo.athenz.example.ztoken.HttpExampleClient -d editors -s tvshow -p ./tvshow_private.pem -k v0 -pd recommend -pr tvshow_editors -z https:// zts-server :8443/zts/v1 -u http://localhost:8080/athenz-data/rec/v1/movie Request was forbidden - not authorized Site Editor Access Site service has access to both /rec/v1/tvshow and /rec/v1/movie endpoints: $ java -Djavax.net.ssl.trustStore = ./zts_truststore.jks -cp ./example-java-client-ztoken-1.0.jar com.yahoo.athenz.example.ztoken.HttpExampleClient -d editors -s site -p ./site_private.pem -k v0 -pd recommend -pr full_access -z https:// zts-server :8443/zts/v1 -u http://localhost:8080/athenz-data/rec/v1/movie Successful response: Name: Slap Shot ; Director: George Roy Hill $ java -Djavax.net.ssl.trustStore = ./zts_truststore.jks -cp ./example-java-client-ztoken-1.0.jar com.yahoo.athenz.example.ztoken.HttpExampleClient -d editors -s site -p ./site_private.pem -k v0 -pd recommend -pr full_access -z https:// zts-server :8443/zts/v1 -u http://localhost:8080/athenz-data/rec/v1/tvshow Successful response: Name: Middle ; Channel: ABC Other Test Cases Now you can modify the movie_editos, tvshow_editors, and site_editors roles in the recommend domain to add and remove the defined services. After you make the changes, it will take about a minute for the updates to propagate from ZMS to the ZTS Server. Then you need to run the zpu_run.sh command again to fetch the updated policy files for the domain onto your host. Then you can run the corresponding test cases to verify your access change.","title":"Java Client/Servlet Example"},{"location":"example_java_decentralized_access/#java-clientservlet-example-decentralized-access-control","text":"Required Components Service Definition Resource Definition Athenz Management Setup Client (Tenant) Domain Movie Editors TvShow Editors Site Editors Service View Server (Provider) Domain Authorization Roles and Policies Movie Access TvShow Access Full Access Code Changes Client Changes Client Project Dependency Update Obtaining ZTokens from ZTS Server Build Http Client Utility Servlet Changes Servlet Project Dependency Update Authorization Checks Build Servlet Deploying Example Servlet Test Cases Invalid Access Without RoleToken Movie Editor Access TvShow Editor Access Site Editor Access Other Test Cases In the decentralized access control model, the client service/user presents an authentication token (NToken) from SIA Provider to get an authorization token (ZToken) from ZTS, and then presents the ZToken to a target service to access its resources. The required steps to setup the environment for provider and tenant services to support decentralized access control are as follows: System administrator creates the provider and tenant domains. Tenant Domain administrator generates a public/private key pair and registers a service in its domain. Provider Domain administrator creates a role and policy that grants access to the given role with configured action and resource. Provider Domain administrator adds the Tenant Service to the role to grant access. Provider Domain administrator installs Athenz Policy Engine Updater (ZPU) on the hosts that will be running the provider service. ZPU must be configured with the provider domain name and setup to run as a cron job to periodically download the latest policy files for the server/provider domain. Tenant Domain administrator installs the private key on the host that will be running the client/tenant service.","title":"Java Client/Servlet Example - Decentralized Access Control"},{"location":"example_java_decentralized_access/#required-components","text":"To support centralized access control in your applications, you only need to install and configure all Athenz components: ZMS and ZTS servers along with the Athenz UI. ZPE Policy updater needs to be install on the target service host. Please follow these guides to make sure you have all of these components up and running in your environment: ZMS Server ZTS Server UI Server On the provider service's host only install ZPU: ZPU Utility To build the client and servlet components of this example, you need to download and install Oracle JDK 8, Apache Maven and Git client if you don't already have these available on your box: Oracle Java Platform JDK 8 Apache Maven Git client","title":"Required Components"},{"location":"example_java_decentralized_access/#service-definition","text":"Let's first define our service that needs to be Athenz protected. We have a simple recommendation service that returns either a movie or tv show for the caller. It has two endpoints: GET /rec/v1/movie GET /rec/v1/tvshow So in this first release we just want to protect access to these endpoints. We're going to get large number of requests per second so contacting ZMS server for centralized authorization checks is not an option. Instead, we have decided to use Athenz' decentralized authorization model.","title":"Service Definition"},{"location":"example_java_decentralized_access/#resource-definition","text":"Defining resources and actions the principals are authorized to execute is one of the most important tasks in the authorization process. Based on our endpoints, it's expected that we'll have 2 general resources: movie tvshow The resources are referenced in their own domain namespace. So those are valid if your domain is specifically created to support this recommendation service only. But's lets assume we might add rental support later, so we need to make sure the policies are based on service specific resources. So we'll define our resources as: rec.movie rec.tvshow Support action for these resources would be read . We can extend our authorization policies later on if we need to introduce other actions - such as write or list as we add more functionality into our service.","title":"Resource Definition"},{"location":"example_java_decentralized_access/#athenz-management-setup","text":"Once we have defined what our resources and actions are, we can create their respective client and server (also commonly referred as tenant and provider) roles and policies in Athenz. Go to Athenz UI and login with your account which should have system administrator access. Follow the instructions in the following guide to setup the required access control: Access Control Setup","title":"Athenz Management Setup"},{"location":"example_java_decentralized_access/#code-changes","text":"Both the client and servlet implementors need to make changes in their respective code bases to support decentralized authorization checks. The client needs to make sure to retrieve its role token from ZTS Service and submit that as part of its request, while the servlet needs to carry out the authorization check based on that role token to determine if it request should be processed or not.","title":"Code Changes"},{"location":"example_java_decentralized_access/#client-changes","text":"The full client source code is available from: https://github.com/yahoo/athenz/tree/master/examples/java/decentralized-use-case/client","title":"Client Changes"},{"location":"example_java_decentralized_access/#client-project-dependency-update","text":"First you need to update your Java project pom.xml file to indicate the dependency on the Athenz auth_core and zts java client libraries. Checkout the Bintray Auth-Core Package and Bintray ZTS Java Client Package pages to make sure you're using the latest release version: dependency groupId com.yahoo.athenz /groupId artifactId athenz-auth-core /artifactId version 1.7.13 /version /dependency dependency groupId com.yahoo.athenz /groupId artifactId athenz-zts-java-client /artifactId version 1.7.13 /version /dependency repositories repository id bintray-yahoo-maven /id name bintray /name url http://yahoo.bintray.com/maven /url /repository /repositories","title":"Client Project Dependency Update"},{"location":"example_java_decentralized_access/#obtaining-ztokens-from-zts-server","text":"The domain administrator must have already generated a public/private key pair for the service and registered public key in Athenz. The private key must be available on the host where the client will be running. First, we need generate our service identity provider: // the fields used in the following snippet of code // privateKeyPath - includes the path to the service s private key file // the corresponding public key is already registered in Athenz // domainName - editors // serviceName - movie , tvshow or site // keyId - v0 PrivateKey privateKey = Crypto . loadPrivateKey ( new File ( privateKeyPath )); ServiceIdentityProvider identityProvider = new SimpleServiceIdentityProvider ( domainName , serviceName , privateKey , keyId ); Then, we need to contact ZTS Server to retrieve a role token for the given service identity (provided by the ServiceIdentityProvider) accessing a target service domain: // the fields used in the following snippet of code // ztsUrl - ZTS Server Url // domainName - editors // serviceName - movie , tvshow or site // identityProvider - service identity provider created above // providerDomain - recommend // providerRole - movie_editors, tvshow_editors, full_access RoleToken roleToken = null ; try ( ZTSClient ztsClient = new ZTSClient ( ztsUrl , domainName , serviceName , identityProvider )) { roleToken = ztsClient . getRoleToken ( providerDomain , providerRole ); } Once we have our RoleToken object, then the client before contacting the provider service needs to include the retrieved token in the request as the value of Athenz-Role-Auth header. // set our Athenz credentials. The ZTSClient provides the header // name that we must use for authorization token while the role // token itself provides the token string (ztoken). con . setRequestProperty ( ZTSClient . getHeader (), roleToken . getToken ());","title":"Obtaining ZTokens from ZTS Server"},{"location":"example_java_decentralized_access/#build-http-client-utility","text":"Checkout and build the client component: $ git clone https://github.com/yahoo/athenz.git $ cd examples/java/decentralized-use-case/client/ $ mvn clean package Verify that the client is built successfully: $ java -cp target/example-java-client-ztoken-1.0.jar com.yahoo.athenz.example.ztoken.HttpExampleClient Missing required options: d, s, p, k, u, z, pd, pr usage: http-example-client -d,--domain arg domain name -k,--keyid arg key identifier -p,--pkey arg private key path -pd,--provider-domain arg Provider domain name -pr,--provider-role arg Provider role name -s,--service arg service name -u,--url arg request url -z,--ztsurl arg ZTS Server url","title":"Build Http Client Utility"},{"location":"example_java_decentralized_access/#servlet-changes","text":"The full servlet source code is available from: https://github.com/yahoo/athenz/tree/master/examples/java/decentralized-use-case/servlet","title":"Servlet Changes"},{"location":"example_java_decentralized_access/#servlet-project-dependency-update","text":"First you need to update your Java project pom.xml file to indicate the dependency on the Athenz ZPE Java Client Library. Checkout the Bintray ZPE Client Package Page to make sure you're using the latest release version: dependency groupId com.yahoo.athenz /groupId artifactId athenz-zpe-java-client /artifactId version 1.7.13 /version /dependency repositories repository id bintray-yahoo-maven /id name bintray /name url http://yahoo.bintray.com/maven /url /repository /repositories","title":"Servlet Project Dependency Update"},{"location":"example_java_decentralized_access/#authorization-checks","text":"First, we need to make sure the servlet initialization time, Athenz ZPE Client library is initialized so it can process and load any domain policy documents retrieved by ZPE Policy Updater. public void init () throws ServletException { // initialize Athenz ZPE client which will load // all policy files into memory AuthZpeClient . init (); } Before any authorization calls, we're going to check to make sure our request contains the Athenz role token: static final String ATHENZ_HEADER = Athenz-Role-Auth ; protected void doGet ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { // retrieve and verify that our request contains an Athenz // role authorization token String athenzRoleToken = request . getHeader ( ATHENZ_HEADER ); if ( athenzRoleToken == null ) { response . sendError ( 403 , Forbidden - No Athenz RoleToken provided in request ); return ; } ... } Next, the most important part is to determine the resource and action based on the given http request. protected void doGet ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { ... switch ( reqUri ) { case /movie : responseText = Name: Slap Shot; Director: George Roy Hill ; athenzResource = rec.movie ; athenzAction = read ; break ; case /tvshow : responseText = Name: Middle; Channel: ABC ; athenzResource = rec.tvshow ; athenzAction = read ; break ; default : response . sendError ( 404 , Unknown endpoint ); return ; } ... } Once we have those two values determined, then all that is left is to use ZPE client library for the authorization check. protected void doGet ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { ... // carry out the authorization check with the expected resource // and action values AccessCheckStatus status = AuthZpeClient . allowAccess ( athenzRoleToken , athenzResource , athenzAction ); if ( status != AccessCheckStatus . ALLOW ) { response . sendError ( 403 , Forbidden - Athenz Authorization Rejected ); return ; } ... }","title":"Authorization Checks"},{"location":"example_java_decentralized_access/#build-servlet","text":"Checkout and build the servlet component: $ git clone https://github.com/yahoo/athenz.git $ cd examples/java/decentralized-use-case/servlet/ $ mvn clean package","title":"Build Servlet"},{"location":"example_java_decentralized_access/#deploying-example-servlet","text":"Download and install latest Jetty 9.3.x container Copy the athenz-data.war from the servlet/target directory to the Jetty distribution's webapps directory Configure ZPU to download the policy documents for domain recommend . $ vi zpu-install-directory /conf/zpe_policy_updater/zpu.conf In the json file, edit the value for the domains field to be set to recommend . Run the zpu utility to retrieve the policy documents from ZTS. $ zpu-directory /bin/zpu_run.sh $ ls -lat zpe-directory /var/zpe/recommend.pol Configure ZPE library to look for the policy file and the athenz.conf files in the expected directory: $ export JAVA_OPTIONS = -Dathenz.zpe.policy_dir= zpu-directory /var/zpe -Dathenz.athenz_conf= zpu-directory /conf/zpe_policy_updater/athenz.conf Start the Jetty server by running the following command from Jetty's distribution base directory: bin/jetty.sh start","title":"Deploying Example Servlet"},{"location":"example_java_decentralized_access/#test-cases","text":"Run the following test cases to verify authorization access for specific services. We're running jetty server on the local box so we're using localhost as the hostname. Copy the example-java-client-ztoken-1.0.jar file from the client/target directory to the directory that includes the private keys for the test services we created in the section Athenz Management Setup above. If the ZTS Server is running with a self-signed certificate, we need to generate a truststore for the java http client to use when communicating with the ZTS Server. From your ZTS Server installation, copy the zts_cert.pem file from the athenz-zts-X.Y/var/zts_server/certs directory into the same directory where the client ztoken utility is saved (previous step) and execute the following commands: $ keytool -importcert -noprompt -alias zts -keystore zts_truststore.jks -file zts_cert.pem -storepass athenz","title":"Test Cases"},{"location":"example_java_decentralized_access/#invalid-access-without-roletoken","text":"For this test case we'll just use the curl client directly: $ curl http://localhost:8080/athenz-data/rec/v1/movie html ... title Error 403 Forbidden - No Athenz RoleToken provided in request /title ... /html","title":"Invalid Access Without RoleToken"},{"location":"example_java_decentralized_access/#movie-editor-access","text":"Movie service can successfully access /rec/v1/movie endpoint: $ java -Djavax.net.ssl.trustStore = ./zts_truststore.jks -cp ./example-java-client-ztoken-1.0.jar com.yahoo.athenz.example.ztoken.HttpExampleClient -d editors -s movie -p ./movie_private.pem -k v0 -pd recommend -pr movie_editors -z https:// zts-server :8443/zts/v1 -u http://localhost:8080/athenz-data/rec/v1/movie Successful response: Name: Slap Shot ; Director: George Roy Hill Movie service does not have access to /rec/v1/tvshow endpoint: $ java -Djavax.net.ssl.trustStore = ./zts_truststore.jks -cp ./example-java-client-ztoken-1.0.jar com.yahoo.athenz.example.ztoken.HttpExampleClient -d editors -s movie -p ./movie_private.pem -k v0 -pd recommend -pr movie_editors -z https:// zts-server :8443/zts/v1 -u http://localhost:8080/athenz-data/rec/v1/tvshow Request was forbidden - not authorized","title":"Movie Editor Access"},{"location":"example_java_decentralized_access/#tvshow-editor-access","text":"TvShow service can successfully access /rec/v1/tvshow endpoint: $ java -Djavax.net.ssl.trustStore = ./zts_truststore.jks -cp ./example-java-client-ztoken-1.0.jar com.yahoo.athenz.example.ztoken.HttpExampleClient -d editors -s tvshow -p ./tvshow_private.pem -k v0 -pd recommend -pr tvshow_editors -z https:// zts-server :8443/zts/v1 -u http://localhost:8080/athenz-data/rec/v1/tvshow Successful response: Name: Middle ; Channel: ABC TvShow service does not have access to /rec/v1/movie endpoint: $ java -Djavax.net.ssl.trustStore = ./zts_truststore.jks -cp ./example-java-client-ztoken-1.0.jar com.yahoo.athenz.example.ztoken.HttpExampleClient -d editors -s tvshow -p ./tvshow_private.pem -k v0 -pd recommend -pr tvshow_editors -z https:// zts-server :8443/zts/v1 -u http://localhost:8080/athenz-data/rec/v1/movie Request was forbidden - not authorized","title":"TvShow Editor Access"},{"location":"example_java_decentralized_access/#site-editor-access","text":"Site service has access to both /rec/v1/tvshow and /rec/v1/movie endpoints: $ java -Djavax.net.ssl.trustStore = ./zts_truststore.jks -cp ./example-java-client-ztoken-1.0.jar com.yahoo.athenz.example.ztoken.HttpExampleClient -d editors -s site -p ./site_private.pem -k v0 -pd recommend -pr full_access -z https:// zts-server :8443/zts/v1 -u http://localhost:8080/athenz-data/rec/v1/movie Successful response: Name: Slap Shot ; Director: George Roy Hill $ java -Djavax.net.ssl.trustStore = ./zts_truststore.jks -cp ./example-java-client-ztoken-1.0.jar com.yahoo.athenz.example.ztoken.HttpExampleClient -d editors -s site -p ./site_private.pem -k v0 -pd recommend -pr full_access -z https:// zts-server :8443/zts/v1 -u http://localhost:8080/athenz-data/rec/v1/tvshow Successful response: Name: Middle ; Channel: ABC","title":"Site Editor Access"},{"location":"example_java_decentralized_access/#other-test-cases","text":"Now you can modify the movie_editos, tvshow_editors, and site_editors roles in the recommend domain to add and remove the defined services. After you make the changes, it will take about a minute for the updates to propagate from ZMS to the ZTS Server. Then you need to run the zpu_run.sh command again to fetch the updated policy files for the domain onto your host. Then you can run the corresponding test cases to verify your access change.","title":"Other Test Cases"},{"location":"example_service_athenz_setup/","text":"Example Service Access Control Setup Client (Tenant) Domain Movie Editors TvShow Editors Site Editors Service View Server (Provider) Domain Authorization Roles and Policies Movie Access TvShow Access Full Access We've decided that our resources for the service will be defined in Athenz as: rec.movie rec.tvshow and the only supported action for now would be read . Now we can create their respective client and server (also commonly referred as tenant and provider) roles and policies in Athenz. Go to Athenz UI and login with your account which should have system administrator access. Client (Tenant) Domain The client services will be defined in the editors domain so let's create that domain and services. Click on the Create a domain link in top left corner to add the domain: Movie Editors Each service is identified by its private/public key pair. The movie service will be authorized to access the /rec/v1/movie endpoint from our recommendation service. So we need to first generate the key pair (at the end we're going to display the contents of the public key since we'll be using that when creating the service in the UI): $ openssl genrsa -out movie_private.pem 2048 $ openssl rsa -in movie_private.pem -pubout movie_public.pem $ cat movie_public.pem Now we need to register the movie service in the editors domain. After you login, click on the editors domain in the left hand tree pane, then choose the Services tab. Click on the Add Service button. In the Key Value field when creating a service, enter the contents of the movie_public.pem file. For the Public Key Id field we'll use v0 . Each service can be identified my multiple key pairs. For example, if you have services running in different geographical data centers, each data center instance can have its own unique public/private key pair. It also allows the service administrator to establish a key rotation policy - e.g. generate a new key pair every 6 months and assign a new key identifier: v0, v1, etc. TvShow Editors The tvshow service will be authorized to access the /rec/v1/tvshow endpoint from our recommendation service. So again, we need to first generate the key pair (at the end we're going to display the contents of the public key since we'll be using that when creating the service in the UI): $ openssl genrsa -out tvshow_private.pem 2048 $ openssl rsa -in tvshow_private.pem -pubout tvshow_public.pem $ cat tvshow_public.pem Now we need to register the tvshow service in the editors domain. After you login, click on the editors domain in the left hand tree pane, then choose the Services tab. Click on the Add Service button. In the Key Value field when creating a service, enter the contents of the tvshow_public.pem file. For the Public Key Id field we'll use v0 . See the Movie Editors section for additional details on this field. Site Editors The site service will be authorized to access both /rec/v1/movie and /rec/v1/tvshow endpoints from our recommendation service. So we need to first generate the key pair (at the end we're going to display the contents of the public key since we'll be using that when creating the service in the UI): $ openssl genrsa -out site_private.pem 2048 $ openssl rsa -in site_private.pem -pubout site_public.pem $ cat site_public.pem Finally, we need to register the site service in the editors domain. After you login, click on the editors domain in the left hand tree pane, then choose the Services tab.Click on the Add Service button. In the Key Value field when creating a service, enter the contents of the site_public.pem file. For the Public Key Id field we'll use v0 . See the Movie Editors section for additional details on this field. Service View Once all three services are successfully registered, you should have the following Services view for the editors domains: Server (Provider) Domain The recommendation service will be run by recommend property. So let's first create this domain in Athenz. Click on the Create a domain link in top left corner to add the domain: Authorization Roles and Policies Typically since we have two resources and only one action supported in this use case, we'll be creating 2 roles that will be providing access control. In this model, if we want one service to have access to both services, we'll need to add that principal to both roles. A slightly different approach would be to create yet another role that provides full access to all recommendation endpoints. Movie Access First we need to create the role that includes principals authorized to access the movie resource. In our example, we'll call this role as movie_editors and include editors.movie service as a member of this role. After you login, click on the recommend domain in the left hand tree pane, then choose the Roles tab. Click on the Add Role button: Now we need to give access to this role with action read to resource rec.movie . Choose the Policies tab and click on the Add Policy button: TvShow Access Now we need to create the role that includes principals authorized to access the tvshow resource. In our example, we'll call this role as tvshow_editors and include editors.tvshow service as a member of this role. After you login, click on the recommend domain in the left hand tree pane, then choose the Roles tab. Click on the Add Role button: Now we need to give access to this role with action read to resource rec.tvshow . Choose the Policies tab and click on the Add Policy button: Full Access Finally, we need to create the role that includes principals authorized to have full access to any resource in our recommendation service. In our example, we'll call this role as full_access and include editors.site service as a member of this role. After you login, click on the recommend domain in the left hand tree pane, then choose the Roles tab. Click on the Add Role button: Now we need to give access to this role with action * to resource rec.* . Since Athenz support glob style wildcards, having * indicates it will match all actions - e.g. read , write , etc. And having the resource as rec.* indicates that it will match rec.movie , rec.tvshow and any other resource that we create with the prefix rec. . Choose the Policies tab and click on the Add Policy button:","title":"Example Service Access Control Setup"},{"location":"example_service_athenz_setup/#example-service-access-control-setup","text":"Client (Tenant) Domain Movie Editors TvShow Editors Site Editors Service View Server (Provider) Domain Authorization Roles and Policies Movie Access TvShow Access Full Access We've decided that our resources for the service will be defined in Athenz as: rec.movie rec.tvshow and the only supported action for now would be read . Now we can create their respective client and server (also commonly referred as tenant and provider) roles and policies in Athenz. Go to Athenz UI and login with your account which should have system administrator access.","title":"Example Service Access Control Setup"},{"location":"example_service_athenz_setup/#client-tenant-domain","text":"The client services will be defined in the editors domain so let's create that domain and services. Click on the Create a domain link in top left corner to add the domain:","title":"Client (Tenant) Domain"},{"location":"example_service_athenz_setup/#movie-editors","text":"Each service is identified by its private/public key pair. The movie service will be authorized to access the /rec/v1/movie endpoint from our recommendation service. So we need to first generate the key pair (at the end we're going to display the contents of the public key since we'll be using that when creating the service in the UI): $ openssl genrsa -out movie_private.pem 2048 $ openssl rsa -in movie_private.pem -pubout movie_public.pem $ cat movie_public.pem Now we need to register the movie service in the editors domain. After you login, click on the editors domain in the left hand tree pane, then choose the Services tab. Click on the Add Service button. In the Key Value field when creating a service, enter the contents of the movie_public.pem file. For the Public Key Id field we'll use v0 . Each service can be identified my multiple key pairs. For example, if you have services running in different geographical data centers, each data center instance can have its own unique public/private key pair. It also allows the service administrator to establish a key rotation policy - e.g. generate a new key pair every 6 months and assign a new key identifier: v0, v1, etc.","title":"Movie Editors"},{"location":"example_service_athenz_setup/#tvshow-editors","text":"The tvshow service will be authorized to access the /rec/v1/tvshow endpoint from our recommendation service. So again, we need to first generate the key pair (at the end we're going to display the contents of the public key since we'll be using that when creating the service in the UI): $ openssl genrsa -out tvshow_private.pem 2048 $ openssl rsa -in tvshow_private.pem -pubout tvshow_public.pem $ cat tvshow_public.pem Now we need to register the tvshow service in the editors domain. After you login, click on the editors domain in the left hand tree pane, then choose the Services tab. Click on the Add Service button. In the Key Value field when creating a service, enter the contents of the tvshow_public.pem file. For the Public Key Id field we'll use v0 . See the Movie Editors section for additional details on this field.","title":"TvShow Editors"},{"location":"example_service_athenz_setup/#site-editors","text":"The site service will be authorized to access both /rec/v1/movie and /rec/v1/tvshow endpoints from our recommendation service. So we need to first generate the key pair (at the end we're going to display the contents of the public key since we'll be using that when creating the service in the UI): $ openssl genrsa -out site_private.pem 2048 $ openssl rsa -in site_private.pem -pubout site_public.pem $ cat site_public.pem Finally, we need to register the site service in the editors domain. After you login, click on the editors domain in the left hand tree pane, then choose the Services tab.Click on the Add Service button. In the Key Value field when creating a service, enter the contents of the site_public.pem file. For the Public Key Id field we'll use v0 . See the Movie Editors section for additional details on this field.","title":"Site Editors"},{"location":"example_service_athenz_setup/#service-view","text":"Once all three services are successfully registered, you should have the following Services view for the editors domains:","title":"Service View"},{"location":"example_service_athenz_setup/#server-provider-domain","text":"The recommendation service will be run by recommend property. So let's first create this domain in Athenz. Click on the Create a domain link in top left corner to add the domain:","title":"Server (Provider) Domain"},{"location":"example_service_athenz_setup/#authorization-roles-and-policies","text":"Typically since we have two resources and only one action supported in this use case, we'll be creating 2 roles that will be providing access control. In this model, if we want one service to have access to both services, we'll need to add that principal to both roles. A slightly different approach would be to create yet another role that provides full access to all recommendation endpoints.","title":"Authorization Roles and Policies"},{"location":"example_service_athenz_setup/#movie-access","text":"First we need to create the role that includes principals authorized to access the movie resource. In our example, we'll call this role as movie_editors and include editors.movie service as a member of this role. After you login, click on the recommend domain in the left hand tree pane, then choose the Roles tab. Click on the Add Role button: Now we need to give access to this role with action read to resource rec.movie . Choose the Policies tab and click on the Add Policy button:","title":"Movie Access"},{"location":"example_service_athenz_setup/#tvshow-access","text":"Now we need to create the role that includes principals authorized to access the tvshow resource. In our example, we'll call this role as tvshow_editors and include editors.tvshow service as a member of this role. After you login, click on the recommend domain in the left hand tree pane, then choose the Roles tab. Click on the Add Role button: Now we need to give access to this role with action read to resource rec.tvshow . Choose the Policies tab and click on the Add Policy button:","title":"TvShow Access"},{"location":"example_service_athenz_setup/#full-access","text":"Finally, we need to create the role that includes principals authorized to have full access to any resource in our recommendation service. In our example, we'll call this role as full_access and include editors.site service as a member of this role. After you login, click on the recommend domain in the left hand tree pane, then choose the Roles tab. Click on the Add Role button: Now we need to give access to this role with action * to resource rec.* . Since Athenz support glob style wildcards, having * indicates it will match all actions - e.g. read , write , etc. And having the resource as rec.* indicates that it will match rec.movie , rec.tvshow and any other resource that we create with the prefix rec. . Choose the Policies tab and click on the Add Policy button:","title":"Full Access"},{"location":"principal_authentication/","text":"Principal Authentication Authority Work Configuration Provided Authorities Unix User Authority Principal Authority Kerberos Authority Certificate Authority Role Authority For a principal (either user or service) to authenticate himself/herself in Athenz, the server must have the appropriate authentication authority implementation configured. Athenz has implementation of several authorities that support variety of authentication methods. The system administrator may decide to configure and use one of the provided authorities or implement a completely new one to satisfy their requirements. Authority Work The job of the Authority is authenticate a specific request and, if valid, generate and return an object representing the authenticated Principal. The Authority interface is defined in the following file: Authority The system administrator can configure a list of authorities for supporting principal authentication. During startup, the server will call the initialize() method for all configured authorities. If the authority requires access to any of the service public keys registered within Athenz, then it needs to implement the AuthorityKeyStore interface as well and provide an implementation of the setKeyStore() method. The server implements the KeyStore interface and will automatically call the setKeyStore() method to pass its implementation to the authority. AuthorityKeyStore When processing a request the server goes through the list of authorities in their configured order and processes until it receives a successful principal object. As soon as a successful response is received from the authenticate method, the server will stop processing other authorities in the list and continue with the authorization check. If no authority returns an authenticated principal, the server returns 401 Unauthenticated response to the calling client. The Authority defines if the authentication details are based on a header or certificate: getCredSource() . If the returned value is HEADER then the Athenz server will retrieve the header, identified by the value returned by the getHeader() method, that the authority is looking for and if a value is present, it will call the authenticate() method to see if the request contains valid credentials or not. The returned principal object contains the Authority object that was used for authentication. This allows the Athenz servers, if necessary, to decide if further checks and/or restrictions are necessary. Configuration Both ZMS and ZTS Servers expect to find the list of authority classes in their respective system properties: ZMS: athenz.zms.authority_classes ZTS: athenz.zts.authority_classes The value of the property must be a comma separated (no spaces) list of authority class names. For example, -Dathenz.zms.authority_classes=com.yahoo.athenz.auth.impl.PrincipalAuthority,com.yahoo.athenz.auth.impl.UserAuthority If you're installing and running Athenz services using the binary packages provided, you can configure the list of authorities in the conf/zms_server/zms.properties or conf/zts_server/zts.properties files for ZMS and ZTS servers respectively: athenz.zms.authority_classes=com.yahoo.athenz.auth.impl.PrincipalAuthority,com.yahoo.athenz.auth.impl.UserAuthority athenz.zts.authority_classes=com.yahoo.athenz.auth.impl.PrincipalAuthority,com.yahoo.athenz.auth.impl.UserAuthority Provided Authorities Here is the list of Athenz provided authorities with brief description of each one. Unix User Authority Class: com.yahoo.athenz.auth.impl.UserAuthority This authority uses the Unix pam login profile to authenticate users. The user that the ZMS process runs as must have read access to the /etc/shadow file. There are two options available: Run the process as root using sudo. This is only recommended for a local development installation. Create a special Unix group that has read access to the /etc/shadow file and set the user that the ZMS process will be running as a member of that group. User Authority is typically not allowed to carry out any authorized operation. It is required that the user first must obtain an NToken for his/her identity and use that NToken to carry out the authorized request. Principal Authority Class: com.yahoo.athenz.auth.impl.PrincipalAuthority This authority uses Athenz generated NTokens. It accepts NTokens, parses to extract the signature and the private key details that were used to sign this token: domain, service, and key id. Then it requests the corresponding public key and verifies the signature. Principal Authority is one of primary authorities in Athenz. It is used to validate NTokens that were issued by ZTS and service tokens generated by SIA Providers. By default, when authenticating an NToken, the authority validates that the IP address in the NToken matches to the IP address of the request. This provides extra security that changes to domain data are not carried out by NTokens that possible have been stolen. Kerberos Authority Class: com.yahoo.athenz.auth.impl.KerberosAuthority This authority supports environments with Kerberos servers. This authority expects to find the Kerberos Ticket in the Authorization header. There are several system properties that must be set for proper initialization of this authority: athenz.auth.kerberos.service_principal - Kerberos service principal athenz.auth.kerberos.keytab_location - Kerberos keytab location athenz.auth.kerberos.jaas_cfg_section - JAAS configuration section. If using a jaas.conf file then that path is specified by the system property java.security.auth.login.config For full details check out the implementation of the Kerberos Authority: Kerberos Authority Certificate Authority Class: com.yahoo.athenz.auth.impl.CertificateAuthority The certificate authority expects that the server has been configured with a truststore that only includes the CA cert that it tasked with issuing principal certificates. The Authority only looks at the CommonName component of the certificate and expects it to include the service name in the {domain}.{service} format. For example: Certificate Subject DN : c = US ; o = Some Athenz Company ; cn = sports . fantasy The authenticated principal in this case is service fantasy in domain sports . Role Authority Class: com.yahoo.athenz.auth.impl.RoleAuthority This authority is used only if the system administrator wants to support RoleTokens as a method for centralized authorization checks. It allows a client that retrieved its Role Token from ZTS Server to submit to ZMS Server for centralized authorization check.","title":"Principal Authentication"},{"location":"principal_authentication/#principal-authentication","text":"Authority Work Configuration Provided Authorities Unix User Authority Principal Authority Kerberos Authority Certificate Authority Role Authority For a principal (either user or service) to authenticate himself/herself in Athenz, the server must have the appropriate authentication authority implementation configured. Athenz has implementation of several authorities that support variety of authentication methods. The system administrator may decide to configure and use one of the provided authorities or implement a completely new one to satisfy their requirements.","title":"Principal Authentication"},{"location":"principal_authentication/#authority-work","text":"The job of the Authority is authenticate a specific request and, if valid, generate and return an object representing the authenticated Principal. The Authority interface is defined in the following file: Authority The system administrator can configure a list of authorities for supporting principal authentication. During startup, the server will call the initialize() method for all configured authorities. If the authority requires access to any of the service public keys registered within Athenz, then it needs to implement the AuthorityKeyStore interface as well and provide an implementation of the setKeyStore() method. The server implements the KeyStore interface and will automatically call the setKeyStore() method to pass its implementation to the authority. AuthorityKeyStore When processing a request the server goes through the list of authorities in their configured order and processes until it receives a successful principal object. As soon as a successful response is received from the authenticate method, the server will stop processing other authorities in the list and continue with the authorization check. If no authority returns an authenticated principal, the server returns 401 Unauthenticated response to the calling client. The Authority defines if the authentication details are based on a header or certificate: getCredSource() . If the returned value is HEADER then the Athenz server will retrieve the header, identified by the value returned by the getHeader() method, that the authority is looking for and if a value is present, it will call the authenticate() method to see if the request contains valid credentials or not. The returned principal object contains the Authority object that was used for authentication. This allows the Athenz servers, if necessary, to decide if further checks and/or restrictions are necessary.","title":"Authority Work"},{"location":"principal_authentication/#configuration","text":"Both ZMS and ZTS Servers expect to find the list of authority classes in their respective system properties: ZMS: athenz.zms.authority_classes ZTS: athenz.zts.authority_classes The value of the property must be a comma separated (no spaces) list of authority class names. For example, -Dathenz.zms.authority_classes=com.yahoo.athenz.auth.impl.PrincipalAuthority,com.yahoo.athenz.auth.impl.UserAuthority If you're installing and running Athenz services using the binary packages provided, you can configure the list of authorities in the conf/zms_server/zms.properties or conf/zts_server/zts.properties files for ZMS and ZTS servers respectively: athenz.zms.authority_classes=com.yahoo.athenz.auth.impl.PrincipalAuthority,com.yahoo.athenz.auth.impl.UserAuthority athenz.zts.authority_classes=com.yahoo.athenz.auth.impl.PrincipalAuthority,com.yahoo.athenz.auth.impl.UserAuthority","title":"Configuration"},{"location":"principal_authentication/#provided-authorities","text":"Here is the list of Athenz provided authorities with brief description of each one.","title":"Provided Authorities"},{"location":"principal_authentication/#unix-user-authority","text":"Class: com.yahoo.athenz.auth.impl.UserAuthority This authority uses the Unix pam login profile to authenticate users. The user that the ZMS process runs as must have read access to the /etc/shadow file. There are two options available: Run the process as root using sudo. This is only recommended for a local development installation. Create a special Unix group that has read access to the /etc/shadow file and set the user that the ZMS process will be running as a member of that group. User Authority is typically not allowed to carry out any authorized operation. It is required that the user first must obtain an NToken for his/her identity and use that NToken to carry out the authorized request.","title":"Unix User Authority"},{"location":"principal_authentication/#principal-authority","text":"Class: com.yahoo.athenz.auth.impl.PrincipalAuthority This authority uses Athenz generated NTokens. It accepts NTokens, parses to extract the signature and the private key details that were used to sign this token: domain, service, and key id. Then it requests the corresponding public key and verifies the signature. Principal Authority is one of primary authorities in Athenz. It is used to validate NTokens that were issued by ZTS and service tokens generated by SIA Providers. By default, when authenticating an NToken, the authority validates that the IP address in the NToken matches to the IP address of the request. This provides extra security that changes to domain data are not carried out by NTokens that possible have been stolen.","title":"Principal Authority"},{"location":"principal_authentication/#kerberos-authority","text":"Class: com.yahoo.athenz.auth.impl.KerberosAuthority This authority supports environments with Kerberos servers. This authority expects to find the Kerberos Ticket in the Authorization header. There are several system properties that must be set for proper initialization of this authority: athenz.auth.kerberos.service_principal - Kerberos service principal athenz.auth.kerberos.keytab_location - Kerberos keytab location athenz.auth.kerberos.jaas_cfg_section - JAAS configuration section. If using a jaas.conf file then that path is specified by the system property java.security.auth.login.config For full details check out the implementation of the Kerberos Authority: Kerberos Authority","title":"Kerberos Authority"},{"location":"principal_authentication/#certificate-authority","text":"Class: com.yahoo.athenz.auth.impl.CertificateAuthority The certificate authority expects that the server has been configured with a truststore that only includes the CA cert that it tasked with issuing principal certificates. The Authority only looks at the CommonName component of the certificate and expects it to include the service name in the {domain}.{service} format. For example: Certificate Subject DN : c = US ; o = Some Athenz Company ; cn = sports . fantasy The authenticated principal in this case is service fantasy in domain sports .","title":"Certificate Authority"},{"location":"principal_authentication/#role-authority","text":"Class: com.yahoo.athenz.auth.impl.RoleAuthority This authority is used only if the system administrator wants to support RoleTokens as a method for centralized authorization checks. It allows a client that retrieved its Role Token from ZTS Server to submit to ZMS Server for centralized authorization check.","title":"Role Authority"},{"location":"private_key_store/","text":"Private Key Store Private Key Store Interfaces Configuration Provided Implementation File Based Private Key Store Athenz servers (both ZMS and ZTS) require a unique private key to sign their respective tokens. There are 2 distinct operations that require the use of signatures: NToken/ZToken signatures Policy Document signatures The private key could be unique per host (if you have multiple ZMS and/or ZTS servers in your production environment) or per data center location. By default the server ships with a file based private key store which expects to find the private key in PEM format in the configured file. The system administrator may decide to configure and use this implementation or otherwise implement a completely new one to satisfy their requirements (e.g. the private keys are to be stored in some external system rather than a file). Private Key Store Interfaces To provide ZMS/ZTS servers with private keys, the following two interfaces must be implemented: PrivateKeyStoreFactory The job of the PrivateKeyStoreFactory class is to implement a single create() method which returns an instance of PrivateKeyStore class implementation. PrivateKeyStore The job of the PrivateKeyStore class is to return a private key for a given host in a PEM format. The hostname is passed as the first argument to the getPrivateKey() method. Each private key in Athenz is identified by a unique key identifier. This allows each service to have multiple active private/public key pairs to support per host keys with key rotation capability. The getPrivateKey() method is passed a StringBuilder object that the implementation must update and return the corresponding key identifier for the public key returned from this method. During server startup, Athenz servers will load the configured private key store factory class and invoke the create method. Then it will use the PrivateKeyStore object returned to retrieve the private key for the host. If the private key store does not return a PrivateKey (returns null), then the server will continue to run. This is necessary since it's possible that an environment may choose to run only ZMS Servers for centralized authorization thus no need to sign and distribute policy documents and only supports TLS certificates for principal authentication thus no need to sign and issue NTokens. Configuration Both ZMS and ZTS Servers expect to find the configured private key store factory class names in their respective system properties: ZMS: athenz.zms.private_key_store_factory_class ZTS: athenz.zts.private_key_store_factory_class For example, -Dathenz.zms.private_key_store_factory_class=com.yahoo.athenz.zms.pkey.file.FilePrivateKeyStoreFactory If you're installing and running Athenz services using the binary packages provided, you can configure the private key store factory class in the conf/zms_server/zms.properties or conf/zts_server/zts.properties files for ZMS and ZTS servers respectively: athenz.zms.private_key_store_factory_class=com.yahoo.athenz.auth.impl.FilePrivateKeyStoreFactory athenz.zts.private_key_store_factory_class=com.yahoo.athenz.auth.impl.FilePrivateKeyStoreFactory Provided Implementation Here is the list of Athenz provided private key store implementations with brief description of each one. File Based Private Key Store Class: com.yahoo.athenz.auth.impl.FilePrivateKeyStoreFactory This factory class creates and returns a single private key regardless of the hostname passed to the getPrivateKey() method. The private key file and its corresponding id can be configured by using the following system properties: Key File: athenz.auth.private_key_store.private_key Key-Id: athenz.auth.private_key_store.private_key_id The key file must be a PEM encoded either RSA or EC private key.","title":"Private Key Store"},{"location":"private_key_store/#private-key-store","text":"Private Key Store Interfaces Configuration Provided Implementation File Based Private Key Store Athenz servers (both ZMS and ZTS) require a unique private key to sign their respective tokens. There are 2 distinct operations that require the use of signatures: NToken/ZToken signatures Policy Document signatures The private key could be unique per host (if you have multiple ZMS and/or ZTS servers in your production environment) or per data center location. By default the server ships with a file based private key store which expects to find the private key in PEM format in the configured file. The system administrator may decide to configure and use this implementation or otherwise implement a completely new one to satisfy their requirements (e.g. the private keys are to be stored in some external system rather than a file).","title":"Private Key Store"},{"location":"private_key_store/#private-key-store-interfaces","text":"To provide ZMS/ZTS servers with private keys, the following two interfaces must be implemented: PrivateKeyStoreFactory The job of the PrivateKeyStoreFactory class is to implement a single create() method which returns an instance of PrivateKeyStore class implementation. PrivateKeyStore The job of the PrivateKeyStore class is to return a private key for a given host in a PEM format. The hostname is passed as the first argument to the getPrivateKey() method. Each private key in Athenz is identified by a unique key identifier. This allows each service to have multiple active private/public key pairs to support per host keys with key rotation capability. The getPrivateKey() method is passed a StringBuilder object that the implementation must update and return the corresponding key identifier for the public key returned from this method. During server startup, Athenz servers will load the configured private key store factory class and invoke the create method. Then it will use the PrivateKeyStore object returned to retrieve the private key for the host. If the private key store does not return a PrivateKey (returns null), then the server will continue to run. This is necessary since it's possible that an environment may choose to run only ZMS Servers for centralized authorization thus no need to sign and distribute policy documents and only supports TLS certificates for principal authentication thus no need to sign and issue NTokens.","title":"Private Key Store Interfaces"},{"location":"private_key_store/#configuration","text":"Both ZMS and ZTS Servers expect to find the configured private key store factory class names in their respective system properties: ZMS: athenz.zms.private_key_store_factory_class ZTS: athenz.zts.private_key_store_factory_class For example, -Dathenz.zms.private_key_store_factory_class=com.yahoo.athenz.zms.pkey.file.FilePrivateKeyStoreFactory If you're installing and running Athenz services using the binary packages provided, you can configure the private key store factory class in the conf/zms_server/zms.properties or conf/zts_server/zts.properties files for ZMS and ZTS servers respectively: athenz.zms.private_key_store_factory_class=com.yahoo.athenz.auth.impl.FilePrivateKeyStoreFactory athenz.zts.private_key_store_factory_class=com.yahoo.athenz.auth.impl.FilePrivateKeyStoreFactory","title":"Configuration"},{"location":"private_key_store/#provided-implementation","text":"Here is the list of Athenz provided private key store implementations with brief description of each one.","title":"Provided Implementation"},{"location":"private_key_store/#file-based-private-key-store","text":"Class: com.yahoo.athenz.auth.impl.FilePrivateKeyStoreFactory This factory class creates and returns a single private key regardless of the hostname passed to the getPrivateKey() method. The private key file and its corresponding id can be configured by using the following system properties: Key File: athenz.auth.private_key_store.private_key Key-Id: athenz.auth.private_key_store.private_key_id The key file must be a PEM encoded either RSA or EC private key.","title":"File Based Private Key Store"},{"location":"reg_service_guide/","text":"Registering ZMS Service Identity Key Generation Private Keys Key Rotation Service Identity Registration Once a domain has been registered in Athenz, the administrator will register service identities that are specified in domain roles and policy assertions. The latter can reference those roles having access to specified resources. Before you can register the service identity, you'll need to generate keys. We'll cover how to create the keys and register the service identity next. Key Generation The registration process requires the domain administrator to generate a private/public RSA key pair (recommended to be at least 2048 bit) for the service. Athenz also supports EC keys. The following are the keys and the services that use those keys: private key - The service agent uses the private key to generate a ServiceToken identifying the service. public key - ZMS/ZTS then use the public key to validate the ServiceToken generated by service agent. The openssl command-line utility is used to generate the key pair: $ openssl genrsa -out service_private.pem 2048 $ openssl rsa -in service_private.pem -pubout gt ; service_public.pem The zms-cli client utility requires that the public key have an extension of .pem. Private Keys The private key file must be installed on all hosts where the client service will be running. Each key pair has a key identifier that will be included in the generated ServiceTokens (NToken) as the value of the k component. If the service\u2019s private key has been compromised or the service has a policy to periodically rotate the keys, the service administrator will generate a new key pair, remove the public key with the old identifier, and register a new public key with a different key identifier. Typically, a service would start with \"0\" as its first identifier and increment when required. Key Rotation If the service\u2019s private key has been compromised or the service has a policy to periodically rotate the keys, the service administrator will generate a new key pair, remove the public key with identifier 0 and register a new public key with a different key identifier as shown below: $ zms-cli -d lt ; domain gt ; delete-public-key lt ; service gt ; 0 $ zms-cli -d lt ; domain gt ; add-public-key lt ; service gt ; 1 new_service_public.pem As mentioned above, the key identifier is included in generated Service Tokens as the value of the k component. Service Identity Registration To create a service identity object in ZMS with the generated public key: $ zms-cli -d lt ; domain gt ; add-service lt ; service gt ; lt ; key-id gt ; lt ; service_public.pem gt ; For example, to register the service \"storage\" in the domain athenz with the key identifier 0 and the public key stored in the file storage_public.pem , run the following zms-cli command: $ zms-cli -d athenz add-service storage 0 ./storage_public.pem","title":"Registering ZMS Service Identity"},{"location":"reg_service_guide/#registering-zms-service-identity","text":"Key Generation Private Keys Key Rotation Service Identity Registration Once a domain has been registered in Athenz, the administrator will register service identities that are specified in domain roles and policy assertions. The latter can reference those roles having access to specified resources. Before you can register the service identity, you'll need to generate keys. We'll cover how to create the keys and register the service identity next.","title":"Registering ZMS Service Identity"},{"location":"reg_service_guide/#key-generation","text":"The registration process requires the domain administrator to generate a private/public RSA key pair (recommended to be at least 2048 bit) for the service. Athenz also supports EC keys. The following are the keys and the services that use those keys: private key - The service agent uses the private key to generate a ServiceToken identifying the service. public key - ZMS/ZTS then use the public key to validate the ServiceToken generated by service agent. The openssl command-line utility is used to generate the key pair: $ openssl genrsa -out service_private.pem 2048 $ openssl rsa -in service_private.pem -pubout gt ; service_public.pem The zms-cli client utility requires that the public key have an extension of .pem.","title":"Key Generation"},{"location":"reg_service_guide/#private-keys","text":"The private key file must be installed on all hosts where the client service will be running. Each key pair has a key identifier that will be included in the generated ServiceTokens (NToken) as the value of the k component. If the service\u2019s private key has been compromised or the service has a policy to periodically rotate the keys, the service administrator will generate a new key pair, remove the public key with the old identifier, and register a new public key with a different key identifier. Typically, a service would start with \"0\" as its first identifier and increment when required.","title":"Private Keys"},{"location":"reg_service_guide/#key-rotation","text":"If the service\u2019s private key has been compromised or the service has a policy to periodically rotate the keys, the service administrator will generate a new key pair, remove the public key with identifier 0 and register a new public key with a different key identifier as shown below: $ zms-cli -d lt ; domain gt ; delete-public-key lt ; service gt ; 0 $ zms-cli -d lt ; domain gt ; add-public-key lt ; service gt ; 1 new_service_public.pem As mentioned above, the key identifier is included in generated Service Tokens as the value of the k component.","title":"Key Rotation"},{"location":"reg_service_guide/#service-identity-registration","text":"To create a service identity object in ZMS with the generated public key: $ zms-cli -d lt ; domain gt ; add-service lt ; service gt ; lt ; key-id gt ; lt ; service_public.pem gt ; For example, to register the service \"storage\" in the domain athenz with the key identifier 0 and the public key stored in the file storage_public.pem , run the following zms-cli command: $ zms-cli -d athenz add-service storage 0 ./storage_public.pem","title":"Service Identity Registration"},{"location":"service_authentication/","text":"Athenz Service Authentication Copper Argos Using zts-svcvert Utility Athenz Service Identity x.509 certificates are used to establish standard mutual TLS communication with other Athenz Enabled Services. The services running on the instance can obtain X.509 certificates from zts using two approaches discussed below: Copper Argos(Prefered) Refer Copper Argos for full details. Using zts-svccert utility (Not recommended) Create a public/private key pair for your service and register the public key in Athenz. Refer Service Registration for complete details on registering services in Athenz. Store your private key securely. You can store that in a file on the host. The recommended approach is to use Key Management Store like HashiCorp. ZMS and ZTS Server use PrivateKeyStoreFactory interface to get access to its secrets. Refer Private Key Store for full details how to implement your private key store. Use the private key to obtain X.509 certificate from ZTS using zts-svccert utility as below: Download latest ZTS SVCCERT utility binary release from Bintray - click on the Files tab, choose the latest version directory and then download the athenz-utils- latest-version -bin.tar.gz file: shell $ tar xvfz athenz-utils-X.Y-bin.tar.gz You need to make sure to pass the correct key-version argument that matches to the key identifier that was used to register the public key for the service in Athenz. zts-svccert -domain domain -service service -private-key private key file -key-version version -zts zts_url -dns-domain dns-name -cert-file output certificate file The certificates and keys should be carefully rotated and service should repeatedly refresh them.","title":"Athenz Service Authentication"},{"location":"service_authentication/#athenz-service-authentication","text":"Copper Argos Using zts-svcvert Utility Athenz Service Identity x.509 certificates are used to establish standard mutual TLS communication with other Athenz Enabled Services. The services running on the instance can obtain X.509 certificates from zts using two approaches discussed below:","title":"Athenz Service Authentication"},{"location":"service_authentication/#copper-argosprefered","text":"Refer Copper Argos for full details.","title":"Copper Argos(Prefered)"},{"location":"service_authentication/#using-zts-svccert-utility-not-recommended","text":"Create a public/private key pair for your service and register the public key in Athenz. Refer Service Registration for complete details on registering services in Athenz. Store your private key securely. You can store that in a file on the host. The recommended approach is to use Key Management Store like HashiCorp. ZMS and ZTS Server use PrivateKeyStoreFactory interface to get access to its secrets. Refer Private Key Store for full details how to implement your private key store. Use the private key to obtain X.509 certificate from ZTS using zts-svccert utility as below: Download latest ZTS SVCCERT utility binary release from Bintray - click on the Files tab, choose the latest version directory and then download the athenz-utils- latest-version -bin.tar.gz file: shell $ tar xvfz athenz-utils-X.Y-bin.tar.gz You need to make sure to pass the correct key-version argument that matches to the key identifier that was used to register the public key for the service in Athenz. zts-svccert -domain domain -service service -private-key private key file -key-version version -zts zts_url -dns-domain dns-name -cert-file output certificate file The certificates and keys should be carefully rotated and service should repeatedly refresh them.","title":"Using zts-svccert utility (Not recommended)"},{"location":"setup_ui/","text":"Setup Athenz UI Requirements Node.JS Getting Software Configuration Start/Stop UI Server UI Access Requirements The following tools are required to be installed on hosts configured to run UI server. Node.js UI Server is a Node.js application. Node.js JavaScript Runtime Verify that you have the required minimum version of node and nodemon binaries installed on your system and are included in your runtime path: $ node --version v6.9.4 $ npm install -g nodemon $ nodemon --version 1 .11.0 Getting Software Download latest Athenz UI release from Bintray - click on the Files tab, choose the latest version directory and then download the athenz-ui- latest-version -bin.tar.gz file: $ tar xvfz athenz-ui-X.Y-bin.tar.gz $ cd athenz-ui-X.Y Configuration To run UI Server, the system administrator must generate the keys, certificates and make necessary changes to the configuration settings. For our configuration script we need the ZMS server hostname and a copy of the server certificate file since ZMS Server is running with a self-signed certificate. From your ZMS Server installation, copy the zms_cert.pem file from the athenz-zms-X.Y/var/zms_server/certs directory to a local directory on the host that will be running the UI Server. For the zms-public-cert-path argument below pass the full path of the zms_cert.pem. $ cd athenz-ui-X.Y $ bin/setup_dev_ui.sh zms-hostname zms-public-cert-path Running this setup script completes the following tasks: Generate a unique public/private key pair that UI Server will use to sign user's authorized service tokens. The UI has already been authorized to be allowed to carry out the users' requested operations. Generate a self-signed X509 certificate for UI Server HTTPS support Create a new domain called athenz and register the ui service in that domain Start/Stop UI Server Set the following environment variable before starting the UI Server: $ export UI_SERVER = ui-server-host-name ZMS_SERVER = zms-server-host-name $ cd athenz-ui-X.Y $ bin/athenz_ui start Based on the sample configuration file provided, Athenz UI Server will be listening on port 9443. To stop the UI server, execute the following commands: $ export UI_SERVER = ui-server-host-name ZMS_SERVER = zms-server-host-name $ cd athenz-ui-X.Y $ bin/athenz_ui stop UI Access To access Athenz UI in your browser, visit: https:// ui-server-host-name :9443 Since the development setup is using self-signed X509 certificates for Athenz ZMS and UI servers, the administrator must add exceptions when accessing Athenz UI or install the self-signed certificates for those two servers into his/her own web browser. The administrator must first access the ZMS Server endpoint in the browser to accept the exception since the Athenz UI contacts ZMS Server to get an authorized token for the user when logging in. The administrator must access: https:// zms-server-host-name :4443/zms/v1/schema first and accept the certificate exception before accessing Athenz UI. Alternatively, the administrator may decide to install the self-signed certificates for the ZMS and UI servers in their browser. For ZMS Server, the self-signed certificate is called zms_cert.pem and this file is located in the athenz-zms-X.Y/var/zms_server/certs directory. For UI Server, the self-signed certificate is called ui_cert.pem and this file is located in the athenz-ui-X.Y/keys directory.","title":"UI Server"},{"location":"setup_ui/#setup-athenz-ui","text":"Requirements Node.JS Getting Software Configuration Start/Stop UI Server UI Access","title":"Setup Athenz UI"},{"location":"setup_ui/#requirements","text":"The following tools are required to be installed on hosts configured to run UI server.","title":"Requirements"},{"location":"setup_ui/#nodejs","text":"UI Server is a Node.js application. Node.js JavaScript Runtime Verify that you have the required minimum version of node and nodemon binaries installed on your system and are included in your runtime path: $ node --version v6.9.4 $ npm install -g nodemon $ nodemon --version 1 .11.0","title":"Node.js"},{"location":"setup_ui/#getting-software","text":"Download latest Athenz UI release from Bintray - click on the Files tab, choose the latest version directory and then download the athenz-ui- latest-version -bin.tar.gz file: $ tar xvfz athenz-ui-X.Y-bin.tar.gz $ cd athenz-ui-X.Y","title":"Getting Software"},{"location":"setup_ui/#configuration","text":"To run UI Server, the system administrator must generate the keys, certificates and make necessary changes to the configuration settings. For our configuration script we need the ZMS server hostname and a copy of the server certificate file since ZMS Server is running with a self-signed certificate. From your ZMS Server installation, copy the zms_cert.pem file from the athenz-zms-X.Y/var/zms_server/certs directory to a local directory on the host that will be running the UI Server. For the zms-public-cert-path argument below pass the full path of the zms_cert.pem. $ cd athenz-ui-X.Y $ bin/setup_dev_ui.sh zms-hostname zms-public-cert-path Running this setup script completes the following tasks: Generate a unique public/private key pair that UI Server will use to sign user's authorized service tokens. The UI has already been authorized to be allowed to carry out the users' requested operations. Generate a self-signed X509 certificate for UI Server HTTPS support Create a new domain called athenz and register the ui service in that domain","title":"Configuration"},{"location":"setup_ui/#startstop-ui-server","text":"Set the following environment variable before starting the UI Server: $ export UI_SERVER = ui-server-host-name ZMS_SERVER = zms-server-host-name $ cd athenz-ui-X.Y $ bin/athenz_ui start Based on the sample configuration file provided, Athenz UI Server will be listening on port 9443. To stop the UI server, execute the following commands: $ export UI_SERVER = ui-server-host-name ZMS_SERVER = zms-server-host-name $ cd athenz-ui-X.Y $ bin/athenz_ui stop","title":"Start/Stop UI Server"},{"location":"setup_ui/#ui-access","text":"To access Athenz UI in your browser, visit: https:// ui-server-host-name :9443 Since the development setup is using self-signed X509 certificates for Athenz ZMS and UI servers, the administrator must add exceptions when accessing Athenz UI or install the self-signed certificates for those two servers into his/her own web browser. The administrator must first access the ZMS Server endpoint in the browser to accept the exception since the Athenz UI contacts ZMS Server to get an authorized token for the user when logging in. The administrator must access: https:// zms-server-host-name :4443/zms/v1/schema first and accept the certificate exception before accessing Athenz UI. Alternatively, the administrator may decide to install the self-signed certificates for the ZMS and UI servers in their browser. For ZMS Server, the self-signed certificate is called zms_cert.pem and this file is located in the athenz-zms-X.Y/var/zms_server/certs directory. For UI Server, the self-signed certificate is called ui_cert.pem and this file is located in the athenz-ui-X.Y/keys directory.","title":"UI Access"},{"location":"setup_ui_prod/","text":"Setup Athenz UI for Production Requirements Node.JS Getting Software Configuration Private/Public Key Pair X509 Certificate Register UI Service Start/Stop UI Server Requirements The following tools are required to be installed on hosts configured to run UI server. Node.js UI Server is a Node.js application. Node.js JavaScript Runtime Verify that you have the required minimum version of node and nodemon binaries installed on your system and are included in your runtime path: $ node --version v6.9.4 $ nodemon --version 1 .11.0 Getting Software Download latest Athenz UI release from https://bintray.com/yahoo/maven/athenz-ui/_latestVersion#files $ tar xvfz athenz-ui-X.Y-bin.tar.gz $ cd athenz-ui-X.Y Configuration To run UI Server, the system administrator must generate the keys and make necessary changes to the configuration settings. Private/Public Key Pair Generate a unique private/public key pair that UI Server will use to sign user's authorized service tokens. The UI has already been authorized to be allowed to carry out the users' requested operations. From the athenz-ui-X.Y directory execute the following commands: $ cd keys $ openssl genrsa -out athenz.ui.pem 2048 $ openssl rsa -in athenz.ui.pem -pubout athenz.ui_pub.pem X509 Certificate For Athenz UI production server it is strongly recommended to purchase a certificate for HTTPS access from a well known certificate authority. Follow the instructions provided by the Certificate Authority to generate your private key and then the Certificate Request (CSR). Once you have received your X509 certificate name your UI server private key as ui_key.pem and the X509 certificate as ui_cert.pem and copy those files into the keys subdirectory. Register UI Service In order for UI to access ZMS domain data, it must identify itself as a registered service in ZMS. Using the zms-cli utility, we will register a new service in athenz domain: $ cd athenz-ui-X.Y $ bin/ platform /zms-cli -z https:// zms-server :4443/zms/v1 add-domain athenz $ bin/ platform /zms-cli -z https:// zms-server :4443/zms/v1 -d athenz add-service ui 0 keys/athenz.ui_pub.pem Generate Athenz Configuration File Generate an Athenz configuration file athenz.conf in athenz-ui-X.Y/config directory to include the ZMS Server URL and the registered public keys that the athenz client libraries and utilities will use to establish connection and validate any data signed by the ZMS Server: $ cd athenz-ui-X.Y $ bin/ platform /athenz-conf -o config/athenz.conf -z https:// zms-server :4443/ Start/Stop UI Server Set the following environment variable before starting the UI Server: $ export UI_SERVER = ui-server-host-name ZMS_SERVER = zms-server-host-name $ cd athenz-ui-X.Y $ bin/athenz_ui start Based on the sample configuration file provided, Athenz UI Server will be listening on port 9443. To stop the UI server, execute the following commands: $ export UI_SERVER = ui-server-host-name ZMS_SERVER = zms-server-host-name $ cd athenz-ui-X.Y $ bin/athenz_ui stop","title":"UI Server"},{"location":"setup_ui_prod/#setup-athenz-ui-for-production","text":"Requirements Node.JS Getting Software Configuration Private/Public Key Pair X509 Certificate Register UI Service Start/Stop UI Server","title":"Setup Athenz UI for Production"},{"location":"setup_ui_prod/#requirements","text":"The following tools are required to be installed on hosts configured to run UI server.","title":"Requirements"},{"location":"setup_ui_prod/#nodejs","text":"UI Server is a Node.js application. Node.js JavaScript Runtime Verify that you have the required minimum version of node and nodemon binaries installed on your system and are included in your runtime path: $ node --version v6.9.4 $ nodemon --version 1 .11.0","title":"Node.js"},{"location":"setup_ui_prod/#getting-software","text":"Download latest Athenz UI release from https://bintray.com/yahoo/maven/athenz-ui/_latestVersion#files $ tar xvfz athenz-ui-X.Y-bin.tar.gz $ cd athenz-ui-X.Y","title":"Getting Software"},{"location":"setup_ui_prod/#configuration","text":"To run UI Server, the system administrator must generate the keys and make necessary changes to the configuration settings.","title":"Configuration"},{"location":"setup_ui_prod/#privatepublic-key-pair","text":"Generate a unique private/public key pair that UI Server will use to sign user's authorized service tokens. The UI has already been authorized to be allowed to carry out the users' requested operations. From the athenz-ui-X.Y directory execute the following commands: $ cd keys $ openssl genrsa -out athenz.ui.pem 2048 $ openssl rsa -in athenz.ui.pem -pubout athenz.ui_pub.pem","title":"Private/Public Key Pair"},{"location":"setup_ui_prod/#x509-certificate","text":"For Athenz UI production server it is strongly recommended to purchase a certificate for HTTPS access from a well known certificate authority. Follow the instructions provided by the Certificate Authority to generate your private key and then the Certificate Request (CSR). Once you have received your X509 certificate name your UI server private key as ui_key.pem and the X509 certificate as ui_cert.pem and copy those files into the keys subdirectory.","title":"X509 Certificate"},{"location":"setup_ui_prod/#register-ui-service","text":"In order for UI to access ZMS domain data, it must identify itself as a registered service in ZMS. Using the zms-cli utility, we will register a new service in athenz domain: $ cd athenz-ui-X.Y $ bin/ platform /zms-cli -z https:// zms-server :4443/zms/v1 add-domain athenz $ bin/ platform /zms-cli -z https:// zms-server :4443/zms/v1 -d athenz add-service ui 0 keys/athenz.ui_pub.pem","title":"Register UI Service"},{"location":"setup_ui_prod/#generate-athenz-configuration-file","text":"Generate an Athenz configuration file athenz.conf in athenz-ui-X.Y/config directory to include the ZMS Server URL and the registered public keys that the athenz client libraries and utilities will use to establish connection and validate any data signed by the ZMS Server: $ cd athenz-ui-X.Y $ bin/ platform /athenz-conf -o config/athenz.conf -z https:// zms-server :4443/","title":"Generate Athenz Configuration File"},{"location":"setup_ui_prod/#startstop-ui-server","text":"Set the following environment variable before starting the UI Server: $ export UI_SERVER = ui-server-host-name ZMS_SERVER = zms-server-host-name $ cd athenz-ui-X.Y $ bin/athenz_ui start Based on the sample configuration file provided, Athenz UI Server will be listening on port 9443. To stop the UI server, execute the following commands: $ export UI_SERVER = ui-server-host-name ZMS_SERVER = zms-server-host-name $ cd athenz-ui-X.Y $ bin/athenz_ui stop","title":"Start/Stop UI Server"},{"location":"setup_zms/","text":"Setup ZMS (AuthoriZation Management System) Requirements JDK 8 Getting Software Configuration User Authentication System Administrators Start/Stop ZMS Server Requirements The following tools are required to be installed on hosts configured to run ZMS server. JDK 8 ZMS Server is written in Java and using embedded Jetty. Oracle Java Platform JDK 8 While ZMS has been developed and tested with Oracle Java Platform JDK 8 it should run successfully with OpenJDK 8 as well. Getting Software Download latest ZMS binary release from Bintray - click on the Files tab, choose the latest version directory and then download the athenz-zms- latest-version -bin.tar.gz file: $ tar xvfz athenz-zms-X.Y-bin.tar.gz Configuration To run ZMS Server, the system administrator must generate the keys and make necessary changes to the configuration settings. $ cd athenz-zms-X.Y $ bin/setup_dev_zms.sh Running this setup script completes the following two tasks: Generate a unique private key that ZMS Server will use to sign any NTokens it issues Generate a self-signed X509 certificate for ZMS Server HTTPS support User Authentication For a user to authenticate himself/herself in ZMS, the server must have the appropriate authentication authority implementation configured. By default, ZMS enables the following two authorities: Unix User Authority - using pam login profile to authenticate users Principal Authority - validating Principal Tokens that are issued when users authenticate using their unix login password. The server also provides other authorities - e.g. Kerberos, TLS Certificate that are not enabled by default. Since the default setup includes Unix Authority, the user that the ZMS process runs as must have read access to the /etc/shadow file. There are two options available: Run the process as root using sudo. This is only recommended for a local development installation. Create a special Unix group that has read access to the /etc/shadow file and set the user that the ZMS process will be running as a member of that group. Checkout the Principal Authentication section for full details on authorities. System Administrators When running the server very first time, ZMS Server automatically creates the required domains and sets the running user as the system administrator. The system administrators are the only ones authorized to create top level domains in Athenz. Before running the server very first time, you can configure the set of system administrators by following these steps: $ cd athenz-zms-X.Y $ vi conf/zms_server/zms.properties Modify the athenz.zms.domain_admin=user.${USER} line and include comma separated list of unix user ids that should be set as Athenz system administrators. e.g. athenz.zms.domain_admin=user.joe,user.john Start/Stop ZMS Server Start the ZMS Server by executing: $ cd athenz-zms-X.Y $ sudo -E bin/zms start See the User Authentication section above regarding an alternative solution of starting ZMS Server without using sudo. Based on the sample configuration file provided, ZMS Server will be listening on port 4443. Stop the ZMS Server by executing: $ cd athenz-zms-X.Y $ sudo bin/zms stop","title":"ZMS Server"},{"location":"setup_zms/#setup-zms-authorization-management-system","text":"Requirements JDK 8 Getting Software Configuration User Authentication System Administrators Start/Stop ZMS Server","title":"Setup ZMS (AuthoriZation Management System)"},{"location":"setup_zms/#requirements","text":"The following tools are required to be installed on hosts configured to run ZMS server.","title":"Requirements"},{"location":"setup_zms/#jdk-8","text":"ZMS Server is written in Java and using embedded Jetty. Oracle Java Platform JDK 8 While ZMS has been developed and tested with Oracle Java Platform JDK 8 it should run successfully with OpenJDK 8 as well.","title":"JDK 8"},{"location":"setup_zms/#getting-software","text":"Download latest ZMS binary release from Bintray - click on the Files tab, choose the latest version directory and then download the athenz-zms- latest-version -bin.tar.gz file: $ tar xvfz athenz-zms-X.Y-bin.tar.gz","title":"Getting Software"},{"location":"setup_zms/#configuration","text":"To run ZMS Server, the system administrator must generate the keys and make necessary changes to the configuration settings. $ cd athenz-zms-X.Y $ bin/setup_dev_zms.sh Running this setup script completes the following two tasks: Generate a unique private key that ZMS Server will use to sign any NTokens it issues Generate a self-signed X509 certificate for ZMS Server HTTPS support","title":"Configuration"},{"location":"setup_zms/#user-authentication","text":"For a user to authenticate himself/herself in ZMS, the server must have the appropriate authentication authority implementation configured. By default, ZMS enables the following two authorities: Unix User Authority - using pam login profile to authenticate users Principal Authority - validating Principal Tokens that are issued when users authenticate using their unix login password. The server also provides other authorities - e.g. Kerberos, TLS Certificate that are not enabled by default. Since the default setup includes Unix Authority, the user that the ZMS process runs as must have read access to the /etc/shadow file. There are two options available: Run the process as root using sudo. This is only recommended for a local development installation. Create a special Unix group that has read access to the /etc/shadow file and set the user that the ZMS process will be running as a member of that group. Checkout the Principal Authentication section for full details on authorities.","title":"User Authentication"},{"location":"setup_zms/#system-administrators","text":"When running the server very first time, ZMS Server automatically creates the required domains and sets the running user as the system administrator. The system administrators are the only ones authorized to create top level domains in Athenz. Before running the server very first time, you can configure the set of system administrators by following these steps: $ cd athenz-zms-X.Y $ vi conf/zms_server/zms.properties Modify the athenz.zms.domain_admin=user.${USER} line and include comma separated list of unix user ids that should be set as Athenz system administrators. e.g. athenz.zms.domain_admin=user.joe,user.john","title":"System Administrators"},{"location":"setup_zms/#startstop-zms-server","text":"Start the ZMS Server by executing: $ cd athenz-zms-X.Y $ sudo -E bin/zms start See the User Authentication section above regarding an alternative solution of starting ZMS Server without using sudo. Based on the sample configuration file provided, ZMS Server will be listening on port 4443. Stop the ZMS Server by executing: $ cd athenz-zms-X.Y $ sudo bin/zms stop","title":"Start/Stop ZMS Server"},{"location":"setup_zms_prod/","text":"Setup ZMS (AuthoriZation Management System) For Production The primary requirement for running ZMS in a Production environment is using JDBC (MySQL Server) to store the domain data as opposed to file based json documents. Requirements JDK 8 MySQL Server ZMS Server Schema Setup MySQL User and Permissions Getting Software Configuration DB Access Private Key Server X509 Certificate User Authentication System Administrators Start/Stop ZMS Server Requirements The following tools are required to be installed on hosts configured to run ZMS server. JDK 8 ZMS Server is written in Java and using embedded Jetty. Oracle Java Platform JDK 8 While ZMS has been developed and tested with Oracle Java Platform JDK 8 it should run successfully with OpenJDK 8 as well. MySQL Server On a separate host, download and install the latest version of MySQL Server ZMS Server Schema Setup Copy the zms_server.sql file from the Athenz Git repository (from the servers/zms/schema directory) onto this host and create the database: $ mysql -u root zms_server.sql MySQL User and Permissions Follow MySQL documentation to create a user and grant this user full privileges over the zms_server database created. For example, let's assume our ZMS Server will be running on zms1.athenz.com host and we want to create a user called zms_admin with password \"rdvXC7wgvm3g\": $ mysql -u root mysql CREATE USER zms_admin @ zms1.athenz.com IDENTIFIED BY rdvXC7wgvm3g ; mysql GRANT ALL PRIVILEGES ON zms_server.* TO zms_admin @ zms1.athenz.com ; mysql FLUSH PRIVILEGES ; We recommend to have a strong admin password for better security. Getting Software Download latest ZMS binary release from https://bintray.com/yahoo/maven/athenz-zms/_latestVersion#files $ tar xvfz athenz-zms-X.Y-bin.tar.gz $ cd athenz-zms-X.Y Configuration To run ZMS Server, the system administrator must generate the keys and make necessary changes to the configuration settings. DB Access In the \"MySQL Server\" section above we installed and configured the schema required for ZMS Server. We also created a zms admin user and granted full access over those tables. Now, we need to configure the ZMS with those access details: $ cd conf/zms_server $ vi zms.properties Make the following changes: Configure the ZMS Server to use JDBC object store implementation. Uncomment the #athenz.zms.object_store_factory_class= line and set it to point to the JDBC Factory class name. It should be set to: athenz.zms.object_store_factory_class=com.yahoo.athenz.zms.store.impl.JDBCObjectStoreFactory Uncomment the #athenz.zms.jdbcstore= line and set it to point to your MySQL Server instance. For example if your DB Server is running on a host called db1.athenz.com, then your line would be: athenz.zms.jdbc_store=jdbc:mysql://db1.athenz.com:3306/zms_server Uncomment the #athenz.zms.jdbc_user= line and set it to the user configured to have full access over zms server database: athenz.zms.jdbc_user=zms_admin Uncomment the #athenz.zms.jdbc_password= line and set it to the configured password the for the jdbc user with full access: athenz.zms.jdbc_password=rdvXC7wgvm3g Storing the password in property file is not secure. The more robust approach is to use a Key Management Store like HashiCorp Vault to store your passwords. Athenz provides a PrivateKeyStoreFactory interface for accessing secrets from your key management store. The recommended approach would to write your own implementation of this interface and configure ZMS server to use that factory to fetch the password for your database access. ZMS Server expect the private key store factory implementation class name in its athenz.zms.private_key_store_factory_class system property. Refer to Private Key Store section for full details how to implement your private key store. When storing the jdbc user password for your database access in your key management store with a given keyname like athenz.admin_db_password and using your own implementation of the PrivateKeyStoreFactory, then the value of the athenz.zms.jdbc_password property would be the key name. For example: athenz.zms.jdbc_password=athenz.admin_db_password The password is retrieved using the getApplicationSecret() of your private key store class that takes keyName ( athenz.admin_db_password in this case) as input and returns key value that is your configured password. Private Key Generate a unique private key that ZMS Server will use to sign any NTokens it issues. From the athenz-zms-X.Y directory execute the following commands: $ cd var/zms_server/keys $ openssl genrsa -out zms_private.pem 2048 If you have multiple ZMS servers in your environment, your private key must be stored in your key management store and securely installed on all hosts where ZMS servers will be running in the specified directory. Server X509 Certificate While it is still possible to generate and use a self-signed X509 certificate for ZMS Servers, it is recommended to purchase one for your production server from a well known certificate authority. Having such a certificate installed on your ZMS Servers will no longer require to distribute the server's CA certificate to other hosts (e.g. ZTS Servers, Hosts running ZPU). Follow the instructions provided by the Certificate Authority that you're going to purchase your certificate from to generate your private key and then the Certificate Request (CSR). Once you have received your X509 certificate, we just need to add that certificate along with its private key to a keystore for Jetty use. From the athenz-zms-X.Y directory execute the following command: $ openssl pkcs12 -export -out zms_keystore.pkcs12 -in zms_cert.pem -inkey zms_key.pem User Authentication For a user to authenticate himself/herself in ZMS, the server must have the appropriate authentication authority implementation configured. By default, ZMS enables the following two authorities: Unix User Authority - using pam login profile to authenticate users Principal Authority - validating Principal Tokens that are issued when users authenticate using their unix login password. The server also provides other authorities - e.g. Kerberos, TLS Certificate that are not enabled by default. Since the default setup includes Unix Authority, the user that the ZMS process runs as must have read access to the /etc/shadow file. There are two options available: Create a special Unix group that has read access to the /etc/shadow file and set the user that the ZMS process will be running as a member of that group. Run the process as root using sudo. This is not recommended for a production installation. To add your own authentication authority modify the athenz.zms.authority_classes=com.yahoo.athenz.auth.impl.PrincipalAuthority,com.yahoo.athenz.auth.impl.UserAuthority line and include comma separated list of authority implementation classes to support. System Administrators When running the server very first time, ZMS Server automatically creates the required domains and sets the running user as the system administrator. The system administrators are the only ones authorized to create top level domains in Athenz. Before running the server very first time, you can configure the set of system administrators by following these steps: $ cd athenz-zms-X.Y $ vi conf/zms_server/zms.properties Modify the athenz.zms.domain_admin=user.${USER} line and include comma separated list of unix user ids that should be set as Athenz system administrators. e.g. athenz.zms.domain_admin=user.joe,user.john Start/Stop ZMS Server Start the ZMS Server by executing: $ cd athenz-zms-X.Y $ bin/zms start If using the Unix Authority to authenticate users against their unix password, make sure the user that the ZMS Server process is running as has read access to the /etc/shadow file. For full details, please check out the User Authentication section above. Based on the sample configuration file provided, ZMS Server will be listening on port 4443. Stop the ZMS Server by executing: $ cd athenz-zms-X.Y $ bin/zms stop","title":"ZMS Server"},{"location":"setup_zms_prod/#setup-zms-authorization-management-system-for-production","text":"The primary requirement for running ZMS in a Production environment is using JDBC (MySQL Server) to store the domain data as opposed to file based json documents. Requirements JDK 8 MySQL Server ZMS Server Schema Setup MySQL User and Permissions Getting Software Configuration DB Access Private Key Server X509 Certificate User Authentication System Administrators Start/Stop ZMS Server","title":"Setup ZMS (AuthoriZation Management System) For Production"},{"location":"setup_zms_prod/#requirements","text":"The following tools are required to be installed on hosts configured to run ZMS server.","title":"Requirements"},{"location":"setup_zms_prod/#jdk-8","text":"ZMS Server is written in Java and using embedded Jetty. Oracle Java Platform JDK 8 While ZMS has been developed and tested with Oracle Java Platform JDK 8 it should run successfully with OpenJDK 8 as well.","title":"JDK 8"},{"location":"setup_zms_prod/#mysql-server","text":"On a separate host, download and install the latest version of MySQL Server","title":"MySQL Server"},{"location":"setup_zms_prod/#zms-server-schema-setup","text":"Copy the zms_server.sql file from the Athenz Git repository (from the servers/zms/schema directory) onto this host and create the database: $ mysql -u root zms_server.sql","title":"ZMS Server Schema Setup"},{"location":"setup_zms_prod/#mysql-user-and-permissions","text":"Follow MySQL documentation to create a user and grant this user full privileges over the zms_server database created. For example, let's assume our ZMS Server will be running on zms1.athenz.com host and we want to create a user called zms_admin with password \"rdvXC7wgvm3g\": $ mysql -u root mysql CREATE USER zms_admin @ zms1.athenz.com IDENTIFIED BY rdvXC7wgvm3g ; mysql GRANT ALL PRIVILEGES ON zms_server.* TO zms_admin @ zms1.athenz.com ; mysql FLUSH PRIVILEGES ; We recommend to have a strong admin password for better security.","title":"MySQL User and Permissions"},{"location":"setup_zms_prod/#getting-software","text":"Download latest ZMS binary release from https://bintray.com/yahoo/maven/athenz-zms/_latestVersion#files $ tar xvfz athenz-zms-X.Y-bin.tar.gz $ cd athenz-zms-X.Y","title":"Getting Software"},{"location":"setup_zms_prod/#configuration","text":"To run ZMS Server, the system administrator must generate the keys and make necessary changes to the configuration settings.","title":"Configuration"},{"location":"setup_zms_prod/#db-access","text":"In the \"MySQL Server\" section above we installed and configured the schema required for ZMS Server. We also created a zms admin user and granted full access over those tables. Now, we need to configure the ZMS with those access details: $ cd conf/zms_server $ vi zms.properties Make the following changes: Configure the ZMS Server to use JDBC object store implementation. Uncomment the #athenz.zms.object_store_factory_class= line and set it to point to the JDBC Factory class name. It should be set to: athenz.zms.object_store_factory_class=com.yahoo.athenz.zms.store.impl.JDBCObjectStoreFactory Uncomment the #athenz.zms.jdbcstore= line and set it to point to your MySQL Server instance. For example if your DB Server is running on a host called db1.athenz.com, then your line would be: athenz.zms.jdbc_store=jdbc:mysql://db1.athenz.com:3306/zms_server Uncomment the #athenz.zms.jdbc_user= line and set it to the user configured to have full access over zms server database: athenz.zms.jdbc_user=zms_admin Uncomment the #athenz.zms.jdbc_password= line and set it to the configured password the for the jdbc user with full access: athenz.zms.jdbc_password=rdvXC7wgvm3g Storing the password in property file is not secure. The more robust approach is to use a Key Management Store like HashiCorp Vault to store your passwords. Athenz provides a PrivateKeyStoreFactory interface for accessing secrets from your key management store. The recommended approach would to write your own implementation of this interface and configure ZMS server to use that factory to fetch the password for your database access. ZMS Server expect the private key store factory implementation class name in its athenz.zms.private_key_store_factory_class system property. Refer to Private Key Store section for full details how to implement your private key store. When storing the jdbc user password for your database access in your key management store with a given keyname like athenz.admin_db_password and using your own implementation of the PrivateKeyStoreFactory, then the value of the athenz.zms.jdbc_password property would be the key name. For example: athenz.zms.jdbc_password=athenz.admin_db_password The password is retrieved using the getApplicationSecret() of your private key store class that takes keyName ( athenz.admin_db_password in this case) as input and returns key value that is your configured password.","title":"DB Access"},{"location":"setup_zms_prod/#private-key","text":"Generate a unique private key that ZMS Server will use to sign any NTokens it issues. From the athenz-zms-X.Y directory execute the following commands: $ cd var/zms_server/keys $ openssl genrsa -out zms_private.pem 2048 If you have multiple ZMS servers in your environment, your private key must be stored in your key management store and securely installed on all hosts where ZMS servers will be running in the specified directory.","title":"Private Key"},{"location":"setup_zms_prod/#server-x509-certificate","text":"While it is still possible to generate and use a self-signed X509 certificate for ZMS Servers, it is recommended to purchase one for your production server from a well known certificate authority. Having such a certificate installed on your ZMS Servers will no longer require to distribute the server's CA certificate to other hosts (e.g. ZTS Servers, Hosts running ZPU). Follow the instructions provided by the Certificate Authority that you're going to purchase your certificate from to generate your private key and then the Certificate Request (CSR). Once you have received your X509 certificate, we just need to add that certificate along with its private key to a keystore for Jetty use. From the athenz-zms-X.Y directory execute the following command: $ openssl pkcs12 -export -out zms_keystore.pkcs12 -in zms_cert.pem -inkey zms_key.pem","title":"Server X509 Certificate"},{"location":"setup_zms_prod/#user-authentication","text":"For a user to authenticate himself/herself in ZMS, the server must have the appropriate authentication authority implementation configured. By default, ZMS enables the following two authorities: Unix User Authority - using pam login profile to authenticate users Principal Authority - validating Principal Tokens that are issued when users authenticate using their unix login password. The server also provides other authorities - e.g. Kerberos, TLS Certificate that are not enabled by default. Since the default setup includes Unix Authority, the user that the ZMS process runs as must have read access to the /etc/shadow file. There are two options available: Create a special Unix group that has read access to the /etc/shadow file and set the user that the ZMS process will be running as a member of that group. Run the process as root using sudo. This is not recommended for a production installation. To add your own authentication authority modify the athenz.zms.authority_classes=com.yahoo.athenz.auth.impl.PrincipalAuthority,com.yahoo.athenz.auth.impl.UserAuthority line and include comma separated list of authority implementation classes to support.","title":"User Authentication"},{"location":"setup_zms_prod/#system-administrators","text":"When running the server very first time, ZMS Server automatically creates the required domains and sets the running user as the system administrator. The system administrators are the only ones authorized to create top level domains in Athenz. Before running the server very first time, you can configure the set of system administrators by following these steps: $ cd athenz-zms-X.Y $ vi conf/zms_server/zms.properties Modify the athenz.zms.domain_admin=user.${USER} line and include comma separated list of unix user ids that should be set as Athenz system administrators. e.g. athenz.zms.domain_admin=user.joe,user.john","title":"System Administrators"},{"location":"setup_zms_prod/#startstop-zms-server","text":"Start the ZMS Server by executing: $ cd athenz-zms-X.Y $ bin/zms start If using the Unix Authority to authenticate users against their unix password, make sure the user that the ZMS Server process is running as has read access to the /etc/shadow file. For full details, please check out the User Authentication section above. Based on the sample configuration file provided, ZMS Server will be listening on port 4443. Stop the ZMS Server by executing: $ cd athenz-zms-X.Y $ bin/zms stop","title":"Start/Stop ZMS Server"},{"location":"setup_zpu/","text":"Setup ZPU (ZPE Policy Updater) ZPU is only needed to support decentralized authorization. The policy updater is the utility that retrieves from ZTS the policy files for provisioned domains on a host, which ZPE uses to evaluate access requests. Requirements JDK 8 Getting Software Configuration Domain Setting Generate Athenz Configuration File ZTS Certificate TrustStore ZPE Policy Directory Run ZPU Utility Periodic Update Policy File Details Requirements The following tools are required to be installed on hosts configured to run ZPE Policy Updater. JDK 8 ZPU Utility is a java application. Oracle Java Platform JDK 8 While ZPU has been developed and tested with Oracle Java Platform JDK 8 it should run successfully with OpenJDK 8 as well. Getting Software Download latest ZPU binary release from Bintray - click on the Files tab, choose the latest version directory and then download the athenz-zpu- latest-version -bin.tar.gz file:: $ tar xvfz athenz-zpu-X.Y-bin.tar.gz $ cd athenz-zpu-X.Y Configuration To successfully run ZPU, the domain administrator must update a couple of settings files and generate a java truststore the utility. Domain Setting Before running ZPU utility, the system administrator must configure what domains are provisioned on the host so the utility can retrieve the policy files for those domains only. $ cd athenz-zpu-X.Y $ vi conf/zpe_policy_updater/zpu.conf In the json file, edit the value for the \"domains\" field and specify a comma separated list of domain names. ZTS Certificate TrustStore ZPU needs to access ZTS Server to download all domain policies in order to execute authorization checks. Since ZTS Server is running with a self-signed certificate, we need to generate a truststore for the java http client to use when communicating with the ZTS Server. From your ZTS Server installation, copy the zts_cert.pem file from the athenz-zts-X.Y/var/zts_server/certs directory to the athenz-zpu-X.Y/var/zpe_policy_updater/certs directory and execute the following command: $ cd athenz-zpu-X.Y/var/zpe_policy_updater/certs $ keytool -importcert -noprompt -alias zts -keystore zpu_truststore.jks -file zts_cert.pem -storepass athenz Generate Athenz Configuration File Generate an Athenz configuration file athenz.conf in athenz-zpu-X.Y/conf/zpe_policy_updater directory to include the ZTS Server URL and the registered public keys that the athenz client libraries and utilities will use to establish connection and validate any data signed by the ZMS and ZTS Servers. To communicate with ZMS over SSL, the utility needs to have access to the ZMS Server's public certificate so you need to copy the zms_cert.pem file from the athenz-zms-X.Y/var/zms_server/certs directory to the athenz-zpu-X.Y/var/zpe_policy_updater/certs directory $ cd athenz-zpu-X.Y $ bin/ platform /athenz-conf -o conf/zpe_policy_updater/athenz.conf -c var/zpe_policy_updater/certs/zms_cert.pem -z https:// zms-server :4443/ -t https:// zts-server :8443/ ZPE Policy Directory By default ZPU will save any downloaded policy files in the ${ROOT}/var/zpe directory. You need to make sure this is the directory where ZPE is configured to look for policy files. To change this directory, please update the UTILITY_POLICY_FILE_DIR setting in the conf/zpe_policy_updater/utility_settings file. Run ZPU Utility Set the required Athenz ROOT environment variable to the athenz-zpu-X.Y directory and from there start the ZPU utility by executing: $ export ROOT = full-path-to-athenz-zpu-X.Y $ bin/zpu_run.sh Periodic Update The ZPU utility needs to run periodically so it can automatically download any modified policy files for the configured list of domains. The system administrator should setup this utility to be automatically executed by cron utility at least once every couple of hours. Policy File Details Checkout the ZPU Policy File for details how to manually validate the signatures in the policy file. This would be necessary if you'll be writing your own authorization policy engine library instead of using the Athenz provided one.","title":"ZPU Utility"},{"location":"setup_zpu/#setup-zpu-zpe-policy-updater","text":"ZPU is only needed to support decentralized authorization. The policy updater is the utility that retrieves from ZTS the policy files for provisioned domains on a host, which ZPE uses to evaluate access requests. Requirements JDK 8 Getting Software Configuration Domain Setting Generate Athenz Configuration File ZTS Certificate TrustStore ZPE Policy Directory Run ZPU Utility Periodic Update Policy File Details","title":"Setup ZPU (ZPE Policy Updater)"},{"location":"setup_zpu/#requirements","text":"The following tools are required to be installed on hosts configured to run ZPE Policy Updater.","title":"Requirements"},{"location":"setup_zpu/#jdk-8","text":"ZPU Utility is a java application. Oracle Java Platform JDK 8 While ZPU has been developed and tested with Oracle Java Platform JDK 8 it should run successfully with OpenJDK 8 as well.","title":"JDK 8"},{"location":"setup_zpu/#getting-software","text":"Download latest ZPU binary release from Bintray - click on the Files tab, choose the latest version directory and then download the athenz-zpu- latest-version -bin.tar.gz file:: $ tar xvfz athenz-zpu-X.Y-bin.tar.gz $ cd athenz-zpu-X.Y","title":"Getting Software"},{"location":"setup_zpu/#configuration","text":"To successfully run ZPU, the domain administrator must update a couple of settings files and generate a java truststore the utility.","title":"Configuration"},{"location":"setup_zpu/#domain-setting","text":"Before running ZPU utility, the system administrator must configure what domains are provisioned on the host so the utility can retrieve the policy files for those domains only. $ cd athenz-zpu-X.Y $ vi conf/zpe_policy_updater/zpu.conf In the json file, edit the value for the \"domains\" field and specify a comma separated list of domain names.","title":"Domain Setting"},{"location":"setup_zpu/#zts-certificate-truststore","text":"ZPU needs to access ZTS Server to download all domain policies in order to execute authorization checks. Since ZTS Server is running with a self-signed certificate, we need to generate a truststore for the java http client to use when communicating with the ZTS Server. From your ZTS Server installation, copy the zts_cert.pem file from the athenz-zts-X.Y/var/zts_server/certs directory to the athenz-zpu-X.Y/var/zpe_policy_updater/certs directory and execute the following command: $ cd athenz-zpu-X.Y/var/zpe_policy_updater/certs $ keytool -importcert -noprompt -alias zts -keystore zpu_truststore.jks -file zts_cert.pem -storepass athenz","title":"ZTS Certificate TrustStore"},{"location":"setup_zpu/#generate-athenz-configuration-file","text":"Generate an Athenz configuration file athenz.conf in athenz-zpu-X.Y/conf/zpe_policy_updater directory to include the ZTS Server URL and the registered public keys that the athenz client libraries and utilities will use to establish connection and validate any data signed by the ZMS and ZTS Servers. To communicate with ZMS over SSL, the utility needs to have access to the ZMS Server's public certificate so you need to copy the zms_cert.pem file from the athenz-zms-X.Y/var/zms_server/certs directory to the athenz-zpu-X.Y/var/zpe_policy_updater/certs directory $ cd athenz-zpu-X.Y $ bin/ platform /athenz-conf -o conf/zpe_policy_updater/athenz.conf -c var/zpe_policy_updater/certs/zms_cert.pem -z https:// zms-server :4443/ -t https:// zts-server :8443/","title":"Generate Athenz Configuration File"},{"location":"setup_zpu/#zpe-policy-directory","text":"By default ZPU will save any downloaded policy files in the ${ROOT}/var/zpe directory. You need to make sure this is the directory where ZPE is configured to look for policy files. To change this directory, please update the UTILITY_POLICY_FILE_DIR setting in the conf/zpe_policy_updater/utility_settings file.","title":"ZPE Policy Directory"},{"location":"setup_zpu/#run-zpu-utility","text":"Set the required Athenz ROOT environment variable to the athenz-zpu-X.Y directory and from there start the ZPU utility by executing: $ export ROOT = full-path-to-athenz-zpu-X.Y $ bin/zpu_run.sh","title":"Run ZPU Utility"},{"location":"setup_zpu/#periodic-update","text":"The ZPU utility needs to run periodically so it can automatically download any modified policy files for the configured list of domains. The system administrator should setup this utility to be automatically executed by cron utility at least once every couple of hours.","title":"Periodic Update"},{"location":"setup_zpu/#policy-file-details","text":"Checkout the ZPU Policy File for details how to manually validate the signatures in the policy file. This would be necessary if you'll be writing your own authorization policy engine library instead of using the Athenz provided one.","title":"Policy File Details"},{"location":"setup_zts/","text":"Setup ZTS (authoriZation Token System) Requirements JDK 8 Getting Software Configuration Athenz CA X.509 Certificate Issuing Start/Stop ZTS Server Requirements The following tools are required to be installed on hosts configured to run ZTS server. JDK 8 ZTS Server is written in Java and using embedded Jetty. Oracle Java Platform JDK 8 While ZTS has been developed and tested with Oracle Java Platform JDK 8 it should run successfully with OpenJDK 8 as well. Getting Software Download latest ZTS binary release from Bintray - click on the Files tab, choose the latest version directory and then download the athenz-zts- latest-version -bin.tar.gz file:: $ tar xvfz athenz-zts-X.Y-bin.tar.gz $ cd athenz-zts-X.Y Configuration To run ZTS Server, the system administrator must generate the keys, certificates and make necessary changes to the configuration settings. Since ZMS Server is running with a self-signed certificate, we need to generate a truststore for the java http client to use when communicating with the ZMS Server. For our configuration script we need the ZMS server hostname and a copy of the server certificate file. From your ZMS Server installation, copy the zms_cert.pem file from the athenz-zms-X.Y/var/zms_server/certs directory to a local directory on the host that will be running the ZTS Server. For the zms-public-cert-path argument below pass the full path of the zms_cert.pem. $ cd athenz-zms-X.Y $ bin/setup_dev_zts.sh zms-hostname zms-public-cert-path Running this setup script completes the following tasks: Generate a unique private key that ZTS Server will use to sign any ZTokens it issues Generate a self-signed X509 certificate for ZTS Server HTTPS support Generate a truststore for secure communication with the ZMS Server Registers the zts service in Athenz sys.auth domain Generates an Athenz configuration file Athenz CA X.509 Certificate Issuing For authenticating services using X509 certificates, ZTS Servers expect the configured cert signer factory class names in its athenz.zts.cert_signer_factory_class system property. Self Cert Signer com.yahoo.athenz.zts.cert.impl.SelfCertSignerFactory is a sample implementation of cert Signer we have for development environment. You can use SelfCertSigner or have your implementation of Cert Signer. Refer Certificate Signer for full details how to implement your cert signer. Start/Stop ZTS Server Start the ZTS Server by executing: $ cd athenz-zts-X.Y $ bin/zts start Based on the sample configuration file provided, ZTS Server will be listening on port 8443. Stop the ZTS Server by executing: $ cd athenz-zts-X.Y $ bin/zts stop","title":"ZTS Server"},{"location":"setup_zts/#setup-zts-authorization-token-system","text":"Requirements JDK 8 Getting Software Configuration Athenz CA X.509 Certificate Issuing Start/Stop ZTS Server","title":"Setup ZTS (authoriZation Token System)"},{"location":"setup_zts/#requirements","text":"The following tools are required to be installed on hosts configured to run ZTS server.","title":"Requirements"},{"location":"setup_zts/#jdk-8","text":"ZTS Server is written in Java and using embedded Jetty. Oracle Java Platform JDK 8 While ZTS has been developed and tested with Oracle Java Platform JDK 8 it should run successfully with OpenJDK 8 as well.","title":"JDK 8"},{"location":"setup_zts/#getting-software","text":"Download latest ZTS binary release from Bintray - click on the Files tab, choose the latest version directory and then download the athenz-zts- latest-version -bin.tar.gz file:: $ tar xvfz athenz-zts-X.Y-bin.tar.gz $ cd athenz-zts-X.Y","title":"Getting Software"},{"location":"setup_zts/#configuration","text":"To run ZTS Server, the system administrator must generate the keys, certificates and make necessary changes to the configuration settings. Since ZMS Server is running with a self-signed certificate, we need to generate a truststore for the java http client to use when communicating with the ZMS Server. For our configuration script we need the ZMS server hostname and a copy of the server certificate file. From your ZMS Server installation, copy the zms_cert.pem file from the athenz-zms-X.Y/var/zms_server/certs directory to a local directory on the host that will be running the ZTS Server. For the zms-public-cert-path argument below pass the full path of the zms_cert.pem. $ cd athenz-zms-X.Y $ bin/setup_dev_zts.sh zms-hostname zms-public-cert-path Running this setup script completes the following tasks: Generate a unique private key that ZTS Server will use to sign any ZTokens it issues Generate a self-signed X509 certificate for ZTS Server HTTPS support Generate a truststore for secure communication with the ZMS Server Registers the zts service in Athenz sys.auth domain Generates an Athenz configuration file","title":"Configuration"},{"location":"setup_zts/#athenz-ca-x509-certificate-issuing","text":"For authenticating services using X509 certificates, ZTS Servers expect the configured cert signer factory class names in its athenz.zts.cert_signer_factory_class system property. Self Cert Signer com.yahoo.athenz.zts.cert.impl.SelfCertSignerFactory is a sample implementation of cert Signer we have for development environment. You can use SelfCertSigner or have your implementation of Cert Signer. Refer Certificate Signer for full details how to implement your cert signer.","title":"Athenz CA X.509 Certificate Issuing"},{"location":"setup_zts/#startstop-zts-server","text":"Start the ZTS Server by executing: $ cd athenz-zts-X.Y $ bin/zts start Based on the sample configuration file provided, ZTS Server will be listening on port 8443. Stop the ZTS Server by executing: $ cd athenz-zts-X.Y $ bin/zts stop","title":"Start/Stop ZTS Server"},{"location":"setup_zts_prod/","text":"Setup ZTS (authoriZation Token System) for Production Requirements JDK 8 Getting Software Configuration Private/Public Key Pair Server X509 Certificate Register ZTS Service Generate Athenz Configuration File Athenz CA X.509 Certificate Issuing Start/Stop ZTS Server Requirements The following tools are required to be installed on hosts configured to run ZTS server. JDK 8 ZTS Server is written in Java and using embedded Jetty. Oracle Java Platform JDK 8 While ZTS has been developed and tested with Oracle Java Platform JDK 8 it should run successfully with OpenJDK 8 as well. Getting Software Download latest ZTS binary release from https://bintray.com/yahoo/maven/athenz-zts/_latestVersion#files $ tar xvfz athenz-zts-X.Y-bin.tar.gz $ cd athenz-zts-X.Y Configuration To run ZTS Server, the system administrator must generate the keys and make necessary changes to the configuration settings. Private/Public Key Pair Generate a unique private/public key pair that ZTS Server will use to sign any ZTokens it issues. From the athenz-zts-X.Y directory execute the following commands: $ cd var/zts_server/keys $ openssl genrsa -out zts_private.pem 2048 $ openssl rsa -in zts_private.pem -pubout zts_public.pem Server X509 Certificate While it is still possible to generate and use a self-signed X509 certificate for ZTS Servers, it is recommended to purchase one for your production server from a well known certificate authority. Having such a certificate installed on your ZTS Servers will no longer require to distribute the server's public certificate to other hosts (e.g. Hosts running ZPU). Follow the instructions provided by the Certificate Authority to generate your private key and then the Certificate Request (CSR). Once you have received your X509 certificate, we just need to add that certificate along with its private key to a keystore for Jetty use. From the athenz-zts-X.Y directory execute the following command: $ openssl pkcs12 -export -out zts_keystore.pkcs12 -in zts_cert.pem -inkey zts_key.pem Register ZTS Service In order for ZTS to access ZMS domain data, it must identify itself as a registered service in ZMS. Using the zms-cli utility, we will register a new service in sys.auth domain. Since ZMS Servers should be running with a X509 certificate from a well know certificate authority (not a self-signed one) we don't need to reference the CA cert like we did for the local/development environment setup. $ cd athenz-zts-X.Y $ bin/ platform /zms-cli -z https:// zms-server :4443/zms/v1 -d sys.auth add-service zts 0 var/zts_server/keys zts_public.pem Athenz CA X.509 Certificate Issuing For authenticating services using X509 certificates, ZTS Servers expect the configured cert signer factory class names in its athenz.zts.cert_signer_factory_class system property. We already have below implementation of cert Signer: Self Cert Signer com.yahoo.athenz.zts.cert.impl.SelfCertSignerFactory for the dev environment. Http Cert Signer com.yahoo.athenz.zts.cert.impl.HttpCertSignerFactory for the production environment. You can use HttpCert Signer or have your implementation of Cert Signer. Refer Certificate Signer for full details how to implement your own certificate signer. Generate Athenz Configuration File Generate an Athenz configuration file athenz.conf in athenz-zts-X.Y/conf/zts_server directory to include the ZMS Server URL and the registered public keys that the athenz client libraries and utilities will use to establish connection and validate any data signed by the ZMS Server: $ cd athenz-zts-X.Y $ bin/ platform /athenz-conf -o conf/zts_server/athenz.conf -z https:// zms-server :4443/ -t https:// zts-server :8443/ Start/Stop ZTS Server Start the ZTS Server by executing: $ cd athenz-zts-X.Y $ bin/zts start Based on the sample configuration file provided, ZTS Server will be listening on port 8443. Stop the ZTS Server by executing: $ cd athenz-zts-X.Y $ bin/zts stop","title":"ZTS Server"},{"location":"setup_zts_prod/#setup-zts-authorization-token-system-for-production","text":"Requirements JDK 8 Getting Software Configuration Private/Public Key Pair Server X509 Certificate Register ZTS Service Generate Athenz Configuration File Athenz CA X.509 Certificate Issuing Start/Stop ZTS Server","title":"Setup ZTS (authoriZation Token System) for Production"},{"location":"setup_zts_prod/#requirements","text":"The following tools are required to be installed on hosts configured to run ZTS server.","title":"Requirements"},{"location":"setup_zts_prod/#jdk-8","text":"ZTS Server is written in Java and using embedded Jetty. Oracle Java Platform JDK 8 While ZTS has been developed and tested with Oracle Java Platform JDK 8 it should run successfully with OpenJDK 8 as well.","title":"JDK 8"},{"location":"setup_zts_prod/#getting-software","text":"Download latest ZTS binary release from https://bintray.com/yahoo/maven/athenz-zts/_latestVersion#files $ tar xvfz athenz-zts-X.Y-bin.tar.gz $ cd athenz-zts-X.Y","title":"Getting Software"},{"location":"setup_zts_prod/#configuration","text":"To run ZTS Server, the system administrator must generate the keys and make necessary changes to the configuration settings.","title":"Configuration"},{"location":"setup_zts_prod/#privatepublic-key-pair","text":"Generate a unique private/public key pair that ZTS Server will use to sign any ZTokens it issues. From the athenz-zts-X.Y directory execute the following commands: $ cd var/zts_server/keys $ openssl genrsa -out zts_private.pem 2048 $ openssl rsa -in zts_private.pem -pubout zts_public.pem","title":"Private/Public Key Pair"},{"location":"setup_zts_prod/#server-x509-certificate","text":"While it is still possible to generate and use a self-signed X509 certificate for ZTS Servers, it is recommended to purchase one for your production server from a well known certificate authority. Having such a certificate installed on your ZTS Servers will no longer require to distribute the server's public certificate to other hosts (e.g. Hosts running ZPU). Follow the instructions provided by the Certificate Authority to generate your private key and then the Certificate Request (CSR). Once you have received your X509 certificate, we just need to add that certificate along with its private key to a keystore for Jetty use. From the athenz-zts-X.Y directory execute the following command: $ openssl pkcs12 -export -out zts_keystore.pkcs12 -in zts_cert.pem -inkey zts_key.pem","title":"Server X509 Certificate"},{"location":"setup_zts_prod/#register-zts-service","text":"In order for ZTS to access ZMS domain data, it must identify itself as a registered service in ZMS. Using the zms-cli utility, we will register a new service in sys.auth domain. Since ZMS Servers should be running with a X509 certificate from a well know certificate authority (not a self-signed one) we don't need to reference the CA cert like we did for the local/development environment setup. $ cd athenz-zts-X.Y $ bin/ platform /zms-cli -z https:// zms-server :4443/zms/v1 -d sys.auth add-service zts 0 var/zts_server/keys zts_public.pem","title":"Register ZTS Service"},{"location":"setup_zts_prod/#athenz-ca-x509-certificate-issuing","text":"For authenticating services using X509 certificates, ZTS Servers expect the configured cert signer factory class names in its athenz.zts.cert_signer_factory_class system property. We already have below implementation of cert Signer: Self Cert Signer com.yahoo.athenz.zts.cert.impl.SelfCertSignerFactory for the dev environment. Http Cert Signer com.yahoo.athenz.zts.cert.impl.HttpCertSignerFactory for the production environment. You can use HttpCert Signer or have your implementation of Cert Signer. Refer Certificate Signer for full details how to implement your own certificate signer.","title":"Athenz CA X.509 Certificate Issuing"},{"location":"setup_zts_prod/#generate-athenz-configuration-file","text":"Generate an Athenz configuration file athenz.conf in athenz-zts-X.Y/conf/zts_server directory to include the ZMS Server URL and the registered public keys that the athenz client libraries and utilities will use to establish connection and validate any data signed by the ZMS Server: $ cd athenz-zts-X.Y $ bin/ platform /athenz-conf -o conf/zts_server/athenz.conf -z https:// zms-server :4443/ -t https:// zts-server :8443/","title":"Generate Athenz Configuration File"},{"location":"setup_zts_prod/#startstop-zts-server","text":"Start the ZTS Server by executing: $ cd athenz-zts-X.Y $ bin/zts start Based on the sample configuration file provided, ZTS Server will be listening on port 8443. Stop the ZTS Server by executing: $ cd athenz-zts-X.Y $ bin/zts stop","title":"Start/Stop ZTS Server"},{"location":"system_view/","text":"Architecture - System View System Diagram ZMS ZTS SIA ZPE ZPU System Diagram Before we go into the details of the authorization flow, it's important to understand the subsystems involved. The authorization (AuthZ) system shown in the figure below consists of several logical subsystems, which we will elaborate on in the following section. ZMS (authZ Management System) ZMS is the source of truth for domains, roles, and policies for centralized authorization. In addition to allowing CRUD operations on the basic entities, ZMS provides an API to replicate the entities, per domain, to ZTS. ZMS supports a centralized call to check if a principal has access to a resource both for internal management system checks, as well as a simple centralized deployment. Because ZMS supports service identities, ZMS can authenticate services. For centralized authorization, ZMS may be the only Athenz subsystem that you need to interact with. ZTS (authZ Token System) ZTS, the authentication token service, is only needed to support decentralized or data plane functionality. In many ways, ZTS is like a local replica of ZMS's data to check a principal's authentication and confirm membership in roles within a domain. The authentication is in the form of a signed ZToken that can be presented to any decentralized service that wants to authorize access efficiently. Multiple ZTS instances can be distributed to different locations as needed to scale for issuing tokens. SIA (Service Identity Agent) Provider SIA (Service Identity Agent) Provider is part of the container, although likely built with Athenz libraries. As services are authenticated by their private keys, the job of the SIA Provider is to generate a NToken and sign it with the given private key so that the service can present that NToken to ZMS/ZTS as its identity credentials. The corresponding public key must be registered in ZMS so Athenz services can validate the signature. ZPE (AuthZ Policy Engine) Like ZTS, ZPE, the authorization policy engine is only needed to support decentralized authorization. ZPE is the subsystem of Athenz that evaluates policies for a set of roles to yield an allowed or a denied response. ZPE is a library that your service calls and only refers to a local policy cache for your services domain (a small amount of data). ZPU (AuthZ PolicyEngine Updater) Like ZTS and ZPE, ZPU is only needed to support decentralized authorization. The policy updater is the utility that retrieves from ZTS the policy files for provisioned domains on a host, which ZPE uses to evaluate access requests.","title":"System View"},{"location":"system_view/#architecture-system-view","text":"System Diagram ZMS ZTS SIA ZPE ZPU","title":"Architecture - System View"},{"location":"system_view/#system-diagram","text":"Before we go into the details of the authorization flow, it's important to understand the subsystems involved. The authorization (AuthZ) system shown in the figure below consists of several logical subsystems, which we will elaborate on in the following section.","title":"System Diagram"},{"location":"system_view/#zms-authz-management-system","text":"ZMS is the source of truth for domains, roles, and policies for centralized authorization. In addition to allowing CRUD operations on the basic entities, ZMS provides an API to replicate the entities, per domain, to ZTS. ZMS supports a centralized call to check if a principal has access to a resource both for internal management system checks, as well as a simple centralized deployment. Because ZMS supports service identities, ZMS can authenticate services. For centralized authorization, ZMS may be the only Athenz subsystem that you need to interact with.","title":"ZMS (authZ Management System)"},{"location":"system_view/#zts-authz-token-system","text":"ZTS, the authentication token service, is only needed to support decentralized or data plane functionality. In many ways, ZTS is like a local replica of ZMS's data to check a principal's authentication and confirm membership in roles within a domain. The authentication is in the form of a signed ZToken that can be presented to any decentralized service that wants to authorize access efficiently. Multiple ZTS instances can be distributed to different locations as needed to scale for issuing tokens.","title":"ZTS (authZ Token System)"},{"location":"system_view/#sia-service-identity-agent-provider","text":"SIA (Service Identity Agent) Provider is part of the container, although likely built with Athenz libraries. As services are authenticated by their private keys, the job of the SIA Provider is to generate a NToken and sign it with the given private key so that the service can present that NToken to ZMS/ZTS as its identity credentials. The corresponding public key must be registered in ZMS so Athenz services can validate the signature.","title":"SIA (Service Identity Agent) Provider"},{"location":"system_view/#zpe-authz-policy-engine","text":"Like ZTS, ZPE, the authorization policy engine is only needed to support decentralized authorization. ZPE is the subsystem of Athenz that evaluates policies for a set of roles to yield an allowed or a denied response. ZPE is a library that your service calls and only refers to a local policy cache for your services domain (a small amount of data).","title":"ZPE (AuthZ Policy Engine)"},{"location":"system_view/#zpu-authz-policyengine-updater","text":"Like ZTS and ZPE, ZPU is only needed to support decentralized authorization. The policy updater is the utility that retrieves from ZTS the policy files for provisioned domains on a host, which ZPE uses to evaluate access requests.","title":"ZPU (AuthZ PolicyEngine Updater)"},{"location":"zms_client/","text":"ZMS Client Utility Overview Getting Software Prerequisites Getting Help Specifying ZMS Environments How the ZMS Client Authenticates Listing registered domains in Athenz Displaying Administrators for a Product Domain Adding Domains Parameters Examples Registering Personal Domains Adding and Removing Administrators Adding a Group Role Parameters Example Managing a Group Role Membership Parameters Example Adding a Policy Parameters Example Overview The ZMS client utility allows administrators to manage Athenz domains, to check domain details, create personal domains, and add other administrators. Getting Software Download latest ZMS Client utility binary release from Bintray - click on the Files tab, choose the latest version directory and then download the athenz-utils- latest-version -bin.tar.gz file:: $ tar xvfz athenz-utils-X.Y-bin.tar.gz Prerequisites Before you can use the ZMS client utility, you need to have asked the Athenz administrators to create your top level domain. Getting Help The help argument for the utility will display all commands available through utility. $ zms-cli help To get additional details about a specific command: $ zms-cli help [ command ] For example, to get complete details on how to add a domain including examples: $ zms-cli help add-domain Specifying ZMS Environments Use the -z option to point to the required environment for executing commands. $ zms-cli -z https://zms-server.athenzcompany.com:4443/zms/v1 -d athenz show-domain How the ZMS Client Authenticates The Athenz ZMS server requires the user to provide its UserToken to authorize the requests. The UserToken is obtained from the ZMS Server with the user\u2019s credentials and is valid for one hour. Before communicating with the ZMS Server, the zms-cli utility: prompts for the user's password generates an Authorization header and passes it to ZMS to retrieve a UserToken After communicating with the ZMS Server, the zms-cli utility caches the user's NToken in the user's home directory in the file .ntoken . It will continue to use the token until it expires, and then will prompt for the user's password. Listing registered domains in Athenz To find out what domains have been provisioned in Athenz, run the following: $ zms-cli list-domain The list-domain command also takes an optional prefix argument to filter the domains and only return those that start with the specified string. For example, if the user wants to list only the domains that have been configured in the athenz product domain, he/she will run the following command: $ zms-cli list-domain athenz domains: - athenz - athenz.ci - athenz.qa Displaying Administrators for a Product Domain To view the full list of administrators for a given domain, run the following: $ zms-cli -d lt ; domain-name gt ; show-role admin For example, to view the Athenz system administrators for the domain media.news : $ zms-cli -d media.news show-role admin Adding Domains The Top Level Product Domains in ZMS are provisioned by Athenz administrators. Once the Product Domain has been created, the designated domain administrators can create any subdomains as necessary. To create a new domain, the administrator uses the add-domain command: $ zms-cli add-domain lt ; product sub domain gt ; [ lt ; admin1 gt ; lt ; admin2 gt ; ... ] Parameters lt;domain gt; The name of the domain to be added, which could either be a product domain or a subdomain. For example, to add a subdomain called storage in the athenz domain, the value for domain would be athenz.storage . The parent domain must exist before a subdomain can be created. The domain name can only include any letters, digits and the '-' character. The maximum length of the domain name (including all subdomain parts) is 256 bytes. [ lt;admin1 gt; ...] A space-separated list of administrators for the domain. The user creating the domain is automatically added as an administrator. Examples If user joe executes the command below, the product domain coretech is created and will include user.joe as an administrator: $ zms-cli add-domain coretech When user joe executes the command below, the sub domain athenz.ci is created and will have the administrators yby.joe , yby.john , and yby.jane : $ zms-cli add-domain athenz.ci yby.john yby.jane Registering Personal Domains ZMS supports Personal Domains. These domains are provisioned for users in the User user domain and have the same functionality as Product Domains in Athenz. The Personal Domain uses the syntax user. user-id and can have configured number of subdomains (default 2). For example, if your user ID is joe and you'd like to create a Personal Domain, you would run the following command: $ zms-cli add-domain user.joe Then, to create a subdomain called athenz-test in your Personal Domain, you would run the following command: $ zms-cli add-domain user.joe.athenz-test If the user wants to list only his/her personal domains that have been registered, he/she will run the following command: $ zms-cli list-domain user. lt ; user-id gt ; Adding and Removing Administrators Domain administrators are the principals listed as members of the role admin . When you create a domain, the role and corresponding policy role are created. Administrators can manage the list of current domain administrators by adding or removing members in the admin role. To add one or more administrators: $ zms-cli -d lt ; domain gt ; add-member admin lt ; user1 gt ; [ lt ; user2 gt ; ... ] To remove existing domain administrators: $ zms-cli -d lt ; domain gt ; delete-member admin lt ; user1 gt ; [ lt ; user2 gt ; ... ] ZMS allows you to remove yourself from the admin role. Once you ve been removed, you ll need to ask another domain administrator to re-add you to the `admin` role. Adding a Group Role To add new group role to a domain, the administrator will execute the following zms-cli command: $ zms-cli -d lt ; domain gt ; add-group-role lt ; role gt ; lt ; member gt ; [ lt ; member gt ; ... ] Parameters lt;domain gt; The name of the domain that the new role belongs to. lt;role gt; The name of the new role to be added. lt;member gt; [ lt;member gt; ...] A space-separated list of members for the role. At least one member must be specified. If the member is a regular user, then user's id must be prefixed with user. . Once the group has been created, the administrator can add and/or delete members using the add-member and delete-member commands. Example When the domain administrator executes the command below, a new role called readers will be added to the the domain athenz.ci will have the following members: user - yby.john and service - media.sports.storage : $ zms-cli -d athenz.ci add-group-role readers yby.john media.sports.storage Managing a Group Role Membership To add and/or delete members to/from a given role in a domain, the administrator will execute the following zms-cli commands: $ zms-cli -d lt ; domain gt ; add-member lt ; role gt ; lt ; member gt ; [ lt ; member gt ; ... ] $ zms-cli -d lt ; domain gt ; delete-member lt ; role gt ; lt ; member gt ; [ lt ; member gt ; ... ] Parameters lt;domain gt; The name of the domain that the role belongs to. lt;role gt; The name of the role that will be modified to add or remove members. lt;member gt; [ lt;member gt; ...] A space-separated list of members to be added to the role or to be removed from the role. At least one member must be specified. If the member is a regular user, the user's id must be prefixed with user. . When specifying service identities as members you must provide the full service name in then domain-name . service-name format. Example To add two new members: service \"media.sports.storage\" and user \"yby.john\", to a role called \"readers\" in the domain \"athenz\", the domain administrator will execute the following command: $ zms-cli -d athenz add-member readers yby.john media.sports.storage To delete member \"media.sports.storage\" from a role called \"writers\" in the domain \"athenz\", the domain administrator will execute the following command: $ zms-cli -d athenz delete-member writers media.sports.storage Adding a Policy To add new policy to a domain, the administrator will execute the following zms-cli command: $ zms-cli -d lt ; domain gt ; add-policy lt ; policy gt ; [ lt ; assertion gt ; ] Parameters lt;domain gt; The name of the domain that the new policy belongs to. lt;policy gt; The name of the new policy to be added. [ lt;assertion gt;] where lt;assertion gt; is lt;effect gt; lt;action gt; to lt;role gt; on lt;resource gt; The value effect must be either 'grant' or 'deny'. The action is the domain administrator defined action available for the resource (e.g. read, write, delete). The role is the name of the role this assertion applies to. The resource is the name of the resource this assertion applies to. Once the policy has been created, the administrator can add and/or delete assertions using the add-assertion and delete-assertion commands. Example When the domain administrator executes the command below, a new policy called writers will be added to the the domain athenz.ci that will grant write access to all the members of the sports_writers role on articles.sports.* : $ zms-cli -d athenz.ci add-policy writers grant write to sports_writers on articles.sports.*","title":"ZMS Client Utility"},{"location":"zms_client/#zms-client-utility","text":"Overview Getting Software Prerequisites Getting Help Specifying ZMS Environments How the ZMS Client Authenticates Listing registered domains in Athenz Displaying Administrators for a Product Domain Adding Domains Parameters Examples Registering Personal Domains Adding and Removing Administrators Adding a Group Role Parameters Example Managing a Group Role Membership Parameters Example Adding a Policy Parameters Example","title":"ZMS Client Utility"},{"location":"zms_client/#overview","text":"The ZMS client utility allows administrators to manage Athenz domains, to check domain details, create personal domains, and add other administrators.","title":"Overview"},{"location":"zms_client/#getting-software","text":"Download latest ZMS Client utility binary release from Bintray - click on the Files tab, choose the latest version directory and then download the athenz-utils- latest-version -bin.tar.gz file:: $ tar xvfz athenz-utils-X.Y-bin.tar.gz","title":"Getting Software"},{"location":"zms_client/#prerequisites","text":"Before you can use the ZMS client utility, you need to have asked the Athenz administrators to create your top level domain.","title":"Prerequisites"},{"location":"zms_client/#getting-help","text":"The help argument for the utility will display all commands available through utility. $ zms-cli help To get additional details about a specific command: $ zms-cli help [ command ] For example, to get complete details on how to add a domain including examples: $ zms-cli help add-domain","title":"Getting Help"},{"location":"zms_client/#specifying-zms-environments","text":"Use the -z option to point to the required environment for executing commands. $ zms-cli -z https://zms-server.athenzcompany.com:4443/zms/v1 -d athenz show-domain","title":"Specifying ZMS Environments"},{"location":"zms_client/#how-the-zms-client-authenticates","text":"The Athenz ZMS server requires the user to provide its UserToken to authorize the requests. The UserToken is obtained from the ZMS Server with the user\u2019s credentials and is valid for one hour. Before communicating with the ZMS Server, the zms-cli utility: prompts for the user's password generates an Authorization header and passes it to ZMS to retrieve a UserToken After communicating with the ZMS Server, the zms-cli utility caches the user's NToken in the user's home directory in the file .ntoken . It will continue to use the token until it expires, and then will prompt for the user's password.","title":"How the ZMS Client Authenticates"},{"location":"zms_client/#listing-registered-domains-in-athenz","text":"To find out what domains have been provisioned in Athenz, run the following: $ zms-cli list-domain The list-domain command also takes an optional prefix argument to filter the domains and only return those that start with the specified string. For example, if the user wants to list only the domains that have been configured in the athenz product domain, he/she will run the following command: $ zms-cli list-domain athenz domains: - athenz - athenz.ci - athenz.qa","title":"Listing registered domains in Athenz"},{"location":"zms_client/#displaying-administrators-for-a-product-domain","text":"To view the full list of administrators for a given domain, run the following: $ zms-cli -d lt ; domain-name gt ; show-role admin For example, to view the Athenz system administrators for the domain media.news : $ zms-cli -d media.news show-role admin","title":"Displaying Administrators for a Product Domain"},{"location":"zms_client/#adding-domains","text":"The Top Level Product Domains in ZMS are provisioned by Athenz administrators. Once the Product Domain has been created, the designated domain administrators can create any subdomains as necessary. To create a new domain, the administrator uses the add-domain command: $ zms-cli add-domain lt ; product sub domain gt ; [ lt ; admin1 gt ; lt ; admin2 gt ; ... ]","title":"Adding Domains"},{"location":"zms_client/#parameters","text":"lt;domain gt; The name of the domain to be added, which could either be a product domain or a subdomain. For example, to add a subdomain called storage in the athenz domain, the value for domain would be athenz.storage . The parent domain must exist before a subdomain can be created. The domain name can only include any letters, digits and the '-' character. The maximum length of the domain name (including all subdomain parts) is 256 bytes. [ lt;admin1 gt; ...] A space-separated list of administrators for the domain. The user creating the domain is automatically added as an administrator.","title":"Parameters"},{"location":"zms_client/#examples","text":"If user joe executes the command below, the product domain coretech is created and will include user.joe as an administrator: $ zms-cli add-domain coretech When user joe executes the command below, the sub domain athenz.ci is created and will have the administrators yby.joe , yby.john , and yby.jane : $ zms-cli add-domain athenz.ci yby.john yby.jane","title":"Examples"},{"location":"zms_client/#registering-personal-domains","text":"ZMS supports Personal Domains. These domains are provisioned for users in the User user domain and have the same functionality as Product Domains in Athenz. The Personal Domain uses the syntax user. user-id and can have configured number of subdomains (default 2). For example, if your user ID is joe and you'd like to create a Personal Domain, you would run the following command: $ zms-cli add-domain user.joe Then, to create a subdomain called athenz-test in your Personal Domain, you would run the following command: $ zms-cli add-domain user.joe.athenz-test If the user wants to list only his/her personal domains that have been registered, he/she will run the following command: $ zms-cli list-domain user. lt ; user-id gt ;","title":"Registering Personal Domains"},{"location":"zms_client/#adding-and-removing-administrators","text":"Domain administrators are the principals listed as members of the role admin . When you create a domain, the role and corresponding policy role are created. Administrators can manage the list of current domain administrators by adding or removing members in the admin role. To add one or more administrators: $ zms-cli -d lt ; domain gt ; add-member admin lt ; user1 gt ; [ lt ; user2 gt ; ... ] To remove existing domain administrators: $ zms-cli -d lt ; domain gt ; delete-member admin lt ; user1 gt ; [ lt ; user2 gt ; ... ] ZMS allows you to remove yourself from the admin role. Once you ve been removed, you ll need to ask another domain administrator to re-add you to the `admin` role.","title":"Adding and Removing Administrators"},{"location":"zms_client/#adding-a-group-role","text":"To add new group role to a domain, the administrator will execute the following zms-cli command: $ zms-cli -d lt ; domain gt ; add-group-role lt ; role gt ; lt ; member gt ; [ lt ; member gt ; ... ]","title":"Adding a Group Role"},{"location":"zms_client/#parameters_1","text":"lt;domain gt; The name of the domain that the new role belongs to. lt;role gt; The name of the new role to be added. lt;member gt; [ lt;member gt; ...] A space-separated list of members for the role. At least one member must be specified. If the member is a regular user, then user's id must be prefixed with user. . Once the group has been created, the administrator can add and/or delete members using the add-member and delete-member commands.","title":"Parameters"},{"location":"zms_client/#example","text":"When the domain administrator executes the command below, a new role called readers will be added to the the domain athenz.ci will have the following members: user - yby.john and service - media.sports.storage : $ zms-cli -d athenz.ci add-group-role readers yby.john media.sports.storage","title":"Example"},{"location":"zms_client/#managing-a-group-role-membership","text":"To add and/or delete members to/from a given role in a domain, the administrator will execute the following zms-cli commands: $ zms-cli -d lt ; domain gt ; add-member lt ; role gt ; lt ; member gt ; [ lt ; member gt ; ... ] $ zms-cli -d lt ; domain gt ; delete-member lt ; role gt ; lt ; member gt ; [ lt ; member gt ; ... ]","title":"Managing a Group Role Membership"},{"location":"zms_client/#parameters_2","text":"lt;domain gt; The name of the domain that the role belongs to. lt;role gt; The name of the role that will be modified to add or remove members. lt;member gt; [ lt;member gt; ...] A space-separated list of members to be added to the role or to be removed from the role. At least one member must be specified. If the member is a regular user, the user's id must be prefixed with user. . When specifying service identities as members you must provide the full service name in then domain-name . service-name format.","title":"Parameters"},{"location":"zms_client/#example_1","text":"To add two new members: service \"media.sports.storage\" and user \"yby.john\", to a role called \"readers\" in the domain \"athenz\", the domain administrator will execute the following command: $ zms-cli -d athenz add-member readers yby.john media.sports.storage To delete member \"media.sports.storage\" from a role called \"writers\" in the domain \"athenz\", the domain administrator will execute the following command: $ zms-cli -d athenz delete-member writers media.sports.storage","title":"Example"},{"location":"zms_client/#adding-a-policy","text":"To add new policy to a domain, the administrator will execute the following zms-cli command: $ zms-cli -d lt ; domain gt ; add-policy lt ; policy gt ; [ lt ; assertion gt ; ]","title":"Adding a Policy"},{"location":"zms_client/#parameters_3","text":"lt;domain gt; The name of the domain that the new policy belongs to. lt;policy gt; The name of the new policy to be added. [ lt;assertion gt;] where lt;assertion gt; is lt;effect gt; lt;action gt; to lt;role gt; on lt;resource gt; The value effect must be either 'grant' or 'deny'. The action is the domain administrator defined action available for the resource (e.g. read, write, delete). The role is the name of the role this assertion applies to. The resource is the name of the resource this assertion applies to. Once the policy has been created, the administrator can add and/or delete assertions using the add-assertion and delete-assertion commands.","title":"Parameters"},{"location":"zms_client/#example_2","text":"When the domain administrator executes the command below, a new policy called writers will be added to the the domain athenz.ci that will grant write access to all the members of the sports_writers role on articles.sports.* : $ zms-cli -d athenz.ci add-policy writers grant write to sports_writers on articles.sports.*","title":"Example"},{"location":"zpu_policy_file/","text":"ZPU Policy File Policy File Signature Validation ZTS Signature Validation ZMS Signature Validation Policy File Structure ZPU is only needed to support decentralized authorization. The policy updater is the utility that retrieves from ZTS the policy files for provisioned domains on a host, which ZPE uses to evaluate access requests. The ZPE library automatically parses the policy file, validates it, and uses it for authorization checks. This document describes the format and how to validate the policy file. Policy File Signature Validation The policy file data which is provided in json format is signed by both ZMS and ZTS servers since ZMS is the authority on policy data but the file is downloaded from ZTS servers. ZTS Signature Validation To validate the ZTS signature, the json is presented in the following structure: {\"signedPolicyData\": zts-data ,\"keyId\":\" key-id ,\"signature\":\" signature \"} a) Extract the key-id and fetch the public key with that key identifier from Athenz for service zts in domain sys.auth . For example, using zms-cli command line utility: $ zms-cli -d sys.auth show-public-key zts zts1.0 public-key: keyID: zts1.0 value: LS0tLS1CRUdJTiBQVUJMSUMgS0VZLS0tLS0KTUZrd0V...WS0tLS0tCg-- The public key is encoded in YBase64 encoding so it must be decoded before the public key can be used to validate the signature. Checkout YBase64 class implemenation in athenz-auth-core library for details. b) Validate the signature of the extracted zts-data string using Bouncycastle. signature field is also YBase64 encoded, so it must be decoded before using in the verify function. 1) Load the public key retrieved in step (a) and generate a PublicKey object. 2) Generate the signature algorithm based on the public key algorithm. ZTS server is using SHA256 digest algorithm with either RSA or ECSDA keys so the possible values are either RSA_SHA256 or ECDSA_SHA256. 3) Generate a signer and verify the signature (include proper exception handling): java.security.Signature signer = java.security.Signature.getInstance(signatureAlgorithm, BC_PROVIDER); signer.initVerify(publicKey); signer.update(utf8Bytes(ztsData)); boolean valid = signer.verify(signature); ZMS Signature Validation To validate the ZMS signature, we need to further parse the zts-data object we retrieved in the ZTS Signture validation section. That json has the following structure: {\"expires\":\" expiry-date \",\"modified\":\" modified-date \",\"policyData\": zms-data ,\"zmsKeyId\":\" key-id ,\"zmsSignature\":\" signature \"} a) Extract the key-id and fetch the public key with that key identifier from Athenz for service zms in domain sys.auth . For example, using zms-cli command line utility: $ zms-cli -d sys.auth show-public-key zms zms1.0 public-key: keyID: zms1.0 value: LS0tLS1CRUdJTiBQVUJMSUMgS0VZLS0tLS0KTUZrd0V...WS0tLS0tCg-- The public key is encoded in YBase64 encoding so it must be decoded before the public key can be used to validate the signature. Checkout YBase64 class implemenation in athenz-auth-core library for details. b) Validate the signature of the extracted zms-data string using Bouncycastle. signature field is also YBase64 encoded, so it must be decoded before using in the verify function. 1) Load the public key retrieved in step (a) and generate a PublicKey object. 2) Generate the signature algorithm based on the public key algorithm. ZMS server is using SHA256 digest algorithm with either RSA or ECSDA keys so the possible values are either RSA_SHA256 or ECDSA_SHA256. 3) Generate a signer and verify the signature (include proper exception handling): java.security.Signature signer = java.security.Signature.getInstance(signatureAlgorithm, BC_PROVIDER); signer.initVerify(publicKey); signer.update(utf8Bytes(zmsData)); boolean valid = signer.verify(signature); Policy File Structure Athenz Services are using RDL to represent its objects. These should directly map to json objects: type DomainSignedPolicyData Struct { SignedPolicyData signedPolicyData; //policy data signed by ZMS String signature; //signature generated based on the domain policies object String keyId; //the identifier of the key used to generate the signature } type SignedPolicyData Struct { PolicyData policyData; //list of policies defined in a domain String zmsSignature; //zms signature generated based on the domain policies object String zmsKeyId; //the identifier of the zms key used to generate the signature Timestamp modified; //when the domain itself was last modified Timestamp expires; //timestamp specifying the expiration time for using this set of policies } type PolicyData Struct { DomainName domain; //name of the domain Array Policy policies; //list of policies defined in this server } type Policy Struct { ResourceName name; //name of the policy Timestamp modified (optional); //last modification timestamp of this policy Array Assertion assertions; //list of defined assertions for this policy } type Assertion Struct { String role; //the subject of the assertion, a role String resource; //the object of the assertion. Must be in the local namespace. Can contain wildcards String action; //the predicate of the assertion. Can contain wildcards AssertionEffect effect (optional, default=ALLOW); //the effect of the assertion in the policy language Int64 id (optional); //assertion id - auto generated by server } type AssertionEffect Enum { ALLOW, DENY } DomainName and ResourceName reference regular Strings. The zts java model classes are available in the athenz-zts-core library. dependencies dependency groupId com.yahoo.athenz /groupId artifactId athenz-zts-core /artifactId version 1.7.51 /version /dependency /dependencies repositories repository snapshots enabled false /enabled /snapshots id bintray-yahoo-maven /id name bintray /name url http://yahoo.bintray.com/maven /url /repository /repositories","title":"ZPU Policy File"},{"location":"zpu_policy_file/#zpu-policy-file","text":"Policy File Signature Validation ZTS Signature Validation ZMS Signature Validation Policy File Structure ZPU is only needed to support decentralized authorization. The policy updater is the utility that retrieves from ZTS the policy files for provisioned domains on a host, which ZPE uses to evaluate access requests. The ZPE library automatically parses the policy file, validates it, and uses it for authorization checks. This document describes the format and how to validate the policy file.","title":"ZPU Policy File"},{"location":"zpu_policy_file/#policy-file-signature-validation","text":"The policy file data which is provided in json format is signed by both ZMS and ZTS servers since ZMS is the authority on policy data but the file is downloaded from ZTS servers.","title":"Policy File Signature Validation"},{"location":"zpu_policy_file/#zts-signature-validation","text":"To validate the ZTS signature, the json is presented in the following structure: {\"signedPolicyData\": zts-data ,\"keyId\":\" key-id ,\"signature\":\" signature \"} a) Extract the key-id and fetch the public key with that key identifier from Athenz for service zts in domain sys.auth . For example, using zms-cli command line utility: $ zms-cli -d sys.auth show-public-key zts zts1.0 public-key: keyID: zts1.0 value: LS0tLS1CRUdJTiBQVUJMSUMgS0VZLS0tLS0KTUZrd0V...WS0tLS0tCg-- The public key is encoded in YBase64 encoding so it must be decoded before the public key can be used to validate the signature. Checkout YBase64 class implemenation in athenz-auth-core library for details. b) Validate the signature of the extracted zts-data string using Bouncycastle. signature field is also YBase64 encoded, so it must be decoded before using in the verify function. 1) Load the public key retrieved in step (a) and generate a PublicKey object. 2) Generate the signature algorithm based on the public key algorithm. ZTS server is using SHA256 digest algorithm with either RSA or ECSDA keys so the possible values are either RSA_SHA256 or ECDSA_SHA256. 3) Generate a signer and verify the signature (include proper exception handling): java.security.Signature signer = java.security.Signature.getInstance(signatureAlgorithm, BC_PROVIDER); signer.initVerify(publicKey); signer.update(utf8Bytes(ztsData)); boolean valid = signer.verify(signature);","title":"ZTS Signature Validation"},{"location":"zpu_policy_file/#zms-signature-validation","text":"To validate the ZMS signature, we need to further parse the zts-data object we retrieved in the ZTS Signture validation section. That json has the following structure: {\"expires\":\" expiry-date \",\"modified\":\" modified-date \",\"policyData\": zms-data ,\"zmsKeyId\":\" key-id ,\"zmsSignature\":\" signature \"} a) Extract the key-id and fetch the public key with that key identifier from Athenz for service zms in domain sys.auth . For example, using zms-cli command line utility: $ zms-cli -d sys.auth show-public-key zms zms1.0 public-key: keyID: zms1.0 value: LS0tLS1CRUdJTiBQVUJMSUMgS0VZLS0tLS0KTUZrd0V...WS0tLS0tCg-- The public key is encoded in YBase64 encoding so it must be decoded before the public key can be used to validate the signature. Checkout YBase64 class implemenation in athenz-auth-core library for details. b) Validate the signature of the extracted zms-data string using Bouncycastle. signature field is also YBase64 encoded, so it must be decoded before using in the verify function. 1) Load the public key retrieved in step (a) and generate a PublicKey object. 2) Generate the signature algorithm based on the public key algorithm. ZMS server is using SHA256 digest algorithm with either RSA or ECSDA keys so the possible values are either RSA_SHA256 or ECDSA_SHA256. 3) Generate a signer and verify the signature (include proper exception handling): java.security.Signature signer = java.security.Signature.getInstance(signatureAlgorithm, BC_PROVIDER); signer.initVerify(publicKey); signer.update(utf8Bytes(zmsData)); boolean valid = signer.verify(signature);","title":"ZMS Signature Validation"},{"location":"zpu_policy_file/#policy-file-structure","text":"Athenz Services are using RDL to represent its objects. These should directly map to json objects: type DomainSignedPolicyData Struct { SignedPolicyData signedPolicyData; //policy data signed by ZMS String signature; //signature generated based on the domain policies object String keyId; //the identifier of the key used to generate the signature } type SignedPolicyData Struct { PolicyData policyData; //list of policies defined in a domain String zmsSignature; //zms signature generated based on the domain policies object String zmsKeyId; //the identifier of the zms key used to generate the signature Timestamp modified; //when the domain itself was last modified Timestamp expires; //timestamp specifying the expiration time for using this set of policies } type PolicyData Struct { DomainName domain; //name of the domain Array Policy policies; //list of policies defined in this server } type Policy Struct { ResourceName name; //name of the policy Timestamp modified (optional); //last modification timestamp of this policy Array Assertion assertions; //list of defined assertions for this policy } type Assertion Struct { String role; //the subject of the assertion, a role String resource; //the object of the assertion. Must be in the local namespace. Can contain wildcards String action; //the predicate of the assertion. Can contain wildcards AssertionEffect effect (optional, default=ALLOW); //the effect of the assertion in the policy language Int64 id (optional); //assertion id - auto generated by server } type AssertionEffect Enum { ALLOW, DENY } DomainName and ResourceName reference regular Strings. The zts java model classes are available in the athenz-zts-core library. dependencies dependency groupId com.yahoo.athenz /groupId artifactId athenz-zts-core /artifactId version 1.7.51 /version /dependency /dependencies repositories repository snapshots enabled false /enabled /snapshots id bintray-yahoo-maven /id name bintray /name url http://yahoo.bintray.com/maven /url /repository /repositories","title":"Policy File Structure"}]}