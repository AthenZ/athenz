{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Athenz is a set of services and libraries supporting service authentication and role-based authorization (RBAC) for provisioning and configuration (centralized authorization) use cases as well as serving/runtime (decentralized authorization) use cases. Athenz authorization system utilizes x.509 certificates and Access Tokens. The name \"Athenz\" is derived from \"AuthNZ\" (N for authentication and Z for authorization). It provides support for the following three major functional areas. Service Authentication \u00b6 Athenz provides secure identity in the form of short lived X.509 certificate and a certificate and IP-based distributed system to handle for every workload or service deployed in private (e.g. Openstack, K8S, Screwdriver) on-box enforcement. or public cloud (e.g. AWS EC2, ECS, Fargate, Lambda). Using these X.509 certificates clients and services establish secure connections and through mutual TLS authentication verify each other's identity. The service identity certificates are valid for 30 days only and the service identity agents (SIA) part of those frameworks automatically refresh them daily. The term service within Athenz is more generic than a traditional service. A service identity could represent a command, job, daemon, workflow, as well as both an application client and an application service. Since Athenz service authentication is based on X.509 certificates , it is important that you have a good understanding what X.509 certificates are and how they're used to establish secure connections in Internet protocols such as TLS . Role-Based Authorization (RBAC) \u00b6 Once the client is authenticated with its x.509 certificate, the service their own role-based access control systems that have no central store can then check if the given client is authorized to carry out the requested and often rely on network ACLs and manual updating. action. Athenz provides fine-grained role-based access control (RBAC) support for a centralized management system with support for control-plane access control decisions and a decentralized enforcement mechanism suitable for data-plane access control decisions. It also provides a delegated management model that supports multi-tenant and self-service concepts. AWS Temporary Credentials Support \u00b6 When working with AWS, Athenz provides support to access AWS services from on-prem services with using AWS temporary credentials rather than static credentials. Athenz ZTS server can be used to request AWS temporary credentials for configured AWS IAM roles.","title":"About"},{"location":"#service-authentication","text":"Athenz provides secure identity in the form of short lived X.509 certificate and a certificate and IP-based distributed system to handle for every workload or service deployed in private (e.g. Openstack, K8S, Screwdriver) on-box enforcement. or public cloud (e.g. AWS EC2, ECS, Fargate, Lambda). Using these X.509 certificates clients and services establish secure connections and through mutual TLS authentication verify each other's identity. The service identity certificates are valid for 30 days only and the service identity agents (SIA) part of those frameworks automatically refresh them daily. The term service within Athenz is more generic than a traditional service. A service identity could represent a command, job, daemon, workflow, as well as both an application client and an application service. Since Athenz service authentication is based on X.509 certificates , it is important that you have a good understanding what X.509 certificates are and how they're used to establish secure connections in Internet protocols such as TLS .","title":"Service Authentication"},{"location":"#role-based-authorization-rbac","text":"Once the client is authenticated with its x.509 certificate, the service their own role-based access control systems that have no central store can then check if the given client is authorized to carry out the requested and often rely on network ACLs and manual updating. action. Athenz provides fine-grained role-based access control (RBAC) support for a centralized management system with support for control-plane access control decisions and a decentralized enforcement mechanism suitable for data-plane access control decisions. It also provides a delegated management model that supports multi-tenant and self-service concepts.","title":"Role-Based Authorization (RBAC)"},{"location":"#aws-temporary-credentials-support","text":"When working with AWS, Athenz provides support to access AWS services from on-prem services with using AWS temporary credentials rather than static credentials. Athenz ZTS server can be used to request AWS temporary credentials for configured AWS IAM roles.","title":"AWS Temporary Credentials Support"},{"location":"athenz_templates/","text":"Introducing Athenz Templates \u00b6 Templates are a collection of predefined roles, policies and services that can be applied on a domain. Imagine in a real world scenario if you are creating a solution for any organization(Openstack, Kubernetes) and subsequently want to set up provisioning rules(a static set of roles and policies) for the solution, rather than requiring each domain admin to create each of these roles and policies manually, you can pre-bundle the roles and policies as a template and Athenz will automatically apply them for you while creating or updating a domain. Templates \u00b6 Creating and updating templates \u00b6 All templates will be managed by the Athenz System Administrators. To create / update templates, the administrators should create a file named solution_templates.json and store it in their data repository. The file should follow the format below { \"<template_name>\": { \"metadata\": {}, \"roles\": [<athenz-roles>], \"policies\": [<athenz-policies>], \"services\": [<athenz-services>] } } A sample file can be found at servers/zms/conf/solution_templates.json Template Entities \u00b6 A Template consists of metadata, services, roles and role metadata, policies with assertions. Please find the explanation for every entity below MetaData \u00b6 Metadata contains critical fields to represent vital characteristics of a template. Look at the sample structure below for one of the templates in use. \"metadata\": { \"latestVersion\": 1, \"timestamp\": \"2020-06-16T00:00:00.000Z\", \"description\": \"Description of template\", \"keywordsToReplace\": \"_env_,_track_\", \"autoUpdate\": false } A - Description - description of the template (restrict it to 140 characters if possible) B - latestVersion - to manage versioning. Everytime there is a change in the template including a template metadata change, Make sure to bump up the latestVersion field by 1. C - Timestamp - recorded timestamp when you update(including metadata change) a template. This is purely to help you time track template changes. D - keywordsToReplace - this field is a comma separated placeholder you can add to your role/policy name which will be auto replaced on the fly. for ex: keywordsToReplace will be set to \u201c env , track \u201d for a role name \u201c domain :role.some-role. env .track. track .emitters\". You should leave keywordsToReplace field empty if you do not have any placeholders in your role or policy name. (for ex: \"keywordsToReplace\": \"\",) Note: domain is the only exception here. When applying a template to a domain, the server will automatically include the correct domain name in role/policy names by replacing the domain placeholder with the appropriate value so do not worry about adding it. Example structure of roles/policies which uses multiple placeholders: \"roles\": [ { \"name\": \"_domain_:role.some-role._env_.track._track_.emitters\", \"modified\": \"1970-01-01T00:00:00.000Z\" } ], \"policies\": [ { \"name\": \"_domain_:policy.some-policy._env_.track._track_.emitters\", \"modified\": \"1970-01-01T00:00:00.000Z\", \"assertions\": [ { \"resource\": \"some-resource._env_:role.track._track_.emitters\", \"role\": \"_domain_:role.some-role._env_.track._track_.emitters\", \"action\": \"assume_role\" } ] } ] Roles \u00b6 Roles can have attributes like name, modified timestamp, Role Meta attributes (check the complete role meta attributes list below) and roleMembers. By default roles that are created by the template will not have any members unless the role members are hard-coded in the template (check the example structure below). The domain administrator will need to add members to those roles after the domain is created or the template has been applied to a domain. Now if you notice role members array in the image below, members can also have placeholders which have to be added to keywordsToReplace. Sample structure for Roles with role members: \"roles\": [ { \"name\": \"_domain_:role.aws_instance_launch_provider\", \"modified\": \"1970-01-01T00:00:00.000Z\", \"roleMembers\": [ { \"memberName\": \"athens.aws.*\" } ] }, { \"name\": \"_domain_:role.aws.ssh_login\", \"modified\": \"1970-01-01T00:00:00.000Z\" }, { \"name\": \"_domain_:role.aws_ssh_cert_request\", \"modified\": \"1970-01-01T00:00:00.000Z\", \"roleMembers\": [ { \"memberName\": \"_domain_._service_\" } ] } ] Allowed Role Meta Attributes: \"selfServe\": \"false\", \"memberExpiryDays\": 90, \"tokenExpiryMins\": 30, \"certExpiryMins\": 10, \"serviceExpiryDays\": 50, \"memberReviewDays\": 65, \"serviceReviewDays\": 15, \"reviewEnabled\": true Policies \u00b6 Array of policies with name, modified timestamp and array of assertions. Check the sample Json below. \"policies\": [ { \"name\": \"_domain_:policy.aws_instance_launch_provider\", \"modified\": \"1970-01-01T00:00:00.000Z\", \"assertions\": [ { \"resource\": \"_domain_:service._service_\", \"role\": \"_domain_:role.aws_instance_launch_provider\", \"action\": \"launch\" } ] }, { \"name\": \"_domain_:policy.aws.ssh_login\", \"modified\": \"1970-01-01T00:00:00.000Z\", \"assertions\": [ { \"resource\": \"_domain_:aws._service_.*\", \"role\": \"_domain_:role.aws.ssh_login\", \"action\": \"ssh_login\", \"effect\": \"DENY\" } ] } Applying Templates \u00b6 Templates can be applied via ZMS CLI and via Athenz UI. let's take a look at a few examples on how to apply different types of templates. Example 1 \u00b6 Templates with placeholders in role and policy names (aka comma separated values in keywordsToReplace under template metadata field) will have to pass the key value pair for all placeholders via CLI. However, Athenz UI will automatically detect the placeholders and prompt the user to enter those placeholder values without which you cannot apply a template CLI \u00b6 zms-cli -d some-domain set-domain-template some-template-name env=ecli track=clit UI \u00b6 Example 2 \u00b6 Templates with static role and policy names i.e. no placeholders zms-cli -d some-domain set-domain-template other-template-name UI \u00b6 The update button with blue background means there is a latest version of the template available to apply and the update button with white background means there is no new version but you can still apply if you accidentally deleted a policy or role which is part of the template and wanted to patch it up. Auto Update \u00b6 Auto update flag in templates lets the zms server to patch up the changes made to roles and policies automatically. This way the template creator does not need to communicate the tenant domains to patch them up manually through Athenz UI or CLI. AutoUpdate runs on zms servers during application startup in an uninterrupted fashion and applies roles and policies for all eligible templates. This feature will work only for templates with no placeholders at the moment i.e. the metadata section in the template should have the following values keywordsToReplace=\"\" and autoUpdate set to true. Note: it is important to bump up the latestVersion flag to apply any changes in the template including metadata changes like autoUpdate and keywordsToReplace. FAQ \u00b6 1 - What happens if i set the auto-update flag to true in template metadata but did not bump up the version? \u00b6 Auto update will not kick in if the server does not detect a version bump in the template. 2 - Is there a way to apply a template for the first time on a newly created domain in UI? \u00b6 No. you can only update a template in the UI using the apply template button. You have to apply template for the first time via Cli 3 - What happens if i pass a template name that is invalid via CLI? \u00b6 If any of the template names is invalid, the request will be rejected with a Bad Request error message indicating the invalid template name. If the template is not found, then the request will be rejected with a Not Found error message indicating the template name that\u2019s not registered in ZMS. 4 - What is the difference between current version and latest version in the UI? \u00b6 Current version is the template version already applied on your domain and the latest version is a new version that is available for you to apply. You will see a dark blue button in the UI when there is a latest version. 5 - What should i do if i deleted a role or policy which is part of a template by accident? \u00b6 Go to the UI and click on the update button(with white background if the template already has the latest version) and the roles and policies will be recreated. 6 - What if I accidentally created a bunch of roles and policies while experimenting with a template and wanted to delete it? \u00b6 One has to manually clean it up. 7 - What are the different zms-cli commands to manage templates? \u00b6 Template commands: list-server-template list-domain-template show-server-template template set-domain-template template [template ...] [param-key=param-value ...] delete-domain-template template","title":"Athenz Templates"},{"location":"athenz_templates/#introducing-athenz-templates","text":"Templates are a collection of predefined roles, policies and services that can be applied on a domain. Imagine in a real world scenario if you are creating a solution for any organization(Openstack, Kubernetes) and subsequently want to set up provisioning rules(a static set of roles and policies) for the solution, rather than requiring each domain admin to create each of these roles and policies manually, you can pre-bundle the roles and policies as a template and Athenz will automatically apply them for you while creating or updating a domain.","title":"Introducing Athenz Templates"},{"location":"athenz_templates/#templates","text":"","title":"Templates"},{"location":"athenz_templates/#creating-and-updating-templates","text":"All templates will be managed by the Athenz System Administrators. To create / update templates, the administrators should create a file named solution_templates.json and store it in their data repository. The file should follow the format below { \"<template_name>\": { \"metadata\": {}, \"roles\": [<athenz-roles>], \"policies\": [<athenz-policies>], \"services\": [<athenz-services>] } } A sample file can be found at servers/zms/conf/solution_templates.json","title":"Creating and updating templates"},{"location":"athenz_templates/#template-entities","text":"A Template consists of metadata, services, roles and role metadata, policies with assertions. Please find the explanation for every entity below","title":"Template Entities"},{"location":"athenz_templates/#metadata","text":"Metadata contains critical fields to represent vital characteristics of a template. Look at the sample structure below for one of the templates in use. \"metadata\": { \"latestVersion\": 1, \"timestamp\": \"2020-06-16T00:00:00.000Z\", \"description\": \"Description of template\", \"keywordsToReplace\": \"_env_,_track_\", \"autoUpdate\": false } A - Description - description of the template (restrict it to 140 characters if possible) B - latestVersion - to manage versioning. Everytime there is a change in the template including a template metadata change, Make sure to bump up the latestVersion field by 1. C - Timestamp - recorded timestamp when you update(including metadata change) a template. This is purely to help you time track template changes. D - keywordsToReplace - this field is a comma separated placeholder you can add to your role/policy name which will be auto replaced on the fly. for ex: keywordsToReplace will be set to \u201c env , track \u201d for a role name \u201c domain :role.some-role. env .track. track .emitters\". You should leave keywordsToReplace field empty if you do not have any placeholders in your role or policy name. (for ex: \"keywordsToReplace\": \"\",) Note: domain is the only exception here. When applying a template to a domain, the server will automatically include the correct domain name in role/policy names by replacing the domain placeholder with the appropriate value so do not worry about adding it. Example structure of roles/policies which uses multiple placeholders: \"roles\": [ { \"name\": \"_domain_:role.some-role._env_.track._track_.emitters\", \"modified\": \"1970-01-01T00:00:00.000Z\" } ], \"policies\": [ { \"name\": \"_domain_:policy.some-policy._env_.track._track_.emitters\", \"modified\": \"1970-01-01T00:00:00.000Z\", \"assertions\": [ { \"resource\": \"some-resource._env_:role.track._track_.emitters\", \"role\": \"_domain_:role.some-role._env_.track._track_.emitters\", \"action\": \"assume_role\" } ] } ]","title":"MetaData"},{"location":"athenz_templates/#roles","text":"Roles can have attributes like name, modified timestamp, Role Meta attributes (check the complete role meta attributes list below) and roleMembers. By default roles that are created by the template will not have any members unless the role members are hard-coded in the template (check the example structure below). The domain administrator will need to add members to those roles after the domain is created or the template has been applied to a domain. Now if you notice role members array in the image below, members can also have placeholders which have to be added to keywordsToReplace. Sample structure for Roles with role members: \"roles\": [ { \"name\": \"_domain_:role.aws_instance_launch_provider\", \"modified\": \"1970-01-01T00:00:00.000Z\", \"roleMembers\": [ { \"memberName\": \"athens.aws.*\" } ] }, { \"name\": \"_domain_:role.aws.ssh_login\", \"modified\": \"1970-01-01T00:00:00.000Z\" }, { \"name\": \"_domain_:role.aws_ssh_cert_request\", \"modified\": \"1970-01-01T00:00:00.000Z\", \"roleMembers\": [ { \"memberName\": \"_domain_._service_\" } ] } ] Allowed Role Meta Attributes: \"selfServe\": \"false\", \"memberExpiryDays\": 90, \"tokenExpiryMins\": 30, \"certExpiryMins\": 10, \"serviceExpiryDays\": 50, \"memberReviewDays\": 65, \"serviceReviewDays\": 15, \"reviewEnabled\": true","title":"Roles"},{"location":"athenz_templates/#policies","text":"Array of policies with name, modified timestamp and array of assertions. Check the sample Json below. \"policies\": [ { \"name\": \"_domain_:policy.aws_instance_launch_provider\", \"modified\": \"1970-01-01T00:00:00.000Z\", \"assertions\": [ { \"resource\": \"_domain_:service._service_\", \"role\": \"_domain_:role.aws_instance_launch_provider\", \"action\": \"launch\" } ] }, { \"name\": \"_domain_:policy.aws.ssh_login\", \"modified\": \"1970-01-01T00:00:00.000Z\", \"assertions\": [ { \"resource\": \"_domain_:aws._service_.*\", \"role\": \"_domain_:role.aws.ssh_login\", \"action\": \"ssh_login\", \"effect\": \"DENY\" } ] }","title":"Policies"},{"location":"athenz_templates/#applying-templates","text":"Templates can be applied via ZMS CLI and via Athenz UI. let's take a look at a few examples on how to apply different types of templates.","title":"Applying Templates"},{"location":"athenz_templates/#example-1","text":"Templates with placeholders in role and policy names (aka comma separated values in keywordsToReplace under template metadata field) will have to pass the key value pair for all placeholders via CLI. However, Athenz UI will automatically detect the placeholders and prompt the user to enter those placeholder values without which you cannot apply a template","title":"Example 1"},{"location":"athenz_templates/#example-2","text":"Templates with static role and policy names i.e. no placeholders zms-cli -d some-domain set-domain-template other-template-name","title":"Example 2"},{"location":"athenz_templates/#auto-update","text":"Auto update flag in templates lets the zms server to patch up the changes made to roles and policies automatically. This way the template creator does not need to communicate the tenant domains to patch them up manually through Athenz UI or CLI. AutoUpdate runs on zms servers during application startup in an uninterrupted fashion and applies roles and policies for all eligible templates. This feature will work only for templates with no placeholders at the moment i.e. the metadata section in the template should have the following values keywordsToReplace=\"\" and autoUpdate set to true. Note: it is important to bump up the latestVersion flag to apply any changes in the template including metadata changes like autoUpdate and keywordsToReplace.","title":"Auto Update"},{"location":"athenz_templates/#faq","text":"","title":"FAQ"},{"location":"auth_flow/","text":"Architecture - Authorization Flow \u00b6 Use Cases Manage Access Control / Permissions for Resources Real-Time Service Security Authorization Flow Centralized Access Control (Control-Plane) Principals Authenticated Service Decentralized Access Control (Data-Plane) Policy Engine Reserved Domains Management Scenarios Simple Centralized Scenario Multi-tenancy Scenario Service Authentication Use Cases \u00b6 Manage Access Control and Permissions for Resources \u00b6 Athenz allows you to manage access control and permissions to resources through the centralized authori**z**ation **m**anagement **s**ervice (ZMS) and domain configuration that defines resources, roles, and actions. The diagram below shows a simplification of the use case without domain configuration. Your domain configuration file gives you fine control over who can access resources and what actions can be taken. ZMS manages your domain files and provides a RESTful API that allows you to create and modify domain configurations. This gives you the ability to control user access , tenancy , and secure editorial content and infrastructure assets . Real-Time Service Security \u00b6 Athenz provides endpoint protection for services, so a service such as Sports in the diagram below doesn't need to set network ACLs for other services wanting to access data. Instead, services are authorized by Athenz to access resources from another service based on the permissions defined by the domain administrator. Authorization Flow \u00b6 Centralized Access Control (Control-Plane) \u00b6 A traditional centralized mechanism works as expected for services that are not dealing with the decentralized authorization: the server with resources can simply ask the ZMS directly about access, passing the service identity and resource/action information to get a simple boolean answer. This does not scale well enough for data-plane access, since a central service must be consulted, but requires no local installation of the ZPE and related storage and synchronization logic. It is suitable for provisioning and configuration use cases where the number of requests processed by the server are small and the latency for authorization checks is not important. Principals \u00b6 In Athenz, actors that can assume a role are called principals. Principals can be users or services, and users can be those looking for resources from a service or use the ZMS management console. In the following sections, we'll look at centralized authorization for the service principal we just discussed. Authenticated Service \u00b6 To contact Athenz Services (ZMS/ZTS) or other Athenz Enabled services, the client service must first obtain an Athenz CA issued X.509 certificate. The services establish standard mutual TLS communication with other Athenz Enabled Services. Once the mutual TLS authentication is established, the provider service contacts Athenz Management Service directly to determine if a specific authenticated service has been authorized to carry out the given action on the requested resource. The application receives a simple boolean answer whether or not the request should be processed or rejected. The domain administrator can create a separate service that only has access for the given provider, thus provider having access to the service's identity will not have access to any other resource. Refer Service Authentication for full details on X.509 certificate based authentication. Decentralized Access Control (Data-Plane) \u00b6 A more interesting scenario introduces the local policy engine (ZPE), and a few supporting changes. Rather than directly asking for an access check with a principal identity, the identity is instead used to get a ZToken, and that is presented to the target service until it expires. This mechanism allows a service to make a completely local access check against ZPE, given a ZToken and locally cached policies. Specifically, as shown in the diagram below, the client service/user presents an X.509 certificate from SIA Provider to get an authorization token (ZToken) from ZTS, and then presents the ZToken to a target service to access its resources. That service can make use of a local ZPE to validate the role assertions in the ZToken, and then correlate them to the asynchronously updated Policies for the domain involved. The ZPE can make the decision locally, without going off box. It has no knowledge about specific users, only roles, and because roles and policies are always in the domain, the amount of data to distribute to the machine is small. Policy Engine \u00b6 The Policy Engine (ZPE) only needs to deal with policies and their roles, actions, and resources. Concepts like groups would only affect how a principal can assume a role, so is involved in getting the ZToken, but not using it in the ZPE. When evaluating policies, the relevant assertions of all relevant policies must be considered. Assertions are treated like a big \"OR\" with the default effect of \"Allow\", whereas any single \"Deny\" will override any other assertions. The policies can have prefix-matching wildcards, so that glob-style matching needs to be part of the \"is this assertion relevant\" logic. The policies must be fetched from ZTS for the ZPE to operate. Additionally, the policies must be refreshed as they change. It is expected that policies will change at a much lower frequency than user/role assignments, so a daily pull may be fine for this. The policies are not sensitive (secret) information, but their integrity is important, so the policies fetched (per domain) is signed by both ZMS and ZTS servers. This requires a predictable serialization of the policy data structures. That will be fields in the order the schema specifies, serialized to JSON, then signed. The actual fetch is performed by a locally running distribution agent, which could be implemented as a cron job or other async fetching mechanism. The resulting policies could be atomically changed per domain. Because the ZPE only will have policies for the domains of services running on the same host/container, there will be relatively few of them. The API for getting signed policies actually gets many policies in a single list, which is signed as a whole according to the ordering rules above. Reserved Domains \u00b6 The following domains are reserved and are automatically provisioned during server startup: user - The reserved domain for authenticated users. sys - The reserved domain for managing system activities sys.auth - The Athenz domain itself, which is where policies governing the top level domains reside. Management Scenarios \u00b6 Simple Centralized Scenario \u00b6 In the simplest scenario, one would perform the following actions. Note that even in this case, the management calls themselves are protected by Athenz, so for example one property admin cannot modify another property's domain. Set up domains as a super admin Assign domain administrators for the domain Create services in the domain Create roles, as the domain admin, to model the expected activity. Assign users and services as needed. Create policies, with references to resources that are the target of various actions The services would implement the access check calls to enforce access based on the ZMS \"access check\" API. This may happen in a container or filter. Multi-tenancy Scenario \u00b6 Setting up a tenant in a provider requires the concepts of a cross-domain \"trust relation\". Such a trust relation can be implemented as follows: A Policy is set up in the group-defining domain (Domain-A) that asserts that one of its local Roles can \u201cassume\u201d a role in the target Domain. The role used in this policy is arbitrary, under the control of Domain-A, who can add/remove users from it as it needs. A Role is created in the target Domain-B, but instead of specifying users, the trusted domain is set to Domain-A. Domain-B can then set up whatever policies it needs to protect relevant resources, by referring to its special role as the principal At access check time, when the policy is encountered that indicates a role that is trusted, that role (in another Domain) must then be consulted to determine who can assume the role. Service Authentication \u00b6 Refer Service Authentication for full details on X.509 cerificate based authentication.","title":"Authorization Flow"},{"location":"auth_flow/#architecture-authorization-flow","text":"Use Cases Manage Access Control / Permissions for Resources Real-Time Service Security Authorization Flow Centralized Access Control (Control-Plane) Principals Authenticated Service Decentralized Access Control (Data-Plane) Policy Engine Reserved Domains Management Scenarios Simple Centralized Scenario Multi-tenancy Scenario Service Authentication","title":"Architecture - Authorization Flow"},{"location":"auth_flow/#use-cases","text":"","title":"Use Cases"},{"location":"auth_flow/#manage-access-control-and-permissions-for-resources","text":"Athenz allows you to manage access control and permissions to resources through the centralized authori**z**ation **m**anagement **s**ervice (ZMS) and domain configuration that defines resources, roles, and actions. The diagram below shows a simplification of the use case without domain configuration. Your domain configuration file gives you fine control over who can access resources and what actions can be taken. ZMS manages your domain files and provides a RESTful API that allows you to create and modify domain configurations. This gives you the ability to control user access , tenancy , and secure editorial content and infrastructure assets .","title":"Manage Access Control and Permissions for Resources"},{"location":"auth_flow/#real-time-service-security","text":"Athenz provides endpoint protection for services, so a service such as Sports in the diagram below doesn't need to set network ACLs for other services wanting to access data. Instead, services are authorized by Athenz to access resources from another service based on the permissions defined by the domain administrator.","title":"Real-Time Service Security"},{"location":"auth_flow/#authorization-flow","text":"","title":"Authorization Flow"},{"location":"auth_flow/#centralized-access-control-control-plane","text":"A traditional centralized mechanism works as expected for services that are not dealing with the decentralized authorization: the server with resources can simply ask the ZMS directly about access, passing the service identity and resource/action information to get a simple boolean answer. This does not scale well enough for data-plane access, since a central service must be consulted, but requires no local installation of the ZPE and related storage and synchronization logic. It is suitable for provisioning and configuration use cases where the number of requests processed by the server are small and the latency for authorization checks is not important.","title":"Centralized Access Control (Control-Plane)"},{"location":"auth_flow/#principals","text":"In Athenz, actors that can assume a role are called principals. Principals can be users or services, and users can be those looking for resources from a service or use the ZMS management console. In the following sections, we'll look at centralized authorization for the service principal we just discussed.","title":"Principals"},{"location":"auth_flow/#decentralized-access-control-data-plane","text":"A more interesting scenario introduces the local policy engine (ZPE), and a few supporting changes. Rather than directly asking for an access check with a principal identity, the identity is instead used to get a ZToken, and that is presented to the target service until it expires. This mechanism allows a service to make a completely local access check against ZPE, given a ZToken and locally cached policies. Specifically, as shown in the diagram below, the client service/user presents an X.509 certificate from SIA Provider to get an authorization token (ZToken) from ZTS, and then presents the ZToken to a target service to access its resources. That service can make use of a local ZPE to validate the role assertions in the ZToken, and then correlate them to the asynchronously updated Policies for the domain involved. The ZPE can make the decision locally, without going off box. It has no knowledge about specific users, only roles, and because roles and policies are always in the domain, the amount of data to distribute to the machine is small.","title":"Decentralized Access Control (Data-Plane)"},{"location":"auth_flow/#policy-engine","text":"The Policy Engine (ZPE) only needs to deal with policies and their roles, actions, and resources. Concepts like groups would only affect how a principal can assume a role, so is involved in getting the ZToken, but not using it in the ZPE. When evaluating policies, the relevant assertions of all relevant policies must be considered. Assertions are treated like a big \"OR\" with the default effect of \"Allow\", whereas any single \"Deny\" will override any other assertions. The policies can have prefix-matching wildcards, so that glob-style matching needs to be part of the \"is this assertion relevant\" logic. The policies must be fetched from ZTS for the ZPE to operate. Additionally, the policies must be refreshed as they change. It is expected that policies will change at a much lower frequency than user/role assignments, so a daily pull may be fine for this. The policies are not sensitive (secret) information, but their integrity is important, so the policies fetched (per domain) is signed by both ZMS and ZTS servers. This requires a predictable serialization of the policy data structures. That will be fields in the order the schema specifies, serialized to JSON, then signed. The actual fetch is performed by a locally running distribution agent, which could be implemented as a cron job or other async fetching mechanism. The resulting policies could be atomically changed per domain. Because the ZPE only will have policies for the domains of services running on the same host/container, there will be relatively few of them. The API for getting signed policies actually gets many policies in a single list, which is signed as a whole according to the ordering rules above.","title":"Policy Engine"},{"location":"auth_flow/#reserved-domains","text":"The following domains are reserved and are automatically provisioned during server startup: user - The reserved domain for authenticated users. sys - The reserved domain for managing system activities sys.auth - The Athenz domain itself, which is where policies governing the top level domains reside.","title":"Reserved Domains"},{"location":"auth_flow/#management-scenarios","text":"","title":"Management Scenarios"},{"location":"auth_flow/#simple-centralized-scenario","text":"In the simplest scenario, one would perform the following actions. Note that even in this case, the management calls themselves are protected by Athenz, so for example one property admin cannot modify another property's domain. Set up domains as a super admin Assign domain administrators for the domain Create services in the domain Create roles, as the domain admin, to model the expected activity. Assign users and services as needed. Create policies, with references to resources that are the target of various actions The services would implement the access check calls to enforce access based on the ZMS \"access check\" API. This may happen in a container or filter.","title":"Simple Centralized Scenario"},{"location":"auth_flow/#multi-tenancy-scenario","text":"Setting up a tenant in a provider requires the concepts of a cross-domain \"trust relation\". Such a trust relation can be implemented as follows: A Policy is set up in the group-defining domain (Domain-A) that asserts that one of its local Roles can \u201cassume\u201d a role in the target Domain. The role used in this policy is arbitrary, under the control of Domain-A, who can add/remove users from it as it needs. A Role is created in the target Domain-B, but instead of specifying users, the trusted domain is set to Domain-A. Domain-B can then set up whatever policies it needs to protect relevant resources, by referring to its special role as the principal At access check time, when the policy is encountered that indicates a role that is trusted, that role (in another Domain) must then be consulted to determine who can assume the role.","title":"Multi-tenancy Scenario"},{"location":"auth_flow/#service-authentication","text":"Refer Service Authentication for full details on X.509 cerificate based authentication.","title":"Service Authentication"},{"location":"aws_athenz_setup/","text":"Athenz Setup on AWS \u00b6 Athenz Team provides a set of instructions using CloudFormation Templates to deploy Athenz ZMS, ZTS and UI components on Linux EC2 instances in AWS. https://github.com/AthenZ/athenz-aws-cf-setup/blob/master/README.md","title":"Introduction"},{"location":"aws_athenz_setup/#athenz-setup-on-aws","text":"Athenz Team provides a set of instructions using CloudFormation Templates to deploy Athenz ZMS, ZTS and UI components on Linux EC2 instances in AWS. https://github.com/AthenZ/athenz-aws-cf-setup/blob/master/README.md","title":"Athenz Setup on AWS"},{"location":"aws_temp_creds/","text":"This feature allows any service to obtain temporary session credentials for a role defined in AWS IAM to carry out operations against AWS Services. For example, your service might need to access its own S3 bucket to push some data to AWS. Instead of using an IAM user's credentials to access that S3 bucket, the administrator will define a role providing access to that S3 bucket and then configure their service to retrieve temporary session credentials for that role through ZTS Server. Connection Details \u00b6 To obtain temporary credentials, the client must contact ZTS Server running in AWS. Client X.509 Certificate Requirements \u00b6 To contact ZTS running in AWS to obtain temporary credentials, the client service must authenticate itself using Athenz issued client X.509 certificates. The steps are different depending on where your client service is running. Follow these steps to obtain a service x.509 certificate for your client service. AWS Account ID Registration \u00b6 To register an AWS Account with a domain, run the following command: zms-cli -d <domain-name> set-aws-account <aws-account-id> AWS Configuration Setup \u00b6 To obtain temporary credentials for a given role through ZTS Server, the administrator must follow through these steps: 1. You must already have a role created in AWS IAM that you would like to obtain temporary credentials for. 2. In AWS, setup a trust relationship for your role such that ZTS can assume that role. On the IAM Roles page, choose the role that you want to modify and click on the Trust Relationships tab. Click on the Edit Trust Relationship button and append the following section to the current document's Statement element (don't forget to make sure to convert the Statement element into an array and add necessary commas): { \"Effect\": \"Allow\", \"Principal\": { \"AWS\": \"arn:aws:iam::<account-id>:role/athenz-zts-service\" }, \"Action\": \"sts:AssumeRole\" } If configured correctly, the Trust Relationships tab should show athenz-zts-service as one of entries in the Trusted Entities table. Expiration Period \u00b6 AWS announced that they have extended the federated api access to AWS resources from the default 1 hour to up to 12 hours . To change the expiration period for a role, click on the Edit link in the role configuration screen in IAM and choose either one of the predefined duration or specify a custom one. Once the role is configured with a longer duration period. use the ZTS client api as described in the Obtaining AWS Temporary Credentials section to specify the requested duration for the temporary credentials. External ID Condition \u00b6 By including an external id condition in the AssumeRole policy, the account administrator secures its roles to be accessed by unauthorized principals in case ZTS has been compromised since AWS STS will reject any assume role requests unless the external id is specified as part of the request. Once an external id has been chosen, the AssumeRole policy configured for the role can be updated to include the external id condition. For example, to configure an external id hockey for our role we'll have the following policy: { \"Effect\": \"Allow\", \"Principal\": { \"AWS\": \"arn:aws:iam::<account-id>:role/athenz-zts-service\" }, \"Action\": \"sts:AssumeRole\", \"Condition\": { \"StringEquals\": { \"sts:ExternalId\": \"hockey\" } } } If configured correctly, the Trust Relationships tab should show athenz-zts-service as one of entries in the Trusted Entities table with a condition field specified. Once the role is configured with an external id condition, use the ZTS client api as described in the Obtaining AWS Temporary Credentials section to specify the external id for the temporary credentials. The external ID must be kept securely. Your application will need to fetch the external id and then use it in the API call to fetch AWS temporary credentials. Athenz AWS Assume Role Configuration Setup \u00b6 1. In ZMS, create a role in your domain with any service identities that may request temporary credentials for the AWS role. Go to Athenz UI, choose your Athenz domain and click on the Add Role link in the top left corner. 2. In ZMS, create a policy authorizing your Athenz role members to assume the AWS role. When creating the policy the action must be assume_aws_role , choose the role as created in the previous step and specify the IAM role name as the resource. 3. Make sure your role contains all the service identities that may request temporary credentials for this role. 4. The changes will propagate from ZMS to ZTS running within AWS within 2 minutes, and then you can use the ZTS Client library or its REST API to request temporary credentials. Obtaining AWS Temporary Credentials \u00b6 We're going to look at how to obtain AWS Temporary Credentials with the use of the ZTS Client Library in Java and directly with ZTS Server's REST API. By default the AWS Temporary Credentials returned are valid only for 1 hour. If configured, it can be extended upto 12 hours - see Expiration period section for full details. The client must refresh the credentials before they expire. REST API \u00b6 To obtain a AWS Temporary Credentials, the application would use the following endpoint from ZTS Server running in AWS: GET /zts/v1/domain/{domainName}/role/{awsRoleName}/creds?durationSeconds={durationSeconds}&externalId={externalId} durationSeconds and externalId query arguments are optional. For example, with our setup as described above, sherpa.api is our service identity and we have retrieved the X.509 certificate for this service. The file locations are as follows: private-key: /var/lib/sia/keys/sherpa.api.key.pem certificate: /var/lib/sia/certs/sherpa.api.cert.pem The following request would retrieve AWS temporary session credentials for the sherpa.property domain's aws IAM role s3-uploader : curl --key /var/lib/sia/keys/sherpa.api.key.pem --cert /var/lib/sia/certs/sherpa.api.cert.pem https://your.zts/zts/v1/domain/sherpa.property/role/s3-uploader/creds Note that the awsRoleName URL parameter is the name of the IAM role you want to assume, not the Athenz role created in ZMS. Expiration Period \u00b6 The following request would retrieve AWS temporary session credentials for the sherpa.property domain's aws iam role s3-uploader with duration set to 6 hours (6 * 60 * 60 = 21600 seconds): curl --key /var/lib/sia/keys/sherpa.api.key.pem --cert /var/lib/sia/certs/sherpa.api.cert.pem https://your.zts/zts/v1/domain/sherpa.property/role/s3-uploader/creds?durationSeconds=21600 External ID Condition \u00b6 If we had configured our AssumeRole policy for the s3-uploader role with an external id of hockey then our request would be: curl --key /var/lib/sia/keys/sherpa.api.key.pem --cert /var/lib/sia/certs/sherpa.api.cert.pem https://your.zts/zts/v1/domain/sherpa.property/role/s3-uploader/creds?externalId=hockey Case Sensitivity \u00b6 While object names (e.g. in your assume_aws_role policy statement) in Athenz are all normalized to lower case, role names in IAM are case sensitive . When calling ZTS to fetch temporary credentials using AssumeRole, the awsRoleName parameter must match exactly (including case) the role name configured in IAM or the request will be denied. Java \u00b6 First you need to update your Java project pom.xml file to indicate the dependency on the Athenz cert refresher and zts java client libraries. Checkout the Maven Central Athenz Cert Refresher Package and Maven Central ZTS Java Client Package pages to make sure you're using the latest release version: <dependencies> <dependency> <groupId> com.yahoo.athenz </groupId> <artifactId> athenz-zts-java-client </artifactId> <version> VERSION-NUMBER </version> </dependency> <dependency> <groupId> com.yahoo.athenz </groupId> <artifactId> athenz-cert-refresher </artifactId> <version> VERSION-NUMBER </version> </dependency> </dependencies> To obtain a AWS Temporary Credentials Provider, the application would use the following constructor: /** * Constructs a new AWSCredentialsProvider object with the given SSLContext object, * ZTS Server Url, Athenz domain name and AWS Role Name to retrieve temporary * credentials for. The constructor will automatically create and use the ZTS * client object for retrieving credentials. This object must be closed so * the ZTS client object is closed as well. * @param ztsUrl ZTS Server's URL * @param sslContext SSLContext that includes service's private key and x.509 certificate * for authenticating requests * @param domainName name of the Athenz domain * @param roleName is the name of the IAM role * @param minExpiryTime (optional) specifies that the returned creds must be * at least valid (min/lower bound) for specified number of seconds * @param maxExpiryTime (optional) specifies that the returned creds must be * at most valid (max/upper bound) for specified number of seconds. * @param externalId (optional) external id to satisfy configured assume role condition */ public AWSCredentialsProviderImpl ( String ztsUrl , SSLContext sslContext , String domainName , String roleName , String externalId , Integer minExpiryTime , Integer maxExpiryTime ) For example, with our setup as described above, sherpa.api is our service identity and we have retrieved the X.509 certificate for this service. The file location are as follows: private-key: /var/lib/sia/keys/sherpa.api.key.pem certificate: /var/lib/sia/certs/sherpa.api.cert.pem The ZTS server is running with a public X.509 certificate so we're going to use the standard jdk truststore for our connection which has a default password of changeit . The following request would retrieve AWS temporary session credentials for the sherpa.property domain's aws iam role s3-uploader : import javax.net.ssl.SSLContext ; import com.oath.auth.KeyRefresher ; import com.oath.auth.Utils ; import com.yahoo.athenz.zts.AWSCredentialsProviderImpl ; final String ztsUrl = \"https://your.zts/zts/v1\" ; final String keyPath = \"/var/lib/sia/keys/sherpa.api.key.pem\" ; final String certPath = \"/var/lib/sia/certs/sherpa.api.cert.pem\" ; final String trustStorePath = javaHome + \"/jre/lib/security/cacerts\" ; final String trustStorePassword = \"changeit\" ; try { // Create our SSL Context object based on our private key and // certificate and jdk truststore KeyRefresher keyRefresher = Utils . generateKeyRefresher ( trustStorePath , trustStorePassword , certPath , keyPath ); // Default refresh period is every hour. keyRefresher . startup (); // Can be adjusted to use other values in milliseconds. // keyRefresher.startup(900000); SSLContext sslContext = Utils . buildSSLContext ( keyRefresher . getKeyManagerProxy (), keyRefresher . getTrustManagerProxy ()); // obtain temporary credential provider for our domain and role // without external id and default period of 1 hour AWSCredentialsProviderImpl awsCredProvider = new AWSCredentialsProviderImpl ( ztsUrl , sslContext , \"sherpa.property\" , \"s3-uploader\" , null , null , null ); // retrieve and display aws temporary creds. Typically you just pass // the AWSCredentialsProvider object to any AWS api that requires it. // for example, when creating an AWS S3 client // AmazonS3 s3client = AmazonS3ClientBuilder.standard() // .withCredentials(awsCredProvider) // .withRegion(getRegion()) // .build(); try { AWSCredentials awsCreds = awsCredProvider . getCredentials (); if ( awsCreds == null ) { System . out . println ( \"Error: AWS Credentials are not available\" ); // handle failure } System . out . println ( \"AWS Temporary Credentials:\\n\" ); System . out . println ( \"\\tAccess Key Id : \" + awsCreds . getAWSAccessKeyId ()); System . out . println ( \"\\tSecret Key : \" + awsCreds . getAWSSecretKey ()); } catch ( ZTSClientException ex ) { System . out . println ( \"Unable to retrieve AWS credentials: \" + ex . getMessage ()); // handle failure } // once we're done with our api and we no longer need our // provider we need to make sure to close it awsCredProvider . close (); } catch ( Exception ex ) { // handle failure } ** Important ** During the shutdown of the application, ZTSClient.cancelPrefetch() must be called to stop the timer thread that automatically fetches and refreshes any cached tokens in the ZTS Client. Expiration Period \u00b6 The following request would retrieve AWS temporary session credentials for the sherpa.property domain's aws iam role s3-uploader with duration set to 6 hours (6 * 60 * 60 = 21600 seconds) and a minimum timeout of 15 minutes. This indicates that the client will cache the token for 5 hours and 45 minutes. // obtain temporary credential provider for our domain and role AWSCredentialsProviderImpl awsCredProvider = new AWSCredentialsProviderImpl ( ztsUrl , sslContext , \"sherpa.property\" , \"s3-uploader\" , 900 , 21600 , null ); External ID Condition \u00b6 If we had configured our AssumeRole policy for the s3-uploader role with an external id of hockey then our request would be: // obtain temporary credential provider for our domain and role externalId = retrieveExternalIDFromYkeykey(); // would return \"hockey\" AWSCredentialsProviderImpl awsCredProvider = new AWSCredentialsProviderImpl(ztsUrl, sslContext, \"sherpa.property\", \"s3-uploader\", null, null, externalId); Go \u00b6 To obtain a AWS Temporary Credentials, the application would use the Athenz ZTS Go Client. For example, with our setup as described above, sherpa.api is our service identity and we have retrieved the X.509 certificate for this service. The file location are as follows: private-key: /var/lib/sia/keys/sherpa.api.key.pem certificate: /var/lib/sia/certs/sherpa.api.cert.pem First you need to update your Go project to indicate the dependency on the Athenz zts go client libraries: import ( \"github.com/AthenZ/athenz/clients/go/zts\" \"github.com/AthenZ/athenz/libs/go/athenzutils\" ) The ZTS server is running with a public X.509 certificate so we're not going to specify CA certificates for our request: ztsUrl := \"https://your.zts/zts/v1\" key := \"/var/lib/sia/keys/sherpa.api.key.pem\" cert := \"/var/lib/sia/certs/sherpa.api.cert.pem\" ztsClient, err := athenzutils.ZtsClient(ztsUrl, key, cert, \"\", false) if err != nil { log.Fatalf(\"Fatal: Error creating zts client: %v\", err) } domain := \"sherpa.property\" role := \"s3-uploader\" externalId := \"hockey\" awsCreds, err := ztsClient.GetAWSTemporaryCredentials(zts.DomainName(domain), zts.AWSArnRoleName(role), nil, externalId) if err != nil { log.Fatalf(\"Fatal: Error fetching AWS Credentials: %v\\n\", err) } fmt.Println(\"[default]\") fmt.Printf(\"aws_access_key_id=%s\\n\", awsCreds.AccessKeyId) fmt.Printf(\"aws_secret_access_key=%s\\n\", awsCreds.SecretAccessKey) fmt.Printf(\"aws_session_token=%s\\n\", awsCreds.SessionToken) Using AWS Temporary Credentials \u00b6 If you want to use the AWS temporary credentials with aws command line utilities, they can be set as environment variables or be added to the ~/.aws/credentials file for a given profile. The settings must include all three components returned by the api: access key id secret access key session token The following example shows the use of environment variables with temporary credentials: $ export AWS_ACCESS_KEY_ID={YOUR_ACCESS_KEY_ID} $ export AWS_SECRET_ACCESS_KEY={YOUR_SECRET_ACCESS_KEY} $ export AWS_SESSION_TOKEN={YOUR_SESSION_TOKEN} $ aws ec2 describe-instances --region us-west-1 The following example shows the use of the aws credentials file using default profile: $ cat ~/.aws/credentials [default] aws_access_key_id={YOUR_ACCESS_KEY_ID} aws_secret_access_key={YOUR_SECRET_ACCESS_KEY} aws_session_token={YOUR_SESSION_TOKEN} Checkout Using Temporary Security Credentials to Request Access to AWS Resources for full details how to use temporary credentials in AWS. ** Important ** When passing the role name that you're trying to assume in the aws-builder-creds utility as the value to the -r argument, it must be the AWS IAM Role name and not the role name in your Athenz domain. Troubleshooting \u00b6 ZTS Server returns a unique error message indicating what part of the configuration is causing the failure to fetch AWS temporary credentials. Athenz Domain Configuration \u00b6 Athenz Configuration Error: unable to retrieve AWS account for: <domainName> The domain, identified in the <domainName> field, does not have AWS account id configured. Follow the steps in the AWS Account ID Registration section to register your AWS account id for your domain. Athenz Role Configuration \u00b6 Athenz Configuration Error: Forbidden (assume_aws_role on <resource-name> for <principal>) This error indicates that the principal, identified in the <principal> field, requesting the temporary credentials is not authorized. There are two common issues that generate this error message: The caller is using the athenz role name as the value for the role name parameter (-r in the aws-builder-creds utility). The value for this parameter must be the AWS IAM role name and not the Athenz role name. Make sure the <principal> is included as a member in the role that you had setup in the Athenz AWS Assume Role Configuration Setup section in this document. AWS Configuration \u00b6 AWS Configuration Error: unable to assume role <roleName> in domain <domainName> for principal <principal> error: <aws-error-message> This error indicates that AWS STS refused to issue temporary credentials to the Athenz ZTS service. This usually indicates that either the role name specified in the request is incorrect (you must specify the IAM Role name you're trying to assume and not the Athenz Role Name) or the role in IAM does not have the trust relationship setup for ZTS service as described in the AWS Configuration Setup section in this document. If you have configured a non-default duration or an external id for your role make sure you're passing the correct values in the API. AWS STS will reject the assume role request if the external id is not passed or a duration value is passed that is longer than the configured period.","title":"AWS Temp Credentials"},{"location":"aws_temp_creds/#connection-details","text":"To obtain temporary credentials, the client must contact ZTS Server running in AWS.","title":"Connection Details"},{"location":"aws_temp_creds/#client-x509-certificate-requirements","text":"To contact ZTS running in AWS to obtain temporary credentials, the client service must authenticate itself using Athenz issued client X.509 certificates. The steps are different depending on where your client service is running. Follow these steps to obtain a service x.509 certificate for your client service.","title":"Client X.509 Certificate Requirements"},{"location":"aws_temp_creds/#aws-account-id-registration","text":"To register an AWS Account with a domain, run the following command: zms-cli -d <domain-name> set-aws-account <aws-account-id>","title":"AWS Account ID Registration"},{"location":"aws_temp_creds/#aws-configuration-setup","text":"To obtain temporary credentials for a given role through ZTS Server, the administrator must follow through these steps: 1. You must already have a role created in AWS IAM that you would like to obtain temporary credentials for. 2. In AWS, setup a trust relationship for your role such that ZTS can assume that role. On the IAM Roles page, choose the role that you want to modify and click on the Trust Relationships tab. Click on the Edit Trust Relationship button and append the following section to the current document's Statement element (don't forget to make sure to convert the Statement element into an array and add necessary commas): { \"Effect\": \"Allow\", \"Principal\": { \"AWS\": \"arn:aws:iam::<account-id>:role/athenz-zts-service\" }, \"Action\": \"sts:AssumeRole\" } If configured correctly, the Trust Relationships tab should show athenz-zts-service as one of entries in the Trusted Entities table.","title":"AWS Configuration Setup"},{"location":"aws_temp_creds/#expiration-period","text":"AWS announced that they have extended the federated api access to AWS resources from the default 1 hour to up to 12 hours . To change the expiration period for a role, click on the Edit link in the role configuration screen in IAM and choose either one of the predefined duration or specify a custom one. Once the role is configured with a longer duration period. use the ZTS client api as described in the Obtaining AWS Temporary Credentials section to specify the requested duration for the temporary credentials.","title":"Expiration Period"},{"location":"aws_temp_creds/#external-id-condition","text":"By including an external id condition in the AssumeRole policy, the account administrator secures its roles to be accessed by unauthorized principals in case ZTS has been compromised since AWS STS will reject any assume role requests unless the external id is specified as part of the request. Once an external id has been chosen, the AssumeRole policy configured for the role can be updated to include the external id condition. For example, to configure an external id hockey for our role we'll have the following policy: { \"Effect\": \"Allow\", \"Principal\": { \"AWS\": \"arn:aws:iam::<account-id>:role/athenz-zts-service\" }, \"Action\": \"sts:AssumeRole\", \"Condition\": { \"StringEquals\": { \"sts:ExternalId\": \"hockey\" } } } If configured correctly, the Trust Relationships tab should show athenz-zts-service as one of entries in the Trusted Entities table with a condition field specified. Once the role is configured with an external id condition, use the ZTS client api as described in the Obtaining AWS Temporary Credentials section to specify the external id for the temporary credentials. The external ID must be kept securely. Your application will need to fetch the external id and then use it in the API call to fetch AWS temporary credentials.","title":"External ID Condition"},{"location":"aws_temp_creds/#athenz-aws-assume-role-configuration-setup","text":"1. In ZMS, create a role in your domain with any service identities that may request temporary credentials for the AWS role. Go to Athenz UI, choose your Athenz domain and click on the Add Role link in the top left corner. 2. In ZMS, create a policy authorizing your Athenz role members to assume the AWS role. When creating the policy the action must be assume_aws_role , choose the role as created in the previous step and specify the IAM role name as the resource. 3. Make sure your role contains all the service identities that may request temporary credentials for this role. 4. The changes will propagate from ZMS to ZTS running within AWS within 2 minutes, and then you can use the ZTS Client library or its REST API to request temporary credentials.","title":"Athenz AWS Assume Role Configuration Setup"},{"location":"aws_temp_creds/#obtaining-aws-temporary-credentials","text":"We're going to look at how to obtain AWS Temporary Credentials with the use of the ZTS Client Library in Java and directly with ZTS Server's REST API. By default the AWS Temporary Credentials returned are valid only for 1 hour. If configured, it can be extended upto 12 hours - see Expiration period section for full details. The client must refresh the credentials before they expire.","title":"Obtaining AWS Temporary Credentials"},{"location":"aws_temp_creds/#rest-api","text":"To obtain a AWS Temporary Credentials, the application would use the following endpoint from ZTS Server running in AWS: GET /zts/v1/domain/{domainName}/role/{awsRoleName}/creds?durationSeconds={durationSeconds}&externalId={externalId} durationSeconds and externalId query arguments are optional. For example, with our setup as described above, sherpa.api is our service identity and we have retrieved the X.509 certificate for this service. The file locations are as follows: private-key: /var/lib/sia/keys/sherpa.api.key.pem certificate: /var/lib/sia/certs/sherpa.api.cert.pem The following request would retrieve AWS temporary session credentials for the sherpa.property domain's aws IAM role s3-uploader : curl --key /var/lib/sia/keys/sherpa.api.key.pem --cert /var/lib/sia/certs/sherpa.api.cert.pem https://your.zts/zts/v1/domain/sherpa.property/role/s3-uploader/creds Note that the awsRoleName URL parameter is the name of the IAM role you want to assume, not the Athenz role created in ZMS.","title":"REST API"},{"location":"aws_temp_creds/#expiration-period_1","text":"The following request would retrieve AWS temporary session credentials for the sherpa.property domain's aws iam role s3-uploader with duration set to 6 hours (6 * 60 * 60 = 21600 seconds): curl --key /var/lib/sia/keys/sherpa.api.key.pem --cert /var/lib/sia/certs/sherpa.api.cert.pem https://your.zts/zts/v1/domain/sherpa.property/role/s3-uploader/creds?durationSeconds=21600","title":"Expiration Period"},{"location":"aws_temp_creds/#external-id-condition_1","text":"If we had configured our AssumeRole policy for the s3-uploader role with an external id of hockey then our request would be: curl --key /var/lib/sia/keys/sherpa.api.key.pem --cert /var/lib/sia/certs/sherpa.api.cert.pem https://your.zts/zts/v1/domain/sherpa.property/role/s3-uploader/creds?externalId=hockey","title":"External ID Condition"},{"location":"aws_temp_creds/#case-sensitivity","text":"While object names (e.g. in your assume_aws_role policy statement) in Athenz are all normalized to lower case, role names in IAM are case sensitive . When calling ZTS to fetch temporary credentials using AssumeRole, the awsRoleName parameter must match exactly (including case) the role name configured in IAM or the request will be denied.","title":"Case Sensitivity"},{"location":"aws_temp_creds/#java","text":"First you need to update your Java project pom.xml file to indicate the dependency on the Athenz cert refresher and zts java client libraries. Checkout the Maven Central Athenz Cert Refresher Package and Maven Central ZTS Java Client Package pages to make sure you're using the latest release version: <dependencies> <dependency> <groupId> com.yahoo.athenz </groupId> <artifactId> athenz-zts-java-client </artifactId> <version> VERSION-NUMBER </version> </dependency> <dependency> <groupId> com.yahoo.athenz </groupId> <artifactId> athenz-cert-refresher </artifactId> <version> VERSION-NUMBER </version> </dependency> </dependencies> To obtain a AWS Temporary Credentials Provider, the application would use the following constructor: /** * Constructs a new AWSCredentialsProvider object with the given SSLContext object, * ZTS Server Url, Athenz domain name and AWS Role Name to retrieve temporary * credentials for. The constructor will automatically create and use the ZTS * client object for retrieving credentials. This object must be closed so * the ZTS client object is closed as well. * @param ztsUrl ZTS Server's URL * @param sslContext SSLContext that includes service's private key and x.509 certificate * for authenticating requests * @param domainName name of the Athenz domain * @param roleName is the name of the IAM role * @param minExpiryTime (optional) specifies that the returned creds must be * at least valid (min/lower bound) for specified number of seconds * @param maxExpiryTime (optional) specifies that the returned creds must be * at most valid (max/upper bound) for specified number of seconds. * @param externalId (optional) external id to satisfy configured assume role condition */ public AWSCredentialsProviderImpl ( String ztsUrl , SSLContext sslContext , String domainName , String roleName , String externalId , Integer minExpiryTime , Integer maxExpiryTime ) For example, with our setup as described above, sherpa.api is our service identity and we have retrieved the X.509 certificate for this service. The file location are as follows: private-key: /var/lib/sia/keys/sherpa.api.key.pem certificate: /var/lib/sia/certs/sherpa.api.cert.pem The ZTS server is running with a public X.509 certificate so we're going to use the standard jdk truststore for our connection which has a default password of changeit . The following request would retrieve AWS temporary session credentials for the sherpa.property domain's aws iam role s3-uploader : import javax.net.ssl.SSLContext ; import com.oath.auth.KeyRefresher ; import com.oath.auth.Utils ; import com.yahoo.athenz.zts.AWSCredentialsProviderImpl ; final String ztsUrl = \"https://your.zts/zts/v1\" ; final String keyPath = \"/var/lib/sia/keys/sherpa.api.key.pem\" ; final String certPath = \"/var/lib/sia/certs/sherpa.api.cert.pem\" ; final String trustStorePath = javaHome + \"/jre/lib/security/cacerts\" ; final String trustStorePassword = \"changeit\" ; try { // Create our SSL Context object based on our private key and // certificate and jdk truststore KeyRefresher keyRefresher = Utils . generateKeyRefresher ( trustStorePath , trustStorePassword , certPath , keyPath ); // Default refresh period is every hour. keyRefresher . startup (); // Can be adjusted to use other values in milliseconds. // keyRefresher.startup(900000); SSLContext sslContext = Utils . buildSSLContext ( keyRefresher . getKeyManagerProxy (), keyRefresher . getTrustManagerProxy ()); // obtain temporary credential provider for our domain and role // without external id and default period of 1 hour AWSCredentialsProviderImpl awsCredProvider = new AWSCredentialsProviderImpl ( ztsUrl , sslContext , \"sherpa.property\" , \"s3-uploader\" , null , null , null ); // retrieve and display aws temporary creds. Typically you just pass // the AWSCredentialsProvider object to any AWS api that requires it. // for example, when creating an AWS S3 client // AmazonS3 s3client = AmazonS3ClientBuilder.standard() // .withCredentials(awsCredProvider) // .withRegion(getRegion()) // .build(); try { AWSCredentials awsCreds = awsCredProvider . getCredentials (); if ( awsCreds == null ) { System . out . println ( \"Error: AWS Credentials are not available\" ); // handle failure } System . out . println ( \"AWS Temporary Credentials:\\n\" ); System . out . println ( \"\\tAccess Key Id : \" + awsCreds . getAWSAccessKeyId ()); System . out . println ( \"\\tSecret Key : \" + awsCreds . getAWSSecretKey ()); } catch ( ZTSClientException ex ) { System . out . println ( \"Unable to retrieve AWS credentials: \" + ex . getMessage ()); // handle failure } // once we're done with our api and we no longer need our // provider we need to make sure to close it awsCredProvider . close (); } catch ( Exception ex ) { // handle failure } ** Important ** During the shutdown of the application, ZTSClient.cancelPrefetch() must be called to stop the timer thread that automatically fetches and refreshes any cached tokens in the ZTS Client.","title":"Java"},{"location":"aws_temp_creds/#expiration-period_2","text":"The following request would retrieve AWS temporary session credentials for the sherpa.property domain's aws iam role s3-uploader with duration set to 6 hours (6 * 60 * 60 = 21600 seconds) and a minimum timeout of 15 minutes. This indicates that the client will cache the token for 5 hours and 45 minutes. // obtain temporary credential provider for our domain and role AWSCredentialsProviderImpl awsCredProvider = new AWSCredentialsProviderImpl ( ztsUrl , sslContext , \"sherpa.property\" , \"s3-uploader\" , 900 , 21600 , null );","title":"Expiration Period"},{"location":"aws_temp_creds/#external-id-condition_2","text":"If we had configured our AssumeRole policy for the s3-uploader role with an external id of hockey then our request would be: // obtain temporary credential provider for our domain and role externalId = retrieveExternalIDFromYkeykey(); // would return \"hockey\" AWSCredentialsProviderImpl awsCredProvider = new AWSCredentialsProviderImpl(ztsUrl, sslContext, \"sherpa.property\", \"s3-uploader\", null, null, externalId);","title":"External ID Condition"},{"location":"aws_temp_creds/#go","text":"To obtain a AWS Temporary Credentials, the application would use the Athenz ZTS Go Client. For example, with our setup as described above, sherpa.api is our service identity and we have retrieved the X.509 certificate for this service. The file location are as follows: private-key: /var/lib/sia/keys/sherpa.api.key.pem certificate: /var/lib/sia/certs/sherpa.api.cert.pem First you need to update your Go project to indicate the dependency on the Athenz zts go client libraries: import ( \"github.com/AthenZ/athenz/clients/go/zts\" \"github.com/AthenZ/athenz/libs/go/athenzutils\" ) The ZTS server is running with a public X.509 certificate so we're not going to specify CA certificates for our request: ztsUrl := \"https://your.zts/zts/v1\" key := \"/var/lib/sia/keys/sherpa.api.key.pem\" cert := \"/var/lib/sia/certs/sherpa.api.cert.pem\" ztsClient, err := athenzutils.ZtsClient(ztsUrl, key, cert, \"\", false) if err != nil { log.Fatalf(\"Fatal: Error creating zts client: %v\", err) } domain := \"sherpa.property\" role := \"s3-uploader\" externalId := \"hockey\" awsCreds, err := ztsClient.GetAWSTemporaryCredentials(zts.DomainName(domain), zts.AWSArnRoleName(role), nil, externalId) if err != nil { log.Fatalf(\"Fatal: Error fetching AWS Credentials: %v\\n\", err) } fmt.Println(\"[default]\") fmt.Printf(\"aws_access_key_id=%s\\n\", awsCreds.AccessKeyId) fmt.Printf(\"aws_secret_access_key=%s\\n\", awsCreds.SecretAccessKey) fmt.Printf(\"aws_session_token=%s\\n\", awsCreds.SessionToken)","title":"Go"},{"location":"aws_temp_creds/#using-aws-temporary-credentials","text":"If you want to use the AWS temporary credentials with aws command line utilities, they can be set as environment variables or be added to the ~/.aws/credentials file for a given profile. The settings must include all three components returned by the api: access key id secret access key session token The following example shows the use of environment variables with temporary credentials: $ export AWS_ACCESS_KEY_ID={YOUR_ACCESS_KEY_ID} $ export AWS_SECRET_ACCESS_KEY={YOUR_SECRET_ACCESS_KEY} $ export AWS_SESSION_TOKEN={YOUR_SESSION_TOKEN} $ aws ec2 describe-instances --region us-west-1 The following example shows the use of the aws credentials file using default profile: $ cat ~/.aws/credentials [default] aws_access_key_id={YOUR_ACCESS_KEY_ID} aws_secret_access_key={YOUR_SECRET_ACCESS_KEY} aws_session_token={YOUR_SESSION_TOKEN} Checkout Using Temporary Security Credentials to Request Access to AWS Resources for full details how to use temporary credentials in AWS. ** Important ** When passing the role name that you're trying to assume in the aws-builder-creds utility as the value to the -r argument, it must be the AWS IAM Role name and not the role name in your Athenz domain.","title":"Using AWS Temporary Credentials"},{"location":"aws_temp_creds/#troubleshooting","text":"ZTS Server returns a unique error message indicating what part of the configuration is causing the failure to fetch AWS temporary credentials.","title":"Troubleshooting"},{"location":"aws_temp_creds/#athenz-domain-configuration","text":"Athenz Configuration Error: unable to retrieve AWS account for: <domainName> The domain, identified in the <domainName> field, does not have AWS account id configured. Follow the steps in the AWS Account ID Registration section to register your AWS account id for your domain.","title":"Athenz Domain Configuration"},{"location":"aws_temp_creds/#athenz-role-configuration","text":"Athenz Configuration Error: Forbidden (assume_aws_role on <resource-name> for <principal>) This error indicates that the principal, identified in the <principal> field, requesting the temporary credentials is not authorized. There are two common issues that generate this error message: The caller is using the athenz role name as the value for the role name parameter (-r in the aws-builder-creds utility). The value for this parameter must be the AWS IAM role name and not the Athenz role name. Make sure the <principal> is included as a member in the role that you had setup in the Athenz AWS Assume Role Configuration Setup section in this document.","title":"Athenz Role Configuration"},{"location":"aws_temp_creds/#aws-configuration","text":"AWS Configuration Error: unable to assume role <roleName> in domain <domainName> for principal <principal> error: <aws-error-message> This error indicates that AWS STS refused to issue temporary credentials to the Athenz ZTS service. This usually indicates that either the role name specified in the request is incorrect (you must specify the IAM Role name you're trying to assume and not the Athenz Role Name) or the role in IAM does not have the trust relationship setup for ZTS service as described in the AWS Configuration Setup section in this document. If you have configured a non-default duration or an external id for your role make sure you're passing the correct values in the API. AWS STS will reject the assume role request if the external id is not passed or a duration value is passed that is longer than the configured period.","title":"AWS Configuration"},{"location":"capabilities/","text":"Athenz Capabilities \u00b6 OAuth2 Access Token Support \u00b6 Athenz supports the OAuth2 standard by enabling the generation of Access Tokens. Access tokens represent an authoritative statement that a given principal may assume some number of roles in a domain for a limited period. They are signed to prevent tampering. For more information, please refer to Obtaining OAuth2 Access Tokens Notifications \u00b6 Athenz can be configured to send Email Notifications. These notifications can remind users that there are tasks that require their attention such as approving a member's request to join a role, warn them on a certificate that is close to expiration, and even alert them on Athenz health when needed. To enable notifications, refer to Email Notifications Templates \u00b6 Templates are a collection of predefined roles, policies, and services that can be applied to a domain. For more information, please refer to Athenz Templates Audit features \u00b6 Athenz maintains a history of all the changes that were executed in a domain by their respective administrators. The audit log can be used whenever the administrator wants to find out who made a specific change. The query can be filtered for a specific role in a given period. AWS service identity certificate support \u00b6 The term service within Athenz is more generic than a traditional service. A service identity could represent a command, job, daemon, workflow, as well as both a client and a server. EC2 instances in AWS are no exception. They too can be bootstrapped to Athenz which allows them to access other Athenz enabled services while providing services for identities with valid authorization. For more information, please refer to Athenz Service Identity X.509 Certificate for AWS EC2 instances AWS temp credentials support \u00b6 This feature allows any service to obtain temporary session credentials for a role defined in AWS IAM to carry out operations against AWS Services. For more information, please refer to AWS Temp Credentials","title":"Athenz Capabilities"},{"location":"capabilities/#athenz-capabilities","text":"","title":"Athenz Capabilities"},{"location":"capabilities/#oauth2-access-token-support","text":"Athenz supports the OAuth2 standard by enabling the generation of Access Tokens. Access tokens represent an authoritative statement that a given principal may assume some number of roles in a domain for a limited period. They are signed to prevent tampering. For more information, please refer to Obtaining OAuth2 Access Tokens","title":"OAuth2 Access Token Support"},{"location":"capabilities/#notifications","text":"Athenz can be configured to send Email Notifications. These notifications can remind users that there are tasks that require their attention such as approving a member's request to join a role, warn them on a certificate that is close to expiration, and even alert them on Athenz health when needed. To enable notifications, refer to Email Notifications","title":"Notifications"},{"location":"capabilities/#templates","text":"Templates are a collection of predefined roles, policies, and services that can be applied to a domain. For more information, please refer to Athenz Templates","title":"Templates"},{"location":"capabilities/#audit-features","text":"Athenz maintains a history of all the changes that were executed in a domain by their respective administrators. The audit log can be used whenever the administrator wants to find out who made a specific change. The query can be filtered for a specific role in a given period.","title":"Audit features"},{"location":"capabilities/#aws-service-identity-certificate-support","text":"The term service within Athenz is more generic than a traditional service. A service identity could represent a command, job, daemon, workflow, as well as both a client and a server. EC2 instances in AWS are no exception. They too can be bootstrapped to Athenz which allows them to access other Athenz enabled services while providing services for identities with valid authorization. For more information, please refer to Athenz Service Identity X.509 Certificate for AWS EC2 instances","title":"AWS service identity certificate support"},{"location":"capabilities/#aws-temp-credentials-support","text":"This feature allows any service to obtain temporary session credentials for a role defined in AWS IAM to carry out operations against AWS Services. For more information, please refer to AWS Temp Credentials","title":"AWS temp credentials support"},{"location":"cent_authz_flow/","text":"In this section, we're going to examine the centralized authorization flow. Subsystems \u00b6 Before we go into the details of the authorization flow, it's important to understand the subsystems involved. The authorization (AuthZ) system shown in the figure below consists of several logical subsystems, which we will elaborate on in the following section. ZMS (AuthZ Management System) \u00b6 ZMS is where domains, roles, and policies are defined. This is Athenz's centralized authorization system and is likely part of a larger management system. In addition to allowing CRUD operations on the basic entities, ZMS provides an API to replicate the entities, per domain, to ZTS. It also can directly support the access check, both for internal management system checks, as well as a simple centralized deployment. ZMS is the source of truth for domains, roles, and policies for centralized authorization. ZMS supports a centralized call to check if a principal has access to a resource. Because ZMS supports service identities, ZMS can authenticate services. For centralized authorization, ZMS may be the only Athenz subsystem that you need to interact with. SIA (Service Identity Agent) \u00b6 SIA is required for authenticating existing unmanaged services. Any service that launches other services should integrate SIA (or an equivalent system). To confirm a service's identity, SIA communicates with ZTS. Centralized Access Control \u00b6 A traditional centralized mechanism works as expected for services that are not dealing with the decentralized authorization: the server with resources can simply ask the ZMS directly about access, passing its credentials (X.509 Cert) and resource/action information for a given principal to get a simple boolean answer. In this model, the Athenz Management Service is the only component that needs to be deployed and managed within your environment. This does not scale well enough for data-plane access, since a central service must be consulted, but requires no local installation of other components and related storage and synchronization logic, so it is suitable for human interaction and control-plane provisioning uses where the number of requests processed by the server is small and the latency for authorization checks is not important. Principals \u00b6 In Athenz, actors that can assume a role are called principals. Principals can be users or services, and users can be those looking for resources from a service or use the ZMS management console. The user or service must be configured with Athenz CA certificates and require mutual client authentication to accept and validate the service's X.509 certificate. Once validated, it can extract the CN field from the certificate would be the service's identity. Finally, just like the user case, it which would perform an identical check with ZMS to confirm access passing the action, resource and service name to ZMS.","title":"Centralized Authorization Flow"},{"location":"cent_authz_flow/#subsystems","text":"Before we go into the details of the authorization flow, it's important to understand the subsystems involved. The authorization (AuthZ) system shown in the figure below consists of several logical subsystems, which we will elaborate on in the following section.","title":"Subsystems"},{"location":"cent_authz_flow/#zms-authz-management-system","text":"ZMS is where domains, roles, and policies are defined. This is Athenz's centralized authorization system and is likely part of a larger management system. In addition to allowing CRUD operations on the basic entities, ZMS provides an API to replicate the entities, per domain, to ZTS. It also can directly support the access check, both for internal management system checks, as well as a simple centralized deployment. ZMS is the source of truth for domains, roles, and policies for centralized authorization. ZMS supports a centralized call to check if a principal has access to a resource. Because ZMS supports service identities, ZMS can authenticate services. For centralized authorization, ZMS may be the only Athenz subsystem that you need to interact with.","title":"ZMS (AuthZ Management System)"},{"location":"cent_authz_flow/#sia-service-identity-agent","text":"SIA is required for authenticating existing unmanaged services. Any service that launches other services should integrate SIA (or an equivalent system). To confirm a service's identity, SIA communicates with ZTS.","title":"SIA (Service Identity Agent)"},{"location":"cent_authz_flow/#centralized-access-control","text":"A traditional centralized mechanism works as expected for services that are not dealing with the decentralized authorization: the server with resources can simply ask the ZMS directly about access, passing its credentials (X.509 Cert) and resource/action information for a given principal to get a simple boolean answer. In this model, the Athenz Management Service is the only component that needs to be deployed and managed within your environment. This does not scale well enough for data-plane access, since a central service must be consulted, but requires no local installation of other components and related storage and synchronization logic, so it is suitable for human interaction and control-plane provisioning uses where the number of requests processed by the server is small and the latency for authorization checks is not important.","title":"Centralized Access Control"},{"location":"cent_authz_flow/#principals","text":"In Athenz, actors that can assume a role are called principals. Principals can be users or services, and users can be those looking for resources from a service or use the ZMS management console. The user or service must be configured with Athenz CA certificates and require mutual client authentication to accept and validate the service's X.509 certificate. Once validated, it can extract the CN field from the certificate would be the service's identity. Finally, just like the user case, it which would perform an identical check with ZMS to confirm access passing the action, resource and service name to ZMS.","title":"Principals"},{"location":"cert_signer/","text":"Certificate Signer \u00b6 Cert Signer Interfaces Configuration Provided Implementations Self Cert Signer HTTP Cert Signer Athenz supports service authentication with X.509 certificates. The services receive X509 certificates from ZTS which requires a cert signer implementation to sign and issue X509 certificates for Athenz Services. This feature, commonly referred as Copper Argos, is described in the following section . Cert Signer Interfaces \u00b6 For ZTS servers to issue X509 certificates, the following two interfaces must be implemented: CertSignerFactory . The job of the CertSignerFactory class is to implement a single create() method which returns an instance of CertSigner class implementation. CertSigner . This class implements six methods listed below: generateX509Certificate(): This method generates a signed X509 Certificate based on the given request. It takes three parameters csr (Certificate request) , requested key usage keyUsage (null for both server and client, otherwise specified usage type: server or client) and expiryTime which specifies requested certificate expiration time in minutes and returns a X509 Certificate in PEM format getCACertificate(): This method is to retrieve the CA certificate in PEM format that will be returned along with the x509 certificate back to the client. generateSSHCertificate(): This method is to generate a SSH Certificate based on the given request. getSSHCertificate(): This method is to retrieve the SSH Signer certificate for the given type. getMaxCertExpiryTimeMins(): This method is to retrieve the certificate max expiry time supported by the given signer. close(): This method is for closing the certSigner signer object and release all allocated resources During server startup, ZTS servers will load the configured cert signer factory class and invoke the create method. Then it will use the CertSigner object returned to issue X509 certificates to requesting services. Configuration \u00b6 ZTS Servers expect the configured cert signer factory class name in its athenz.zts.cert_signer_factory_class system property. For example, -Dathenz.zts.cert_signer_factory_class=com.yahoo.athenz.zts.cert.impl.HttpCertSignerFactory If you're installing and running Athenz services using the binary packages provided, you can configure the cert signer factory class in the conf/zts_server/zts.properties file for ZTS server: athenz.zts.cert_signer_factory_class=com.yahoo.athenz.zts.cert.impl.HttpCertSignerFactory Provided Implementations \u00b6 Here is the list of Athenz provided certificate signer implementations with a brief description of each one. Self Cert Signer \u00b6 Class: com.yahoo.athenz.zts.cert.impl.SelfCertSignerFactory This factory class creates and returns an object of SelfCertSigner class com.yahoo.athenz.zts.cert.impl.SelfCertSignerFactory The private key file name, private key password and the DN for self signer can be configured by using the following system properties: Key File: athenz.zts.self_signer_private_key_fname Key password: athenz.zts.self_signer_private_key_password DN: athenz.zts.self_signer_cert_dn The key file must be a PEM encoded either RSA or EC private key. Http Cert Signer \u00b6 Class: com.yahoo.athenz.zts.cert.impl.HttpCertSignerFactory This factory class creates and returns a object of HttpCertSigner class com.yahoo.athenz.zts.cert.impl.SelfCertSignerFactory This signer assumes you have a certificate singing daemon that implements POST/GET REST /x509 and /ssh endpoints to sign and return x.509 certificates. The base uri of signer service and other settings can be configured by using the following system properties: Base Uri of Cert Signer Service: athenz.zts.certsign_base_uri Connect Timeout: athenz.zts.certsign_connect_timeout This setting specifies in seconds the connect timeout. We are setting it to 10. Request Timeout: athenz.zts.certsign_request_timeout This setting specifies in seconds the request timeout. We are setting it to 5. Retry count: athenz.zts.certsign_retry_count This setting specifies the number of times the request should be retried if it's not completed with the requested timeout value. We are setting it to 3.","title":"Certificate Signer"},{"location":"cert_signer/#certificate-signer","text":"Cert Signer Interfaces Configuration Provided Implementations Self Cert Signer HTTP Cert Signer Athenz supports service authentication with X.509 certificates. The services receive X509 certificates from ZTS which requires a cert signer implementation to sign and issue X509 certificates for Athenz Services. This feature, commonly referred as Copper Argos, is described in the following section .","title":"Certificate Signer"},{"location":"cert_signer/#cert-signer-interfaces","text":"For ZTS servers to issue X509 certificates, the following two interfaces must be implemented: CertSignerFactory . The job of the CertSignerFactory class is to implement a single create() method which returns an instance of CertSigner class implementation. CertSigner . This class implements six methods listed below: generateX509Certificate(): This method generates a signed X509 Certificate based on the given request. It takes three parameters csr (Certificate request) , requested key usage keyUsage (null for both server and client, otherwise specified usage type: server or client) and expiryTime which specifies requested certificate expiration time in minutes and returns a X509 Certificate in PEM format getCACertificate(): This method is to retrieve the CA certificate in PEM format that will be returned along with the x509 certificate back to the client. generateSSHCertificate(): This method is to generate a SSH Certificate based on the given request. getSSHCertificate(): This method is to retrieve the SSH Signer certificate for the given type. getMaxCertExpiryTimeMins(): This method is to retrieve the certificate max expiry time supported by the given signer. close(): This method is for closing the certSigner signer object and release all allocated resources During server startup, ZTS servers will load the configured cert signer factory class and invoke the create method. Then it will use the CertSigner object returned to issue X509 certificates to requesting services.","title":"Cert Signer Interfaces"},{"location":"cert_signer/#configuration","text":"ZTS Servers expect the configured cert signer factory class name in its athenz.zts.cert_signer_factory_class system property. For example, -Dathenz.zts.cert_signer_factory_class=com.yahoo.athenz.zts.cert.impl.HttpCertSignerFactory If you're installing and running Athenz services using the binary packages provided, you can configure the cert signer factory class in the conf/zts_server/zts.properties file for ZTS server: athenz.zts.cert_signer_factory_class=com.yahoo.athenz.zts.cert.impl.HttpCertSignerFactory","title":"Configuration"},{"location":"cert_signer/#provided-implementations","text":"Here is the list of Athenz provided certificate signer implementations with a brief description of each one.","title":"Provided Implementations"},{"location":"cert_signer/#self-cert-signer","text":"Class: com.yahoo.athenz.zts.cert.impl.SelfCertSignerFactory This factory class creates and returns an object of SelfCertSigner class com.yahoo.athenz.zts.cert.impl.SelfCertSignerFactory The private key file name, private key password and the DN for self signer can be configured by using the following system properties: Key File: athenz.zts.self_signer_private_key_fname Key password: athenz.zts.self_signer_private_key_password DN: athenz.zts.self_signer_cert_dn The key file must be a PEM encoded either RSA or EC private key.","title":"Self Cert Signer"},{"location":"cert_signer/#http-cert-signer","text":"Class: com.yahoo.athenz.zts.cert.impl.HttpCertSignerFactory This factory class creates and returns a object of HttpCertSigner class com.yahoo.athenz.zts.cert.impl.SelfCertSignerFactory This signer assumes you have a certificate singing daemon that implements POST/GET REST /x509 and /ssh endpoints to sign and return x.509 certificates. The base uri of signer service and other settings can be configured by using the following system properties: Base Uri of Cert Signer Service: athenz.zts.certsign_base_uri Connect Timeout: athenz.zts.certsign_connect_timeout This setting specifies in seconds the connect timeout. We are setting it to 10. Request Timeout: athenz.zts.certsign_request_timeout This setting specifies in seconds the request timeout. We are setting it to 5. Retry count: athenz.zts.certsign_retry_count This setting specifies the number of times the request should be retried if it's not completed with the requested timeout value. We are setting it to 3.","title":"Http Cert Signer"},{"location":"client_side_x509_credentials/","text":"In order to contact Athenz Services (ZMS/ZTS) or other Athenz Enabled services, your client needs to establish a HTTPS connection using its Athenz issued x.509 certificate. This section contains some examples how to utilize Athenz x.509 certificates for service authentication Table of Contents \u00b6 Java ZMS Client ZTS Client HTTPSUrlConnection Client Java \u00b6 In the following set of examples we're going to assume that the service has already obtained its x.509 certificate from Athenz. ZMS Client \u00b6 We're going to use our ZMS Java client to communicate with ZMS running in AWS to carry out a centralized access check to see if principal user.john has read access to sports:nhl-scores resource. First we need to update our Java project pom.xml file to indicate our dependency on the ZMS Java Client and Certificate Refresh Helper libraries <dependencies> <dependency> <groupId>com.yahoo.athenz</groupId> <artifactId>athenz-zms-java-client</artifactId> <version>VERSION-NUMBER</version> </dependency> <dependency> <groupId>com.yahoo.athenz</groupId> <artifactId>athenz-cert-refresher</artifactId> <version>VERSION-NUMBER</version> </dependency> </dependencies> Next, let's assume the Athenz identity for the service is sports.api and SIA running on this host has already generated the private key for the service and retrieved the X.509 certificate from ZTS Server: / var / lib / sia / keys / sports . api . key . pem / var / lib / sia / certs / sports . api . cert . pem The ZMS server is running with a public X.509 certificate so we're going to use the standard jdk truststore for our connection which has a default password of changeit . import javax.net.ssl.SSLContext ; import com.oath.auth.KeyRefresher ; import com.oath.auth.Utils ; final String zmsUrl = \"https://zms-address/zms/v1\" ; final String keyPath = \"/var/lib/sia/keys/sports.api.key.pem\" ; final String certPath = \"/var/lib/sia/certs/sports.api.cert.pem\" ; final String trustStorePath = javaHome + \"/jre/lib/security/cacerts\" ; final String trustStorePassword = \"changeit\" ; try { // Create our SSL Context object based on our private key and // certificate and jdk truststore KeyRefresher keyRefresher = Utils . generateKeyRefresher ( trustStorePath , trustStorePassword , certPath , keyPath ); // Default refresh period is every hour. keyRefresher . startup (); // Can be adjusted to use other values in milliseconds. However, // only one keyRefresher.startup call must be present. // keyRefresher.startup(900000); SSLContext sslContext = Utils . buildSSLContext ( keyRefresher . getKeyManagerProxy (), keyRefresher . getTrustManagerProxy ()); // create our zms client and execute request try ( ZMSClient zmsClient = new ZMSClient ( zmsUrl , sslContext )) { try { Access access = zmsClient . getAccess ( \"read\" , \"sports:nhl-scores\" , null , \"user.john\" ); System . out . println ( \"Access: \" + access . getGranted ()); } catch ( ZMSClientException ex ) { LOGGER . error ( \"Unable to carry out access check: {}\" , ex . getMessage ()); return ; } } } catch ( Exception ex ) { LOGGER . error ( \"Unable to process request\" , ex ); return ; } ZTS Client \u00b6 We're going to use our ZTS Java client to communicate with ZTS Server running in AWS to retrieve the public key for the weather.api service with key id weather.api.key . First we need to update our Java project pom.xml file to indicate our dependency on the ZTS Java Client and Certificate Refresh Helper libraries <dependencies> <dependency> <groupId>com.yahoo.athenz</groupId> <artifactId>athenz-zts-java-client</artifactId> <version>VERSION-NUMBER</version> </dependency> <dependency> <groupId>com.yahoo.athenz</groupId> <artifactId>athenz-cert-refresher</artifactId> <version>VERSION-NUMBER</version> </dependency> </dependencies> Next, let's assume the Athenz identity for the service is sports.api and SIA running on this host has already generated the private key for the service and retrieved the X.509 certificate from ZTS Server: / var / lib / sia / keys / sports . api . key . pem / var / lib / sia / certs / sports . api . cert . pem The ZTS server is running with a public X.509 certificate so we're going to use the standard jdk truststore for our connection which has a default password of changeit . import javax.net.ssl.SSLContext ; import com.oath.auth.KeyRefresher ; import com.oath.auth.Utils ; final String ztsUrl = \"https://zts-address/zts/v1\" ; final String keyPath = \"/var/lib/sia/keys/sports.api.key.pem\" ; final String certPath = \"/var/lib/sia/certs/sports.api.cert.pem\" ; final String trustStorePath = javaHome + \"/jre/lib/security/cacerts\" ; final String trustStorePassword = \"changeit\" ; try { // Create our SSL Context object based on our private key and // certificate and jdk truststore KeyRefresher keyRefresher = Utils . generateKeyRefresher ( trustStorePath , trustStorePassword , certPath , keyPath ); // Default refresh period is every hour. keyRefresher . startup (); // Can be adjusted to use other values in milliseconds. //keyRefresher.startup(900000); SSLContext sslContext = Utils . buildSSLContext ( keyRefresher . getKeyManagerProxy (), keyRefresher . getTrustManagerProxy ()); // create our zts client and execute request try ( ZTSClient ztsClient = new ZTSClient ( ztsUrl , sslContext )) { try { PublicKeyEntry publicKey = ztsClient . getPublicKeyEntry ( \"weather\" , \"api\" , \"weather.api.key\" ); System . out . println ( \"PublicKey: \" + publicKey . getKey ()); } catch ( ZTSClientException ex ) { LOGGER . error ( \"Unable to retrieve public key: {}\" , ex . getMessage ()); return ; } } } catch ( Exception ex ) { LOGGER . error ( \"Unable to process request\" , ex ); return ; } ** Important ** During the shutdown of the application, ZTSClient.cancelPrefetch() must be called to stop the timer thread that automatically fetches and refreshes any cached tokens in the ZTS Client. Apache HTTPClient \u00b6 This example demonstrates how to correctly set up Apache HTTPClient for mutual TLS with persistent connections and connection pooling, with automatic certificate refreshing. import com.oath.auth.KeyRefresher ; import com.oath.auth.Utils ; import org.apache.http.HttpResponse ; import org.apache.http.client.methods.HttpGet ; import org.apache.http.impl.client.CloseableHttpClient ; import org.apache.http.impl.client.HttpClients ; import org.apache.http.impl.client.NoopUserTokenHandler ; import org.apache.http.util.EntityUtils ; import java.io.IOException ; import java.net.URI ; import javax.net.ssl.SSLContext ; public class Example { private final KeyRefresher keyRefresher ; private final CloseableHttpClient httpClient ; // These parameters normally point to files generated by SIA on managed hosts public Example ( String trustStorePath , String trustStorePassword , String certPath , String keyPath ) throws Exception { // Create a key refresher to automatically reload key/cert when updated by SIA this . keyRefresher = Utils . generateKeyRefresher ( trustStorePath , trustStorePassword , certPath , keyPath ); keyRefresher . startup (); // Create TLS context // Note that this may create a TLS 1.3 context when supported SSLContext sslContext = Utils . buildSSLContext ( keyRefresher . getKeyManagerProxy (), keyRefresher . getTrustManagerProxy ()); // Create the actual HTTP client this . httpClient = HttpClients . custom () // Use the context that has our keys and trusted CAs . setSSLContext ( sslContext ) // Enable connection pooling - when mutual TLS used this gets disabled by default! . setUserTokenHandler ( NoopUserTokenHandler . INSTANCE ) // You can set more options here as desired, for example number of connections to use . build (); } public void callSomeService ( URI uri ) { HttpResponse response = null ; try { HttpGet request = new HttpGet ( uri ); response = httpClient . execute ( request ); // Do something with the response System . err . println ( \"Got response: \" + response . getStatusLine (). getStatusCode ()); } catch ( IOException e ) { // Handle connection level errors here e . printStackTrace (); } finally { // Ensure the entire request entity is consumed to release the connection for reuse // Note that calling CloseableHttpResponse.close() will make the connection ineligible // for reuse so it must be avoided if ( response != null ) { EntityUtils . consumeQuietly ( response . getEntity ()); } } } } HTTPSUrlConnection Client \u00b6 Note: This method does not support connection pooling and is only included as a demonstration, production code should use fully featured HTTP client. We're going to use a HTTPSUrlConnection client to communicate with an HTTPS Server running to retrieve some data for a given url. First we need to update our Java project pom.xml file to indicate our dependency on the Certificate Refresh Helper library. <dependencies> <dependency> <groupId>com.yahoo.athenz</groupId> <artifactId>athenz-cert-refresher</artifactId> <version>VERSION-NUMBER</version> </dependency> </dependencies> Next, let's assume the Athenz identity for the service is sports.api and SIA running on this host has already generated the private key for the service and retrieved the X.509 certificate from ZTS Server: / var / lib / sia / keys / sports . api . key . pem / var / lib / sia / certs / sports . api . cert . pem The HTTPS server is running with an Athenz issued certificate so our truststore must include the Athenz CA certificates. For the following example, the truststore containing the Athenz CA certificates will be located at /home/example/athenz_certificate_bundle.jks with a default password of changeit . import javax.net.ssl.SSLContext ; import com.oath.auth.KeyRefresher ; import com.oath.auth.Utils ; final String keyPath = \"/var/lib/sia/keys/sports.api.key.pem\" ; final String certPath = \"/var/lib/sia/certs/sports.api.cert.pem\" ; final String trustStorePath = \"/home/example/athenz_certificate_bundle.jks\" ; final String trustStorePassword = \"changeit\" ; try { KeyRefresher keyRefresher = Utils . generateKeyRefresher ( trustStorePath , trustStorePassword , certPath , keyPath ); // Default refresh period is every hour. keyRefresher . startup (); // Can be adjusted to use other values in milliseconds. //keyRefresher.startup(900000); SSLContext sslContext = Utils . buildSSLContext ( keyRefresher . getKeyManagerProxy (), keyRefresher . getTrustManagerProxy ()); HttpsURLConnection . setDefaultSSLSocketFactory ( sslContext . getSocketFactory ()); HttpsURLConnection con = ( HttpsURLConnection ) new URL ( url ). openConnection (); con . setReadTimeout ( 15000 ); con . setDoOutput ( true ); con . connect (); try ( BufferedReader br = new BufferedReader ( new InputStreamReader ( con . getInputStream ()))) { StringBuilder sb = new StringBuilder (); String line ; while (( line = br . readLine ()) != null ) { sb . append ( line ); } System . out . println ( \"Data output: \" + sb . toString ()); } } catch ( Exception ex ) { LOGGER . error ( \"Unable to process request\" , ex ); return ; }","title":"Client Side Service Identity Authentication"},{"location":"client_side_x509_credentials/#table-of-contents","text":"Java ZMS Client ZTS Client HTTPSUrlConnection Client","title":"Table of Contents"},{"location":"client_side_x509_credentials/#java","text":"In the following set of examples we're going to assume that the service has already obtained its x.509 certificate from Athenz.","title":"Java"},{"location":"client_side_x509_credentials/#zms-client","text":"We're going to use our ZMS Java client to communicate with ZMS running in AWS to carry out a centralized access check to see if principal user.john has read access to sports:nhl-scores resource. First we need to update our Java project pom.xml file to indicate our dependency on the ZMS Java Client and Certificate Refresh Helper libraries <dependencies> <dependency> <groupId>com.yahoo.athenz</groupId> <artifactId>athenz-zms-java-client</artifactId> <version>VERSION-NUMBER</version> </dependency> <dependency> <groupId>com.yahoo.athenz</groupId> <artifactId>athenz-cert-refresher</artifactId> <version>VERSION-NUMBER</version> </dependency> </dependencies> Next, let's assume the Athenz identity for the service is sports.api and SIA running on this host has already generated the private key for the service and retrieved the X.509 certificate from ZTS Server: / var / lib / sia / keys / sports . api . key . pem / var / lib / sia / certs / sports . api . cert . pem The ZMS server is running with a public X.509 certificate so we're going to use the standard jdk truststore for our connection which has a default password of changeit . import javax.net.ssl.SSLContext ; import com.oath.auth.KeyRefresher ; import com.oath.auth.Utils ; final String zmsUrl = \"https://zms-address/zms/v1\" ; final String keyPath = \"/var/lib/sia/keys/sports.api.key.pem\" ; final String certPath = \"/var/lib/sia/certs/sports.api.cert.pem\" ; final String trustStorePath = javaHome + \"/jre/lib/security/cacerts\" ; final String trustStorePassword = \"changeit\" ; try { // Create our SSL Context object based on our private key and // certificate and jdk truststore KeyRefresher keyRefresher = Utils . generateKeyRefresher ( trustStorePath , trustStorePassword , certPath , keyPath ); // Default refresh period is every hour. keyRefresher . startup (); // Can be adjusted to use other values in milliseconds. However, // only one keyRefresher.startup call must be present. // keyRefresher.startup(900000); SSLContext sslContext = Utils . buildSSLContext ( keyRefresher . getKeyManagerProxy (), keyRefresher . getTrustManagerProxy ()); // create our zms client and execute request try ( ZMSClient zmsClient = new ZMSClient ( zmsUrl , sslContext )) { try { Access access = zmsClient . getAccess ( \"read\" , \"sports:nhl-scores\" , null , \"user.john\" ); System . out . println ( \"Access: \" + access . getGranted ()); } catch ( ZMSClientException ex ) { LOGGER . error ( \"Unable to carry out access check: {}\" , ex . getMessage ()); return ; } } } catch ( Exception ex ) { LOGGER . error ( \"Unable to process request\" , ex ); return ; }","title":"ZMS Client"},{"location":"client_side_x509_credentials/#zts-client","text":"We're going to use our ZTS Java client to communicate with ZTS Server running in AWS to retrieve the public key for the weather.api service with key id weather.api.key . First we need to update our Java project pom.xml file to indicate our dependency on the ZTS Java Client and Certificate Refresh Helper libraries <dependencies> <dependency> <groupId>com.yahoo.athenz</groupId> <artifactId>athenz-zts-java-client</artifactId> <version>VERSION-NUMBER</version> </dependency> <dependency> <groupId>com.yahoo.athenz</groupId> <artifactId>athenz-cert-refresher</artifactId> <version>VERSION-NUMBER</version> </dependency> </dependencies> Next, let's assume the Athenz identity for the service is sports.api and SIA running on this host has already generated the private key for the service and retrieved the X.509 certificate from ZTS Server: / var / lib / sia / keys / sports . api . key . pem / var / lib / sia / certs / sports . api . cert . pem The ZTS server is running with a public X.509 certificate so we're going to use the standard jdk truststore for our connection which has a default password of changeit . import javax.net.ssl.SSLContext ; import com.oath.auth.KeyRefresher ; import com.oath.auth.Utils ; final String ztsUrl = \"https://zts-address/zts/v1\" ; final String keyPath = \"/var/lib/sia/keys/sports.api.key.pem\" ; final String certPath = \"/var/lib/sia/certs/sports.api.cert.pem\" ; final String trustStorePath = javaHome + \"/jre/lib/security/cacerts\" ; final String trustStorePassword = \"changeit\" ; try { // Create our SSL Context object based on our private key and // certificate and jdk truststore KeyRefresher keyRefresher = Utils . generateKeyRefresher ( trustStorePath , trustStorePassword , certPath , keyPath ); // Default refresh period is every hour. keyRefresher . startup (); // Can be adjusted to use other values in milliseconds. //keyRefresher.startup(900000); SSLContext sslContext = Utils . buildSSLContext ( keyRefresher . getKeyManagerProxy (), keyRefresher . getTrustManagerProxy ()); // create our zts client and execute request try ( ZTSClient ztsClient = new ZTSClient ( ztsUrl , sslContext )) { try { PublicKeyEntry publicKey = ztsClient . getPublicKeyEntry ( \"weather\" , \"api\" , \"weather.api.key\" ); System . out . println ( \"PublicKey: \" + publicKey . getKey ()); } catch ( ZTSClientException ex ) { LOGGER . error ( \"Unable to retrieve public key: {}\" , ex . getMessage ()); return ; } } } catch ( Exception ex ) { LOGGER . error ( \"Unable to process request\" , ex ); return ; } ** Important ** During the shutdown of the application, ZTSClient.cancelPrefetch() must be called to stop the timer thread that automatically fetches and refreshes any cached tokens in the ZTS Client.","title":"ZTS Client"},{"location":"client_side_x509_credentials/#apache-httpclient","text":"This example demonstrates how to correctly set up Apache HTTPClient for mutual TLS with persistent connections and connection pooling, with automatic certificate refreshing. import com.oath.auth.KeyRefresher ; import com.oath.auth.Utils ; import org.apache.http.HttpResponse ; import org.apache.http.client.methods.HttpGet ; import org.apache.http.impl.client.CloseableHttpClient ; import org.apache.http.impl.client.HttpClients ; import org.apache.http.impl.client.NoopUserTokenHandler ; import org.apache.http.util.EntityUtils ; import java.io.IOException ; import java.net.URI ; import javax.net.ssl.SSLContext ; public class Example { private final KeyRefresher keyRefresher ; private final CloseableHttpClient httpClient ; // These parameters normally point to files generated by SIA on managed hosts public Example ( String trustStorePath , String trustStorePassword , String certPath , String keyPath ) throws Exception { // Create a key refresher to automatically reload key/cert when updated by SIA this . keyRefresher = Utils . generateKeyRefresher ( trustStorePath , trustStorePassword , certPath , keyPath ); keyRefresher . startup (); // Create TLS context // Note that this may create a TLS 1.3 context when supported SSLContext sslContext = Utils . buildSSLContext ( keyRefresher . getKeyManagerProxy (), keyRefresher . getTrustManagerProxy ()); // Create the actual HTTP client this . httpClient = HttpClients . custom () // Use the context that has our keys and trusted CAs . setSSLContext ( sslContext ) // Enable connection pooling - when mutual TLS used this gets disabled by default! . setUserTokenHandler ( NoopUserTokenHandler . INSTANCE ) // You can set more options here as desired, for example number of connections to use . build (); } public void callSomeService ( URI uri ) { HttpResponse response = null ; try { HttpGet request = new HttpGet ( uri ); response = httpClient . execute ( request ); // Do something with the response System . err . println ( \"Got response: \" + response . getStatusLine (). getStatusCode ()); } catch ( IOException e ) { // Handle connection level errors here e . printStackTrace (); } finally { // Ensure the entire request entity is consumed to release the connection for reuse // Note that calling CloseableHttpResponse.close() will make the connection ineligible // for reuse so it must be avoided if ( response != null ) { EntityUtils . consumeQuietly ( response . getEntity ()); } } } }","title":"Apache HTTPClient"},{"location":"client_side_x509_credentials/#httpsurlconnection-client","text":"Note: This method does not support connection pooling and is only included as a demonstration, production code should use fully featured HTTP client. We're going to use a HTTPSUrlConnection client to communicate with an HTTPS Server running to retrieve some data for a given url. First we need to update our Java project pom.xml file to indicate our dependency on the Certificate Refresh Helper library. <dependencies> <dependency> <groupId>com.yahoo.athenz</groupId> <artifactId>athenz-cert-refresher</artifactId> <version>VERSION-NUMBER</version> </dependency> </dependencies> Next, let's assume the Athenz identity for the service is sports.api and SIA running on this host has already generated the private key for the service and retrieved the X.509 certificate from ZTS Server: / var / lib / sia / keys / sports . api . key . pem / var / lib / sia / certs / sports . api . cert . pem The HTTPS server is running with an Athenz issued certificate so our truststore must include the Athenz CA certificates. For the following example, the truststore containing the Athenz CA certificates will be located at /home/example/athenz_certificate_bundle.jks with a default password of changeit . import javax.net.ssl.SSLContext ; import com.oath.auth.KeyRefresher ; import com.oath.auth.Utils ; final String keyPath = \"/var/lib/sia/keys/sports.api.key.pem\" ; final String certPath = \"/var/lib/sia/certs/sports.api.cert.pem\" ; final String trustStorePath = \"/home/example/athenz_certificate_bundle.jks\" ; final String trustStorePassword = \"changeit\" ; try { KeyRefresher keyRefresher = Utils . generateKeyRefresher ( trustStorePath , trustStorePassword , certPath , keyPath ); // Default refresh period is every hour. keyRefresher . startup (); // Can be adjusted to use other values in milliseconds. //keyRefresher.startup(900000); SSLContext sslContext = Utils . buildSSLContext ( keyRefresher . getKeyManagerProxy (), keyRefresher . getTrustManagerProxy ()); HttpsURLConnection . setDefaultSSLSocketFactory ( sslContext . getSocketFactory ()); HttpsURLConnection con = ( HttpsURLConnection ) new URL ( url ). openConnection (); con . setReadTimeout ( 15000 ); con . setDoOutput ( true ); con . connect (); try ( BufferedReader br = new BufferedReader ( new InputStreamReader ( con . getInputStream ()))) { StringBuilder sb = new StringBuilder (); String line ; while (( line = br . readLine ()) != null ) { sb . append ( line ); } System . out . println ( \"Data output: \" + sb . toString ()); } } catch ( Exception ex ) { LOGGER . error ( \"Unable to process request\" , ex ); return ; }","title":"HTTPSUrlConnection Client"},{"location":"copper_argos/","text":"Copper Argos: Athenz Service Identity X.509 Certificates \u00b6 Introduction Copper Argos Provider Service Registration Instance Register Request Instance Refresh Request Conclusion Introduction \u00b6 Rather than having a service administrator generate a key pair and register in Athenz, a new solution called Copper Argos was designed and implemented that would allow the service to be identified by its X.509 certificate issued by Athenz: Athenz would integrate with a Certificate Signer Daemon that would store its private key in HSM (e.g. AWS CloudHSM) A Service Identity Agent (SIA) running on an instance would generate a key pair on the instance itself, generate a CSR and send along with its authentication details to ZTS Server to request a certificate for the service. Once the request is authorized and validated, ZTS would contact Certificate Signer Daemon to mint a certificate for the instance. It would be valid for 30 days and the SIA running on the instance will be responsible to refresh the certificate daily. The service running on host can use the generated private key and the X.509 certificate it received from ZTS to identify itself to other services running within the organization. Copper Argos \u00b6 Copper Argos is Athenz generalized model for service providers to launch other service identities in an authorized way through a callback-based verification model. The high level requirements for Copper Argos are as follows: Once authorized as a service launcher in Athenz, the Provider will launch the Service by providing it with a signed identity document. SIA installed on the instance during bootstrap process or available as part of the base image that the service is deployed on will create a public/private key pair, generate a certificate request (CSR) and submit the identity document along with its CSR to Athenz ZTS Service. Athenz ZTS Service would carry out 2 authorization checks: a. It verifies that the Provider is authorized to launch services. This prohibits any service act like a provider and attempt to launch other services. b. It verifies that the Service being launched has authorized the Provider as its launcher. This prohibits any authorized Provider to launch any other service without explicit authorization from the tenant service administrator. Athenz ZTS contacts the Provider to validate the signed instance identity document. Once verified, ZTS contacts Certificate Signer Daemon to generate a X.509 Certificate valid for 30 days for the given CSR and returns to instance. SIA is responsible for contacting ZTS daily to refresh the service X.509 certificate. The next several section describe the for Copper Argos requirements in more detail. Provider Service Registration \u00b6 An important part of issuing X.509 certificates is trusting the Provider. The Provider must retrieve a TLS certificate for its own service from Athenz and use that as its Server Certificate. When ZTS contacts Provider Service to validate an instance document, it will require TLS authentication and verify that the certificate the service used for establish secure communication was issued for the expected provider service by ZTS itself. As part of its registration, the provider will also specify a unique registered dns suffix that would be combined with the service identity name and included as a dnsName attribute value in the X.509 certificate. For example, if an instance deployed is going to have an Athenz identity of sports.api and the Provider\u2019s dns suffix is sports.athenz.cloud, then the dnsName attribute in the generated X.509 certificate would be api.sports.sports.athenz.cloud. The official format for the dnsName attribute is <service>.<domain-with-dashes>.<dns-suffix> . Instance Register Request \u00b6 Before a tenant service can be launched by a specific provider and issued a TLS certificate for, the tenant domain administrator must authorize a specific provider service to launch its services. The provider is expected to configure separate launcher services for each data center and/or region it supports. This allows the tenant the flexibility to authorize the provider to launch its service in specific data center/region (e.g. grant launch action to provider sys.auth.aws.us-west-2) or in all supported data centers/regions (e.g. grant launch action to provider sys.auth.aws.*). ZTS does not have knowledge of each provider\u2019s signed instance document details - what\u2019s included, what is the format or what crypto algorithm was used to sign the document. Although each provider is strongly recommended to represent their instance documents as signed Json Web Tokens, ZTS treats it as an opaque string and relies on the registered provider service callback verifier to validate the document. ZTS does impose specific requirements on the X.509 CSR generated by SIA: The Subject CN in the CSR must be the Athenz service identity name (e.g. sports.api - api service in sports domain) The CSR must include a SAN dnsName attribute with the format: <service>.<domain-with-dashes>.<provider-dnsname-suffix> . The provider-dnsname-suffix must be provided by the provider service to the SIA agent. The provider must specify a unique identifier for the instance within the provider\u2019s namespace (this could be combination of multiple strings - e.g. instance-id.pod-id.cluster-id) and this information must be included in the CSR as another SAN dnsName attribute with the format: <provider-unique-instance-id>.instanceid.athenz.<provider-dnsname-suffix> . The ZTS server will use this information along with the issued TLS Certificate Serial number to revoke specific instances if they\u2019re compromised (more details are provided in the Instance Refresh Request section below). Instance Refresh Request \u00b6 During instance refresh request, ZTS Server carries out additional checks in addition to contacting provider service for verification of the instance. It will first verify that the connection is using the previous TLS certificate issued for the service and provider and the service authorization policies are still in place. In case a host is compromised and the attacker obtains the private key and ZTS issued X.509 certificate corresponding to that key, Athenz has additional checks in place to prevent the attacker to continuously refresh the certificate. A requirement of Copper Argos is that the CSR that the SIA generates must include a unique id that the provider has assigned to that instance in the X509 v3 SAN Extension dnsName field. Since each certificate is uniquely identified by its Serial Number (defined as BigInteger - e.g. Serial Number: 7e:14:6f:a2:33:b4:49:84:cb:f1:1f:c5:9d:a8:38:cb) generated by Athenz CA, Athenz ZTS can use that information along with instance id to maintain list of all issued certificates for instances with their serial numbers, detect compromised certificate refresh requests and revoke specific hosts from the refresh requests. When processing refresh requests, Athenz ZTS Server: Validates that the instance id in the CSR matches to the instance id of the certificate that was used for authentication. Retrieve the Instance ID record from the Certificate Database. This database is updated when the initial and refresh certificates are issued. The current serial number of the certificate must match to the certificate serial number registered in the instance ID record. The server keeps track of last 2 (current and previous) serial numbers thus allowing a single retry operation in case the client failed to update its local filesystem after receiving refreshed certificates. So if both the instance and the attacker start using the same instance id for refreshing certificates, Athenz ZTS will detect a mismatch between serial numbers assigned and used in those refresh requests, thus will revoke the instance from refreshing its certificates. Conclusion \u00b6 Copper Argos provides a secure and generic way for service providers to launch other authorized services with Athenz issued service identity X.509 certificates.","title":"Service Identity X.509 Certificates - Copper Argos"},{"location":"copper_argos/#copper-argos-athenz-service-identity-x509-certificates","text":"Introduction Copper Argos Provider Service Registration Instance Register Request Instance Refresh Request Conclusion","title":"Copper Argos: Athenz Service Identity X.509 Certificates"},{"location":"copper_argos/#introduction","text":"Rather than having a service administrator generate a key pair and register in Athenz, a new solution called Copper Argos was designed and implemented that would allow the service to be identified by its X.509 certificate issued by Athenz: Athenz would integrate with a Certificate Signer Daemon that would store its private key in HSM (e.g. AWS CloudHSM) A Service Identity Agent (SIA) running on an instance would generate a key pair on the instance itself, generate a CSR and send along with its authentication details to ZTS Server to request a certificate for the service. Once the request is authorized and validated, ZTS would contact Certificate Signer Daemon to mint a certificate for the instance. It would be valid for 30 days and the SIA running on the instance will be responsible to refresh the certificate daily. The service running on host can use the generated private key and the X.509 certificate it received from ZTS to identify itself to other services running within the organization.","title":"Introduction"},{"location":"copper_argos/#copper-argos","text":"Copper Argos is Athenz generalized model for service providers to launch other service identities in an authorized way through a callback-based verification model. The high level requirements for Copper Argos are as follows: Once authorized as a service launcher in Athenz, the Provider will launch the Service by providing it with a signed identity document. SIA installed on the instance during bootstrap process or available as part of the base image that the service is deployed on will create a public/private key pair, generate a certificate request (CSR) and submit the identity document along with its CSR to Athenz ZTS Service. Athenz ZTS Service would carry out 2 authorization checks: a. It verifies that the Provider is authorized to launch services. This prohibits any service act like a provider and attempt to launch other services. b. It verifies that the Service being launched has authorized the Provider as its launcher. This prohibits any authorized Provider to launch any other service without explicit authorization from the tenant service administrator. Athenz ZTS contacts the Provider to validate the signed instance identity document. Once verified, ZTS contacts Certificate Signer Daemon to generate a X.509 Certificate valid for 30 days for the given CSR and returns to instance. SIA is responsible for contacting ZTS daily to refresh the service X.509 certificate. The next several section describe the for Copper Argos requirements in more detail.","title":"Copper Argos"},{"location":"copper_argos/#provider-service-registration","text":"An important part of issuing X.509 certificates is trusting the Provider. The Provider must retrieve a TLS certificate for its own service from Athenz and use that as its Server Certificate. When ZTS contacts Provider Service to validate an instance document, it will require TLS authentication and verify that the certificate the service used for establish secure communication was issued for the expected provider service by ZTS itself. As part of its registration, the provider will also specify a unique registered dns suffix that would be combined with the service identity name and included as a dnsName attribute value in the X.509 certificate. For example, if an instance deployed is going to have an Athenz identity of sports.api and the Provider\u2019s dns suffix is sports.athenz.cloud, then the dnsName attribute in the generated X.509 certificate would be api.sports.sports.athenz.cloud. The official format for the dnsName attribute is <service>.<domain-with-dashes>.<dns-suffix> .","title":"Provider Service Registration"},{"location":"copper_argos/#instance-register-request","text":"Before a tenant service can be launched by a specific provider and issued a TLS certificate for, the tenant domain administrator must authorize a specific provider service to launch its services. The provider is expected to configure separate launcher services for each data center and/or region it supports. This allows the tenant the flexibility to authorize the provider to launch its service in specific data center/region (e.g. grant launch action to provider sys.auth.aws.us-west-2) or in all supported data centers/regions (e.g. grant launch action to provider sys.auth.aws.*). ZTS does not have knowledge of each provider\u2019s signed instance document details - what\u2019s included, what is the format or what crypto algorithm was used to sign the document. Although each provider is strongly recommended to represent their instance documents as signed Json Web Tokens, ZTS treats it as an opaque string and relies on the registered provider service callback verifier to validate the document. ZTS does impose specific requirements on the X.509 CSR generated by SIA: The Subject CN in the CSR must be the Athenz service identity name (e.g. sports.api - api service in sports domain) The CSR must include a SAN dnsName attribute with the format: <service>.<domain-with-dashes>.<provider-dnsname-suffix> . The provider-dnsname-suffix must be provided by the provider service to the SIA agent. The provider must specify a unique identifier for the instance within the provider\u2019s namespace (this could be combination of multiple strings - e.g. instance-id.pod-id.cluster-id) and this information must be included in the CSR as another SAN dnsName attribute with the format: <provider-unique-instance-id>.instanceid.athenz.<provider-dnsname-suffix> . The ZTS server will use this information along with the issued TLS Certificate Serial number to revoke specific instances if they\u2019re compromised (more details are provided in the Instance Refresh Request section below).","title":"Instance Register Request"},{"location":"copper_argos/#instance-refresh-request","text":"During instance refresh request, ZTS Server carries out additional checks in addition to contacting provider service for verification of the instance. It will first verify that the connection is using the previous TLS certificate issued for the service and provider and the service authorization policies are still in place. In case a host is compromised and the attacker obtains the private key and ZTS issued X.509 certificate corresponding to that key, Athenz has additional checks in place to prevent the attacker to continuously refresh the certificate. A requirement of Copper Argos is that the CSR that the SIA generates must include a unique id that the provider has assigned to that instance in the X509 v3 SAN Extension dnsName field. Since each certificate is uniquely identified by its Serial Number (defined as BigInteger - e.g. Serial Number: 7e:14:6f:a2:33:b4:49:84:cb:f1:1f:c5:9d:a8:38:cb) generated by Athenz CA, Athenz ZTS can use that information along with instance id to maintain list of all issued certificates for instances with their serial numbers, detect compromised certificate refresh requests and revoke specific hosts from the refresh requests. When processing refresh requests, Athenz ZTS Server: Validates that the instance id in the CSR matches to the instance id of the certificate that was used for authentication. Retrieve the Instance ID record from the Certificate Database. This database is updated when the initial and refresh certificates are issued. The current serial number of the certificate must match to the certificate serial number registered in the instance ID record. The server keeps track of last 2 (current and previous) serial numbers thus allowing a single retry operation in case the client failed to update its local filesystem after receiving refreshed certificates. So if both the instance and the attacker start using the same instance id for refreshing certificates, Athenz ZTS will detect a mismatch between serial numbers assigned and used in those refresh requests, thus will revoke the instance from refreshing its certificates.","title":"Instance Refresh Request"},{"location":"copper_argos/#conclusion","text":"Copper Argos provides a secure and generic way for service providers to launch other authorized services with Athenz issued service identity X.509 certificates.","title":"Conclusion"},{"location":"copper_argos_dev/","text":"Copper Argos: Athenz Service Identity X.509 Certificates Development \u00b6 What is Copper Argos Provider Service Registration Tenant Service Launch Authorization Instance Register Request Instance Refresh Request Instance Revocation Request Athenz RDL Instance Register Request Instance Identity Response Instance Refresh Request Instance Revoke Request Instance Provider RDL Authorization Policies System Providers Provider Authorized DNS Suffix Service Authorized Providers Sample Implementation and Setup Tasks Athenz System Setup Provider Service Implementation and Registration Athenz Authorized Provider Registration Tenant Service Registration Provider Client Implementation What is Copper Argos \u00b6 Copper Argos extends Athenz with generalized model for service providers to launch other identities in an authorized way through a callback-based verification model. With this model each provider is responsible for their instance document verification service instead of embedding that logic inside ZTS. Provider Service Registration \u00b6 Each provider is a registered service identity object in Athenz. As such, the provider domain administrator will create the service identity object in their domain and provide the following attributes using zms-cil utility or the REST API. (Athenz UI does not expose optional service attributes since they\u2019re not commonly used). * Provider Endpoint - A REST API endpoint that implements Provider RDL and ZTS will contact to validate the instance document (ServiceIdentity already has the providerEndpoint attribute) Domain administrator will then need to follow up with the Athenz Team to authorize Provider Service as an Instance Launcher Service in Athenz. The Provider will also specify the DNS suffix that will be used by its tenants. There will be a policy in sys.auth domain that grants launch action to instance resource to the providers role. Once approved, the Athenz System admin will add the provider service identity to the providers role in the sys.auth domain either using zms-cli or Athenz UI. There will be policy granting access to the specified Provider SAN dnsName attribute suffix to the list service provider. Requirements for Provider Service: * It must retrieve a TLS certificate for its service from Athenz and use that as its Service Certificate. * When ZTS Contacts Provider Service to validate an instance document, it will require TLS authentication and verify that the certificate the service used for authentication was issued for the expected provider service by ZTS itself. * ZTS issues TLS certificates valid for 30 days only, so the Provider Service Admin must have the capability to periodically refresh its certificate by requesting a new one from ZTS Server (e.g. daily) and dynamically update its service to use the refreshed certificates. Tenant Service Launch Authorization \u00b6 Before a tenant service can be launched by a specific provider and issued a TLS certificate for, the tenant domain administrator must authorize a specific provider service to launch its services. This will require that a role and policy to be created in the tenant\u2019s domain. For example, if weather.api service wants to authorize athenz.aws provider to launch its services, it will need to create the following policy and role in their domain: * Policy: grant launch to aws-provider on weather:service.api * Role: aws-provider role member: athenz.aws.us-west-2 The change can be carried out with using zms-cli or Athenz UI. Instance Register Request \u00b6 Once the service admin creates the appropriate role and policy in its domain authorizing the provider service to bootstrap its instance, it can submit the launch request to the provider service. The steps of the bootstrap process pertaining Athenz integration would include: As part of the launch request, the admin will specify the Athenz domain and service that should be assigned to the instance. The provider service will generate an instance identity document, sign it with its private key and securely transfer this document along with its signature onto to the bootstrapped host. As part of the bootstrap process or possible as part of the image, the Service Identity Agent (SIA) will also be installed on the host. SIA will generate a public/private key pair on the host, generate a CSR using the newly generated private key. The CSR requirements are as follows: The Subject CN in the CSR must be the Athenz service identity name (e.g. weather.api - api service in weather domain) The CSR must include a SAN dnsName attribute with the format: <service-with-domain>.<provider-dnsname-suffix> . The provider-dnsname-suffix must match the value registered for the provider service. The <service-with-domain> part is left up to to the provider to define what format they want to use (e.g. <service>.<domain> or <service>.<domain-with-dashes> ). ZTS server will pass these hostnames to the provider as entries in the attribute field for validation. The provider must specify a unique identifier for the instance within the provider\u2019s namespace (this could be combination of multiple strings - e.g. instance-id.pod-id.cluster-id) and this information must be included in the CSR as another SAN dnsName attribute with the format: <provider-unique-instance-id>.instanceid.athenz.<provider-dnsname-suffix> . The ZTS server will use this information along with the issued TLS Certificate Serial number to revoke specific instances if they\u2019re compromised. SIA will generate an InstanceRegisterInformation object that will include attestation data (this would include the instance identity document, its signature and other attributes that will be necessary for the provider to validate and confirm the instance register request from ZTS) received from the provider and submit the post request to ZTS Server. ZTS Server will carry out the following authorization and verification checks before contacting provider service: The provider service in the info object has been authorized in Athenz to launch services (policy exists in sys.auth domain). Service specified in the info object (domain.service) has authorized provider service in the info object to launch itself (policy exists in the service\u2019s own domain). The provider service is registered in Athenz, has a providerEndpoint (verified as internal ip address) and providerDnsNameSuffix attributes defined. The cn in the CSR matches to the specific domain and service names. The CSR must include only 2 dnsName attributes with the expected format: <service-with-domain>.<provider-dnsname-suffix> <provider-unique-instance-id>.instanceid.athenz.<provider-dnsname-suffix> ZTS Server will contact Provider service at its configured endpoint and verify that the TLS certificate used for authentication by the provider service matches to the service name and was issued by ZTS server itself. ZTS Server will generate an InstanceConfirmation object and submit the post request to the Provider Service. In the InstanceConfirmation object, ZTS server will include the following entries in the optional attributes map: sanDNS: comma separated list of dnsNames attributes in the CSR - there will only be 2 as defined in 6(e) above sanIP - comma separated list of IP addresses in the CSR if any were specified clientIP - the IP address of the client cloudAccount - domain\u2019s account id if one is configured The Provider Service will be responsible for: Validating Signature Validating the instance id Validating the bootup time is within acceptable time period (e..g 5 mins) Validating hostnames included in the CSR Validating IP addresses (if available) included in the CSR Once ZTS service receives a successful response from the Provider Service, it will submit the CSR to Certsignd to generate a X.509 Certificate ZTS Server will retrieve the Serial number from the Certificate and register the certificate along with instanceid and provider service name in its certificate database. This will be used to monitor refresh certificate operations and, in case of a compromise, revoke specific instances from the capability to refresh their own certificates. Instance Refresh Request \u00b6 During instance refresh request, ZTS Server again contacts provider service for verification of the instance. This is necessary in case the credentials have been compromised and the original instance is no longer running and will allow the provider to verify that the instance is indeed still running. ZTS will also verify that the connection is using the previous TLS certificate issued for the service and provider and the authorization policies are still in place. The steps would include: SIA will generate a public/private key pair on the host, generate a CSR using the newly generated private key. The CSR requirements are as follows: The Subject CN in the CSR must be the Athenz service identity name (e.g. weather.api - api service in weather domain) The CSR must include a SAN dnsName attribute with the format: <service-with-domain>.<provider-dnsname-suffix> that was used in the original register request. The provider must specify a unique identifier for the instance within the provider namespace (this could be combination of multiple strings - e.g. instance-id.pod-id.cluster-id) and this information must be included in the CSR as another SAN dnsName attribute with the format: <provider-unique-instance-id>.instanceid.athenz.<provider-dnsname-suffix> . The ZTS server will use this information along with the issued TLS Certificate Serial number to revoke specific instances if they\u2019re compromised. SIA will generate an InstanceRefreshInformation object including attestation data and submit the post request to ZTS Server. It will be required to use the TLS certificate that was issued to that instance previously by ZTS Server. ZTS Server will carry out the following authorization and verification checks before contacting provider service: The provider service in the info object has been authorized in Athenz to launch services (policy exists in sys.auth domain). Service specified in the info object (domain.service) has authorized provider service in the info object to launch itself (policy exists in the service\u2019s own domain). The cn in the CSR matches to the specific domain and service names. The TLS certificate SIA used to contact ZTS server must be for the same service. The TLS certificate SIA used to contact ZTS server must have the same provider and the 2 dnsName attributes as the CSR. ZTS Server will extract the instanceid from CSR and verify that the instance has not been revoked and the serial number matches to the registered entry in the certificate database. ZTS Server will contact Provider service at its configured endpoint and verify that the TLS certificate used for authentication by the provider service matches to the service name and was issued by ZTS server itself. ZTS Server will generate an InstanceConfirmation object and submit the post request to the Provider Service. In the InstanceConfirmation object, ZTS server will include the attestation data presented by instance. The Provider Service will be responsible for: Validating attestation data Validating hostnames included in the CSR Validating IP addresses (if available) included in the CSR Once ZTS service receives a successful response from the Provider Service, it will submit the CSR to Certsignd to generate a X.509 Certificate ZTS Server will retrieve the Serial number from the new Certificate and update the certificate database with the new serial number. Instance Revocation Request \u00b6 If necessary, the domain administrators must be able to revoke specific instances from having the capability to refresh their certificate. The steps would be: Domain Admin will issue a HTTP DELETE /instance/\u2026 request to ZTS Server. ZTS Server will authorize the request and update the serial number for the requested instance id in the certificate database to -1. This operation will revoke the instance from refreshing its certificates. Athenz RDL \u00b6 Instance Register Request \u00b6 InstanceRegisterInformation is the information a provider-hosted booting instance must provide to Athenz to authenticate: type InstanceRegisterInformation Struct { ServiceName provider; //the provider service name (i.e. \"aws.us-west-2\") DomainName domain; //the domain of the instance SimpleName service; //the service this instance is supposed to run String attestationData;//signed identity document containing attributes //like IP address, instance-id, account#, signature, etc String csr; //the Certificate Signing Request for the expected //X.509 certificate in the response String ssh (optional); //if present, return an SSH host certificate. //Format is JSON. Bool token (optional); // if true, return a service token signed by //ZTS for this service } resource InstanceIdentity POST \"/instance\" { InstanceRegisterInformation info; String location (header=\"Location\", out); //return location for subsequent operations expected CREATED; exceptions { ResourceError BAD_REQUEST; ResourceError FORBIDDEN; ResourceError UNAUTHORIZED; ResourceError INTERNAL_SERVER_ERROR; } } Instance Identity Response \u00b6 InstanceIdentity is returned on successful attestation. includes the certifictates, tokens, and any additional provider-specific derived attributes. type InstanceIdentity Struct { ServiceName provider; //the provider service name (i.e. \"aws.us-west-2\") ServiceName name; //name of the identity, fully qualified, e.g weather.api PathElement instanceId; //unique instance id within provider\u2019s namespace String x509Certificate (optional); //an X.509 certificate usable for //both client and server in TLS connections String x509CertificateSigner (optional); //the CA certificate chain to //verify all generated X.509 certs String sshCertificate (optional); //the SSH certificate, signed by //the CA (user or host) String sshCertificateSigner (optional); //the SSH CA's public key //for the sshCertificate (user or host) SignedToken serviceToken (optional); //service token instead of TLS certificate Map<String,String> attributes (optional); //other config-like attributes //determined at boot time } Instance Refresh Request \u00b6 InstanceRefreshInformation is the information a provider-hosted booting instance must provide to Athenz to refresh the TLS certificate it was issued initially. The request must be done using the previously issued client TLS certificate. type InstanceRefreshInformation Struct { String attestationData (optional); //identity attestation data including //document with its signature containing attributes like IP //address, instance-id, account#, etc. String csr (optional); //the Certificate Signing Request for the expected //X.509 certificate in the response String ssh (optional); //if present, return an SSH host certificate. //Format is JSON. Bool token (optional); // if true, return a service token signed by //ZTS for this service } resource InstanceIdentity POST \"/instance/{provider}/{domain}/{service}/{instanceId}\" { ServiceName provider; //the provider service name (i.e. \"aws.us-west-2\") DomainName domain; //the domain of the instance SimpleName service; //the service this instance is supposed to run PathElement instanceId; //the instance id that\u2019s unique within this provider InstanceRefreshInformation info; //the refresh request authenticate; //only TLS Certificate authentication is allowed expected OK; exceptions { ResourceError BAD_REQUEST; ResourceError FORBIDDEN; ResourceError NOT_FOUND; ResourceError UNAUTHORIZED; ResourceError INTERNAL_SERVER_ERROR; } } Instance Revoke Request \u00b6 resource InstanceIdentity DELETE \"/instance/{provider}/{domain}/{service}/{instanceId}\" { ServiceName provider; //the provider service name (i.e. \"aws.us-west-2\") DomainName domain; //the domain of the instance SimpleName service; //the service this instance is supposed to run PathElement instanceId; //the instance id that\u2019s unique within this provider authorize(\u201cdelete\u201d, {domain}:instance.{instanceId}; expected NO_CONTENT; exceptions { ResourceError BAD_REQUEST; ResourceError FORBIDDEN; ResourceError NOT_FOUND; ResourceError UNAUTHORIZED; ResourceError INTERNAL_SERVER_ERROR; } } Instance Provider RDL \u00b6 This is the RDL that any provider that is authorized to create instances through Athenz must implement. This interface must be available over HTTPS only. type InstanceConfirmation Struct { ServiceName provider; //the provider service name DomainName domain; //the domain of the instance SimpleName service; //the service this instance is supposed to run String attestationData; //signed identity document containing attributes //like IP address, instance-id, account#, signature, etc. Map<String,String> attributes (optional); //additional non-signed attributes that assist //in attestation. I.e. \"instanceId\u201d, keyId\", \"accessKey\", etc } Confirm instance identity information and return appropriate response to ZTS Server. On return from the confirmation, the resulting InstanceConfirmation may have additional useful attributes added, for example attributes taken from the identity document like \"account\" number or a canonical value like \"network\" that gets identified differently with different providers. resource InstanceConfirmation POST \"/instance\" { InstanceConfirmation confirmation; authenticate; expected OK; exceptions { ResourceError BAD_REQUEST; ResourceError FORBIDDEN; ResourceError UNAUTHORIZED; } } resource InstanceConfirmation POST \"/refresh\" (name=PostRefreshConfirmation) { InstanceConfirmation confirmation; Authenticate; expected OK; exceptions { ResourceError BAD_REQUEST; ResourceError FORBIDDEN; ResourceError UNAUTHORIZED; } } Authorization Policies \u00b6 System Providers \u00b6 Athenz will maintain list of authorized provider services in sys.auth domain. If necessary, we can configure specific policies to grant additional users access over the roles/policies used to configure the list of provider. Domain: sys.auth Role: providers Members: <provider-name(s)> (e.g. openstack.cluster1) Policy: providers Assertion: grant launch to providers on sys.auth:instance Provider Authorized DNS Suffix \u00b6 When generating a CSR to request a TLS certificate for a service, the sia agent must know what DNS Suffix is the provider authorized to use so it can include the dnsName attribute in the CSR in the expected form (e.g. <service>.<domain-with-dashes>.<provider-dns-suffix> ). ZTS must validate that the provider is authorized to launch a service with that DNS suffix. For now, this information will be authorized against a policy in special sys.auth domain. Domain: sys.auth Role: provider.<provider-name> (e.g. provider.openstack.cluster1) Members: <provider-name(s)> (e.g. openstack.cluster1) Policy: provider.<provider-name> Assertion: grant launch to provider.<provider-name> on sys.auth:dns.<provider-suffix> Service Authorized Providers \u00b6 Each service will have a role/policy in their own domain that they control whether or not authorize specific providers to launch their services. For example, service weather.api wants to authorize AWS services to launch its services: Domain: weather.api Role: api_providers Members: athenz.aws Policy: api_providers Assertion: grant launch to \u201capi_providers\u201d on \u201cweather:service.api\u201d Sample Implementation and Setup Tasks \u00b6 Athenz System Setup \u00b6 Create the provider\u2019s role: $ zms-cli -d sys.auth add-regular-role providers Create the provider\u2019s policy: $ zms-cli -d sys.auth add-policy providers grant launch to providers on instance Provider Service Implementation and Registration \u00b6 Implement provider service that implements Instance Provider RDL. Register the provider service in Athenz in the provider\u2019s domain. For example, we\u2019ll be registering a provider service called openstack.cluster1. Generate private/public key pair for the service. $ openssl genrsa -out service_private.key 2048 $ openssl rsa -in service_private.key -pubout > service_public.key Create the service identity in Athenz with public key id: v0 $ zms-cli -d openstack add-service cluster1 v0 ./service_public.key Determine the https endpoint for your service that ZTS will contact to verify instance information. For example, https://provider-cluster1.openstack.athenz.com:4443/hostsigner/v1 and set the endpoint for the service: $ zms-cli -d openstack set-service-endpoint cluster1 https://provider-cluster1.openstack.athenz.com:4443/hostsigner/v1 Obtain a TLS certificate from ZTS Server for the service to run with. If your service is Jetty based, then the private key and certificate must be added to a keystore using the openssl utility. The certificate is valid for 30 days, so you must setup a cron job that periodically retrieves an updated certificates and your service is refreshed to use to the new certificate. $ zts-svccert -domain openstack -service cluster1 -private-key ./service_private.key -key-version v0 -zts https://<zts-hostname>:4443/zts/v1 -dns-domain athenz.com Determine the dns suffix for your provider service and submit a request to the Athenz system administrators to register the provider service with its dns suffix as an authorized provider service in Athenz Athenz Authorized Provider Registration \u00b6 Verify the dns suffix requested for the provider and, if valid, register the service in Athenz Add the service to the providers role: $ zms-cli -d sys.auth add-member providers openstack.cluster1 Register the dns suffix for the provider service. For example, cluster1.ostk.athenz.cloud $ zms-cli -d sys.auth add-regular-role provider.openstack.providers openstack.cluster1 $ zms-cli -d sys.auth add-policy provider.openstack.providers grant launch to provider.openstack.providers on dns.cluster1.ostk.athenz.cloud Tenant Service Registration \u00b6 Authorize provider service to launch its instances. For example, weater domain wants to authorize its service api to be launched by openstack.cluster1 provider. $ zms-cli -d weather add-regular-role openstack_providers openstack.cluster1 $ zms-cli -d weather add-policy openstack_providers grant launch to openstack_providers on weather:service.api Provider Client Implementation \u00b6 Provider must implement a client that will communicate with ZTS and execute Instance Register and Instance Refresh requests. When bootstrapping the the tenant instance, the Provider service must pass to the client the following details: the provider service name (e.g. openstack.cluster1) its dns suffix (e.g. cluster1.ostk.athenz.cloud) signed instance identity document The client will generate a CSR based on the details it received from its provider service, include the CSR in the InstanceRegisterInformation object and post it to ZTS. The client will be responsible for storing the certificate used from ZTS on the local host and use it for its subsequent requests to ZTS to refresh the certificate.","title":"Service Identity X.509 Certificate Support Requirements - Copper Argos"},{"location":"copper_argos_dev/#copper-argos-athenz-service-identity-x509-certificates-development","text":"What is Copper Argos Provider Service Registration Tenant Service Launch Authorization Instance Register Request Instance Refresh Request Instance Revocation Request Athenz RDL Instance Register Request Instance Identity Response Instance Refresh Request Instance Revoke Request Instance Provider RDL Authorization Policies System Providers Provider Authorized DNS Suffix Service Authorized Providers Sample Implementation and Setup Tasks Athenz System Setup Provider Service Implementation and Registration Athenz Authorized Provider Registration Tenant Service Registration Provider Client Implementation","title":"Copper Argos: Athenz Service Identity X.509 Certificates Development"},{"location":"copper_argos_dev/#what-is-copper-argos","text":"Copper Argos extends Athenz with generalized model for service providers to launch other identities in an authorized way through a callback-based verification model. With this model each provider is responsible for their instance document verification service instead of embedding that logic inside ZTS.","title":"What is Copper Argos"},{"location":"copper_argos_dev/#provider-service-registration","text":"Each provider is a registered service identity object in Athenz. As such, the provider domain administrator will create the service identity object in their domain and provide the following attributes using zms-cil utility or the REST API. (Athenz UI does not expose optional service attributes since they\u2019re not commonly used). * Provider Endpoint - A REST API endpoint that implements Provider RDL and ZTS will contact to validate the instance document (ServiceIdentity already has the providerEndpoint attribute) Domain administrator will then need to follow up with the Athenz Team to authorize Provider Service as an Instance Launcher Service in Athenz. The Provider will also specify the DNS suffix that will be used by its tenants. There will be a policy in sys.auth domain that grants launch action to instance resource to the providers role. Once approved, the Athenz System admin will add the provider service identity to the providers role in the sys.auth domain either using zms-cli or Athenz UI. There will be policy granting access to the specified Provider SAN dnsName attribute suffix to the list service provider. Requirements for Provider Service: * It must retrieve a TLS certificate for its service from Athenz and use that as its Service Certificate. * When ZTS Contacts Provider Service to validate an instance document, it will require TLS authentication and verify that the certificate the service used for authentication was issued for the expected provider service by ZTS itself. * ZTS issues TLS certificates valid for 30 days only, so the Provider Service Admin must have the capability to periodically refresh its certificate by requesting a new one from ZTS Server (e.g. daily) and dynamically update its service to use the refreshed certificates.","title":"Provider Service Registration"},{"location":"copper_argos_dev/#tenant-service-launch-authorization","text":"Before a tenant service can be launched by a specific provider and issued a TLS certificate for, the tenant domain administrator must authorize a specific provider service to launch its services. This will require that a role and policy to be created in the tenant\u2019s domain. For example, if weather.api service wants to authorize athenz.aws provider to launch its services, it will need to create the following policy and role in their domain: * Policy: grant launch to aws-provider on weather:service.api * Role: aws-provider role member: athenz.aws.us-west-2 The change can be carried out with using zms-cli or Athenz UI.","title":"Tenant Service Launch Authorization"},{"location":"copper_argos_dev/#instance-register-request","text":"Once the service admin creates the appropriate role and policy in its domain authorizing the provider service to bootstrap its instance, it can submit the launch request to the provider service. The steps of the bootstrap process pertaining Athenz integration would include: As part of the launch request, the admin will specify the Athenz domain and service that should be assigned to the instance. The provider service will generate an instance identity document, sign it with its private key and securely transfer this document along with its signature onto to the bootstrapped host. As part of the bootstrap process or possible as part of the image, the Service Identity Agent (SIA) will also be installed on the host. SIA will generate a public/private key pair on the host, generate a CSR using the newly generated private key. The CSR requirements are as follows: The Subject CN in the CSR must be the Athenz service identity name (e.g. weather.api - api service in weather domain) The CSR must include a SAN dnsName attribute with the format: <service-with-domain>.<provider-dnsname-suffix> . The provider-dnsname-suffix must match the value registered for the provider service. The <service-with-domain> part is left up to to the provider to define what format they want to use (e.g. <service>.<domain> or <service>.<domain-with-dashes> ). ZTS server will pass these hostnames to the provider as entries in the attribute field for validation. The provider must specify a unique identifier for the instance within the provider\u2019s namespace (this could be combination of multiple strings - e.g. instance-id.pod-id.cluster-id) and this information must be included in the CSR as another SAN dnsName attribute with the format: <provider-unique-instance-id>.instanceid.athenz.<provider-dnsname-suffix> . The ZTS server will use this information along with the issued TLS Certificate Serial number to revoke specific instances if they\u2019re compromised. SIA will generate an InstanceRegisterInformation object that will include attestation data (this would include the instance identity document, its signature and other attributes that will be necessary for the provider to validate and confirm the instance register request from ZTS) received from the provider and submit the post request to ZTS Server. ZTS Server will carry out the following authorization and verification checks before contacting provider service: The provider service in the info object has been authorized in Athenz to launch services (policy exists in sys.auth domain). Service specified in the info object (domain.service) has authorized provider service in the info object to launch itself (policy exists in the service\u2019s own domain). The provider service is registered in Athenz, has a providerEndpoint (verified as internal ip address) and providerDnsNameSuffix attributes defined. The cn in the CSR matches to the specific domain and service names. The CSR must include only 2 dnsName attributes with the expected format: <service-with-domain>.<provider-dnsname-suffix> <provider-unique-instance-id>.instanceid.athenz.<provider-dnsname-suffix> ZTS Server will contact Provider service at its configured endpoint and verify that the TLS certificate used for authentication by the provider service matches to the service name and was issued by ZTS server itself. ZTS Server will generate an InstanceConfirmation object and submit the post request to the Provider Service. In the InstanceConfirmation object, ZTS server will include the following entries in the optional attributes map: sanDNS: comma separated list of dnsNames attributes in the CSR - there will only be 2 as defined in 6(e) above sanIP - comma separated list of IP addresses in the CSR if any were specified clientIP - the IP address of the client cloudAccount - domain\u2019s account id if one is configured The Provider Service will be responsible for: Validating Signature Validating the instance id Validating the bootup time is within acceptable time period (e..g 5 mins) Validating hostnames included in the CSR Validating IP addresses (if available) included in the CSR Once ZTS service receives a successful response from the Provider Service, it will submit the CSR to Certsignd to generate a X.509 Certificate ZTS Server will retrieve the Serial number from the Certificate and register the certificate along with instanceid and provider service name in its certificate database. This will be used to monitor refresh certificate operations and, in case of a compromise, revoke specific instances from the capability to refresh their own certificates.","title":"Instance Register Request"},{"location":"copper_argos_dev/#instance-refresh-request","text":"During instance refresh request, ZTS Server again contacts provider service for verification of the instance. This is necessary in case the credentials have been compromised and the original instance is no longer running and will allow the provider to verify that the instance is indeed still running. ZTS will also verify that the connection is using the previous TLS certificate issued for the service and provider and the authorization policies are still in place. The steps would include: SIA will generate a public/private key pair on the host, generate a CSR using the newly generated private key. The CSR requirements are as follows: The Subject CN in the CSR must be the Athenz service identity name (e.g. weather.api - api service in weather domain) The CSR must include a SAN dnsName attribute with the format: <service-with-domain>.<provider-dnsname-suffix> that was used in the original register request. The provider must specify a unique identifier for the instance within the provider namespace (this could be combination of multiple strings - e.g. instance-id.pod-id.cluster-id) and this information must be included in the CSR as another SAN dnsName attribute with the format: <provider-unique-instance-id>.instanceid.athenz.<provider-dnsname-suffix> . The ZTS server will use this information along with the issued TLS Certificate Serial number to revoke specific instances if they\u2019re compromised. SIA will generate an InstanceRefreshInformation object including attestation data and submit the post request to ZTS Server. It will be required to use the TLS certificate that was issued to that instance previously by ZTS Server. ZTS Server will carry out the following authorization and verification checks before contacting provider service: The provider service in the info object has been authorized in Athenz to launch services (policy exists in sys.auth domain). Service specified in the info object (domain.service) has authorized provider service in the info object to launch itself (policy exists in the service\u2019s own domain). The cn in the CSR matches to the specific domain and service names. The TLS certificate SIA used to contact ZTS server must be for the same service. The TLS certificate SIA used to contact ZTS server must have the same provider and the 2 dnsName attributes as the CSR. ZTS Server will extract the instanceid from CSR and verify that the instance has not been revoked and the serial number matches to the registered entry in the certificate database. ZTS Server will contact Provider service at its configured endpoint and verify that the TLS certificate used for authentication by the provider service matches to the service name and was issued by ZTS server itself. ZTS Server will generate an InstanceConfirmation object and submit the post request to the Provider Service. In the InstanceConfirmation object, ZTS server will include the attestation data presented by instance. The Provider Service will be responsible for: Validating attestation data Validating hostnames included in the CSR Validating IP addresses (if available) included in the CSR Once ZTS service receives a successful response from the Provider Service, it will submit the CSR to Certsignd to generate a X.509 Certificate ZTS Server will retrieve the Serial number from the new Certificate and update the certificate database with the new serial number.","title":"Instance Refresh Request"},{"location":"copper_argos_dev/#instance-revocation-request","text":"If necessary, the domain administrators must be able to revoke specific instances from having the capability to refresh their certificate. The steps would be: Domain Admin will issue a HTTP DELETE /instance/\u2026 request to ZTS Server. ZTS Server will authorize the request and update the serial number for the requested instance id in the certificate database to -1. This operation will revoke the instance from refreshing its certificates.","title":"Instance Revocation Request"},{"location":"copper_argos_dev/#athenz-rdl","text":"","title":"Athenz RDL"},{"location":"copper_argos_dev/#instance-register-request_1","text":"InstanceRegisterInformation is the information a provider-hosted booting instance must provide to Athenz to authenticate: type InstanceRegisterInformation Struct { ServiceName provider; //the provider service name (i.e. \"aws.us-west-2\") DomainName domain; //the domain of the instance SimpleName service; //the service this instance is supposed to run String attestationData;//signed identity document containing attributes //like IP address, instance-id, account#, signature, etc String csr; //the Certificate Signing Request for the expected //X.509 certificate in the response String ssh (optional); //if present, return an SSH host certificate. //Format is JSON. Bool token (optional); // if true, return a service token signed by //ZTS for this service } resource InstanceIdentity POST \"/instance\" { InstanceRegisterInformation info; String location (header=\"Location\", out); //return location for subsequent operations expected CREATED; exceptions { ResourceError BAD_REQUEST; ResourceError FORBIDDEN; ResourceError UNAUTHORIZED; ResourceError INTERNAL_SERVER_ERROR; } }","title":"Instance Register Request"},{"location":"copper_argos_dev/#instance-identity-response","text":"InstanceIdentity is returned on successful attestation. includes the certifictates, tokens, and any additional provider-specific derived attributes. type InstanceIdentity Struct { ServiceName provider; //the provider service name (i.e. \"aws.us-west-2\") ServiceName name; //name of the identity, fully qualified, e.g weather.api PathElement instanceId; //unique instance id within provider\u2019s namespace String x509Certificate (optional); //an X.509 certificate usable for //both client and server in TLS connections String x509CertificateSigner (optional); //the CA certificate chain to //verify all generated X.509 certs String sshCertificate (optional); //the SSH certificate, signed by //the CA (user or host) String sshCertificateSigner (optional); //the SSH CA's public key //for the sshCertificate (user or host) SignedToken serviceToken (optional); //service token instead of TLS certificate Map<String,String> attributes (optional); //other config-like attributes //determined at boot time }","title":"Instance Identity Response"},{"location":"copper_argos_dev/#instance-refresh-request_1","text":"InstanceRefreshInformation is the information a provider-hosted booting instance must provide to Athenz to refresh the TLS certificate it was issued initially. The request must be done using the previously issued client TLS certificate. type InstanceRefreshInformation Struct { String attestationData (optional); //identity attestation data including //document with its signature containing attributes like IP //address, instance-id, account#, etc. String csr (optional); //the Certificate Signing Request for the expected //X.509 certificate in the response String ssh (optional); //if present, return an SSH host certificate. //Format is JSON. Bool token (optional); // if true, return a service token signed by //ZTS for this service } resource InstanceIdentity POST \"/instance/{provider}/{domain}/{service}/{instanceId}\" { ServiceName provider; //the provider service name (i.e. \"aws.us-west-2\") DomainName domain; //the domain of the instance SimpleName service; //the service this instance is supposed to run PathElement instanceId; //the instance id that\u2019s unique within this provider InstanceRefreshInformation info; //the refresh request authenticate; //only TLS Certificate authentication is allowed expected OK; exceptions { ResourceError BAD_REQUEST; ResourceError FORBIDDEN; ResourceError NOT_FOUND; ResourceError UNAUTHORIZED; ResourceError INTERNAL_SERVER_ERROR; } }","title":"Instance Refresh Request"},{"location":"copper_argos_dev/#instance-revoke-request","text":"resource InstanceIdentity DELETE \"/instance/{provider}/{domain}/{service}/{instanceId}\" { ServiceName provider; //the provider service name (i.e. \"aws.us-west-2\") DomainName domain; //the domain of the instance SimpleName service; //the service this instance is supposed to run PathElement instanceId; //the instance id that\u2019s unique within this provider authorize(\u201cdelete\u201d, {domain}:instance.{instanceId}; expected NO_CONTENT; exceptions { ResourceError BAD_REQUEST; ResourceError FORBIDDEN; ResourceError NOT_FOUND; ResourceError UNAUTHORIZED; ResourceError INTERNAL_SERVER_ERROR; } }","title":"Instance Revoke Request"},{"location":"copper_argos_dev/#instance-provider-rdl","text":"This is the RDL that any provider that is authorized to create instances through Athenz must implement. This interface must be available over HTTPS only. type InstanceConfirmation Struct { ServiceName provider; //the provider service name DomainName domain; //the domain of the instance SimpleName service; //the service this instance is supposed to run String attestationData; //signed identity document containing attributes //like IP address, instance-id, account#, signature, etc. Map<String,String> attributes (optional); //additional non-signed attributes that assist //in attestation. I.e. \"instanceId\u201d, keyId\", \"accessKey\", etc } Confirm instance identity information and return appropriate response to ZTS Server. On return from the confirmation, the resulting InstanceConfirmation may have additional useful attributes added, for example attributes taken from the identity document like \"account\" number or a canonical value like \"network\" that gets identified differently with different providers. resource InstanceConfirmation POST \"/instance\" { InstanceConfirmation confirmation; authenticate; expected OK; exceptions { ResourceError BAD_REQUEST; ResourceError FORBIDDEN; ResourceError UNAUTHORIZED; } } resource InstanceConfirmation POST \"/refresh\" (name=PostRefreshConfirmation) { InstanceConfirmation confirmation; Authenticate; expected OK; exceptions { ResourceError BAD_REQUEST; ResourceError FORBIDDEN; ResourceError UNAUTHORIZED; } }","title":"Instance Provider RDL"},{"location":"copper_argos_dev/#authorization-policies","text":"","title":"Authorization Policies"},{"location":"copper_argos_dev/#system-providers","text":"Athenz will maintain list of authorized provider services in sys.auth domain. If necessary, we can configure specific policies to grant additional users access over the roles/policies used to configure the list of provider. Domain: sys.auth Role: providers Members: <provider-name(s)> (e.g. openstack.cluster1) Policy: providers Assertion: grant launch to providers on sys.auth:instance","title":"System Providers"},{"location":"copper_argos_dev/#provider-authorized-dns-suffix","text":"When generating a CSR to request a TLS certificate for a service, the sia agent must know what DNS Suffix is the provider authorized to use so it can include the dnsName attribute in the CSR in the expected form (e.g. <service>.<domain-with-dashes>.<provider-dns-suffix> ). ZTS must validate that the provider is authorized to launch a service with that DNS suffix. For now, this information will be authorized against a policy in special sys.auth domain. Domain: sys.auth Role: provider.<provider-name> (e.g. provider.openstack.cluster1) Members: <provider-name(s)> (e.g. openstack.cluster1) Policy: provider.<provider-name> Assertion: grant launch to provider.<provider-name> on sys.auth:dns.<provider-suffix>","title":"Provider Authorized DNS Suffix"},{"location":"copper_argos_dev/#service-authorized-providers","text":"Each service will have a role/policy in their own domain that they control whether or not authorize specific providers to launch their services. For example, service weather.api wants to authorize AWS services to launch its services: Domain: weather.api Role: api_providers Members: athenz.aws Policy: api_providers Assertion: grant launch to \u201capi_providers\u201d on \u201cweather:service.api\u201d","title":"Service Authorized Providers"},{"location":"copper_argos_dev/#sample-implementation-and-setup-tasks","text":"","title":"Sample Implementation and Setup Tasks"},{"location":"copper_argos_dev/#athenz-system-setup","text":"Create the provider\u2019s role: $ zms-cli -d sys.auth add-regular-role providers Create the provider\u2019s policy: $ zms-cli -d sys.auth add-policy providers grant launch to providers on instance","title":"Athenz System Setup"},{"location":"copper_argos_dev/#provider-service-implementation-and-registration","text":"Implement provider service that implements Instance Provider RDL. Register the provider service in Athenz in the provider\u2019s domain. For example, we\u2019ll be registering a provider service called openstack.cluster1. Generate private/public key pair for the service. $ openssl genrsa -out service_private.key 2048 $ openssl rsa -in service_private.key -pubout > service_public.key Create the service identity in Athenz with public key id: v0 $ zms-cli -d openstack add-service cluster1 v0 ./service_public.key Determine the https endpoint for your service that ZTS will contact to verify instance information. For example, https://provider-cluster1.openstack.athenz.com:4443/hostsigner/v1 and set the endpoint for the service: $ zms-cli -d openstack set-service-endpoint cluster1 https://provider-cluster1.openstack.athenz.com:4443/hostsigner/v1 Obtain a TLS certificate from ZTS Server for the service to run with. If your service is Jetty based, then the private key and certificate must be added to a keystore using the openssl utility. The certificate is valid for 30 days, so you must setup a cron job that periodically retrieves an updated certificates and your service is refreshed to use to the new certificate. $ zts-svccert -domain openstack -service cluster1 -private-key ./service_private.key -key-version v0 -zts https://<zts-hostname>:4443/zts/v1 -dns-domain athenz.com Determine the dns suffix for your provider service and submit a request to the Athenz system administrators to register the provider service with its dns suffix as an authorized provider service in Athenz","title":"Provider Service Implementation and Registration"},{"location":"copper_argos_dev/#athenz-authorized-provider-registration","text":"Verify the dns suffix requested for the provider and, if valid, register the service in Athenz Add the service to the providers role: $ zms-cli -d sys.auth add-member providers openstack.cluster1 Register the dns suffix for the provider service. For example, cluster1.ostk.athenz.cloud $ zms-cli -d sys.auth add-regular-role provider.openstack.providers openstack.cluster1 $ zms-cli -d sys.auth add-policy provider.openstack.providers grant launch to provider.openstack.providers on dns.cluster1.ostk.athenz.cloud","title":"Athenz Authorized Provider Registration"},{"location":"copper_argos_dev/#tenant-service-registration","text":"Authorize provider service to launch its instances. For example, weater domain wants to authorize its service api to be launched by openstack.cluster1 provider. $ zms-cli -d weather add-regular-role openstack_providers openstack.cluster1 $ zms-cli -d weather add-policy openstack_providers grant launch to openstack_providers on weather:service.api","title":"Tenant Service Registration"},{"location":"copper_argos_dev/#provider-client-implementation","text":"Provider must implement a client that will communicate with ZTS and execute Instance Register and Instance Refresh requests. When bootstrapping the the tenant instance, the Provider service must pass to the client the following details: the provider service name (e.g. openstack.cluster1) its dns suffix (e.g. cluster1.ostk.athenz.cloud) signed instance identity document The client will generate a CSR based on the details it received from its provider service, include the CSR in the InstanceRegisterInformation object and post it to ZTS. The client will be responsible for storing the certificate used from ZTS on the local host and use it for its subsequent requests to ZTS to refresh the certificate.","title":"Provider Client Implementation"},{"location":"data_model/","text":"Architecture - Data Model \u00b6 Concepts Data Model Terminology Domains Resources Policies Roles Principals Users Services Groups Tokens Principal Token - NToken Access Tokens Having a firm grasp on some fundamental concepts will help you understand the Athenz architecture, the flow for both centralized and decentralized authorization, and how to set up role-based authorization. Concepts \u00b6 Role based Access Control (RBAC) system Symbolic names are used to identify the entities involved in authorization, so humans can read and understand the assertions Namespaces are strictly partitioned into Domains, which imply an ownership and control aspect to the names Enforcement can be factored such that it can be done in a distributed way, making possible data-plane checks that do not go off-box Administrative tasks can be delegated to created subdomains to avoid reliance on central \"super user\" administrative roles. Multi-tenancy relationships across domains can also take advantage of delegated administration Cryptographic signatures are used to ensure the fidelity of assertions and their lifecycle attributes Policy orientation, as opposed to Resource orientation, allows few assertions (in policies) to affect a potentially large number of resources, and allows more flexible scoping via wildcarding over groups of resources. In Athenz, the authorization management server converts all incoming data to lowercase before any processing - this applies to all data types within Athenz (e.g. domain names, role names, policy names, resource group values, etc). Data Model \u00b6 Terminology \u00b6 Domain - a partition/namespace/account of control and isolation Role - an entity that takes action on resources, when assumed by a principal Resource - an entity to take action on, referred to by unique name Policy - a set of assertions that govern usage of resources Assertion - a quadruple of <effect, role, action, resource> Principal - an authenticated user or service that assumes one or more roles User - a user identity that is authenticated by a particular authority Service - An identity that exposes reusable resources, authenticated by an Athenz-aware container, reachable via an explicit endpoint. Provider - a type of service that participates in the multi-tenant provisioning protocol. Tenant - a Domain that is provisioned to access some Resources in a Provider Group - A group is a collection of user and service principals Control Plane - operations done to provision or otherwise setup a system, outside its normal operation. Data Plane - operations done in the normal usage of a system, after it is set up. These operations are usually highly performance sensitive. There are numerous domains, and domains can themselves \u201ccontain\u201d subdomains, from a creation/deletion perspective. However, all domains and subdomains, regardless of their administrative relationships, are independent and share no state. Relationships between them (i.e. quotas, billing roll ups, etc) must be explicitly introduced if desired. Roles, Policies and their Assertions, and Services are all defined in a Domain. Domains \u00b6 Domains are namespaces, strictly partitioned, providing a context for authoritative statements to be made about entities it contains. Only system administrators can create and destroy top-level domains. Each domain is assigned users in an administrative role. Those admins can, in turn, create and delete subdomains, that is, domains that start with the parent domain as a prefix, using a '.' as a domain delimiter. For example, \"media\" is a top-level domain, and \"media.news\" is a subdomain of it. It is important to note that the only relation between these two domains involves creation and destruction of the domains -- the two domains share no state by default, and there is no inheritance or other relation between them other than that implied by their names. This allows all domains (whether top-level or subdomains) to be completely partitioned from each other, and the ownership of the entities defined within a domain is clear. A domain is a place to group your resources and entities. All resources are partitioned across some set of domains Domains are given a symbolic name, so humans can easily understand a reference to them The domain name is used as a namespace for resource names Domains are similar the concept of an account, and provides a \u201cwalled garden\u201d in which to operate Resources \u00b6 Resources aren't explicitly modeled in Athenz, they are referred to by name. A resource is something that is \"owned\" and controlled in a specific domain. Concrete example: a machine Abstract example: a security policy Identified by a canonical name, so humans can comprehend references to it When referring to resources for authorization, a global naming system needs to be introduced to handle names in namespaces. A Resource Name is defined as follows: { Domain }:{ Entity } The Domain is the namespace mentioned above, and the Entity is an entity path (delimited by periods) within that namespace. The two are often used together to form a short resource name. For example, if the media.news property provisions a table in a db service, the resource name for the table may look like this: media.news:storage.db.table Policies \u00b6 To implement access control, we have policies in our domain that govern the use of our resources. A policy is a set of assertions (rules) about granting or denying an operation/action on a resource. For example, the assertion [grant, update, dev, storage.db.table] would grant the update operation/action to all the members in the dev role on the storage.db.table resource. Note that the assertion fields are declared as general strings, as they may contain \"globbing\" style wildcards, for example \"media.news:role.*\", which would apply to any entity that matched the pattern. Roles \u00b6 A role can be thought of as a group, anyone in the group can assume the role that takes a particular action. Every policy assertion describes what can be done by a role. A role can also delegate the determination of membership to another trusted domain. For example, a netops role managed outside a property domain. This is how we can model tenant relations between a provider domain and tenant domains. Because roles are defined in domains, they can be partitioned by domain, unlike users, which are global. This allows the distributed operation to be more easily scaled. Principals \u00b6 The actors in Athenz that can assume a role are called principals. These principals are authenticated and can be users (for example, authenticated by their Unix or Kerberos credentials). Principals can also be services that are authenticated by a service management system. Athenz currently provides service identity and authentication support. In either case, the identity is expressed as a resource name, and the proof of that identity is provided as an X509 certificate. Users \u00b6 Users are actually defined in some external authority, e.g. Unix or Kerberos system. A special domain is reserved for the purpose of namespacing users, the name of that domain is user , so some example users are: user.john user.doe The credentials that the external system requires are exchanged for X509 certificates before operating on any data. Services \u00b6 The concept of a Service Identity is introduced as the identity of independent agents of execution. Services are defined as a subdomain of the managing domain, which provides a simple way of naming them. For example: media.news.msbe sports.storage The relationship of a service identity and its parent domain essentially means that the parent domain is an authority for the service itself, from a management perspective. A Service Identity may be used as a principal when specifying Roles, just like a User. Athenz provides support for registering such a Service Identity, in a domain, along with its public key that can be used to later verify an NToken that is presented by the service. Groups \u00b6 To simplify principal management, the users and services can be included in Groups. Then, the Group can be added as a principal to any role within Athenz thus granting the members of that group access to the configured resources. For example, if you need to add your development team members to multiple roles in your domain, you can create a group called dev-team , add those users into that group and then include the group as a member in the corresponding roles. When you need to remove or add a member, then you only need to modify the membership of your dev-team group. The groups cannot contain other groups. Tokens \u00b6 Athenz authorization system utilizes 2 types of tokens: Principal Tokens (NTokens) and Access Tokens. Principal Token (NToken) \u00b6 The Principal token can be thought of an identity token because it identifies either a user or a service. Users submit their credentials to ZMS, which validates those credentials and generates, signs and returns principal tokens. A service generates its principal token using the service's private key. The principal token can then be used to access role tokens. A principal token is serialized as a string with following attributes: version (v) - the version of the token - U1 for user tokens and S1 for service tokens domain (d) - the domain of principal. For users this will always be \"user\" name (n) - the name of the principal host (h) - the FQDN of the host that issued this token salt (a) - a salt time (t) - the time the token was issued expires (e) - the time the token expires keyId (k) - the key identifier of the private key that was used to sign this token ip (i) - the IP address where the request to get this token was initiated from authorized-services (b) - the list of services authorized to use this user token signature (s) - the signature of the other items The single letter in parentheses is the key in the serialized string, where semicolons separate key value pairs, and the key and value are separated by an equals sign. For example: v=U1;d=user;n=joe;h=host.athenz.org;a=bb4e;t=1442255237;e=1442258837;k=0;i=10.72.42.32;s=Jw8SvYGYrk Note that requests that include a principal token should be protected to keep the token from being intercepted and reused (for the lifetime of the token). It is strongly recommended to always use HTTPS for such requests. Access Tokens \u00b6 Athenz supports the OAuth2 standard by enabling the generation of Access Tokens. Access tokens represent an authoritative statement that a given principal may assume some number of roles in a domain for a limited period. They are signed to prevent tampering. Using Access Tokens instead of directly asking for an access check with a principal identity, reduces the chance of providing identity details to a compromised service. This mechanism also allows a service to make a completely local access check against the cached policies used by the policy engine.","title":"Data Model"},{"location":"data_model/#architecture-data-model","text":"Concepts Data Model Terminology Domains Resources Policies Roles Principals Users Services Groups Tokens Principal Token - NToken Access Tokens Having a firm grasp on some fundamental concepts will help you understand the Athenz architecture, the flow for both centralized and decentralized authorization, and how to set up role-based authorization.","title":"Architecture - Data Model"},{"location":"data_model/#concepts","text":"Role based Access Control (RBAC) system Symbolic names are used to identify the entities involved in authorization, so humans can read and understand the assertions Namespaces are strictly partitioned into Domains, which imply an ownership and control aspect to the names Enforcement can be factored such that it can be done in a distributed way, making possible data-plane checks that do not go off-box Administrative tasks can be delegated to created subdomains to avoid reliance on central \"super user\" administrative roles. Multi-tenancy relationships across domains can also take advantage of delegated administration Cryptographic signatures are used to ensure the fidelity of assertions and their lifecycle attributes Policy orientation, as opposed to Resource orientation, allows few assertions (in policies) to affect a potentially large number of resources, and allows more flexible scoping via wildcarding over groups of resources. In Athenz, the authorization management server converts all incoming data to lowercase before any processing - this applies to all data types within Athenz (e.g. domain names, role names, policy names, resource group values, etc).","title":"Concepts"},{"location":"data_model/#data-model","text":"","title":"Data Model"},{"location":"data_model/#terminology","text":"Domain - a partition/namespace/account of control and isolation Role - an entity that takes action on resources, when assumed by a principal Resource - an entity to take action on, referred to by unique name Policy - a set of assertions that govern usage of resources Assertion - a quadruple of <effect, role, action, resource> Principal - an authenticated user or service that assumes one or more roles User - a user identity that is authenticated by a particular authority Service - An identity that exposes reusable resources, authenticated by an Athenz-aware container, reachable via an explicit endpoint. Provider - a type of service that participates in the multi-tenant provisioning protocol. Tenant - a Domain that is provisioned to access some Resources in a Provider Group - A group is a collection of user and service principals Control Plane - operations done to provision or otherwise setup a system, outside its normal operation. Data Plane - operations done in the normal usage of a system, after it is set up. These operations are usually highly performance sensitive. There are numerous domains, and domains can themselves \u201ccontain\u201d subdomains, from a creation/deletion perspective. However, all domains and subdomains, regardless of their administrative relationships, are independent and share no state. Relationships between them (i.e. quotas, billing roll ups, etc) must be explicitly introduced if desired. Roles, Policies and their Assertions, and Services are all defined in a Domain.","title":"Terminology"},{"location":"data_model/#domains","text":"Domains are namespaces, strictly partitioned, providing a context for authoritative statements to be made about entities it contains. Only system administrators can create and destroy top-level domains. Each domain is assigned users in an administrative role. Those admins can, in turn, create and delete subdomains, that is, domains that start with the parent domain as a prefix, using a '.' as a domain delimiter. For example, \"media\" is a top-level domain, and \"media.news\" is a subdomain of it. It is important to note that the only relation between these two domains involves creation and destruction of the domains -- the two domains share no state by default, and there is no inheritance or other relation between them other than that implied by their names. This allows all domains (whether top-level or subdomains) to be completely partitioned from each other, and the ownership of the entities defined within a domain is clear. A domain is a place to group your resources and entities. All resources are partitioned across some set of domains Domains are given a symbolic name, so humans can easily understand a reference to them The domain name is used as a namespace for resource names Domains are similar the concept of an account, and provides a \u201cwalled garden\u201d in which to operate","title":"Domains"},{"location":"data_model/#resources","text":"Resources aren't explicitly modeled in Athenz, they are referred to by name. A resource is something that is \"owned\" and controlled in a specific domain. Concrete example: a machine Abstract example: a security policy Identified by a canonical name, so humans can comprehend references to it When referring to resources for authorization, a global naming system needs to be introduced to handle names in namespaces. A Resource Name is defined as follows: { Domain }:{ Entity } The Domain is the namespace mentioned above, and the Entity is an entity path (delimited by periods) within that namespace. The two are often used together to form a short resource name. For example, if the media.news property provisions a table in a db service, the resource name for the table may look like this: media.news:storage.db.table","title":"Resources"},{"location":"data_model/#policies","text":"To implement access control, we have policies in our domain that govern the use of our resources. A policy is a set of assertions (rules) about granting or denying an operation/action on a resource. For example, the assertion [grant, update, dev, storage.db.table] would grant the update operation/action to all the members in the dev role on the storage.db.table resource. Note that the assertion fields are declared as general strings, as they may contain \"globbing\" style wildcards, for example \"media.news:role.*\", which would apply to any entity that matched the pattern.","title":"Policies"},{"location":"data_model/#roles","text":"A role can be thought of as a group, anyone in the group can assume the role that takes a particular action. Every policy assertion describes what can be done by a role. A role can also delegate the determination of membership to another trusted domain. For example, a netops role managed outside a property domain. This is how we can model tenant relations between a provider domain and tenant domains. Because roles are defined in domains, they can be partitioned by domain, unlike users, which are global. This allows the distributed operation to be more easily scaled.","title":"Roles"},{"location":"data_model/#principals","text":"The actors in Athenz that can assume a role are called principals. These principals are authenticated and can be users (for example, authenticated by their Unix or Kerberos credentials). Principals can also be services that are authenticated by a service management system. Athenz currently provides service identity and authentication support. In either case, the identity is expressed as a resource name, and the proof of that identity is provided as an X509 certificate.","title":"Principals"},{"location":"data_model/#users","text":"Users are actually defined in some external authority, e.g. Unix or Kerberos system. A special domain is reserved for the purpose of namespacing users, the name of that domain is user , so some example users are: user.john user.doe The credentials that the external system requires are exchanged for X509 certificates before operating on any data.","title":"Users"},{"location":"data_model/#services","text":"The concept of a Service Identity is introduced as the identity of independent agents of execution. Services are defined as a subdomain of the managing domain, which provides a simple way of naming them. For example: media.news.msbe sports.storage The relationship of a service identity and its parent domain essentially means that the parent domain is an authority for the service itself, from a management perspective. A Service Identity may be used as a principal when specifying Roles, just like a User. Athenz provides support for registering such a Service Identity, in a domain, along with its public key that can be used to later verify an NToken that is presented by the service.","title":"Services"},{"location":"data_model/#groups","text":"To simplify principal management, the users and services can be included in Groups. Then, the Group can be added as a principal to any role within Athenz thus granting the members of that group access to the configured resources. For example, if you need to add your development team members to multiple roles in your domain, you can create a group called dev-team , add those users into that group and then include the group as a member in the corresponding roles. When you need to remove or add a member, then you only need to modify the membership of your dev-team group. The groups cannot contain other groups.","title":"Groups"},{"location":"data_model/#tokens","text":"Athenz authorization system utilizes 2 types of tokens: Principal Tokens (NTokens) and Access Tokens.","title":"Tokens"},{"location":"data_model/#principal-token-ntoken","text":"The Principal token can be thought of an identity token because it identifies either a user or a service. Users submit their credentials to ZMS, which validates those credentials and generates, signs and returns principal tokens. A service generates its principal token using the service's private key. The principal token can then be used to access role tokens. A principal token is serialized as a string with following attributes: version (v) - the version of the token - U1 for user tokens and S1 for service tokens domain (d) - the domain of principal. For users this will always be \"user\" name (n) - the name of the principal host (h) - the FQDN of the host that issued this token salt (a) - a salt time (t) - the time the token was issued expires (e) - the time the token expires keyId (k) - the key identifier of the private key that was used to sign this token ip (i) - the IP address where the request to get this token was initiated from authorized-services (b) - the list of services authorized to use this user token signature (s) - the signature of the other items The single letter in parentheses is the key in the serialized string, where semicolons separate key value pairs, and the key and value are separated by an equals sign. For example: v=U1;d=user;n=joe;h=host.athenz.org;a=bb4e;t=1442255237;e=1442258837;k=0;i=10.72.42.32;s=Jw8SvYGYrk Note that requests that include a principal token should be protected to keep the token from being intercepted and reused (for the lifetime of the token). It is strongly recommended to always use HTTPS for such requests.","title":"Principal Token (NToken)"},{"location":"data_model/#access-tokens","text":"Athenz supports the OAuth2 standard by enabling the generation of Access Tokens. Access tokens represent an authoritative statement that a given principal may assume some number of roles in a domain for a limited period. They are signed to prevent tampering. Using Access Tokens instead of directly asking for an access check with a principal identity, reduces the chance of providing identity details to a compromised service. This mechanism also allows a service to make a completely local access check against the cached policies used by the policy engine.","title":"Access Tokens"},{"location":"decent_authz_flow/","text":"In this section, we're going to examine the decentralized authorization flow. Subsystems \u00b6 Before we go into the details of the authorization flow, it's important to understand the subsystems. ZMS (AuthZ Management System) \u00b6 ZMS is where domains, roles, and policies are defined. This is Athenz's centralized authorization system and is likely part of a larger management system. In addition to allowing CRUD operations on the basic entities, ZMS provides an API to replicate the entities, per domain, to ZTS. It also can directly support the access check, both for internal management system checks, as well as a simple centralized deployment. ZMS is the source of truth for domains, roles, and policies for centralized authorization. ZMS supports a centralized call to check if a principal has access to a resource. Because ZMS supports service identities, ZMS can authenticate services. SIA (Service Identity Agent) \u00b6 SIA is required for authenticating existing services. Any service should integrate SIA (or an equivalent system). To confirm a service's identity, SIA communicates with ZTS. ZTS (AuthZ Token System) \u00b6 ZTS, the authentication token service, is only needed to support decentralized or data plane functionality. In many ways, ZTS is like a local replica of ZMS's data to check a principal's authentication and confirm membership in roles within a domain. The authentication is in the form of a signed Access Token that can be presented to any decentralized service that wants to authorize access efficiently. If needed, multiple ZTS instances will be distributed to different data centers as needed to scale for issuing tokens. ZPE (AuthZ Policy Engine) \u00b6 Like ZTS, ZPE, the authorization policy engine is only needed to support the decentralized authorization. ZPE is the subsystem of Athenz that evaluates policies for a set of roles to yield an allowed or a denied response. ZPE is a library that your service calls and only refers to a local policy cache for your services domain (a small amount of data). ZPU (AuthZ PolicyEngine Updater) \u00b6 Like ZTS and ZPE, ZPU is only needed to support the decentralized authorization. The policy updater is the utility that retrieves from ZTS the policy files for provisioned domains on a host, which ZPE uses to evaluate access requests. Decentralized Access Control \u00b6 A more interesting scenario introduces the local policy engine (ZPE), and a few supporting changes. Rather than directly asking for an access check with a principal identity, the identity is instead used to get an Access Token, and that is presented to the target service until it expires. This mechanism allows a service to make a completely local access check against ZPE, given an Access Token and locally cached policies. Specifically, as shown in the diagram below, the client service/user uses its identity x.509 certificate along with its private key that it got from local SIA (1) to get an authorization token (Access Token) from ZTS (2), and then presents the access token to a target service to access its resources (3). That service can make use of a local ZPE to validate the role assertions in the access token, and then correlate them to the asynchronously updated Policies for the domain involved. The ZPE can make the decision locally, without going off box. It has no knowledge about specific users, only roles, and because roles and policies are always in the domain, the amount of data to distribute to the machine is small. The model works exactly the same when using X.509 certificates instead of tokens. The service would use its identity X.509 certificate to request a X.509 Role Certificate from ZTS and then would make the call to the target service using the X.509 Role Certificate. The target service would first validate the X.509 Certificate and call ZPE to extract the role certificate to carry out the authorization check.","title":"Decentralized Authorization Flow"},{"location":"decent_authz_flow/#subsystems","text":"Before we go into the details of the authorization flow, it's important to understand the subsystems.","title":"Subsystems"},{"location":"decent_authz_flow/#zms-authz-management-system","text":"ZMS is where domains, roles, and policies are defined. This is Athenz's centralized authorization system and is likely part of a larger management system. In addition to allowing CRUD operations on the basic entities, ZMS provides an API to replicate the entities, per domain, to ZTS. It also can directly support the access check, both for internal management system checks, as well as a simple centralized deployment. ZMS is the source of truth for domains, roles, and policies for centralized authorization. ZMS supports a centralized call to check if a principal has access to a resource. Because ZMS supports service identities, ZMS can authenticate services.","title":"ZMS (AuthZ Management System)"},{"location":"decent_authz_flow/#sia-service-identity-agent","text":"SIA is required for authenticating existing services. Any service should integrate SIA (or an equivalent system). To confirm a service's identity, SIA communicates with ZTS.","title":"SIA (Service Identity Agent)"},{"location":"decent_authz_flow/#zts-authz-token-system","text":"ZTS, the authentication token service, is only needed to support decentralized or data plane functionality. In many ways, ZTS is like a local replica of ZMS's data to check a principal's authentication and confirm membership in roles within a domain. The authentication is in the form of a signed Access Token that can be presented to any decentralized service that wants to authorize access efficiently. If needed, multiple ZTS instances will be distributed to different data centers as needed to scale for issuing tokens.","title":"ZTS (AuthZ Token System)"},{"location":"decent_authz_flow/#zpe-authz-policy-engine","text":"Like ZTS, ZPE, the authorization policy engine is only needed to support the decentralized authorization. ZPE is the subsystem of Athenz that evaluates policies for a set of roles to yield an allowed or a denied response. ZPE is a library that your service calls and only refers to a local policy cache for your services domain (a small amount of data).","title":"ZPE (AuthZ Policy Engine)"},{"location":"decent_authz_flow/#zpu-authz-policyengine-updater","text":"Like ZTS and ZPE, ZPU is only needed to support the decentralized authorization. The policy updater is the utility that retrieves from ZTS the policy files for provisioned domains on a host, which ZPE uses to evaluate access requests.","title":"ZPU (AuthZ PolicyEngine Updater)"},{"location":"decent_authz_flow/#decentralized-access-control","text":"A more interesting scenario introduces the local policy engine (ZPE), and a few supporting changes. Rather than directly asking for an access check with a principal identity, the identity is instead used to get an Access Token, and that is presented to the target service until it expires. This mechanism allows a service to make a completely local access check against ZPE, given an Access Token and locally cached policies. Specifically, as shown in the diagram below, the client service/user uses its identity x.509 certificate along with its private key that it got from local SIA (1) to get an authorization token (Access Token) from ZTS (2), and then presents the access token to a target service to access its resources (3). That service can make use of a local ZPE to validate the role assertions in the access token, and then correlate them to the asynchronously updated Policies for the domain involved. The ZPE can make the decision locally, without going off box. It has no knowledge about specific users, only roles, and because roles and policies are always in the domain, the amount of data to distribute to the machine is small. The model works exactly the same when using X.509 certificates instead of tokens. The service would use its identity X.509 certificate to request a X.509 Role Certificate from ZTS and then would make the call to the target service using the X.509 Role Certificate. The target service would first validate the X.509 Certificate and call ZPE to extract the role certificate to carry out the authorization check.","title":"Decentralized Access Control"},{"location":"dev_environment/","text":"Development Environment \u00b6 Development Tools Build Within Docker Container Manual Installation of Development Tools Java Platform JDK 11 Maven Git Client Go Node JS Build Steps Development Tools \u00b6 If you would like to build your own copy of Athenz rather than using the pre-built binary packages, then here is the list of development tools you need to have installed on your system. Build Within Docker Container \u00b6 You can replicate the container environment that Athenz users within Screwdriver to build and deploy Athenz packages. You can start a new container using the openjdk:11 image. Once you check out the Athenz source tree, you can execute the install_deps.sh script to install the required development tools: $ git clone https://github.com/AthenZ/athenz.git $ cd athenz $ sh screwdriver/scripts/install_deps.sh Manual Installation of Development Tools \u00b6 Java Platform JDK 11 \u00b6 To build Athenz components, you must have Java Platform JDK 11 installed on your machine. The main authorization services - ZMS and ZTS, are written in Java and using embedded Jetty. Make sure you have set the $JAVA_HOME environment variable. $ java -XshowSettings:properties -version 2 > & 1 > /dev/null | grep 'java.home' $ export JAVA_HOME = <java-home-directory> ```` #### Maven Download and install [ Apache Maven ]( http://maven.apache.org/download.cgi ) . #### Git Client If you don ' t have git client installed on your host, you can download one from [ Git website ]( https://git-scm.com/downloads ) . 2 .x version of the git client is required. #### Go Install go 1 .22.3 or newer version by following the directions at [ Getting Started - The Go Programming Language ]( https://golang.org/doc/install ) . Make sure you have set the [ $GOPATH environment variable ]( https://pkg.go.dev/cmd/go#hdr-GOPATH_environment_variable ) and that you have ` $GOPATH /bin ` in your ` $PATH ` . ``` shell $ export GOPATH = <gopath-directory> $ mkdir -p $GOPATH /bin $ export PATH = $PATH :/usr/local/go/bin: $GOPATH /bin ```` #### Node JS Install node 18 .x by following the directions at [ Node.js JavaScript Runtime ]( https://nodejs.org/en/ ) Verify that you have the required minimum version of ` node ` , ` npm ` and ` nodemon ` binaries installed on your system and are included in your runtime path: ``` shell $ node --version v18.19.0 $ npm -v 10 .3.0 $ npm install -g nodemon $ nodemon --version 3 .0.3 Build Steps \u00b6 To build Athenz components, change to the top level directory where you want to build the Athenz code and execute (skip the first command if you have already checked out the code using git): $ git clone https://github.com/AthenZ/athenz.git $ cd athenz $ mvn clean install The release packages will be created automatically in the assembly subdirectory.","title":"Development Environment"},{"location":"dev_environment/#development-environment","text":"Development Tools Build Within Docker Container Manual Installation of Development Tools Java Platform JDK 11 Maven Git Client Go Node JS Build Steps","title":"Development Environment"},{"location":"dev_environment/#development-tools","text":"If you would like to build your own copy of Athenz rather than using the pre-built binary packages, then here is the list of development tools you need to have installed on your system.","title":"Development Tools"},{"location":"dev_environment/#build-within-docker-container","text":"You can replicate the container environment that Athenz users within Screwdriver to build and deploy Athenz packages. You can start a new container using the openjdk:11 image. Once you check out the Athenz source tree, you can execute the install_deps.sh script to install the required development tools: $ git clone https://github.com/AthenZ/athenz.git $ cd athenz $ sh screwdriver/scripts/install_deps.sh","title":"Build Within Docker Container"},{"location":"dev_environment/#manual-installation-of-development-tools","text":"","title":"Manual Installation of Development Tools"},{"location":"dev_environment/#java-platform-jdk-11","text":"To build Athenz components, you must have Java Platform JDK 11 installed on your machine. The main authorization services - ZMS and ZTS, are written in Java and using embedded Jetty. Make sure you have set the $JAVA_HOME environment variable. $ java -XshowSettings:properties -version 2 > & 1 > /dev/null | grep 'java.home' $ export JAVA_HOME = <java-home-directory> ```` #### Maven Download and install [ Apache Maven ]( http://maven.apache.org/download.cgi ) . #### Git Client If you don ' t have git client installed on your host, you can download one from [ Git website ]( https://git-scm.com/downloads ) . 2 .x version of the git client is required. #### Go Install go 1 .22.3 or newer version by following the directions at [ Getting Started - The Go Programming Language ]( https://golang.org/doc/install ) . Make sure you have set the [ $GOPATH environment variable ]( https://pkg.go.dev/cmd/go#hdr-GOPATH_environment_variable ) and that you have ` $GOPATH /bin ` in your ` $PATH ` . ``` shell $ export GOPATH = <gopath-directory> $ mkdir -p $GOPATH /bin $ export PATH = $PATH :/usr/local/go/bin: $GOPATH /bin ```` #### Node JS Install node 18 .x by following the directions at [ Node.js JavaScript Runtime ]( https://nodejs.org/en/ ) Verify that you have the required minimum version of ` node ` , ` npm ` and ` nodemon ` binaries installed on your system and are included in your runtime path: ``` shell $ node --version v18.19.0 $ npm -v 10 .3.0 $ npm install -g nodemon $ nodemon --version 3 .0.3","title":"Java Platform JDK 11"},{"location":"dev_environment/#build-steps","text":"To build Athenz components, change to the top level directory where you want to build the Athenz code and execute (skip the first command if you have already checked out the code using git): $ git clone https://github.com/AthenZ/athenz.git $ cd athenz $ mvn clean install The release packages will be created automatically in the assembly subdirectory.","title":"Build Steps"},{"location":"email_notifications/","text":"Athenz can send email notifications for events such as a role member with access that about to expire. Athenz supports Amazon Simple Email Service (Amazon SES) out of the box. This requires Athenz to be deployed on AWS. Users may use other Email Providers by following the steps to Enable Notifications using other Providers Enable Email Notifications using Amazon Simple Email Service (Amazon SES) \u00b6 Enable Email Notifications for ZMS server by editing the zms.properties file: # Notification: Factory class using AWS SES implementation to send out email notifications athenz.zms.notification_service_factory_class=com.yahoo.athenz.common.server.notification.impl.NotificationServiceFactoryImpl # Notification: Email domain from athenz.notification_email_domain_from=from.domain.com # Notification: Email from athenz.notification_email_from=sender.name # Notification: Email domain to athenz.notification_email_domain_to=to.domain.com # Notification: Workflow url for approvers to click from within email body to take action on the notification athenz.notification_workflow_url=https://your.athenz.ui/athenz/workflow # Notification: Athenz UI Link included in Expiry Reminder Emails athenz.notification_athenz_ui_url=https://your.athenz.ui/athenz Enable Notifications using other Providers \u00b6 To use other providers, create a Jar file on the Athenz classpath with implementations for the following Interface: com.yahoo.athenz.common.server.notification.NotificationServiceFactory - A factory that creates a Notification Service based on a Notifications Provider. You may use the existing com.yahoo.athenz.common.server.notification.impl.EmailNotificationService and inject a new provider or implement a compleley new Notifications Provider that will notify users by means other than email. If you do plan on sending email notifications, implement the following interface: com.yahoo.athenz.common.server.notification.EmailProvider For example, to enable Email Notifications with your provider, you may implement com.yahoo.athenz.common.server.notification.NotificationServiceFactory like so: package your.packge ; import com.yahoo.athenz.common.server.notification.impl.EmailNotificationService ; public class YourNotificationServiceFactory implements NotificationServiceFactory { @Override public NotificationService create () { return new EmailNotificationService ( new YourEmailProvider ()); } } Once the jar is ready, change the value of athenz.zms.notification_service_factory_class in the zms.properties file to your factory class: athenz.zms.notification_service_factory_class=your.packge.YourNotificationServiceFactory We can also send notifications to more than one service by specifying all service factories. For example, if we would like notifications to be sent via your.packge.YourNotificationServiceFactory and their.packge.TheirNotificationServiceFactory , specify both values in the property using , as a delimiter: athenz.zms.notification_service_factory_class=your.packge.YourNotificationServiceFactory, their.packge.TheirNotificationServiceFactory","title":"Email Notifications"},{"location":"email_notifications/#enable-email-notifications-using-amazon-simple-email-service-amazon-ses","text":"Enable Email Notifications for ZMS server by editing the zms.properties file: # Notification: Factory class using AWS SES implementation to send out email notifications athenz.zms.notification_service_factory_class=com.yahoo.athenz.common.server.notification.impl.NotificationServiceFactoryImpl # Notification: Email domain from athenz.notification_email_domain_from=from.domain.com # Notification: Email from athenz.notification_email_from=sender.name # Notification: Email domain to athenz.notification_email_domain_to=to.domain.com # Notification: Workflow url for approvers to click from within email body to take action on the notification athenz.notification_workflow_url=https://your.athenz.ui/athenz/workflow # Notification: Athenz UI Link included in Expiry Reminder Emails athenz.notification_athenz_ui_url=https://your.athenz.ui/athenz","title":"Enable Email Notifications using Amazon Simple Email Service (Amazon SES)"},{"location":"email_notifications/#enable-notifications-using-other-providers","text":"To use other providers, create a Jar file on the Athenz classpath with implementations for the following Interface: com.yahoo.athenz.common.server.notification.NotificationServiceFactory - A factory that creates a Notification Service based on a Notifications Provider. You may use the existing com.yahoo.athenz.common.server.notification.impl.EmailNotificationService and inject a new provider or implement a compleley new Notifications Provider that will notify users by means other than email. If you do plan on sending email notifications, implement the following interface: com.yahoo.athenz.common.server.notification.EmailProvider For example, to enable Email Notifications with your provider, you may implement com.yahoo.athenz.common.server.notification.NotificationServiceFactory like so: package your.packge ; import com.yahoo.athenz.common.server.notification.impl.EmailNotificationService ; public class YourNotificationServiceFactory implements NotificationServiceFactory { @Override public NotificationService create () { return new EmailNotificationService ( new YourEmailProvider ()); } } Once the jar is ready, change the value of athenz.zms.notification_service_factory_class in the zms.properties file to your factory class: athenz.zms.notification_service_factory_class=your.packge.YourNotificationServiceFactory We can also send notifications to more than one service by specifying all service factories. For example, if we would like notifications to be sent via your.packge.YourNotificationServiceFactory and their.packge.TheirNotificationServiceFactory , specify both values in the property using , as a delimiter: athenz.zms.notification_service_factory_class=your.packge.YourNotificationServiceFactory, their.packge.TheirNotificationServiceFactory","title":"Enable Notifications using other Providers"},{"location":"events_monitoring/","text":"Athenz can be monitored by capturing events using an Event monitoring service. Athenz Events \u00b6 The following events can be sent by Athenz API HTTP Requests - Name of API method, status and duration Certificate Requests Email Reminders and Notifications Enable ZMS Event Monitoring in Prometheus \u00b6 Enable ZMS Event Monitoring in Prometheus for ZMS server by performing the following steps: Build the athenz_metrics_prometheus Java project located in contributions/metric/prometheus Place it in the ZMS Server classpath Edit the zms.properties file: # Specifies the factory class that implements the Metrics interface # used by the ZMS Server to report stats athenz.zms.metric_factory_class=com.yahoo.athenz.common.metrics.impl.prometheus.PrometheusMetricFactory Enable ZTS Event Monitoring in Prometheus \u00b6 Enable ZTS Event Monitoring in Prometheus for ZTS server by performing the following steps: Build the athenz_metrics_prometheus Java project located in contributions/metric/prometheus Place it in the ZTS Server classpath Edit the zts.properties file: # Specifies the factory class that implements the Metrics interface # used by the ZTS Server to report stats athenz.zts.metric_factory_class=com.yahoo.athenz.common.metrics.impl.prometheus.PrometheusMetricFactory Enable Email Notifications Monitoring \u00b6 You may also choose to enable Email Notifications and record the notifications sent in an Event Monitoring Service. The Event Monitoring Service may be the same one used to record other Athenz Events or can be a dedicated service that captures Notification Events only. To enable Notification Events for Prometheus, perform the following steps: Enable Email Notifications by following the steps in Email Notifications Edit the athenz.zms.notification_service_factory_class property to also include the MetricNotificationServiceFactory class. For example, if the NotificationServiceFactory used is com.yahoo.athenz.common.server.notification.impl.NotificationServiceFactoryImpl (the default AWS Email Notification Service Factory), then the property should be: athenz.zms.notification_service_factory_class=com.yahoo.athenz.common.server.notification.impl.NotificationServiceFactoryImpl, com.yahoo.athenz.common.server.notification.impl.MetricNotificationServiceFactory Build the athenz_metrics_prometheus Java project located in contributions/metric/prometheus Place it in the ZMS / ZTS Server classpath Edit the zts.properties file for ZTS and zms.properties file to ZMS: # Specifies the factory class that implements the Metrics interface # used to record Notification Events athenz.notification.metric_factory_class=com.yahoo.athenz.common.metrics.impl.prometheus.PrometheusMetricFactory Enable Event Monitoring using other Event Monitoring Services \u00b6 To use Monitoring Services other than Prometheus, create a Jar file on the Athenz classpath with implementations for the following Interface: com.yahoo.athenz.common.metrics.MetricFactory - A factory that creates a Notification Service based on a Notifications Provider.","title":"Events Monitoring"},{"location":"events_monitoring/#athenz-events","text":"The following events can be sent by Athenz API HTTP Requests - Name of API method, status and duration Certificate Requests Email Reminders and Notifications","title":"Athenz Events"},{"location":"events_monitoring/#enable-zms-event-monitoring-in-prometheus","text":"Enable ZMS Event Monitoring in Prometheus for ZMS server by performing the following steps: Build the athenz_metrics_prometheus Java project located in contributions/metric/prometheus Place it in the ZMS Server classpath Edit the zms.properties file: # Specifies the factory class that implements the Metrics interface # used by the ZMS Server to report stats athenz.zms.metric_factory_class=com.yahoo.athenz.common.metrics.impl.prometheus.PrometheusMetricFactory","title":"Enable ZMS Event Monitoring in Prometheus"},{"location":"events_monitoring/#enable-zts-event-monitoring-in-prometheus","text":"Enable ZTS Event Monitoring in Prometheus for ZTS server by performing the following steps: Build the athenz_metrics_prometheus Java project located in contributions/metric/prometheus Place it in the ZTS Server classpath Edit the zts.properties file: # Specifies the factory class that implements the Metrics interface # used by the ZTS Server to report stats athenz.zts.metric_factory_class=com.yahoo.athenz.common.metrics.impl.prometheus.PrometheusMetricFactory","title":"Enable ZTS Event Monitoring in Prometheus"},{"location":"events_monitoring/#enable-email-notifications-monitoring","text":"You may also choose to enable Email Notifications and record the notifications sent in an Event Monitoring Service. The Event Monitoring Service may be the same one used to record other Athenz Events or can be a dedicated service that captures Notification Events only. To enable Notification Events for Prometheus, perform the following steps: Enable Email Notifications by following the steps in Email Notifications Edit the athenz.zms.notification_service_factory_class property to also include the MetricNotificationServiceFactory class. For example, if the NotificationServiceFactory used is com.yahoo.athenz.common.server.notification.impl.NotificationServiceFactoryImpl (the default AWS Email Notification Service Factory), then the property should be: athenz.zms.notification_service_factory_class=com.yahoo.athenz.common.server.notification.impl.NotificationServiceFactoryImpl, com.yahoo.athenz.common.server.notification.impl.MetricNotificationServiceFactory Build the athenz_metrics_prometheus Java project located in contributions/metric/prometheus Place it in the ZMS / ZTS Server classpath Edit the zts.properties file for ZTS and zms.properties file to ZMS: # Specifies the factory class that implements the Metrics interface # used to record Notification Events athenz.notification.metric_factory_class=com.yahoo.athenz.common.metrics.impl.prometheus.PrometheusMetricFactory","title":"Enable Email Notifications Monitoring"},{"location":"events_monitoring/#enable-event-monitoring-using-other-event-monitoring-services","text":"To use Monitoring Services other than Prometheus, create a Jar file on the Athenz classpath with implementations for the following Interface: com.yahoo.athenz.common.metrics.MetricFactory - A factory that creates a Notification Service based on a Notifications Provider.","title":"Enable Event Monitoring using other Event Monitoring Services"},{"location":"example_go_centralized_access/","text":"Go Client/Server Example - Centralized Access Control \u00b6 Required Components Service Definition Resource Definition Athenz Management Setup Code Changes Client Changes Client Import Dependency Update Obtaining NTokens Build Go zms_svctoken Client Utility Server Changes Server Project Dependency Update Authorization Checks Build Server Deploying Example Servlet Test Cases Invalid Access Without ServiceToken Movie Editor Access TvShow Editor Access Site Editor Access Other Test Cases In the centralized access control model, the service as a principal requests its NToken from SIA Provider and then presents it to the target service which would perform an identical check with ZMS to confirm access. The required steps to setup the environment for provider and tenant services to support centralized access control are as follows: System administrator creates the provider and tenant domains. Tenant Domain administrator generates a public/private key pair and registers a service in its domain. Provider Domain administrator creates a role and policy that grants access to the given role with configured action and resource. Provider Domain administrator adds the Tenant Service to the role to grant access. Tenant Domain administrator installs the private key on the host that will be running the client/tenant service. Required Components \u00b6 To support centralized access control in your applications, you only need to install and configure the Athenz ZMS server along with the Athenz UI. Please follow these guides to make sure you have both of those components up and running in your environment: ZMS Server UI Server To build the client and server components of this example, you need to download and install Go and Git client if you don't already have these available on your box: The Go Programming Language Git client Make sure your GOPATH variable is set and the PATH variable includes the $(GOPATH)/bin to run the utilities. Service Definition \u00b6 Let's first define our service that needs to be Athenz protected. We have a simple recommendation service that returns either a movie or tv show for the caller. It has two endpoints: GET /rec/v1/movie GET /rec/v1/tvshow So in this first release we just want to protect access to these endpoints. The traffic is very low - we only expect a couple of requests an hour so we have decided to use Athenz' centralized authorization model. Resource Definition \u00b6 Defining resources and actions the principals are authorized to execute is one of the most important tasks in the authorization process. Based on our endpoints, it's expected that we'll have 2 general resources: movie tvshow The resources are referenced in their own domain namespace. So those are valid if your domain is specifically created to support this recommendation service only. But's lets assume we might add rental support later, so we need to make sure the policies are based on service specific resources. So we'll define our resources as: rec.movie rec.tvshow Support action for these resources would be read . We can extend our authorization policies later on if we need to introduce other actions - such as write or list as we add more functionality into our service. Athenz Management Setup \u00b6 Once we have defined what our resources and actions are, we can create their respective client and server (also commonly referred as tenant and provider) roles and policies in Athenz. Go to Athenz UI and login with your account which should have system administrator access. Follow the instructions in the following guide to setup the required access control: Access Control Setup Code Changes \u00b6 Both the client and server implementors need to make changes in their respective code bases to support centralized authorization checks. The client needs to make sure to submit its service identity as part of its request, while the service needs to carry out the authorization check based on that service identity to determine if the request should be processed or not. Client Changes \u00b6 While we'll use the curl client to make the http calls to our example service, we provide a sample client code that utilizes our zmssvctoken go library to generate service identity tokens. The full client source code is available from: https://github.com/AthenZ/athenz/blob/master/utils/zms-svctoken/zms-svctoken.go Client Import Dependency Update \u00b6 First you need to update your go client to import the zms service token library. import ( \"github.com/AthenZ/athenz/libs/go/zmssvctoken\" ) Obtaining NTokens \u00b6 The domain administrator must have already generated a public/private key pair for the service and registered public key in Athenz. The private key must be available on the host where the client will be running. // load private key bytes , err := os . ReadFile ( privateKeyFile ) if err != nil { log . Fatalln ( err ) } // get token builder instance builder , err := zmssvctoken . NewTokenBuilder ( domain , service , bytes , keyVersion ) if err != nil { log . Fatalln ( err ) } // set optional attributes builder . SetExpiration ( 60 * time . Minute ) tok := builder . Token () // get a token for use ntoken , err := tok . Value () Once we have our ntoken value, the http client before contacting the provider service needs to add it as the value for the Athenz-Principal-Auth header: req , err := http . NewRequest ( \"GET\" , \"http://recommend-host/rec/v1/movie\" , nil ) // ... req . Header . Add ( \"Athenz-Principal-Auth\" , ntoken ) Build Go zms_svctoken Client Utility \u00b6 To download, compile and install zms_svctoken utility, execute the following command: $ go get github.com/AthenZ/athenz/utils/zms-svctoken/... Server Changes \u00b6 The full server source code is available from: https://github.com/AthenZ/athenz/tree/master/examples/go/centralized-use-case/server Server Import Dependency Update \u00b6 First you need to update your go client to import the zms client library. import ( \"github.com/AthenZ/athenz/clients/go/zms\" ) Authorization Checks \u00b6 Before any authorization calls, we're going to check to make sure our request contains the Athenz principal token: const authHeader = \"Athenz-Principal-Auth\" func movieHandler ( w http . ResponseWriter , r * http . Request ) { // first let's verify that we have an ntoken if r . Header [ authHeader ] == nil { http . Error ( w , \"403 - Missing NToken\" , 403 ) return } ... } } Next, the most important part is to determine the resource and action based on the given http request. Since we have a separate handler for each endpoint: http . HandleFunc ( \"/rec/v1/movie\" , movieHandler ) http . HandleFunc ( \"/rec/v1/tvshow\" , tvshowHandler ) each function knows exactly what the resource and the action is. Finally, we are going to contact ZMS for the authorization check. func movieHandler ( w http . ResponseWriter , r * http . Request ) { ... // let's generate our resource value which is the // <provider domain>:<entity value> resource := providerDomain + \":rec.movie\" // let's check with ZMS if the principal is authorized if ! authorizeRequest ( r . Header [ authHeader ][ 0 ], resource , \"read\" ) { http . Error ( w , \"403 - Unauthorized access\" , 403 ) return } io . WriteString ( w , \"Name: Slap Shot; Director: George Roy Hill\\n\" ) } func authorizeRequest ( ntoken , resource , action string ) bool { // for our test example we're just going to skip // validating self-signed certificates tr := http . Transport {} config := & tls . Config {} config . InsecureSkipVerify = true tr . TLSClientConfig = config zmsClient := zms . ZMSClient { URL : zmsUrl , Transport : & tr , } zmsClient . AddCredentials ( authHeader , ntoken ) access , err := zmsClient . GetAccess ( zms . ActionName ( action ), zms . ResourceName ( resource ), \"\" , \"\" ) if err != nil { fmt . Println ( \"Unable to verify access: %v\" , err ) return false } return access . Granted } Build Server \u00b6 Checkout and build the server component: $ go get github.com/AthenZ/athenz/examples/go/centralized-use-case/server Deploying Example Server \u00b6 To run the Go server, you just need to specify the ZMS Server url. The server listens on port 8080: $ recommend -zms https://<zms-server>:4443/zms/v1 Test Cases \u00b6 Run the following test cases to verify authorization access for specific services. We're running our go server on the local box so we're using localhost as the hostname. The zms_svctoken utility should already be built and installed on your host. cd to the directory that includes the private keys for the test services we created in the section Athenz Management Setup above. Invalid Access Without ServiceToken \u00b6 For this test case we'll just use the curl client directly: $ curl http://localhost:8080/rec/v1/movie 403 - Missing NToken Movie Editor Access \u00b6 Movie service can successfully access /rec/v1/movie endpoint. So let's first generate an NToken for this service and then contact our server: $ export NTOKEN = ` zms_svctoken -domain editors -service movie -private-key movie_private.pem -key-version v0 ` $ curl -H \"Athenz-Principal-Auth: $NTOKEN \" http://localhost:8080/rec/v1/movie Name: Slap Shot ; Director: George Roy Hill Movie service does not have access to /rec/v1/tvshow endpoint: $ export NTOKEN = ` zms_svctoken -domain editors -service movie -private-key movie_private.pem -key-version v0 ` $ curl -H \"Athenz-Principal-Auth: $NTOKEN \" http://localhost:8080/rec/v1/tvshow 403 - Unauthorized access TvShow Editor Access \u00b6 TvShow service can successfully access /rec/v1/tvshow endpoint. So let's first generate an NToken for this service and then contact our server: $ export NTOKEN = ` zms_svctoken -domain editors -service tvshow -private-key tvshow_private.pem -key-version v0 ` $ curl -H \"Athenz-Principal-Auth: $NTOKEN \" http://localhost:8080/rec/v1/tvshow Name: Middle ; Channel: ABC TvShow service does not have access to /rec/v1/movie endpoint: $ export NTOKEN = ` zms_svctoken -domain editors -service tvshow -private-key tvshow_private.pem -key-version v0 ` $ curl -H \"Athenz-Principal-Auth: $NTOKEN \" http://localhost:8080/rec/v1/movie 403 - Unauthorized access Site Editor Access \u00b6 Site service has access to both /rec/v1/tvshow and /rec/v1/movie endpoints: $ export NTOKEN = ` zms_svctoken -domain editors -service site -private-key site_private.pem -key-version v0 ` $ curl -H \"Athenz-Principal-Auth: $NTOKEN \" http://localhost:8080/rec/v1/movie Name: Slap Shot ; Director: George Roy Hill $ curl -H \"Athenz-Principal-Auth: $NTOKEN \" http://localhost:8080/rec/v1/tvshow Name: Middle ; Channel: ABC Other Test Cases \u00b6 Now you can modify the movie_editos, tvshow_editors, and site_editors roles in the recommend domain to add and remove the defined services and then run the corresponding test cases to verify your access change.","title":"Go Client/Server Example"},{"location":"example_go_centralized_access/#go-clientserver-example-centralized-access-control","text":"Required Components Service Definition Resource Definition Athenz Management Setup Code Changes Client Changes Client Import Dependency Update Obtaining NTokens Build Go zms_svctoken Client Utility Server Changes Server Project Dependency Update Authorization Checks Build Server Deploying Example Servlet Test Cases Invalid Access Without ServiceToken Movie Editor Access TvShow Editor Access Site Editor Access Other Test Cases In the centralized access control model, the service as a principal requests its NToken from SIA Provider and then presents it to the target service which would perform an identical check with ZMS to confirm access. The required steps to setup the environment for provider and tenant services to support centralized access control are as follows: System administrator creates the provider and tenant domains. Tenant Domain administrator generates a public/private key pair and registers a service in its domain. Provider Domain administrator creates a role and policy that grants access to the given role with configured action and resource. Provider Domain administrator adds the Tenant Service to the role to grant access. Tenant Domain administrator installs the private key on the host that will be running the client/tenant service.","title":"Go Client/Server Example - Centralized Access Control"},{"location":"example_go_centralized_access/#required-components","text":"To support centralized access control in your applications, you only need to install and configure the Athenz ZMS server along with the Athenz UI. Please follow these guides to make sure you have both of those components up and running in your environment: ZMS Server UI Server To build the client and server components of this example, you need to download and install Go and Git client if you don't already have these available on your box: The Go Programming Language Git client Make sure your GOPATH variable is set and the PATH variable includes the $(GOPATH)/bin to run the utilities.","title":"Required Components"},{"location":"example_go_centralized_access/#service-definition","text":"Let's first define our service that needs to be Athenz protected. We have a simple recommendation service that returns either a movie or tv show for the caller. It has two endpoints: GET /rec/v1/movie GET /rec/v1/tvshow So in this first release we just want to protect access to these endpoints. The traffic is very low - we only expect a couple of requests an hour so we have decided to use Athenz' centralized authorization model.","title":"Service Definition"},{"location":"example_go_centralized_access/#resource-definition","text":"Defining resources and actions the principals are authorized to execute is one of the most important tasks in the authorization process. Based on our endpoints, it's expected that we'll have 2 general resources: movie tvshow The resources are referenced in their own domain namespace. So those are valid if your domain is specifically created to support this recommendation service only. But's lets assume we might add rental support later, so we need to make sure the policies are based on service specific resources. So we'll define our resources as: rec.movie rec.tvshow Support action for these resources would be read . We can extend our authorization policies later on if we need to introduce other actions - such as write or list as we add more functionality into our service.","title":"Resource Definition"},{"location":"example_go_centralized_access/#athenz-management-setup","text":"Once we have defined what our resources and actions are, we can create their respective client and server (also commonly referred as tenant and provider) roles and policies in Athenz. Go to Athenz UI and login with your account which should have system administrator access. Follow the instructions in the following guide to setup the required access control: Access Control Setup","title":"Athenz Management Setup"},{"location":"example_go_centralized_access/#code-changes","text":"Both the client and server implementors need to make changes in their respective code bases to support centralized authorization checks. The client needs to make sure to submit its service identity as part of its request, while the service needs to carry out the authorization check based on that service identity to determine if the request should be processed or not.","title":"Code Changes"},{"location":"example_go_centralized_access/#client-changes","text":"While we'll use the curl client to make the http calls to our example service, we provide a sample client code that utilizes our zmssvctoken go library to generate service identity tokens. The full client source code is available from: https://github.com/AthenZ/athenz/blob/master/utils/zms-svctoken/zms-svctoken.go","title":"Client Changes"},{"location":"example_go_centralized_access/#client-import-dependency-update","text":"First you need to update your go client to import the zms service token library. import ( \"github.com/AthenZ/athenz/libs/go/zmssvctoken\" )","title":"Client Import Dependency Update"},{"location":"example_go_centralized_access/#obtaining-ntokens","text":"The domain administrator must have already generated a public/private key pair for the service and registered public key in Athenz. The private key must be available on the host where the client will be running. // load private key bytes , err := os . ReadFile ( privateKeyFile ) if err != nil { log . Fatalln ( err ) } // get token builder instance builder , err := zmssvctoken . NewTokenBuilder ( domain , service , bytes , keyVersion ) if err != nil { log . Fatalln ( err ) } // set optional attributes builder . SetExpiration ( 60 * time . Minute ) tok := builder . Token () // get a token for use ntoken , err := tok . Value () Once we have our ntoken value, the http client before contacting the provider service needs to add it as the value for the Athenz-Principal-Auth header: req , err := http . NewRequest ( \"GET\" , \"http://recommend-host/rec/v1/movie\" , nil ) // ... req . Header . Add ( \"Athenz-Principal-Auth\" , ntoken )","title":"Obtaining NTokens"},{"location":"example_go_centralized_access/#build-go-zms_svctoken-client-utility","text":"To download, compile and install zms_svctoken utility, execute the following command: $ go get github.com/AthenZ/athenz/utils/zms-svctoken/...","title":"Build Go zms_svctoken Client Utility"},{"location":"example_go_centralized_access/#server-changes","text":"The full server source code is available from: https://github.com/AthenZ/athenz/tree/master/examples/go/centralized-use-case/server","title":"Server Changes"},{"location":"example_go_centralized_access/#server-import-dependency-update","text":"First you need to update your go client to import the zms client library. import ( \"github.com/AthenZ/athenz/clients/go/zms\" )","title":"Server Import Dependency Update"},{"location":"example_go_centralized_access/#authorization-checks","text":"Before any authorization calls, we're going to check to make sure our request contains the Athenz principal token: const authHeader = \"Athenz-Principal-Auth\" func movieHandler ( w http . ResponseWriter , r * http . Request ) { // first let's verify that we have an ntoken if r . Header [ authHeader ] == nil { http . Error ( w , \"403 - Missing NToken\" , 403 ) return } ... } } Next, the most important part is to determine the resource and action based on the given http request. Since we have a separate handler for each endpoint: http . HandleFunc ( \"/rec/v1/movie\" , movieHandler ) http . HandleFunc ( \"/rec/v1/tvshow\" , tvshowHandler ) each function knows exactly what the resource and the action is. Finally, we are going to contact ZMS for the authorization check. func movieHandler ( w http . ResponseWriter , r * http . Request ) { ... // let's generate our resource value which is the // <provider domain>:<entity value> resource := providerDomain + \":rec.movie\" // let's check with ZMS if the principal is authorized if ! authorizeRequest ( r . Header [ authHeader ][ 0 ], resource , \"read\" ) { http . Error ( w , \"403 - Unauthorized access\" , 403 ) return } io . WriteString ( w , \"Name: Slap Shot; Director: George Roy Hill\\n\" ) } func authorizeRequest ( ntoken , resource , action string ) bool { // for our test example we're just going to skip // validating self-signed certificates tr := http . Transport {} config := & tls . Config {} config . InsecureSkipVerify = true tr . TLSClientConfig = config zmsClient := zms . ZMSClient { URL : zmsUrl , Transport : & tr , } zmsClient . AddCredentials ( authHeader , ntoken ) access , err := zmsClient . GetAccess ( zms . ActionName ( action ), zms . ResourceName ( resource ), \"\" , \"\" ) if err != nil { fmt . Println ( \"Unable to verify access: %v\" , err ) return false } return access . Granted }","title":"Authorization Checks"},{"location":"example_go_centralized_access/#build-server","text":"Checkout and build the server component: $ go get github.com/AthenZ/athenz/examples/go/centralized-use-case/server","title":"Build Server"},{"location":"example_go_centralized_access/#deploying-example-server","text":"To run the Go server, you just need to specify the ZMS Server url. The server listens on port 8080: $ recommend -zms https://<zms-server>:4443/zms/v1","title":"Deploying Example Server"},{"location":"example_go_centralized_access/#test-cases","text":"Run the following test cases to verify authorization access for specific services. We're running our go server on the local box so we're using localhost as the hostname. The zms_svctoken utility should already be built and installed on your host. cd to the directory that includes the private keys for the test services we created in the section Athenz Management Setup above.","title":"Test Cases"},{"location":"example_go_centralized_access/#invalid-access-without-servicetoken","text":"For this test case we'll just use the curl client directly: $ curl http://localhost:8080/rec/v1/movie 403 - Missing NToken","title":"Invalid Access Without ServiceToken"},{"location":"example_go_centralized_access/#movie-editor-access","text":"Movie service can successfully access /rec/v1/movie endpoint. So let's first generate an NToken for this service and then contact our server: $ export NTOKEN = ` zms_svctoken -domain editors -service movie -private-key movie_private.pem -key-version v0 ` $ curl -H \"Athenz-Principal-Auth: $NTOKEN \" http://localhost:8080/rec/v1/movie Name: Slap Shot ; Director: George Roy Hill Movie service does not have access to /rec/v1/tvshow endpoint: $ export NTOKEN = ` zms_svctoken -domain editors -service movie -private-key movie_private.pem -key-version v0 ` $ curl -H \"Athenz-Principal-Auth: $NTOKEN \" http://localhost:8080/rec/v1/tvshow 403 - Unauthorized access","title":"Movie Editor Access"},{"location":"example_go_centralized_access/#tvshow-editor-access","text":"TvShow service can successfully access /rec/v1/tvshow endpoint. So let's first generate an NToken for this service and then contact our server: $ export NTOKEN = ` zms_svctoken -domain editors -service tvshow -private-key tvshow_private.pem -key-version v0 ` $ curl -H \"Athenz-Principal-Auth: $NTOKEN \" http://localhost:8080/rec/v1/tvshow Name: Middle ; Channel: ABC TvShow service does not have access to /rec/v1/movie endpoint: $ export NTOKEN = ` zms_svctoken -domain editors -service tvshow -private-key tvshow_private.pem -key-version v0 ` $ curl -H \"Athenz-Principal-Auth: $NTOKEN \" http://localhost:8080/rec/v1/movie 403 - Unauthorized access","title":"TvShow Editor Access"},{"location":"example_go_centralized_access/#site-editor-access","text":"Site service has access to both /rec/v1/tvshow and /rec/v1/movie endpoints: $ export NTOKEN = ` zms_svctoken -domain editors -service site -private-key site_private.pem -key-version v0 ` $ curl -H \"Athenz-Principal-Auth: $NTOKEN \" http://localhost:8080/rec/v1/movie Name: Slap Shot ; Director: George Roy Hill $ curl -H \"Athenz-Principal-Auth: $NTOKEN \" http://localhost:8080/rec/v1/tvshow Name: Middle ; Channel: ABC","title":"Site Editor Access"},{"location":"example_go_centralized_access/#other-test-cases","text":"Now you can modify the movie_editos, tvshow_editors, and site_editors roles in the recommend domain to add and remove the defined services and then run the corresponding test cases to verify your access change.","title":"Other Test Cases"},{"location":"example_java_centralized_access/","text":"Java Client/Servlet Example - Centralized Access Control \u00b6 Required Components Service Definition Resource Definition Athenz Management Setup Code Changes Getting an SSL Context to be used in Http Clients Client Project Dependency Update Build Http Client Utility Servlet Changes Servlet Project Dependency Update Enable TLS Client Certificate Authentication Authorization Checks Build Servlet Deploying Example Servlet Test Cases Invalid Access Without ServiceToken Movie Editor Access TvShow Editor Access Site Editor Access Other Test Cases In the centralized access control model, the service as a principal requests an X509 certificate from SIA Provider and then presents it to the target service which would perform an identical check with ZMS to confirm access. The required steps to setup the environment for provider and tenant services to support centralized access control are as follows: System administrator creates the provider and tenant domains. Tenant Domain administrator generates a public/private key pair and registers a service in its domain. Provider Domain administrator creates a role and policy that grants access to the given role with configured action and resource. Provider Domain administrator adds the Tenant Service to the role to grant access. Tenant Domain administrator installs the private key on the host that will be running the client/tenant service. Required Components \u00b6 To support centralized access control in your applications, you only need to install and configure the Athenz ZMS server along with the Athenz UI. Please follow these guides to make sure you have both of those components up and running in your environment: ZMS Server UI Server To build the client and servlet components of this example, you need to download and install JDK 11, Apache Maven and Git client if you don't already have these available on your box: Java Platform JDK 11 Apache Maven Git client Service Definition \u00b6 Let's first define our service that needs to be Athenz protected. We have a simple recommendation service that returns either a movie or tv show for the caller. It has two endpoints: GET /rec/v1/movie GET /rec/v1/tvshow So in this first release we just want to protect access to these endpoints. The traffic is very low - we only expect a couple of requests an hour so we have decided to use Athenz' centralized authorization model. Resource Definition \u00b6 Defining resources and actions the principals are authorized to execute is one of the most important tasks in the authorization process. Based on our endpoints, it's expected that we'll have 2 general resources: movie tvshow The resources are referenced in their own domain namespace. So those are valid if your domain is specifically created to support this recommendation service only. But's lets assume we might add rental support later, so we need to make sure the policies are based on service specific resources. So we'll define our resources as: rec.movie rec.tvshow Support action for these resources would be read . We can extend our authorization policies later on if we need to introduce other actions - such as write or list as we add more functionality into our service. Athenz Management Setup \u00b6 Once we have defined what our resources and actions are, we can create their respective client and server (also commonly referred as tenant and provider) roles and policies in Athenz. Go to Athenz UI and login with your account which should have system administrator access. Follow the instructions in the following guide to setup the required access control: Access Control Setup Obtaining X509 Certificate \u00b6 The service should obtain an X509 certificate that will be used for authentication with Athenz. Follow the steps in the Authentication section to receive a certificate depending on the environment: Athenz Service Identity X.509 Certificate for AWS EC2 instances Athenz Service Identity X.509 Certificate for AWS ECS containers Athenz Service Identity X.509 Certificate for AWS Fargate tasks Athenz Service Identity X.509 Certificate for AWS EKS pods Athenz Service Identity X.509 Certificate for AWS Lambda functions Code Changes \u00b6 Both the client and servlet implementors need to make changes in their respective code bases to support centralized authorization checks. The client needs to make sure to submit its service certificate as part of its request, while the servlet needs to carry out the authorization check based on that service identity to determine if it request should be processed or not. Getting an SSL Context to be used in Http Clients \u00b6 The full client source code is available from: https://github.com/AthenZ/athenz/tree/master/libs/java/cert_refresher/examples/tls-support/src/main/java/com/yahoo/athenz/example/http/tls/client/HttpTLSClient.java Client Project Dependency Update \u00b6 First you need to update your Java project pom.xml file to indicate the dependency on the Athenz Cert Refresher Library. Checkout the Maven Central Athenz Cert Refresher Package to make sure you're using the latest release version: <dependency> <groupId>com.yahoo.athenz</groupId> <artifactId>athenz-cert-refresher</artifactId> <version>VERSION-NUMBER</version> </dependency> Build Http Client Utility \u00b6 Checkout and build the client component: $ git clone https://github.com/AthenZ/athenz.git $ cd libs/java/cert_refresher/examples/tls-support/src/main/java/com/yahoo/athenz/example/http/tls/client/ $ mvn clean package Verify that the client is built successfully: $ java -cp target/example-http-tls-java-client-1.0.jar HttpExampleClient Missing required options: k, c, t, p, u usage: http-example-client -k,--keyid <arg> key identifier -c,--cert <arg> certficate path -t,--trustStorePath <arg> CA TrustStore path -p,--trustStorePassword <arg> CA TrustStore password -u,--url <arg> request url Servlet Changes \u00b6 The full servlet source code is available from: https://github.com/AthenZ/athenz/tree/master/examples/java/centralized-use-case/servlet Servlet Project Dependency Update \u00b6 First you need to update your Java project pom.xml file to indicate the dependency on the Athenz ZMS Java Client Library and the Athenz Cert Refresher Libarry. Checkout Maven Central ZMS Client Package Page and Maven Central Athenz Cert Refresher Package to make sure you're using the latest release version: <dependency> <groupId>com.yahoo.athenz</groupId> <artifactId>athenz-zms-java-client</artifactId> <version>VERSION-NUMBER</version> </dependency> <dependency> <groupId>com.yahoo.athenz</groupId> <artifactId>athenz-cert-refresher</artifactId> <version>VERSION-NUMBER</version> </dependency> Enable TLS Client Certificate Authentication \u00b6 To enable TLS Client Certificate Authentication, follow the steps in Server Side Service Identity Authentication Authorization Checks \u00b6 Before any authorization calls, we're going to check to make sure our request contains the Athenz X509 certificate: static final String ATHENZ_HEADER = \"Athenz-Principal-Auth\" ; protected void doGet ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { // retrieve and verify that our request contains an Athenz // service authentication certificate X509Certificate [] certs = ( X509Certificate [] ) request . getAttribute ( JAVAX_CERT_ATTR ); // Assuming only one certificate sent in the request if ( certs == null || certs [ 0 ] == null ) { response . sendError ( 403 , \"Forbidden - No Athenz X509 certificate provided in request\" ); return ; } ... } Next, the most important part is to determine the resource and action based on the given http request. protected void doGet ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { ... switch ( reqUri ) { case \"/movie\" : responseText = \"Name: Slap Shot; Director: George Roy Hill\" ; athenzResource = \"rec.movie\" ; athenzAction = \"read\" ; break ; case \"/tvshow\" : responseText = \"Name: Middle; Channel: ABC\" ; athenzResource = \"rec.tvshow\" ; athenzAction = \"read\" ; break ; default : response . sendError ( 404 , \"Unknown endpoint\" ); return ; } ... } Once we have those two values determined, then all that is left is to contact ZMS for the authorization check. protected void doGet ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { ... // carry out the authorization check with the expected resource // and action values String principalName = x509cert . getSubjectX500Principal (). getName (); Access access = zmsClient . getAccess ( athenzAction , athenzResource , null , principalName ); boolean authorized = access . getGranted (); if ( ! authorized ) { response . sendError ( 403 , \"Forbidden - Athenz Authorization Rejected\" ); return ; } ... } Build Servlet \u00b6 Checkout and build the servlet component: $ git clone https://github.com/AthenZ/athenz.git $ cd examples/java/centralized-use-case/servlet/ $ mvn clean package Deploying Example Servlet \u00b6 Download and install latest Jetty 9.3.x container Copy the athenz-control.war from the servlet/target directory to the Jetty distribution's webapps directory Configure ZMS Server's URL in the expected environment variable: export ZMS_SERVER_URL = https://<zms-server-hostname>:4443/zms/v1 Configure Valid Issuers file path in the expected environment variable: export ATHENZ_ISSUERS_FILEPATH = <Path to valid issuers file> Configure environment variables for our web app cert, key and truststore: export REC_SERVLET_ATHENZ_KEY_PATH = <Path to key> export REC_SERVLET_ATHENZ_CERT_PATH = <Path to cert> export REC_SERVLET_ATHENZ_TRUSTSTORE_PATH = <Path to truststore> export REC_SERVLET_ATHENZ_TRUSTSTORE_PASSWORD = <truststore password> If the ZMS Server is running with a self-signed certificate, we need to generate a truststore for the java http client to use when communicating with the ZMS Server. From your ZMS Server installation, copy the zms_cert.pem file from the athenz-zms-X.Y/var/zms_server/certs directory to the jetty's etc subdirectory and execute the following commands: $ keytool -importcert -noprompt -alias zms -keystore zms_truststore.jks -file zms_cert.pem -storepass athenz $ export JAVA_OPTIONS = -Djavax.net.ssl.trustStore = <full-path-to-jetty-basedir>/etc/zms_truststore.jks Start the Jetty server by running the following command from Jetty's distribution base directory: bin/jetty.sh start Test Cases \u00b6 Run the following test cases to verify authorization access for specific services. We're running jetty server on the local box so we're using localhost as the hostname. Copy the example-http-tls-java-client-1.0.jar file from the client/target directory to the directory that includes the private keys for the test services we created in the section Athenz Management Setup above. Invalid Access Without Cert \u00b6 For this test case we'll just use the curl client directly: $ curl http://localhost:8080/athenz-control/rec/v1/movie <html> ... <title>Error 403 Forbidden - No Athenz X509 certificate provided in request</title> ... </html> Movie Editor Access \u00b6 Movie service can successfully access /rec/v1/movie endpoint: $ java -cp ./example-http-tls-java-client-1.0.jar HttpTLSClient -d editors -s movie -p ./movie_private.pem -k v0 -u http://localhost:8080/athenz-control/rec/v1/movie Successful response: Name: Slap Shot ; Director: George Roy Hill Movie service does not have access to /rec/v1/tvshow endpoint: $ java -cp ./example-http-tls-java-client-1.0.jar HttpTLSClient -d editors -s movie -p ./movie_private.pem -k v0 -u http://localhost:8080/athenz-control/rec/v1/tvshow Request was forbidden - not authorized TvShow Editor Access \u00b6 TvShow service can successfully access /rec/v1/tvshow endpoint: $ java -cp ./example-http-tls-java-client-1.0.jar HttpTLSClient -d editors -s tvshow -p ./tvshow_private.pem -k v0 -u http://localhost:8080/athenz-control/rec/v1/tvshow Successful response: Name: Middle ; Channel: ABC TvShow service does not have access to /rec/v1/movie endpoint: $ java -cp ./example-http-tls-java-client-1.0.jar HttpTLSClient -d editors -s tvshow -p ./tvshow_private.pem -k v0 -u http://localhost:8080/athenz-control/rec/v1/movie Request was forbidden - not authorized Site Editor Access \u00b6 Site service has access to both /rec/v1/tvshow and /rec/v1/movie endpoints: $ java -cp ./example-http-tls-java-client-1.0.jar HttpTLSClient -d editors -s site -p ./site_private.pem -k v0 -u http://localhost:8080/athenz-control/rec/v1/movie Successful response: Name: Slap Shot ; Director: George Roy Hill $ java -cp ./example-http-tls-java-client-1.0.jar HttpTLSClient -d editors -s site -p ./site_private.pem -k v0 -u http://localhost:8080/athenz-control/rec/v1/tvshow Successful response: Name: Middle ; Channel: ABC Other Test Cases \u00b6 Now you can modify the movie_editos, tvshow_editors, and site_editors roles in the recommend domain to add and remove the defined services and then run the corresponding test cases to verify your access change.","title":"Java Client/Servlet Centralized Example"},{"location":"example_java_centralized_access/#java-clientservlet-example-centralized-access-control","text":"Required Components Service Definition Resource Definition Athenz Management Setup Code Changes Getting an SSL Context to be used in Http Clients Client Project Dependency Update Build Http Client Utility Servlet Changes Servlet Project Dependency Update Enable TLS Client Certificate Authentication Authorization Checks Build Servlet Deploying Example Servlet Test Cases Invalid Access Without ServiceToken Movie Editor Access TvShow Editor Access Site Editor Access Other Test Cases In the centralized access control model, the service as a principal requests an X509 certificate from SIA Provider and then presents it to the target service which would perform an identical check with ZMS to confirm access. The required steps to setup the environment for provider and tenant services to support centralized access control are as follows: System administrator creates the provider and tenant domains. Tenant Domain administrator generates a public/private key pair and registers a service in its domain. Provider Domain administrator creates a role and policy that grants access to the given role with configured action and resource. Provider Domain administrator adds the Tenant Service to the role to grant access. Tenant Domain administrator installs the private key on the host that will be running the client/tenant service.","title":"Java Client/Servlet Example - Centralized Access Control"},{"location":"example_java_centralized_access/#required-components","text":"To support centralized access control in your applications, you only need to install and configure the Athenz ZMS server along with the Athenz UI. Please follow these guides to make sure you have both of those components up and running in your environment: ZMS Server UI Server To build the client and servlet components of this example, you need to download and install JDK 11, Apache Maven and Git client if you don't already have these available on your box: Java Platform JDK 11 Apache Maven Git client","title":"Required Components"},{"location":"example_java_centralized_access/#service-definition","text":"Let's first define our service that needs to be Athenz protected. We have a simple recommendation service that returns either a movie or tv show for the caller. It has two endpoints: GET /rec/v1/movie GET /rec/v1/tvshow So in this first release we just want to protect access to these endpoints. The traffic is very low - we only expect a couple of requests an hour so we have decided to use Athenz' centralized authorization model.","title":"Service Definition"},{"location":"example_java_centralized_access/#resource-definition","text":"Defining resources and actions the principals are authorized to execute is one of the most important tasks in the authorization process. Based on our endpoints, it's expected that we'll have 2 general resources: movie tvshow The resources are referenced in their own domain namespace. So those are valid if your domain is specifically created to support this recommendation service only. But's lets assume we might add rental support later, so we need to make sure the policies are based on service specific resources. So we'll define our resources as: rec.movie rec.tvshow Support action for these resources would be read . We can extend our authorization policies later on if we need to introduce other actions - such as write or list as we add more functionality into our service.","title":"Resource Definition"},{"location":"example_java_centralized_access/#athenz-management-setup","text":"Once we have defined what our resources and actions are, we can create their respective client and server (also commonly referred as tenant and provider) roles and policies in Athenz. Go to Athenz UI and login with your account which should have system administrator access. Follow the instructions in the following guide to setup the required access control: Access Control Setup","title":"Athenz Management Setup"},{"location":"example_java_centralized_access/#obtaining-x509-certificate","text":"The service should obtain an X509 certificate that will be used for authentication with Athenz. Follow the steps in the Authentication section to receive a certificate depending on the environment: Athenz Service Identity X.509 Certificate for AWS EC2 instances Athenz Service Identity X.509 Certificate for AWS ECS containers Athenz Service Identity X.509 Certificate for AWS Fargate tasks Athenz Service Identity X.509 Certificate for AWS EKS pods Athenz Service Identity X.509 Certificate for AWS Lambda functions","title":"Obtaining X509 Certificate"},{"location":"example_java_centralized_access/#code-changes","text":"Both the client and servlet implementors need to make changes in their respective code bases to support centralized authorization checks. The client needs to make sure to submit its service certificate as part of its request, while the servlet needs to carry out the authorization check based on that service identity to determine if it request should be processed or not.","title":"Code Changes"},{"location":"example_java_centralized_access/#getting-an-ssl-context-to-be-used-in-http-clients","text":"The full client source code is available from: https://github.com/AthenZ/athenz/tree/master/libs/java/cert_refresher/examples/tls-support/src/main/java/com/yahoo/athenz/example/http/tls/client/HttpTLSClient.java","title":"Getting an SSL Context to be used in Http Clients"},{"location":"example_java_centralized_access/#client-project-dependency-update","text":"First you need to update your Java project pom.xml file to indicate the dependency on the Athenz Cert Refresher Library. Checkout the Maven Central Athenz Cert Refresher Package to make sure you're using the latest release version: <dependency> <groupId>com.yahoo.athenz</groupId> <artifactId>athenz-cert-refresher</artifactId> <version>VERSION-NUMBER</version> </dependency>","title":"Client Project Dependency Update"},{"location":"example_java_centralized_access/#build-http-client-utility","text":"Checkout and build the client component: $ git clone https://github.com/AthenZ/athenz.git $ cd libs/java/cert_refresher/examples/tls-support/src/main/java/com/yahoo/athenz/example/http/tls/client/ $ mvn clean package Verify that the client is built successfully: $ java -cp target/example-http-tls-java-client-1.0.jar HttpExampleClient Missing required options: k, c, t, p, u usage: http-example-client -k,--keyid <arg> key identifier -c,--cert <arg> certficate path -t,--trustStorePath <arg> CA TrustStore path -p,--trustStorePassword <arg> CA TrustStore password -u,--url <arg> request url","title":"Build Http Client Utility"},{"location":"example_java_centralized_access/#servlet-changes","text":"The full servlet source code is available from: https://github.com/AthenZ/athenz/tree/master/examples/java/centralized-use-case/servlet","title":"Servlet Changes"},{"location":"example_java_centralized_access/#servlet-project-dependency-update","text":"First you need to update your Java project pom.xml file to indicate the dependency on the Athenz ZMS Java Client Library and the Athenz Cert Refresher Libarry. Checkout Maven Central ZMS Client Package Page and Maven Central Athenz Cert Refresher Package to make sure you're using the latest release version: <dependency> <groupId>com.yahoo.athenz</groupId> <artifactId>athenz-zms-java-client</artifactId> <version>VERSION-NUMBER</version> </dependency> <dependency> <groupId>com.yahoo.athenz</groupId> <artifactId>athenz-cert-refresher</artifactId> <version>VERSION-NUMBER</version> </dependency>","title":"Servlet Project Dependency Update"},{"location":"example_java_centralized_access/#enable-tls-client-certificate-authentication","text":"To enable TLS Client Certificate Authentication, follow the steps in Server Side Service Identity Authentication","title":"Enable TLS Client Certificate Authentication"},{"location":"example_java_centralized_access/#authorization-checks","text":"Before any authorization calls, we're going to check to make sure our request contains the Athenz X509 certificate: static final String ATHENZ_HEADER = \"Athenz-Principal-Auth\" ; protected void doGet ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { // retrieve and verify that our request contains an Athenz // service authentication certificate X509Certificate [] certs = ( X509Certificate [] ) request . getAttribute ( JAVAX_CERT_ATTR ); // Assuming only one certificate sent in the request if ( certs == null || certs [ 0 ] == null ) { response . sendError ( 403 , \"Forbidden - No Athenz X509 certificate provided in request\" ); return ; } ... } Next, the most important part is to determine the resource and action based on the given http request. protected void doGet ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { ... switch ( reqUri ) { case \"/movie\" : responseText = \"Name: Slap Shot; Director: George Roy Hill\" ; athenzResource = \"rec.movie\" ; athenzAction = \"read\" ; break ; case \"/tvshow\" : responseText = \"Name: Middle; Channel: ABC\" ; athenzResource = \"rec.tvshow\" ; athenzAction = \"read\" ; break ; default : response . sendError ( 404 , \"Unknown endpoint\" ); return ; } ... } Once we have those two values determined, then all that is left is to contact ZMS for the authorization check. protected void doGet ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { ... // carry out the authorization check with the expected resource // and action values String principalName = x509cert . getSubjectX500Principal (). getName (); Access access = zmsClient . getAccess ( athenzAction , athenzResource , null , principalName ); boolean authorized = access . getGranted (); if ( ! authorized ) { response . sendError ( 403 , \"Forbidden - Athenz Authorization Rejected\" ); return ; } ... }","title":"Authorization Checks"},{"location":"example_java_centralized_access/#build-servlet","text":"Checkout and build the servlet component: $ git clone https://github.com/AthenZ/athenz.git $ cd examples/java/centralized-use-case/servlet/ $ mvn clean package","title":"Build Servlet"},{"location":"example_java_centralized_access/#deploying-example-servlet","text":"Download and install latest Jetty 9.3.x container Copy the athenz-control.war from the servlet/target directory to the Jetty distribution's webapps directory Configure ZMS Server's URL in the expected environment variable: export ZMS_SERVER_URL = https://<zms-server-hostname>:4443/zms/v1 Configure Valid Issuers file path in the expected environment variable: export ATHENZ_ISSUERS_FILEPATH = <Path to valid issuers file> Configure environment variables for our web app cert, key and truststore: export REC_SERVLET_ATHENZ_KEY_PATH = <Path to key> export REC_SERVLET_ATHENZ_CERT_PATH = <Path to cert> export REC_SERVLET_ATHENZ_TRUSTSTORE_PATH = <Path to truststore> export REC_SERVLET_ATHENZ_TRUSTSTORE_PASSWORD = <truststore password> If the ZMS Server is running with a self-signed certificate, we need to generate a truststore for the java http client to use when communicating with the ZMS Server. From your ZMS Server installation, copy the zms_cert.pem file from the athenz-zms-X.Y/var/zms_server/certs directory to the jetty's etc subdirectory and execute the following commands: $ keytool -importcert -noprompt -alias zms -keystore zms_truststore.jks -file zms_cert.pem -storepass athenz $ export JAVA_OPTIONS = -Djavax.net.ssl.trustStore = <full-path-to-jetty-basedir>/etc/zms_truststore.jks Start the Jetty server by running the following command from Jetty's distribution base directory: bin/jetty.sh start","title":"Deploying Example Servlet"},{"location":"example_java_centralized_access/#test-cases","text":"Run the following test cases to verify authorization access for specific services. We're running jetty server on the local box so we're using localhost as the hostname. Copy the example-http-tls-java-client-1.0.jar file from the client/target directory to the directory that includes the private keys for the test services we created in the section Athenz Management Setup above.","title":"Test Cases"},{"location":"example_java_centralized_access/#invalid-access-without-cert","text":"For this test case we'll just use the curl client directly: $ curl http://localhost:8080/athenz-control/rec/v1/movie <html> ... <title>Error 403 Forbidden - No Athenz X509 certificate provided in request</title> ... </html>","title":"Invalid Access Without Cert"},{"location":"example_java_centralized_access/#movie-editor-access","text":"Movie service can successfully access /rec/v1/movie endpoint: $ java -cp ./example-http-tls-java-client-1.0.jar HttpTLSClient -d editors -s movie -p ./movie_private.pem -k v0 -u http://localhost:8080/athenz-control/rec/v1/movie Successful response: Name: Slap Shot ; Director: George Roy Hill Movie service does not have access to /rec/v1/tvshow endpoint: $ java -cp ./example-http-tls-java-client-1.0.jar HttpTLSClient -d editors -s movie -p ./movie_private.pem -k v0 -u http://localhost:8080/athenz-control/rec/v1/tvshow Request was forbidden - not authorized","title":"Movie Editor Access"},{"location":"example_java_centralized_access/#tvshow-editor-access","text":"TvShow service can successfully access /rec/v1/tvshow endpoint: $ java -cp ./example-http-tls-java-client-1.0.jar HttpTLSClient -d editors -s tvshow -p ./tvshow_private.pem -k v0 -u http://localhost:8080/athenz-control/rec/v1/tvshow Successful response: Name: Middle ; Channel: ABC TvShow service does not have access to /rec/v1/movie endpoint: $ java -cp ./example-http-tls-java-client-1.0.jar HttpTLSClient -d editors -s tvshow -p ./tvshow_private.pem -k v0 -u http://localhost:8080/athenz-control/rec/v1/movie Request was forbidden - not authorized","title":"TvShow Editor Access"},{"location":"example_java_centralized_access/#site-editor-access","text":"Site service has access to both /rec/v1/tvshow and /rec/v1/movie endpoints: $ java -cp ./example-http-tls-java-client-1.0.jar HttpTLSClient -d editors -s site -p ./site_private.pem -k v0 -u http://localhost:8080/athenz-control/rec/v1/movie Successful response: Name: Slap Shot ; Director: George Roy Hill $ java -cp ./example-http-tls-java-client-1.0.jar HttpTLSClient -d editors -s site -p ./site_private.pem -k v0 -u http://localhost:8080/athenz-control/rec/v1/tvshow Successful response: Name: Middle ; Channel: ABC","title":"Site Editor Access"},{"location":"example_java_centralized_access/#other-test-cases","text":"Now you can modify the movie_editos, tvshow_editors, and site_editors roles in the recommend domain to add and remove the defined services and then run the corresponding test cases to verify your access change.","title":"Other Test Cases"},{"location":"example_java_decentralized_access/","text":"Java Client/Servlet Example - Decentralized Access Control \u00b6 Required Components Service Definition Resource Definition Athenz Management Setup Client (Tenant) Domain Movie Editors TvShow Editors Site Editors Service View Server (Provider) Domain Authorization Roles and Policies Movie Access TvShow Access Full Access Code Changes Client Changes Client Project Dependency Update Obtaining Access Tokens from ZTS Server Build Http Client Utility Servlet Changes Servlet Project Dependency Update Authorization Checks Build Servlet Deploying Example Servlet Test Cases Invalid Access Without RoleToken Movie Editor Access TvShow Editor Access Site Editor Access Other Test Cases In the decentralized access control model, the client service/user uses its identity x.509 certificate along with its private key that it got from local SIA (1) to get an authorization token (Access Token) from ZTS (2), and then presents the access token to a target service to access its resources (3). The required steps to setup the environment for provider and tenant services to support decentralized access control are as follows: System administrator creates the provider and tenant domains. Tenant Domain administrator generates a public/private key pair and registers a service in its domain. Provider Domain administrator creates a role and policy that grants access to the given role with configured action and resource. Provider Domain administrator adds the Tenant Service to the role to grant access. Provider Domain administrator installs Athenz Policy Engine Updater (ZPU) on the hosts that will be running the provider service. ZPU must be configured with the provider domain name and setup to run as a cron job to periodically download the latest policy files for the server/provider domain. Tenant Domain administrator installs the private key on the host that will be running the client/tenant service. Required Components \u00b6 To support centralized access control in your applications, you only need to install and configure all Athenz components: ZMS and ZTS servers along with the Athenz UI. ZPE Policy updater needs to be install on the target service host. Please follow these guides to make sure you have all of these components up and running in your environment: ZMS Server ZTS Server UI Server On the provider service's host only install ZPU: ZPU Utility To build the client and servlet components of this example, you need to download and install JDK 11, Apache Maven and Git client if you don't already have these available on your box: Java Platform JDK 11 Apache Maven Git client Service Definition \u00b6 Let's first define our service that needs to be Athenz protected. We have a simple recommendation service that returns either a movie or tv show for the caller. It has two endpoints: GET /rec/v1/movie GET /rec/v1/tvshow So in this first release we just want to protect access to these endpoints. We're going to get large number of requests per second so contacting ZMS server for centralized authorization checks is not an option. Instead, we have decided to use Athenz' decentralized authorization model. Resource Definition \u00b6 Defining resources and actions the principals are authorized to execute is one of the most important tasks in the authorization process. Based on our endpoints, it's expected that we'll have 2 general resources: movie tvshow The resources are referenced in their own domain namespace. So those are valid if your domain is specifically created to support this recommendation service only. But's lets assume we might add rental support later, so we need to make sure the policies are based on service specific resources. So we'll define our resources as: rec.movie rec.tvshow Support action for these resources would be read . We can extend our authorization policies later on if we need to introduce other actions - such as write or list as we add more functionality into our service. Athenz Management Setup \u00b6 Once we have defined what our resources and actions are, we can create their respective client and server (also commonly referred as tenant and provider) roles and policies in Athenz. Go to Athenz UI and login with your account which should have system administrator access. Follow the instructions in the following guide to setup the required access control: Access Control Setup Code Changes \u00b6 Both the client and servlet implementors need to make changes in their respective code bases to support decentralized authorization checks. The client needs to make sure to retrieve its Access Token from ZTS Service and submit that as part of its request, while the servlet needs to carry out the authorization check based on that Access Token to determine if it request should be processed or not. Client Changes \u00b6 The full client source code is available from: https://github.com/AthenZ/athenz/tree/master/examples/java/decentralized-use-case/client Client Project Dependency Update \u00b6 First you need to update your Java project pom.xml file to indicate the dependency on the Athenz auth_core and zts java client libraries. Checkout the Maven Central Athenz Cert Refresher Package and Maven Central ZTS Java Client Package pages to make sure you're using the latest release version: <dependency> <groupId>com.yahoo.athenz</groupId> <artifactId>athenz-cert-refresher</artifactId> <version>VERSION-NUMBER</version> </dependency> <dependency> <groupId>com.yahoo.athenz</groupId> <artifactId>athenz-zts-java-client</artifactId> <version>VERSION-NUMBER</version> </dependency> Obtaining Access Tokens from ZTS Server \u00b6 The service should obtain an X509 certificate that will be used for authentication with Athenz. Follow the steps in the Authentication section to receive a certificate depending on the environment: Athenz Service Identity X.509 Certificate for AWS EC2 instances Athenz Service Identity X.509 Certificate for AWS ECS containers Athenz Service Identity X.509 Certificate for AWS Fargate tasks Athenz Service Identity X.509 Certificate for AWS EKS pods Athenz Service Identity X.509 Certificate for AWS Lambda functions Then, we need to contact ZTS Server to retrieve an access token for the given service identity (provided by the ServiceIdentityProvider) accessing a target service domain: // the fields used in the following snippet of code // ztsUrl -> ZTS Server Url // domainName -> 'recommend' // serviceName -> 'movie', 'tvshow' or 'site' // providerRole -> 'movie_editors, tvshow_editors, full_access' KeyRefresher keyRefresher = Utils . generateKeyRefresher ( trustStorePath , trustStorePassword , certPath , keyPath ); keyRefresher . startup (); SSLContext sslContext = Utils . buildSSLContext ( keyRefresher . getKeyManagerProxy (), keyRefresher . getTrustManagerProxy ()); HttpsURLConnection . setDefaultSSLSocketFactory ( sslContext . getSocketFactory ()); ZTSClient ztsClient = new ZTSClient ( ztsUrl , sslContext ); List < String > roles = new ArrayList <> (); roles . add ( providerRole ); // Can be several of roles. Our example only use one AccessTokenResponse accessTokenResponse = ztsClient . getAccessToken ( domainName , roles , serviceName , 0 , true ); String accessToken = accessTokenResponse == null ? null : accessTokenResponse . getToken_type () + \" \" + accessTokenResponse . getAccess_token (); Once we have our Access Token, we can use it in the Authorization header. // set our Athenz credentials. The ZTSClient provides the header // name that we must use for authorization token while the access // token itself provides the token string. con . setRequestProperty ( ZTSClient . getHeader (), accessToken ); Build Http Client Utility \u00b6 Checkout and build the client component: $ git clone https://github.com/AthenZ/athenz.git $ cd examples/java/decentralized-use-case/client/ $ mvn clean package Verify that the client is built successfully: $ java -cp target/example-java-client-access-token-1.0.jar com.yahoo.athenz.example.accesstoken.HttpExampleClient Missing required options: k, c, t, p, d, pr, s, u, z usage: http-example-client -k,--keyid <arg> key identifier -c,--cert <arg> certficate path -t,--trustStorePath <arg> CA TrustStore path -p,--trustStorePassword <arg> CA TrustStore password -d,--domain <arg> domain name -pr,--provider-role <arg> Provider role name -s,--service <arg> service name -u,--url <arg> request url -z,--ztsurl <arg> ZTS Server url Servlet Changes \u00b6 The full servlet source code is available from: https://github.com/AthenZ/athenz/tree/master/examples/java/decentralized-use-case/servlet Servlet Project Dependency Update \u00b6 First you need to update your Java project pom.xml file to indicate the dependency on the Athenz ZPE Java Client Library. Checkout the Maven Central ZPE Client Package Page to make sure you're using the latest release version: <dependency> <groupId>com.yahoo.athenz</groupId> <artifactId>athenz-zpe-java-client</artifactId> <version>VERSION-NUMBER</version> </dependency> Authorization Checks \u00b6 First, we need to make sure the servlet initialization time, Athenz ZPE Client library is initialized so it can process and load any domain policy documents retrieved by ZPE Policy Updater. public void init () throws ServletException { // initialize Athenz ZPE client which will load // all policy files into memory AuthZpeClient . init (); } Before any authorization calls, we're going to check to make sure our request contains the Athenz role token: static final String ATHENZ_HEADER = \"Athenz-Role-Auth\" ; protected void doGet ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { // retrieve and verify that our request contains an Athenz // access token String accessToken = request . getHeader ( ATHENZ_HEADER ); if ( accessToken == null ) { response . sendError ( 403 , \"Forbidden - No Athenz accessToken provided in request\" ); return ; } ... } Next, the most important part is to determine the resource and action based on the given http request. protected void doGet ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { ... switch ( reqUri ) { case \"/movie\" : responseText = \"Name: Slap Shot; Director: George Roy Hill\" ; athenzResource = \"rec.movie\" ; athenzAction = \"read\" ; break ; case \"/tvshow\" : responseText = \"Name: Middle; Channel: ABC\" ; athenzResource = \"rec.tvshow\" ; athenzAction = \"read\" ; break ; default : response . sendError ( 404 , \"Unknown endpoint\" ); return ; } ... } Once we have those two values determined, then all that is left is to use ZPE client library for the authorization check. protected void doGet ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { ... // carry out the authorization check with the expected resource // and action values AccessCheckStatus status = AuthZpeClient . allowAccess ( accessToken , athenzResource , athenzAction ); if ( status != AccessCheckStatus . ALLOW ) { response . sendError ( 403 , \"Forbidden - Athenz Authorization Rejected\" ); return ; } ... } Build Servlet \u00b6 Checkout and build the servlet component: $ git clone https://github.com/AthenZ/athenz.git $ cd examples/java/decentralized-use-case/servlet/ $ mvn clean package Deploying Example Servlet \u00b6 Download and install latest Jetty 9.3.x container Copy the athenz-data.war from the servlet/target directory to the Jetty distribution's webapps directory Configure ZPU to download the policy documents for domain recommend . $ vi <zpu-install-directory>/conf/zpe_policy_updater/zpu.conf In the json file, edit the value for the domains field to be set to recommend . Run the zpu utility to retrieve the policy documents from ZTS. $ <zpu-directory>/bin/zpu_run.sh $ ls -lat <zpe-directory>/var/zpe/recommend.pol Configure ZPE library to look for the policy file and the athenz.conf files in the expected directory: $ export JAVA_OPTIONS = \"-Dathenz.zpe.policy_dir=<zpu-directory>/var/zpe -Dathenz.athenz_conf=<zpu-directory>/conf/zpe_policy_updater/athenz.conf\" Start the Jetty server by running the following command from Jetty's distribution base directory: bin/jetty.sh start Test Cases \u00b6 Run the following test cases to verify authorization access for specific services. We're running jetty server on the local box so we're using localhost as the hostname. Copy the example-java-client-access-token-1.0.jar file from the client/target directory to the directory that includes the private keys for the test services we created in the section Athenz Management Setup above. If the ZTS Server is running with a self-signed certificate, we need to generate a truststore for the java http client to use when communicating with the ZTS Server. From your ZTS Server installation, copy the zts_cert.pem file from the athenz-zts-X.Y/var/zts_server/certs directory into the same directory where the client access token utility is saved (previous step) and execute the following commands: $ keytool -importcert -noprompt -alias zts -keystore zts_truststore.jks -file zts_cert.pem -storepass athenz Invalid Access Without accessToken \u00b6 For this test case we'll just use the curl client directly: $ curl http://localhost:8080/athenz-data/rec/v1/movie <html> ... <title>Error 403 Forbidden - No Athenz accessToken provided in request</title> ... </html> Movie Editor Access \u00b6 Movie service can successfully access /rec/v1/movie endpoint: $ java -Djavax.net.ssl.trustStore = ./zts_truststore.jks -cp ./example-java-client-access-token-1.0.jar com.yahoo.athenz.example.accesstoken.HttpExampleClient -t ./zts_truststore.jks -p athenz -s movie -p ./movie_private.pem -d recommend -pr movie_editors -z https://<zts-server>:8443/zts/v1 -u http://localhost:8080/athenz-data/rec/v1/movie Successful response: Name: Slap Shot ; Director: George Roy Hill Movie service does not have access to /rec/v1/tvshow endpoint: $ java -Djavax.net.ssl.trustStore = ./zts_truststore.jks -cp ./example-java-client-access-token-1.0.jar com.yahoo.athenz.example.accesstoken.HttpExampleClient -t ./zts_truststore.jks -p athenz -s movie -p ./movie_private.pem -d recommend -pr movie_editors -z https://<zts-server>:8443/zts/v1 -u http://localhost:8080/athenz-data/rec/v1/tvshow Request was forbidden - not authorized TvShow Editor Access \u00b6 TvShow service can successfully access /rec/v1/tvshow endpoint: $ java -Djavax.net.ssl.trustStore = ./zts_truststore.jks -cp ./example-java-client-access-token-1.0.jar com.yahoo.athenz.example.accesstoken.HttpExampleClient -t ./zts_truststore.jks -p athenz -s tvshow -p ./tvshow_private.pem -d recommend -pr tvshow_editors -z https://<zts-server>:8443/zts/v1 -u http://localhost:8080/athenz-data/rec/v1/tvshow Successful response: Name: Middle ; Channel: ABC TvShow service does not have access to /rec/v1/movie endpoint: $ java -Djavax.net.ssl.trustStore = ./zts_truststore.jks -cp ./example-java-client-access-token-1.0.jar com.yahoo.athenz.example.accesstoken.HttpExampleClient -t ./zts_truststore.jks -p athenz -s tvshow -p ./tvshow_private.pem -d recommend -pr tvshow_editors -z https://<zts-server>:8443/zts/v1 -u http://localhost:8080/athenz-data/rec/v1/movie Request was forbidden - not authorized Site Editor Access \u00b6 Site service has access to both /rec/v1/tvshow and /rec/v1/movie endpoints: $ java -Djavax.net.ssl.trustStore = ./zts_truststore.jks -cp ./example-java-client-access-token-1.0.jar com.yahoo.athenz.example.accesstoken.HttpExampleClient -t ./zts_truststore.jks -p athenz -s site -p ./site_private.pem -d recommend -pr full_access -z https://<zts-server>:8443/zts/v1 -u http://localhost:8080/athenz-data/rec/v1/movie Successful response: Name: Slap Shot ; Director: George Roy Hill $ java -Djavax.net.ssl.trustStore = ./zts_truststore.jks -cp ./example-java-client-access-token-1.0.jar com.yahoo.athenz.example.accesstoken.HttpExampleClient -t ./zts_truststore.jks -p athenz -s site -p ./site_private.pem -k v0 -d recommend -pr full_access -z https://<zts-server>:8443/zts/v1 -u http://localhost:8080/athenz-data/rec/v1/tvshow Successful response: Name: Middle ; Channel: ABC Other Test Cases \u00b6 Now you can modify the movie_editos, tvshow_editors, and site_editors roles in the recommend domain to add and remove the defined services. After you make the changes, it will take about a minute for the updates to propagate from ZMS to the ZTS Server. Then you need to run the zpu_run.sh command again to fetch the updated policy files for the domain onto your host. Then you can run the corresponding test cases to verify your access change.","title":"Java Client/Servlet Decentralized Example"},{"location":"example_java_decentralized_access/#java-clientservlet-example-decentralized-access-control","text":"Required Components Service Definition Resource Definition Athenz Management Setup Client (Tenant) Domain Movie Editors TvShow Editors Site Editors Service View Server (Provider) Domain Authorization Roles and Policies Movie Access TvShow Access Full Access Code Changes Client Changes Client Project Dependency Update Obtaining Access Tokens from ZTS Server Build Http Client Utility Servlet Changes Servlet Project Dependency Update Authorization Checks Build Servlet Deploying Example Servlet Test Cases Invalid Access Without RoleToken Movie Editor Access TvShow Editor Access Site Editor Access Other Test Cases In the decentralized access control model, the client service/user uses its identity x.509 certificate along with its private key that it got from local SIA (1) to get an authorization token (Access Token) from ZTS (2), and then presents the access token to a target service to access its resources (3). The required steps to setup the environment for provider and tenant services to support decentralized access control are as follows: System administrator creates the provider and tenant domains. Tenant Domain administrator generates a public/private key pair and registers a service in its domain. Provider Domain administrator creates a role and policy that grants access to the given role with configured action and resource. Provider Domain administrator adds the Tenant Service to the role to grant access. Provider Domain administrator installs Athenz Policy Engine Updater (ZPU) on the hosts that will be running the provider service. ZPU must be configured with the provider domain name and setup to run as a cron job to periodically download the latest policy files for the server/provider domain. Tenant Domain administrator installs the private key on the host that will be running the client/tenant service.","title":"Java Client/Servlet Example - Decentralized Access Control"},{"location":"example_java_decentralized_access/#required-components","text":"To support centralized access control in your applications, you only need to install and configure all Athenz components: ZMS and ZTS servers along with the Athenz UI. ZPE Policy updater needs to be install on the target service host. Please follow these guides to make sure you have all of these components up and running in your environment: ZMS Server ZTS Server UI Server On the provider service's host only install ZPU: ZPU Utility To build the client and servlet components of this example, you need to download and install JDK 11, Apache Maven and Git client if you don't already have these available on your box: Java Platform JDK 11 Apache Maven Git client","title":"Required Components"},{"location":"example_java_decentralized_access/#service-definition","text":"Let's first define our service that needs to be Athenz protected. We have a simple recommendation service that returns either a movie or tv show for the caller. It has two endpoints: GET /rec/v1/movie GET /rec/v1/tvshow So in this first release we just want to protect access to these endpoints. We're going to get large number of requests per second so contacting ZMS server for centralized authorization checks is not an option. Instead, we have decided to use Athenz' decentralized authorization model.","title":"Service Definition"},{"location":"example_java_decentralized_access/#resource-definition","text":"Defining resources and actions the principals are authorized to execute is one of the most important tasks in the authorization process. Based on our endpoints, it's expected that we'll have 2 general resources: movie tvshow The resources are referenced in their own domain namespace. So those are valid if your domain is specifically created to support this recommendation service only. But's lets assume we might add rental support later, so we need to make sure the policies are based on service specific resources. So we'll define our resources as: rec.movie rec.tvshow Support action for these resources would be read . We can extend our authorization policies later on if we need to introduce other actions - such as write or list as we add more functionality into our service.","title":"Resource Definition"},{"location":"example_java_decentralized_access/#athenz-management-setup","text":"Once we have defined what our resources and actions are, we can create their respective client and server (also commonly referred as tenant and provider) roles and policies in Athenz. Go to Athenz UI and login with your account which should have system administrator access. Follow the instructions in the following guide to setup the required access control: Access Control Setup","title":"Athenz Management Setup"},{"location":"example_java_decentralized_access/#code-changes","text":"Both the client and servlet implementors need to make changes in their respective code bases to support decentralized authorization checks. The client needs to make sure to retrieve its Access Token from ZTS Service and submit that as part of its request, while the servlet needs to carry out the authorization check based on that Access Token to determine if it request should be processed or not.","title":"Code Changes"},{"location":"example_java_decentralized_access/#client-changes","text":"The full client source code is available from: https://github.com/AthenZ/athenz/tree/master/examples/java/decentralized-use-case/client","title":"Client Changes"},{"location":"example_java_decentralized_access/#client-project-dependency-update","text":"First you need to update your Java project pom.xml file to indicate the dependency on the Athenz auth_core and zts java client libraries. Checkout the Maven Central Athenz Cert Refresher Package and Maven Central ZTS Java Client Package pages to make sure you're using the latest release version: <dependency> <groupId>com.yahoo.athenz</groupId> <artifactId>athenz-cert-refresher</artifactId> <version>VERSION-NUMBER</version> </dependency> <dependency> <groupId>com.yahoo.athenz</groupId> <artifactId>athenz-zts-java-client</artifactId> <version>VERSION-NUMBER</version> </dependency>","title":"Client Project Dependency Update"},{"location":"example_java_decentralized_access/#obtaining-access-tokens-from-zts-server","text":"The service should obtain an X509 certificate that will be used for authentication with Athenz. Follow the steps in the Authentication section to receive a certificate depending on the environment: Athenz Service Identity X.509 Certificate for AWS EC2 instances Athenz Service Identity X.509 Certificate for AWS ECS containers Athenz Service Identity X.509 Certificate for AWS Fargate tasks Athenz Service Identity X.509 Certificate for AWS EKS pods Athenz Service Identity X.509 Certificate for AWS Lambda functions Then, we need to contact ZTS Server to retrieve an access token for the given service identity (provided by the ServiceIdentityProvider) accessing a target service domain: // the fields used in the following snippet of code // ztsUrl -> ZTS Server Url // domainName -> 'recommend' // serviceName -> 'movie', 'tvshow' or 'site' // providerRole -> 'movie_editors, tvshow_editors, full_access' KeyRefresher keyRefresher = Utils . generateKeyRefresher ( trustStorePath , trustStorePassword , certPath , keyPath ); keyRefresher . startup (); SSLContext sslContext = Utils . buildSSLContext ( keyRefresher . getKeyManagerProxy (), keyRefresher . getTrustManagerProxy ()); HttpsURLConnection . setDefaultSSLSocketFactory ( sslContext . getSocketFactory ()); ZTSClient ztsClient = new ZTSClient ( ztsUrl , sslContext ); List < String > roles = new ArrayList <> (); roles . add ( providerRole ); // Can be several of roles. Our example only use one AccessTokenResponse accessTokenResponse = ztsClient . getAccessToken ( domainName , roles , serviceName , 0 , true ); String accessToken = accessTokenResponse == null ? null : accessTokenResponse . getToken_type () + \" \" + accessTokenResponse . getAccess_token (); Once we have our Access Token, we can use it in the Authorization header. // set our Athenz credentials. The ZTSClient provides the header // name that we must use for authorization token while the access // token itself provides the token string. con . setRequestProperty ( ZTSClient . getHeader (), accessToken );","title":"Obtaining Access Tokens from ZTS Server"},{"location":"example_java_decentralized_access/#build-http-client-utility","text":"Checkout and build the client component: $ git clone https://github.com/AthenZ/athenz.git $ cd examples/java/decentralized-use-case/client/ $ mvn clean package Verify that the client is built successfully: $ java -cp target/example-java-client-access-token-1.0.jar com.yahoo.athenz.example.accesstoken.HttpExampleClient Missing required options: k, c, t, p, d, pr, s, u, z usage: http-example-client -k,--keyid <arg> key identifier -c,--cert <arg> certficate path -t,--trustStorePath <arg> CA TrustStore path -p,--trustStorePassword <arg> CA TrustStore password -d,--domain <arg> domain name -pr,--provider-role <arg> Provider role name -s,--service <arg> service name -u,--url <arg> request url -z,--ztsurl <arg> ZTS Server url","title":"Build Http Client Utility"},{"location":"example_java_decentralized_access/#servlet-changes","text":"The full servlet source code is available from: https://github.com/AthenZ/athenz/tree/master/examples/java/decentralized-use-case/servlet","title":"Servlet Changes"},{"location":"example_java_decentralized_access/#servlet-project-dependency-update","text":"First you need to update your Java project pom.xml file to indicate the dependency on the Athenz ZPE Java Client Library. Checkout the Maven Central ZPE Client Package Page to make sure you're using the latest release version: <dependency> <groupId>com.yahoo.athenz</groupId> <artifactId>athenz-zpe-java-client</artifactId> <version>VERSION-NUMBER</version> </dependency>","title":"Servlet Project Dependency Update"},{"location":"example_java_decentralized_access/#authorization-checks","text":"First, we need to make sure the servlet initialization time, Athenz ZPE Client library is initialized so it can process and load any domain policy documents retrieved by ZPE Policy Updater. public void init () throws ServletException { // initialize Athenz ZPE client which will load // all policy files into memory AuthZpeClient . init (); } Before any authorization calls, we're going to check to make sure our request contains the Athenz role token: static final String ATHENZ_HEADER = \"Athenz-Role-Auth\" ; protected void doGet ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { // retrieve and verify that our request contains an Athenz // access token String accessToken = request . getHeader ( ATHENZ_HEADER ); if ( accessToken == null ) { response . sendError ( 403 , \"Forbidden - No Athenz accessToken provided in request\" ); return ; } ... } Next, the most important part is to determine the resource and action based on the given http request. protected void doGet ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { ... switch ( reqUri ) { case \"/movie\" : responseText = \"Name: Slap Shot; Director: George Roy Hill\" ; athenzResource = \"rec.movie\" ; athenzAction = \"read\" ; break ; case \"/tvshow\" : responseText = \"Name: Middle; Channel: ABC\" ; athenzResource = \"rec.tvshow\" ; athenzAction = \"read\" ; break ; default : response . sendError ( 404 , \"Unknown endpoint\" ); return ; } ... } Once we have those two values determined, then all that is left is to use ZPE client library for the authorization check. protected void doGet ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { ... // carry out the authorization check with the expected resource // and action values AccessCheckStatus status = AuthZpeClient . allowAccess ( accessToken , athenzResource , athenzAction ); if ( status != AccessCheckStatus . ALLOW ) { response . sendError ( 403 , \"Forbidden - Athenz Authorization Rejected\" ); return ; } ... }","title":"Authorization Checks"},{"location":"example_java_decentralized_access/#build-servlet","text":"Checkout and build the servlet component: $ git clone https://github.com/AthenZ/athenz.git $ cd examples/java/decentralized-use-case/servlet/ $ mvn clean package","title":"Build Servlet"},{"location":"example_java_decentralized_access/#deploying-example-servlet","text":"Download and install latest Jetty 9.3.x container Copy the athenz-data.war from the servlet/target directory to the Jetty distribution's webapps directory Configure ZPU to download the policy documents for domain recommend . $ vi <zpu-install-directory>/conf/zpe_policy_updater/zpu.conf In the json file, edit the value for the domains field to be set to recommend . Run the zpu utility to retrieve the policy documents from ZTS. $ <zpu-directory>/bin/zpu_run.sh $ ls -lat <zpe-directory>/var/zpe/recommend.pol Configure ZPE library to look for the policy file and the athenz.conf files in the expected directory: $ export JAVA_OPTIONS = \"-Dathenz.zpe.policy_dir=<zpu-directory>/var/zpe -Dathenz.athenz_conf=<zpu-directory>/conf/zpe_policy_updater/athenz.conf\" Start the Jetty server by running the following command from Jetty's distribution base directory: bin/jetty.sh start","title":"Deploying Example Servlet"},{"location":"example_java_decentralized_access/#test-cases","text":"Run the following test cases to verify authorization access for specific services. We're running jetty server on the local box so we're using localhost as the hostname. Copy the example-java-client-access-token-1.0.jar file from the client/target directory to the directory that includes the private keys for the test services we created in the section Athenz Management Setup above. If the ZTS Server is running with a self-signed certificate, we need to generate a truststore for the java http client to use when communicating with the ZTS Server. From your ZTS Server installation, copy the zts_cert.pem file from the athenz-zts-X.Y/var/zts_server/certs directory into the same directory where the client access token utility is saved (previous step) and execute the following commands: $ keytool -importcert -noprompt -alias zts -keystore zts_truststore.jks -file zts_cert.pem -storepass athenz","title":"Test Cases"},{"location":"example_java_decentralized_access/#invalid-access-without-accesstoken","text":"For this test case we'll just use the curl client directly: $ curl http://localhost:8080/athenz-data/rec/v1/movie <html> ... <title>Error 403 Forbidden - No Athenz accessToken provided in request</title> ... </html>","title":"Invalid Access Without accessToken"},{"location":"example_java_decentralized_access/#movie-editor-access","text":"Movie service can successfully access /rec/v1/movie endpoint: $ java -Djavax.net.ssl.trustStore = ./zts_truststore.jks -cp ./example-java-client-access-token-1.0.jar com.yahoo.athenz.example.accesstoken.HttpExampleClient -t ./zts_truststore.jks -p athenz -s movie -p ./movie_private.pem -d recommend -pr movie_editors -z https://<zts-server>:8443/zts/v1 -u http://localhost:8080/athenz-data/rec/v1/movie Successful response: Name: Slap Shot ; Director: George Roy Hill Movie service does not have access to /rec/v1/tvshow endpoint: $ java -Djavax.net.ssl.trustStore = ./zts_truststore.jks -cp ./example-java-client-access-token-1.0.jar com.yahoo.athenz.example.accesstoken.HttpExampleClient -t ./zts_truststore.jks -p athenz -s movie -p ./movie_private.pem -d recommend -pr movie_editors -z https://<zts-server>:8443/zts/v1 -u http://localhost:8080/athenz-data/rec/v1/tvshow Request was forbidden - not authorized","title":"Movie Editor Access"},{"location":"example_java_decentralized_access/#tvshow-editor-access","text":"TvShow service can successfully access /rec/v1/tvshow endpoint: $ java -Djavax.net.ssl.trustStore = ./zts_truststore.jks -cp ./example-java-client-access-token-1.0.jar com.yahoo.athenz.example.accesstoken.HttpExampleClient -t ./zts_truststore.jks -p athenz -s tvshow -p ./tvshow_private.pem -d recommend -pr tvshow_editors -z https://<zts-server>:8443/zts/v1 -u http://localhost:8080/athenz-data/rec/v1/tvshow Successful response: Name: Middle ; Channel: ABC TvShow service does not have access to /rec/v1/movie endpoint: $ java -Djavax.net.ssl.trustStore = ./zts_truststore.jks -cp ./example-java-client-access-token-1.0.jar com.yahoo.athenz.example.accesstoken.HttpExampleClient -t ./zts_truststore.jks -p athenz -s tvshow -p ./tvshow_private.pem -d recommend -pr tvshow_editors -z https://<zts-server>:8443/zts/v1 -u http://localhost:8080/athenz-data/rec/v1/movie Request was forbidden - not authorized","title":"TvShow Editor Access"},{"location":"example_java_decentralized_access/#site-editor-access","text":"Site service has access to both /rec/v1/tvshow and /rec/v1/movie endpoints: $ java -Djavax.net.ssl.trustStore = ./zts_truststore.jks -cp ./example-java-client-access-token-1.0.jar com.yahoo.athenz.example.accesstoken.HttpExampleClient -t ./zts_truststore.jks -p athenz -s site -p ./site_private.pem -d recommend -pr full_access -z https://<zts-server>:8443/zts/v1 -u http://localhost:8080/athenz-data/rec/v1/movie Successful response: Name: Slap Shot ; Director: George Roy Hill $ java -Djavax.net.ssl.trustStore = ./zts_truststore.jks -cp ./example-java-client-access-token-1.0.jar com.yahoo.athenz.example.accesstoken.HttpExampleClient -t ./zts_truststore.jks -p athenz -s site -p ./site_private.pem -k v0 -d recommend -pr full_access -z https://<zts-server>:8443/zts/v1 -u http://localhost:8080/athenz-data/rec/v1/tvshow Successful response: Name: Middle ; Channel: ABC","title":"Site Editor Access"},{"location":"example_java_decentralized_access/#other-test-cases","text":"Now you can modify the movie_editos, tvshow_editors, and site_editors roles in the recommend domain to add and remove the defined services. After you make the changes, it will take about a minute for the updates to propagate from ZMS to the ZTS Server. Then you need to run the zpu_run.sh command again to fetch the updated policy files for the domain onto your host. Then you can run the corresponding test cases to verify your access change.","title":"Other Test Cases"},{"location":"example_service_athenz_setup/","text":"Example Service Access Control Setup \u00b6 Client (Tenant) Domain Movie Editors TvShow Editors Site Editors Service View Server (Provider) Domain Authorization Roles and Policies Movie Access TvShow Access Full Access We've decided that our resources for the service will be defined in Athenz as: rec.movie rec.tvshow and the only supported action for now would be read . Now we can create their respective client and server (also commonly referred as tenant and provider) roles and policies in Athenz. Go to Athenz UI and login with your account which should have system administrator access. Client (Tenant) Domain \u00b6 The client services will be defined in the editors domain so let's create that domain and services. Click on the Create a domain link in top left corner to add the domain: Movie Editors \u00b6 Each service is identified by its private/public key pair. The movie service will be authorized to access the /rec/v1/movie endpoint from our recommendation service. So we need to first generate the key pair (at the end we're going to display the contents of the public key since we'll be using that when creating the service in the UI): $ openssl genrsa -out movie_private.pem 2048 $ openssl rsa -in movie_private.pem -pubout > movie_public.pem $ cat movie_public.pem Now we need to register the movie service in the editors domain. After you login, click on the editors domain in the left hand tree pane, then choose the Services tab. Click on the Add Service button. In the Key Value field when creating a service, enter the contents of the movie_public.pem file. For the Public Key Id field we'll use v0 . Each service can be identified my multiple key pairs. For example, if you have services running in different geographical data centers, each data center instance can have its own unique public/private key pair. It also allows the service administrator to establish a key rotation policy - e.g. generate a new key pair every 6 months and assign a new key identifier: v0, v1, etc. TvShow Editors \u00b6 The tvshow service will be authorized to access the /rec/v1/tvshow endpoint from our recommendation service. So again, we need to first generate the key pair (at the end we're going to display the contents of the public key since we'll be using that when creating the service in the UI): $ openssl genrsa -out tvshow_private.pem 2048 $ openssl rsa -in tvshow_private.pem -pubout > tvshow_public.pem $ cat tvshow_public.pem Now we need to register the tvshow service in the editors domain. After you login, click on the editors domain in the left hand tree pane, then choose the Services tab. Click on the Add Service button. In the Key Value field when creating a service, enter the contents of the tvshow_public.pem file. For the Public Key Id field we'll use v0 . See the Movie Editors section for additional details on this field. Site Editors \u00b6 The site service will be authorized to access both /rec/v1/movie and /rec/v1/tvshow endpoints from our recommendation service. So we need to first generate the key pair (at the end we're going to display the contents of the public key since we'll be using that when creating the service in the UI): $ openssl genrsa -out site_private.pem 2048 $ openssl rsa -in site_private.pem -pubout > site_public.pem $ cat site_public.pem Finally, we need to register the site service in the editors domain. After you login, click on the editors domain in the left hand tree pane, then choose the Services tab.Click on the Add Service button. In the Key Value field when creating a service, enter the contents of the site_public.pem file. For the Public Key Id field we'll use v0 . See the Movie Editors section for additional details on this field. Service View \u00b6 Once all three services are successfully registered, you should have the following Services view for the editors domains: Server (Provider) Domain \u00b6 The recommendation service will be run by recommend property. So let's first create this domain in Athenz. Click on the Create a domain link in top left corner to add the domain: Authorization Roles and Policies \u00b6 Typically since we have two resources and only one action supported in this use case, we'll be creating 2 roles that will be providing access control. In this model, if we want one service to have access to both services, we'll need to add that principal to both roles. A slightly different approach would be to create yet another role that provides full access to all recommendation endpoints. Movie Access \u00b6 First we need to create the role that includes principals authorized to access the movie resource. In our example, we'll call this role as movie_editors and include editors.movie service as a member of this role. After you login, click on the recommend domain in the left hand tree pane, then choose the Roles tab. Click on the Add Role button: Now we need to give access to this role with action read to resource rec.movie . Choose the Policies tab and click on the Add Policy button: TvShow Access \u00b6 Now we need to create the role that includes principals authorized to access the tvshow resource. In our example, we'll call this role as tvshow_editors and include editors.tvshow service as a member of this role. After you login, click on the recommend domain in the left hand tree pane, then choose the Roles tab. Click on the Add Role button: Now we need to give access to this role with action read to resource rec.tvshow . Choose the Policies tab and click on the Add Policy button: Full Access \u00b6 Finally, we need to create the role that includes principals authorized to have full access to any resource in our recommendation service. In our example, we'll call this role as full_access and include editors.site service as a member of this role. After you login, click on the recommend domain in the left hand tree pane, then choose the Roles tab. Click on the Add Role button: Now we need to give access to this role with action * to resource rec.* . Since Athenz support glob style wildcards, having * indicates it will match all actions - e.g. read , write , etc. And having the resource as rec.* indicates that it will match rec.movie , rec.tvshow and any other resource that we create with the prefix rec. . Choose the Policies tab and click on the Add Policy button:","title":"Example Service Access Control Setup"},{"location":"example_service_athenz_setup/#example-service-access-control-setup","text":"Client (Tenant) Domain Movie Editors TvShow Editors Site Editors Service View Server (Provider) Domain Authorization Roles and Policies Movie Access TvShow Access Full Access We've decided that our resources for the service will be defined in Athenz as: rec.movie rec.tvshow and the only supported action for now would be read . Now we can create their respective client and server (also commonly referred as tenant and provider) roles and policies in Athenz. Go to Athenz UI and login with your account which should have system administrator access.","title":"Example Service Access Control Setup"},{"location":"example_service_athenz_setup/#client-tenant-domain","text":"The client services will be defined in the editors domain so let's create that domain and services. Click on the Create a domain link in top left corner to add the domain:","title":"Client (Tenant) Domain"},{"location":"example_service_athenz_setup/#movie-editors","text":"Each service is identified by its private/public key pair. The movie service will be authorized to access the /rec/v1/movie endpoint from our recommendation service. So we need to first generate the key pair (at the end we're going to display the contents of the public key since we'll be using that when creating the service in the UI): $ openssl genrsa -out movie_private.pem 2048 $ openssl rsa -in movie_private.pem -pubout > movie_public.pem $ cat movie_public.pem Now we need to register the movie service in the editors domain. After you login, click on the editors domain in the left hand tree pane, then choose the Services tab. Click on the Add Service button. In the Key Value field when creating a service, enter the contents of the movie_public.pem file. For the Public Key Id field we'll use v0 . Each service can be identified my multiple key pairs. For example, if you have services running in different geographical data centers, each data center instance can have its own unique public/private key pair. It also allows the service administrator to establish a key rotation policy - e.g. generate a new key pair every 6 months and assign a new key identifier: v0, v1, etc.","title":"Movie Editors"},{"location":"example_service_athenz_setup/#tvshow-editors","text":"The tvshow service will be authorized to access the /rec/v1/tvshow endpoint from our recommendation service. So again, we need to first generate the key pair (at the end we're going to display the contents of the public key since we'll be using that when creating the service in the UI): $ openssl genrsa -out tvshow_private.pem 2048 $ openssl rsa -in tvshow_private.pem -pubout > tvshow_public.pem $ cat tvshow_public.pem Now we need to register the tvshow service in the editors domain. After you login, click on the editors domain in the left hand tree pane, then choose the Services tab. Click on the Add Service button. In the Key Value field when creating a service, enter the contents of the tvshow_public.pem file. For the Public Key Id field we'll use v0 . See the Movie Editors section for additional details on this field.","title":"TvShow Editors"},{"location":"example_service_athenz_setup/#site-editors","text":"The site service will be authorized to access both /rec/v1/movie and /rec/v1/tvshow endpoints from our recommendation service. So we need to first generate the key pair (at the end we're going to display the contents of the public key since we'll be using that when creating the service in the UI): $ openssl genrsa -out site_private.pem 2048 $ openssl rsa -in site_private.pem -pubout > site_public.pem $ cat site_public.pem Finally, we need to register the site service in the editors domain. After you login, click on the editors domain in the left hand tree pane, then choose the Services tab.Click on the Add Service button. In the Key Value field when creating a service, enter the contents of the site_public.pem file. For the Public Key Id field we'll use v0 . See the Movie Editors section for additional details on this field.","title":"Site Editors"},{"location":"example_service_athenz_setup/#service-view","text":"Once all three services are successfully registered, you should have the following Services view for the editors domains:","title":"Service View"},{"location":"example_service_athenz_setup/#server-provider-domain","text":"The recommendation service will be run by recommend property. So let's first create this domain in Athenz. Click on the Create a domain link in top left corner to add the domain:","title":"Server (Provider) Domain"},{"location":"example_service_athenz_setup/#authorization-roles-and-policies","text":"Typically since we have two resources and only one action supported in this use case, we'll be creating 2 roles that will be providing access control. In this model, if we want one service to have access to both services, we'll need to add that principal to both roles. A slightly different approach would be to create yet another role that provides full access to all recommendation endpoints.","title":"Authorization Roles and Policies"},{"location":"example_service_athenz_setup/#movie-access","text":"First we need to create the role that includes principals authorized to access the movie resource. In our example, we'll call this role as movie_editors and include editors.movie service as a member of this role. After you login, click on the recommend domain in the left hand tree pane, then choose the Roles tab. Click on the Add Role button: Now we need to give access to this role with action read to resource rec.movie . Choose the Policies tab and click on the Add Policy button:","title":"Movie Access"},{"location":"example_service_athenz_setup/#tvshow-access","text":"Now we need to create the role that includes principals authorized to access the tvshow resource. In our example, we'll call this role as tvshow_editors and include editors.tvshow service as a member of this role. After you login, click on the recommend domain in the left hand tree pane, then choose the Roles tab. Click on the Add Role button: Now we need to give access to this role with action read to resource rec.tvshow . Choose the Policies tab and click on the Add Policy button:","title":"TvShow Access"},{"location":"example_service_athenz_setup/#full-access","text":"Finally, we need to create the role that includes principals authorized to have full access to any resource in our recommendation service. In our example, we'll call this role as full_access and include editors.site service as a member of this role. After you login, click on the recommend domain in the left hand tree pane, then choose the Roles tab. Click on the Add Role button: Now we need to give access to this role with action * to resource rec.* . Since Athenz support glob style wildcards, having * indicates it will match all actions - e.g. read , write , etc. And having the resource as rec.* indicates that it will match rec.movie , rec.tvshow and any other resource that we create with the prefix rec. . Choose the Policies tab and click on the Add Policy button:","title":"Full Access"},{"location":"how_to_sample_identity_from_local_athenz/","text":"Overview \u00b6 In this guide, you will be able to create a service in Athenz and obtain a service identity in the form of X.509 certificate from Athenz. Prerequisites \u00b6 Athenz running locally on docker Steps \u00b6 As part of local set up, an example domain by the name \"athenz\" is created and \"athenz-admin\" user is added as a domain administrator of that domain. Please refer to concepts to understand more about domains. To see the workflow of obtaining a service identity certificate from Athenz, please use following steps - Download latest Athenz Utils from Maven Central (click on the Browse button, choose the latest version directory and then download the athenz-utils-$latestVer-bin.tar.gz file) & add it in the current shell PATH variable. Below $athenzUtilsLocation denotes the path where file is downloaded from Maven Central. tar -xf $athenzUtilsLocation /athenz-utils- $latestVer -bin.tar.gz -C $athenzUtilsLocation export PATH = $athenzUtilsLocation /athenz-utils- $latestVer /bin/ ` uname | tr '[:upper:]' '[:lower:]' ` : $PATH Create a public private key pair, register the new service and its public key in Athenz Management Service. Athenz Management Service (ZMS) is running inside a docker container exposed over local port 4443. mkdir -p docker/sample/example-service openssl genrsa -out docker/sample/example-service/athenz.example-service.key.pem 4096 2 > /dev/null openssl rsa -pubout -in docker/sample/example-service/athenz.example-service.key.pem -out docker/sample/example-service/athenz.example-service.pub.pem zms-cli -z https://127.0.0.1:4443/zms/v1 -cert docker/sample/domain-admin/team_admin_cert.pem -key docker/sample/domain-admin/team_admin_key.pem \\ -d athenz add-service example-service v0 docker/sample/example-service/athenz.example-service.pub.pem Now to obtain a service identity certificate, first domain admin needs to authorize a provider. Athenz uses a generalized model for service providers to launch other service identities in an authorized way through a callback-based verification model. For more details please refer to copper argos In this case we will be using Athenz Token Service itself as a provider. In production, it can be any provider like Kubernetes, Openstack, AWS EC2 etc. Domain administrators have a full control over which provider they can authorize to launch their domains' services. Run following command to authorize Athenz Token Service to issue identity certificates for the service created previously zms-cli -z https://127.0.0.1:4443/zms/v1 -cert docker/sample/domain-admin/team_admin_cert.pem -key docker/sample/domain-admin/team_admin_key.pem \\ -d athenz set-domain-template zts_instance_launch_provider service = example-service Wait for few seconds for Athenz Token Service to receive the launch authorization changes from Management Service. Athenz Token Service (ZTS) is running inside a docker container exposed over local port 8443. Use zts-svccert utility to obtain the service identity certificate from Athenz. Athenz also provides agents which can do this for you automatically. zts-svccert -domain athenz -service example-service \\ -private-key docker/sample/example-service/athenz.example-service.key.pem -key-version v0 -zts https://127.0.0.1:8443/zts/v1 \\ -dns-domain zts.athenz.cloud -cert-file docker/sample/example-service/athenz.example-service.cert.pem \\ -cacert docker/sample/CAs/athenz_ca.pem -provider sys.auth.zts -instance instance123 Verify the Common Name ( CN ) in the certificate openssl x509 -in docker/sample/example-service/athenz.example-service.cert.pem -noout -subject","title":"Quick Guide to obtain identity cert using local docker"},{"location":"how_to_sample_identity_from_local_athenz/#overview","text":"In this guide, you will be able to create a service in Athenz and obtain a service identity in the form of X.509 certificate from Athenz.","title":"Overview"},{"location":"how_to_sample_identity_from_local_athenz/#prerequisites","text":"Athenz running locally on docker","title":"Prerequisites"},{"location":"how_to_sample_identity_from_local_athenz/#steps","text":"As part of local set up, an example domain by the name \"athenz\" is created and \"athenz-admin\" user is added as a domain administrator of that domain. Please refer to concepts to understand more about domains. To see the workflow of obtaining a service identity certificate from Athenz, please use following steps - Download latest Athenz Utils from Maven Central (click on the Browse button, choose the latest version directory and then download the athenz-utils-$latestVer-bin.tar.gz file) & add it in the current shell PATH variable. Below $athenzUtilsLocation denotes the path where file is downloaded from Maven Central. tar -xf $athenzUtilsLocation /athenz-utils- $latestVer -bin.tar.gz -C $athenzUtilsLocation export PATH = $athenzUtilsLocation /athenz-utils- $latestVer /bin/ ` uname | tr '[:upper:]' '[:lower:]' ` : $PATH Create a public private key pair, register the new service and its public key in Athenz Management Service. Athenz Management Service (ZMS) is running inside a docker container exposed over local port 4443. mkdir -p docker/sample/example-service openssl genrsa -out docker/sample/example-service/athenz.example-service.key.pem 4096 2 > /dev/null openssl rsa -pubout -in docker/sample/example-service/athenz.example-service.key.pem -out docker/sample/example-service/athenz.example-service.pub.pem zms-cli -z https://127.0.0.1:4443/zms/v1 -cert docker/sample/domain-admin/team_admin_cert.pem -key docker/sample/domain-admin/team_admin_key.pem \\ -d athenz add-service example-service v0 docker/sample/example-service/athenz.example-service.pub.pem Now to obtain a service identity certificate, first domain admin needs to authorize a provider. Athenz uses a generalized model for service providers to launch other service identities in an authorized way through a callback-based verification model. For more details please refer to copper argos In this case we will be using Athenz Token Service itself as a provider. In production, it can be any provider like Kubernetes, Openstack, AWS EC2 etc. Domain administrators have a full control over which provider they can authorize to launch their domains' services. Run following command to authorize Athenz Token Service to issue identity certificates for the service created previously zms-cli -z https://127.0.0.1:4443/zms/v1 -cert docker/sample/domain-admin/team_admin_cert.pem -key docker/sample/domain-admin/team_admin_key.pem \\ -d athenz set-domain-template zts_instance_launch_provider service = example-service Wait for few seconds for Athenz Token Service to receive the launch authorization changes from Management Service. Athenz Token Service (ZTS) is running inside a docker container exposed over local port 8443. Use zts-svccert utility to obtain the service identity certificate from Athenz. Athenz also provides agents which can do this for you automatically. zts-svccert -domain athenz -service example-service \\ -private-key docker/sample/example-service/athenz.example-service.key.pem -key-version v0 -zts https://127.0.0.1:8443/zts/v1 \\ -dns-domain zts.athenz.cloud -cert-file docker/sample/example-service/athenz.example-service.cert.pem \\ -cacert docker/sample/CAs/athenz_ca.pem -provider sys.auth.zts -instance instance123 Verify the Common Name ( CN ) in the certificate openssl x509 -in docker/sample/example-service/athenz.example-service.cert.pem -noout -subject","title":"Steps"},{"location":"how_to_sample_identity_from_local_athenz_ec2/","text":"Overview \u00b6 In this guide, you will be able to create a service in Athenz and obtain a service identity in the form of X.509 certificate from Athenz for an instance running on AWS EC2. Prerequisites \u00b6 Athenz running locally on EC2 in docker Steps \u00b6 As part of local set up, an example domain by the name \"athenz\" is created and \"athenz-admin\" user is added as a domain administrator of that domain. Please refer to concepts to understand more about domains. To see the workflow of obtaining a service identity certificate from Athenz, please use following steps - Login to the ec2-docker instance created Athenz running locally on EC2 in docker cd to the directory where Athenz is checked out from GitHub Download latest Athenz Utils from Maven Central (click on the Browse button, choose the latest version directory and then download the athenz-utils-$latestVer-bin.tar.gz file) & add it in the current shell PATH variable. Below $athenzUtilsLocation denotes the path where file is downloaded from Maven Central. tar -xf $athenzUtilsLocation /athenz-utils- $latestVer -bin.tar.gz -C $athenzUtilsLocation export PATH = $athenzUtilsLocation /athenz-utils- $latestVer /bin/ ` uname | tr '[:upper:]' '[:lower:]' ` : $PATH Create a new service using Athenz management Service client utility. Athenz Management Service (ZMS) is running inside a docker container exposed over local port 4443. We will be using a different EC2 instance to get the identity for the ec2-demo service. zms-cli -z https://127.0.0.1:4443/zms/v1 -cert docker/sample/domain-admin/team_admin_cert.pem \\ -key docker/sample/domain-admin/team_admin_key.pem -c docker/sample/CAs/athenz_ca.pem -d athenz add-service ec2-demo Now to obtain a service identity certificate, first domain admin needs to authorize a provider. Athenz uses a generalized model for service providers to launch other service identities in an authorized way through a callback-based verification model. For more details please refer to copper argos Athenz code comes bundled with AWS EC2 instance provider which verifies instance metadata in the request before issuing identity certificate. Domain administrators have a full control over which provider they can authorize to launch their domains' services. Run following command to authorize the EC2 provider to issue identity certificates for the service created previously zms-cli -z https://127.0.0.1:4443/zms/v1 -cert docker/sample/domain-admin/team_admin_cert.pem -key docker/sample/domain-admin/team_admin_key.pem \\ -c docker/sample/CAs/athenz_ca.pem -d athenz set-domain-template aws_instance_launch_provider service = ec2-demo For verification purposes, we also need to tell Athenz which AWS account is associated with the incoming instance's Athenz domain. Replace the AWS account id you are running this demo, in the command below. This should be done with Athenz system administrator credentials. zms-cli -z https://127.0.0.1:4443/zms/v1 -cert docker/sample/domain-admin/domain_admin_cert.pem -key docker/sample/domain-admin/domain_admin_key.pem \\ -c docker/sample/CAs/athenz_ca.pem -d athenz set-aws-account 111111111111 Create a new role ( e.g ec2-identity-demo ) which will be used as instance profile role for a new EC2 instance for which we will get identity from Athenz. You can re-purpose the policy created for EC2 docker instance for this. Create another role by name \"athenz.ec2-demo\" which is in the form of . where athenz is the name of the domain and ec2-demo is the service. This role wouldnt have any permissions set attached to it, but it will define a trust relationship with the EC2 instance profile role created above, so that EC2 instance profile can assume this role. The trust relationship policy json should look like below. Replace the AWS account id you are running this demo, in the policy json. { \"Version\" : \"2012-10-17\" , \"Statement\" : [ { \"Effect\" : \"Allow\" , \"Principal\" : { \"Service\" : \"ec2.amazonaws.com\" } , \"Action\" : \"sts:AssumeRole\" } , { \"Effect\" : \"Allow\" , \"Principal\" : { \"AWS\" : \"arn:aws:iam::1111111111111:role/ec2-identity-demo\" } , \"Action\" : \"sts:AssumeRole\" } ] } For additional details, refer to AWS EC2 identity set up We will be using Athenz's Service Identity Agent Daemon ( siad ) for EC2 to get the identity. Drop a config file /etc/sia/sia_config which will be used by siad with following content - { \"version\" : \"1.0.0\" , \"service\" : \"aws-demo\" , \"ssh\" : false , \"accounts\" : [ { \"domain\" : \"athenz\" , \"account\" : \"111111111111\" } ] } Athenz ZTS can issue SSH certificates as well, but for now we will not be using that option. Replace the account id in the config above. Make /etc/hosts file entry pointing to the ec2-docker instance Athenz is running on. e.g. 10 .0.0.150 athenz-zts-server Note Make sure this ec2 instance can communicate with ec2-docker instance over port 8443 ( Athenz Token Management Service is listening on port 8443 ) Get the Athenz CA certificate from ec2-docker instance and store it at /opt/athenz/athenz_ca.pem You will be able to find this file on ec2-docker instance at docker/sample/CAs/athenz_ca.pem inside the git check out directory of Athenz. Download siad binary for Linux and copy it to /usr/local/bin Run following command to get the identity certificate sudo /usr/local/bin/siad -cmd post -zts athenz-zts-server -ztscacert /opt/athenz/athenz_ca.pem -ztsawsdomain aws.athenz.cloud SIAD stores the certificate at /var/lib/sia/certs and corresponding private key at /var/lib/sia/keys . Verify the Common Name ( CN ) in the certificate openssl x509 -in /var/lib/sia/certs/athenz.ec2-demo.cert.pem -noout -subject","title":"Quick Guide to obtain identity cert using local docker on EC2"},{"location":"how_to_sample_identity_from_local_athenz_ec2/#overview","text":"In this guide, you will be able to create a service in Athenz and obtain a service identity in the form of X.509 certificate from Athenz for an instance running on AWS EC2.","title":"Overview"},{"location":"how_to_sample_identity_from_local_athenz_ec2/#prerequisites","text":"Athenz running locally on EC2 in docker","title":"Prerequisites"},{"location":"how_to_sample_identity_from_local_athenz_ec2/#steps","text":"As part of local set up, an example domain by the name \"athenz\" is created and \"athenz-admin\" user is added as a domain administrator of that domain. Please refer to concepts to understand more about domains. To see the workflow of obtaining a service identity certificate from Athenz, please use following steps - Login to the ec2-docker instance created Athenz running locally on EC2 in docker cd to the directory where Athenz is checked out from GitHub Download latest Athenz Utils from Maven Central (click on the Browse button, choose the latest version directory and then download the athenz-utils-$latestVer-bin.tar.gz file) & add it in the current shell PATH variable. Below $athenzUtilsLocation denotes the path where file is downloaded from Maven Central. tar -xf $athenzUtilsLocation /athenz-utils- $latestVer -bin.tar.gz -C $athenzUtilsLocation export PATH = $athenzUtilsLocation /athenz-utils- $latestVer /bin/ ` uname | tr '[:upper:]' '[:lower:]' ` : $PATH Create a new service using Athenz management Service client utility. Athenz Management Service (ZMS) is running inside a docker container exposed over local port 4443. We will be using a different EC2 instance to get the identity for the ec2-demo service. zms-cli -z https://127.0.0.1:4443/zms/v1 -cert docker/sample/domain-admin/team_admin_cert.pem \\ -key docker/sample/domain-admin/team_admin_key.pem -c docker/sample/CAs/athenz_ca.pem -d athenz add-service ec2-demo Now to obtain a service identity certificate, first domain admin needs to authorize a provider. Athenz uses a generalized model for service providers to launch other service identities in an authorized way through a callback-based verification model. For more details please refer to copper argos Athenz code comes bundled with AWS EC2 instance provider which verifies instance metadata in the request before issuing identity certificate. Domain administrators have a full control over which provider they can authorize to launch their domains' services. Run following command to authorize the EC2 provider to issue identity certificates for the service created previously zms-cli -z https://127.0.0.1:4443/zms/v1 -cert docker/sample/domain-admin/team_admin_cert.pem -key docker/sample/domain-admin/team_admin_key.pem \\ -c docker/sample/CAs/athenz_ca.pem -d athenz set-domain-template aws_instance_launch_provider service = ec2-demo For verification purposes, we also need to tell Athenz which AWS account is associated with the incoming instance's Athenz domain. Replace the AWS account id you are running this demo, in the command below. This should be done with Athenz system administrator credentials. zms-cli -z https://127.0.0.1:4443/zms/v1 -cert docker/sample/domain-admin/domain_admin_cert.pem -key docker/sample/domain-admin/domain_admin_key.pem \\ -c docker/sample/CAs/athenz_ca.pem -d athenz set-aws-account 111111111111 Create a new role ( e.g ec2-identity-demo ) which will be used as instance profile role for a new EC2 instance for which we will get identity from Athenz. You can re-purpose the policy created for EC2 docker instance for this. Create another role by name \"athenz.ec2-demo\" which is in the form of . where athenz is the name of the domain and ec2-demo is the service. This role wouldnt have any permissions set attached to it, but it will define a trust relationship with the EC2 instance profile role created above, so that EC2 instance profile can assume this role. The trust relationship policy json should look like below. Replace the AWS account id you are running this demo, in the policy json. { \"Version\" : \"2012-10-17\" , \"Statement\" : [ { \"Effect\" : \"Allow\" , \"Principal\" : { \"Service\" : \"ec2.amazonaws.com\" } , \"Action\" : \"sts:AssumeRole\" } , { \"Effect\" : \"Allow\" , \"Principal\" : { \"AWS\" : \"arn:aws:iam::1111111111111:role/ec2-identity-demo\" } , \"Action\" : \"sts:AssumeRole\" } ] } For additional details, refer to AWS EC2 identity set up We will be using Athenz's Service Identity Agent Daemon ( siad ) for EC2 to get the identity. Drop a config file /etc/sia/sia_config which will be used by siad with following content - { \"version\" : \"1.0.0\" , \"service\" : \"aws-demo\" , \"ssh\" : false , \"accounts\" : [ { \"domain\" : \"athenz\" , \"account\" : \"111111111111\" } ] } Athenz ZTS can issue SSH certificates as well, but for now we will not be using that option. Replace the account id in the config above. Make /etc/hosts file entry pointing to the ec2-docker instance Athenz is running on. e.g. 10 .0.0.150 athenz-zts-server Note Make sure this ec2 instance can communicate with ec2-docker instance over port 8443 ( Athenz Token Management Service is listening on port 8443 ) Get the Athenz CA certificate from ec2-docker instance and store it at /opt/athenz/athenz_ca.pem You will be able to find this file on ec2-docker instance at docker/sample/CAs/athenz_ca.pem inside the git check out directory of Athenz. Download siad binary for Linux and copy it to /usr/local/bin Run following command to get the identity certificate sudo /usr/local/bin/siad -cmd post -zts athenz-zts-server -ztscacert /opt/athenz/athenz_ca.pem -ztsawsdomain aws.athenz.cloud SIAD stores the certificate at /var/lib/sia/certs and corresponding private key at /var/lib/sia/keys . Verify the Common Name ( CN ) in the certificate openssl x509 -in /var/lib/sia/certs/athenz.ec2-demo.cert.pem -noout -subject","title":"Steps"},{"location":"local_athenz_on_docker/","text":"Overview \u00b6 In this introduction to Athenz, you will be able to run Athenz on your workstation. Prerequisites \u00b6 Docker Git Make toolset Steps \u00b6 Checkout Athenz from Github git clone https://github.com/AthenZ/athenz.git cd to checked out directory and run following command: cd athenz && ./start-local-athenz.sh This script will - download Athenz components docker images from DockerHub generate self-signed certificates to be used by Athenz components configure Athenz with meaningful defaults suitable for local environment ( for production set up, please refer to \"Production set up\" section of docs.) start local containers corresponding to Athenz components (ZMS, ZMS DB, ZTS, ZTS DB, UI) Note If you are using MacOS, then the script prints out a command at the end, which you can execute to add the generated self-signed certificate to your login keychain so that you can access Athenz UI in the browser without certificate warning. If you don't want to do that, please follow appropriate instructions for your workstation and / or browser so that you can access Athenz UI in the browser. Access the UI at https://localhost . For your convenience local set up uses a TestUserAuthority which accepts any username and password as far as it's a same string. To look at a pre-created \"athenz\" domain during start up, login with \"athenz-admin\" as username and password.","title":"Using Athenz on local docker"},{"location":"local_athenz_on_docker/#overview","text":"In this introduction to Athenz, you will be able to run Athenz on your workstation.","title":"Overview"},{"location":"local_athenz_on_docker/#prerequisites","text":"Docker Git Make toolset","title":"Prerequisites"},{"location":"local_athenz_on_docker/#steps","text":"Checkout Athenz from Github git clone https://github.com/AthenZ/athenz.git cd to checked out directory and run following command: cd athenz && ./start-local-athenz.sh This script will - download Athenz components docker images from DockerHub generate self-signed certificates to be used by Athenz components configure Athenz with meaningful defaults suitable for local environment ( for production set up, please refer to \"Production set up\" section of docs.) start local containers corresponding to Athenz components (ZMS, ZMS DB, ZTS, ZTS DB, UI) Note If you are using MacOS, then the script prints out a command at the end, which you can execute to add the generated self-signed certificate to your login keychain so that you can access Athenz UI in the browser without certificate warning. If you don't want to do that, please follow appropriate instructions for your workstation and / or browser so that you can access Athenz UI in the browser. Access the UI at https://localhost . For your convenience local set up uses a TestUserAuthority which accepts any username and password as far as it's a same string. To look at a pre-created \"athenz\" domain during start up, login with \"athenz-admin\" as username and password.","title":"Steps"},{"location":"local_athenz_on_docker_ec2/","text":"Overview \u00b6 In this introduction to Athenz, you will be able to run Athenz on your EC2 instance in AWS. Prerequisites \u00b6 AWS account with access to make changes to policies, IAM roles etc. Steps \u00b6 Create a new policy with following JSON { \"Version\" : \"2012-10-17\" , \"Statement\" : [ { \"Effect\" : \"Allow\" , \"Action\" : [ \"sts:AssumeRole\" ], \"Resource\" : [ \"arn:aws:iam::*:role/*\" ] }, { \"Effect\" : \"Allow\" , \"Action\" : [ \"logs:CreateLogGroup\" , \"logs:CreateLogStream\" , \"logs:PutLogEvents\" , \"logs:DescribeLogStreams\" , \"logs:DescribeLogGroups\" ], \"Resource\" : [ \"arn:aws:logs:*:*:*\" ] }, { \"Effect\" : \"Allow\" , \"Action\" : [ \"ec2:DescribeTags\" ], \"Resource\" : [ \"*\" ] } ] } Create a new IAM role and associate the above created policy with it. Note Make sure your VPC is set up with an Internet Gateway and necessary NACL, Route Table rules to allow EC2 instances in that VPC to be able to reach internet. Create a new EC2 instance in your VPC with the above created role as instance profile role. We will be using Amazon Linux 2 AMI and t2.2xlarge instance type since we will be running 5 docker containers for the purpose of this demo. SSH to the EC2 instance and run following commands to install git and docker - sudo yum update -y sudo yum install git sudo yum install docker -y sudo usermod -a -G docker ec2-user sudo service docker start Note You might have to log out and log back in for ec2-user's docker group membership to come into effect. Checkout Athenz from Github git clone https://github.com/AthenZ/athenz.git cd to checked out directory and run following command: cd athenz && ./start-local-athenz.sh This script will - download Athenz components docker images from DockerHub generate self-signed certificates to be used by Athenz components configure Athenz with meaningful defaults suitable for local environment ( for production set up, please refer to \"Production set up\" section of docs.) start local containers corresponding to Athenz components (ZMS, ZMS DB, ZTS, ZTS DB, UI)","title":"Local athenz on docker ec2"},{"location":"local_athenz_on_docker_ec2/#overview","text":"In this introduction to Athenz, you will be able to run Athenz on your EC2 instance in AWS.","title":"Overview"},{"location":"local_athenz_on_docker_ec2/#prerequisites","text":"AWS account with access to make changes to policies, IAM roles etc.","title":"Prerequisites"},{"location":"local_athenz_on_docker_ec2/#steps","text":"Create a new policy with following JSON { \"Version\" : \"2012-10-17\" , \"Statement\" : [ { \"Effect\" : \"Allow\" , \"Action\" : [ \"sts:AssumeRole\" ], \"Resource\" : [ \"arn:aws:iam::*:role/*\" ] }, { \"Effect\" : \"Allow\" , \"Action\" : [ \"logs:CreateLogGroup\" , \"logs:CreateLogStream\" , \"logs:PutLogEvents\" , \"logs:DescribeLogStreams\" , \"logs:DescribeLogGroups\" ], \"Resource\" : [ \"arn:aws:logs:*:*:*\" ] }, { \"Effect\" : \"Allow\" , \"Action\" : [ \"ec2:DescribeTags\" ], \"Resource\" : [ \"*\" ] } ] } Create a new IAM role and associate the above created policy with it. Note Make sure your VPC is set up with an Internet Gateway and necessary NACL, Route Table rules to allow EC2 instances in that VPC to be able to reach internet. Create a new EC2 instance in your VPC with the above created role as instance profile role. We will be using Amazon Linux 2 AMI and t2.2xlarge instance type since we will be running 5 docker containers for the purpose of this demo. SSH to the EC2 instance and run following commands to install git and docker - sudo yum update -y sudo yum install git sudo yum install docker -y sudo usermod -a -G docker ec2-user sudo service docker start Note You might have to log out and log back in for ec2-user's docker group membership to come into effect. Checkout Athenz from Github git clone https://github.com/AthenZ/athenz.git cd to checked out directory and run following command: cd athenz && ./start-local-athenz.sh This script will - download Athenz components docker images from DockerHub generate self-signed certificates to be used by Athenz components configure Athenz with meaningful defaults suitable for local environment ( for production set up, please refer to \"Production set up\" section of docs.) start local containers corresponding to Athenz components (ZMS, ZMS DB, ZTS, ZTS DB, UI)","title":"Steps"},{"location":"local_ui_development/","text":"Overview \u00b6 In this guide, you will be able to start a local ZMS server and do local ui development from your favorite IDE. Prerequisites \u00b6 Docker, Make toolchain, Node v14.x, nodemon v2.x Steps \u00b6 Checkout Athenz from GitHub git clone https://github.com/AthenZ/athenz cd into the docker directory cd docker Run following command to download ZMS & ZMS DB docker images, and set it up with meaningful defaults for local development: make prepare-ui-dev-env Note If you are using macOS, then the script prints out a command at the end, which you can execute to add the generated self-signed certificate to your login keychain so that you can access Athenz UI in the browser without certificate warning. If you don't want to do that, please follow appropriate instructions for your workstation and / or browser so that you can access Athenz UI in the browser. Now cd into the ui directory & run npm install to download UI dependencies cd ../ui npm install Once dependencies are downloaded, start the UI server using following sudo nodemon -r dotenv/config app.js Note sudo is required because UI is using privileged port 443. If you don't have nodemon installed, you can install it using npm install nodemon -g Access the UI at https://localhost . For your convenience, local set up uses a TestUserAuthority which accepts any username and password as far as it's a same string. To look at a pre-created \"athenz\" domain during start up, login with \"athenz-admin\" as username and password. Now you can keep the UI instance running in the terminal, make changes to the code using your IDE and UI dev server will reload with your changes. Troubleshooting \u00b6 Clean old artifacts \u00b6 It is possible for build to fail if Athenz was previously built. To clean old artifacts run: ./stop-local-athenz.sh Certificate not trusted error when opening https://localhost \u00b6 When you open https://localhost you might get a certificate error as the self-signed certificate isn't trusted. To fix it, please follow the steps in Accessing UI","title":"Local UI development"},{"location":"local_ui_development/#overview","text":"In this guide, you will be able to start a local ZMS server and do local ui development from your favorite IDE.","title":"Overview"},{"location":"local_ui_development/#prerequisites","text":"Docker, Make toolchain, Node v14.x, nodemon v2.x","title":"Prerequisites"},{"location":"local_ui_development/#steps","text":"Checkout Athenz from GitHub git clone https://github.com/AthenZ/athenz cd into the docker directory cd docker Run following command to download ZMS & ZMS DB docker images, and set it up with meaningful defaults for local development: make prepare-ui-dev-env Note If you are using macOS, then the script prints out a command at the end, which you can execute to add the generated self-signed certificate to your login keychain so that you can access Athenz UI in the browser without certificate warning. If you don't want to do that, please follow appropriate instructions for your workstation and / or browser so that you can access Athenz UI in the browser. Now cd into the ui directory & run npm install to download UI dependencies cd ../ui npm install Once dependencies are downloaded, start the UI server using following sudo nodemon -r dotenv/config app.js Note sudo is required because UI is using privileged port 443. If you don't have nodemon installed, you can install it using npm install nodemon -g Access the UI at https://localhost . For your convenience, local set up uses a TestUserAuthority which accepts any username and password as far as it's a same string. To look at a pre-created \"athenz\" domain during start up, login with \"athenz-admin\" as username and password. Now you can keep the UI instance running in the terminal, make changes to the code using your IDE and UI dev server will reload with your changes.","title":"Steps"},{"location":"local_ui_development/#troubleshooting","text":"","title":"Troubleshooting"},{"location":"local_ui_development/#clean-old-artifacts","text":"It is possible for build to fail if Athenz was previously built. To clean old artifacts run: ./stop-local-athenz.sh","title":"Clean old artifacts"},{"location":"local_ui_development/#certificate-not-trusted-error-when-opening-httpslocalhost","text":"When you open https://localhost you might get a certificate error as the self-signed certificate isn't trusted. To fix it, please follow the steps in Accessing UI","title":"Certificate not trusted error when opening https://localhost"},{"location":"member_expiration/","text":"When adding principals to a role, the domain administrator can specify an optional expiry date for the principal. Athenz also provides the capability to automatically assign an expiry date for any principal for a configured role or all roles if the expiry day is configured at the domain level. There are separate limits for user and service principals. The administrator may decide to configure a limit only for user members but not for service principals to avoid any possible service outages when they fail to review and extend service principals' memberships. Athenz can send email notifications to all principals and the domain administrators when access is about to expire. See the Email Notifications section to enable notifications. Role Level Expiry Support \u00b6 The domain administrator may specify a maximum expiry day setting for a specific role: zms-cli -d <domain-name> set-role-member-expiry-days <role-name> <user-member-expiry-days> zms-cli -d <domain-name> set-role-service-expiry-days <role-name> <service-member-expiry-days> If the domain administrator has specified a user max expiry days of 30 to db_reader_access role, then all user members will automatically have an expiration value of 30 days from the current time. If the domain administrator has specified a value longer than 30 days or no expiry, then it will be reduced to 30 days from the current time. However, if the domain administrator specified expiration of fewer than 30 days (e.g. 7 days), then it will be honored and not extended to 30 days. If the domain administrator specifies a shorter limit on an already configured role, for example reducing from 30 to 15 days, then the server will iterate through all members and reduce the expiration to 15 days from the current time based on the configured limit (either user or service principals depending on the setting being changed). Again, if the current expiry is already less than 15 days, the expiration value will not be changed. However, if the domain administrator extends the configuration setting from 30 to 60 days, then no changes will be made to existing users - they will not be automatically extended. All new members will be enforced with a 60 day expiry period, but old members will continue to have their original 30-day expiration values until those values are extended. If the domain administrator specifies an expiration at both role and domain levels, then the role level always overrides the domain setting for the role - regardless if it's shorter or longer than the domain configured value. You can look at the currently configured value for a specific role using zms-cli -d <domain-name> show-role <role-name> command. Domain Level Expiry Support \u00b6 The domain administrator may specify maximum expiry day setting for the full domain: zms-cli -d <domain-name> set-domain-member-expiry-days <user-member-expiry-days> zms-cli -d <domain-name> set-domain-service-expiry-days <service-member-expiry-days> If the domain administrator has specified a max expiry days of 90 to sports domain, then all members in all roles in that domain will automatically have an expiration value of 30 days from the current time. Check the section above to understand how the server automatically assigns an expiration date to all role members. You can look at the currently configured value for a specific domain using zms-cli -d <domain-name> show-domain command. ** Important ** When setting an expiry days at a domain level, the limit is also imposed on all domain administrators in the admin role. Thus, the domain administrator must be careful to extend their expiry days before they lose access to the domain. Email Notifications \u00b6 Athenz automatically monitors all role members and notifies both principals and domain administrators when access to a role is about to expire and can send email notifications. There are 2 types of email notifications you might get. The email notifications are sent when the expiry is 1, 7, 14, 21, and 28 days away. Role Member Expiration \u00b6 The principal (if human) or the principal's domain administrators (if service) will get a notification when the principal's access in a role is about to expiry. The email notification will include the domain and role name that the principal is a member of. The principal must contact the administrators of that role/domain to request their access to be extended. Domain Administrator Notification \u00b6 The domain administrators will receive a single email notification listing all the members that are about to expire in their domain. It is their responsibility to access their domain in Athenz UI and extend those member's expiration, if necessary. Managing Role Member Expiry Reminder Recipients \u00b6 By default, both the role members and the domain administrators will receive notifications as described above. You can change this behavior by adding a tag to the role: zms-cli -d <domain-name> add-role-tag <role-name> zms.DisableExpirationNotifications <one of the following: 0 - non-disabled, 1 - User disabled, 2 - Admin disabled, 3 - both admin and user disabled For example, to prevent administrators from receiving notifications for the \"write\" role in the domain \"sports\", run the following: zms-cli -d sports add-role-tag write zms.DisableExpirationNotifications 2","title":"Role Member Auto Expiry and Notification Support"},{"location":"member_expiration/#role-level-expiry-support","text":"The domain administrator may specify a maximum expiry day setting for a specific role: zms-cli -d <domain-name> set-role-member-expiry-days <role-name> <user-member-expiry-days> zms-cli -d <domain-name> set-role-service-expiry-days <role-name> <service-member-expiry-days> If the domain administrator has specified a user max expiry days of 30 to db_reader_access role, then all user members will automatically have an expiration value of 30 days from the current time. If the domain administrator has specified a value longer than 30 days or no expiry, then it will be reduced to 30 days from the current time. However, if the domain administrator specified expiration of fewer than 30 days (e.g. 7 days), then it will be honored and not extended to 30 days. If the domain administrator specifies a shorter limit on an already configured role, for example reducing from 30 to 15 days, then the server will iterate through all members and reduce the expiration to 15 days from the current time based on the configured limit (either user or service principals depending on the setting being changed). Again, if the current expiry is already less than 15 days, the expiration value will not be changed. However, if the domain administrator extends the configuration setting from 30 to 60 days, then no changes will be made to existing users - they will not be automatically extended. All new members will be enforced with a 60 day expiry period, but old members will continue to have their original 30-day expiration values until those values are extended. If the domain administrator specifies an expiration at both role and domain levels, then the role level always overrides the domain setting for the role - regardless if it's shorter or longer than the domain configured value. You can look at the currently configured value for a specific role using zms-cli -d <domain-name> show-role <role-name> command.","title":"Role Level Expiry Support"},{"location":"member_expiration/#domain-level-expiry-support","text":"The domain administrator may specify maximum expiry day setting for the full domain: zms-cli -d <domain-name> set-domain-member-expiry-days <user-member-expiry-days> zms-cli -d <domain-name> set-domain-service-expiry-days <service-member-expiry-days> If the domain administrator has specified a max expiry days of 90 to sports domain, then all members in all roles in that domain will automatically have an expiration value of 30 days from the current time. Check the section above to understand how the server automatically assigns an expiration date to all role members. You can look at the currently configured value for a specific domain using zms-cli -d <domain-name> show-domain command. ** Important ** When setting an expiry days at a domain level, the limit is also imposed on all domain administrators in the admin role. Thus, the domain administrator must be careful to extend their expiry days before they lose access to the domain.","title":"Domain Level Expiry Support"},{"location":"member_expiration/#email-notifications","text":"Athenz automatically monitors all role members and notifies both principals and domain administrators when access to a role is about to expire and can send email notifications. There are 2 types of email notifications you might get. The email notifications are sent when the expiry is 1, 7, 14, 21, and 28 days away.","title":"Email Notifications"},{"location":"member_expiration/#role-member-expiration","text":"The principal (if human) or the principal's domain administrators (if service) will get a notification when the principal's access in a role is about to expiry. The email notification will include the domain and role name that the principal is a member of. The principal must contact the administrators of that role/domain to request their access to be extended.","title":"Role Member Expiration"},{"location":"member_expiration/#domain-administrator-notification","text":"The domain administrators will receive a single email notification listing all the members that are about to expire in their domain. It is their responsibility to access their domain in Athenz UI and extend those member's expiration, if necessary.","title":"Domain Administrator Notification"},{"location":"member_expiration/#managing-role-member-expiry-reminder-recipients","text":"By default, both the role members and the domain administrators will receive notifications as described above. You can change this behavior by adding a tag to the role: zms-cli -d <domain-name> add-role-tag <role-name> zms.DisableExpirationNotifications <one of the following: 0 - non-disabled, 1 - User disabled, 2 - Admin disabled, 3 - both admin and user disabled For example, to prevent administrators from receiving notifications for the \"write\" role in the domain \"sports\", run the following: zms-cli -d sports add-role-tag write zms.DisableExpirationNotifications 2","title":"Managing Role Member Expiry Reminder Recipients"},{"location":"member_soft_expiration/","text":"When adding principals to a role, the domain administrator can specify an optional reminder date (aka soft expiry) to review the principal. Athenz also provides the capability to automatically assign a reminder review date for any principal for a configured role. There are separate limits for user and service principals. The administrator may decide to configure a limit only for user members but not for service principals. Athenz can send email notifications to all principals and the domain administrators when the review date is approaching. See the Email Notifications section to enable notifications. Role Level Review Reminder Support \u00b6 The domain administrator may specify a maximum review day setting for a specific role: zms-cli -d <domain-name> set-role-member-review-days <role-name> <user-member-review-days> zms-cli -d <domain-name> set-role-service-review-days <role-name> <service-member-review-days> If the domain administrator has specified a user max review days of 30 to db_reader_access role, then all user members will automatically have a review value of 30 days from the current time. If the domain administrator has specified a value longer than 30 days or no review date, then it will be reduced to 30 days from the current time. However, if the domain administrator specified a review date of fewer than 30 days (e.g. 7 days), then it will be honored and not extended to 30 days. If the domain administrator specifies a shorter limit on an already configured role, for example reducing from 30 to 15 days, then the server will iterate through all members and reduce the review to 15 days from the current time based on the configured limit (either user or service principals depending on the setting being changed). Again, if the current review date is already less than 15 days, the review value will not be changed. However, if the domain administrator extends the configuration setting from 30 to 60 days, then no changes will be made to existing users - they will not be automatically extended. All new members will be enforced with a 60 day review period, but old members will continue to have their original 30-day review values until those values are extended. You can look at the currently configured value for a specific role using zms-cli -d <domain-name> show-role <role-name> command. Email Notifications \u00b6 Athenz automatically monitors all role members and notifies both principals and domain administrators when role membership review is approaching and can send email notifications. There are 2 types of email notifications you might get. The email notifications are sent when the review is 1, 7, 14, 21, and 28 days away. Role Member Review \u00b6 The principal (if human) or the principal's domain administrators (if service) will get a notification when the principal's role membership review date is approaching. The email notification will include the domain and role name that the principal is a member of. The principal must contact the administrators of that role/domain to request their access to be extended. Domain Administrator Notification \u00b6 The domain administrators will receive a single email notification listing all the members with approaching review dates in their domain. It is their responsibility to access their domain in Athenz UI and extend those member's review, if necessary. Role Members with Overdue Review \u00b6 The domain administrator or the paranoids team may review the list of members with overdue review dates: zms-cli overdue-review <domain-name> Managing Soft Expiry Reminder Recipients \u00b6 By default, both the role members and the domain administrators will receive notifications as described above. You can change this behavior by adding a tag to the role: zms-cli -d <domain-name> add-role-tag <role-name> zms.DisableReminderNotifications <one of the following: 0 - non-disabled, 1 - User disabled, 2 - Admin disabled, 3 - both admin and user disabled For example, to prevent administrators from receiving notifications for the \"write\" role in the domain \"sports\", run the following: zms-cli -d sports add-role-tag write zms.DisableReminderNotifications 2","title":"Role Member Review Reminder Support"},{"location":"member_soft_expiration/#role-level-review-reminder-support","text":"The domain administrator may specify a maximum review day setting for a specific role: zms-cli -d <domain-name> set-role-member-review-days <role-name> <user-member-review-days> zms-cli -d <domain-name> set-role-service-review-days <role-name> <service-member-review-days> If the domain administrator has specified a user max review days of 30 to db_reader_access role, then all user members will automatically have a review value of 30 days from the current time. If the domain administrator has specified a value longer than 30 days or no review date, then it will be reduced to 30 days from the current time. However, if the domain administrator specified a review date of fewer than 30 days (e.g. 7 days), then it will be honored and not extended to 30 days. If the domain administrator specifies a shorter limit on an already configured role, for example reducing from 30 to 15 days, then the server will iterate through all members and reduce the review to 15 days from the current time based on the configured limit (either user or service principals depending on the setting being changed). Again, if the current review date is already less than 15 days, the review value will not be changed. However, if the domain administrator extends the configuration setting from 30 to 60 days, then no changes will be made to existing users - they will not be automatically extended. All new members will be enforced with a 60 day review period, but old members will continue to have their original 30-day review values until those values are extended. You can look at the currently configured value for a specific role using zms-cli -d <domain-name> show-role <role-name> command.","title":"Role Level Review Reminder Support"},{"location":"member_soft_expiration/#email-notifications","text":"Athenz automatically monitors all role members and notifies both principals and domain administrators when role membership review is approaching and can send email notifications. There are 2 types of email notifications you might get. The email notifications are sent when the review is 1, 7, 14, 21, and 28 days away.","title":"Email Notifications"},{"location":"member_soft_expiration/#role-member-review","text":"The principal (if human) or the principal's domain administrators (if service) will get a notification when the principal's role membership review date is approaching. The email notification will include the domain and role name that the principal is a member of. The principal must contact the administrators of that role/domain to request their access to be extended.","title":"Role Member Review"},{"location":"member_soft_expiration/#domain-administrator-notification","text":"The domain administrators will receive a single email notification listing all the members with approaching review dates in their domain. It is their responsibility to access their domain in Athenz UI and extend those member's review, if necessary.","title":"Domain Administrator Notification"},{"location":"member_soft_expiration/#role-members-with-overdue-review","text":"The domain administrator or the paranoids team may review the list of members with overdue review dates: zms-cli overdue-review <domain-name>","title":"Role Members with Overdue Review"},{"location":"member_soft_expiration/#managing-soft-expiry-reminder-recipients","text":"By default, both the role members and the domain administrators will receive notifications as described above. You can change this behavior by adding a tag to the role: zms-cli -d <domain-name> add-role-tag <role-name> zms.DisableReminderNotifications <one of the following: 0 - non-disabled, 1 - User disabled, 2 - Admin disabled, 3 - both admin and user disabled For example, to prevent administrators from receiving notifications for the \"write\" role in the domain \"sports\", run the following: zms-cli -d sports add-role-tag write zms.DisableReminderNotifications 2","title":"Managing Soft Expiry Reminder Recipients"},{"location":"oidc_aws_eks/","text":"Athenz OIDC Authentication Provider Support for AWS EKS \u00b6 AWS EKS can be configured to use Athenz as OIDC Authentication Provider to authorize access to configured EKS clusters. Athenz Configuration \u00b6 OIDC Spec requires that each client is uniquely identified within the OIDC Provider and has a redirect URI configuration property set. In the context of Athenz, the EKS cluster administrator first must create a unique service (e.g. athenz.prod.eks : service called eks in the domain athenz.prod ) Once the service is created, it must be registered with its redirect URI. $ zms-cli -d <domain-name> set-service-endpoint <service-name> <redirect-uri> AWS EKS Cluster Configuration \u00b6 In the AWS Console, select EKS service, then choose your cluster from the list. In the cluster view, select the Configuratiion tab and then the Authentication tab. Choose the Associate Identity Provider button. In the dialog box specify the following values (leave others blank): Identity Provider Name: athenz Issuer URL: <athenz-zts-endpoint-uri> e.g. https://zts.athenz.io:8443/zts/v1 Client ID: <athenz-service-name> e.g. athenz.prod.eks Groups claim: groups Username prefix: athenz Groups prefix: athenz AWS EKS Cluster Role Binding \u00b6 Next we need to set up and bind a role with subjects authenticated by the Athenz OIDC Provider. In this example, we'll use the cluster-admin role and allow any user in the athenz.prod domain eks-cluster-admins role to assume the capabilities authorized by the cluster-admin role. Create the following yaml called cluster-group.yaml . It binds an ID token from Athenz provider having the groups claim of eks-cluster-admins to be authorized as cluster admins in EKS. kind : ClusterRoleBinding apiVersion : rbac.authorization.k8s.io/v1 metadata : name : oidc-cluster-admin roleRef : apiGroup : rbac.authorization.k8s.io kind : ClusterRole name : cluster-admin subjects : - kind : Group name : athenz:eks-cluster-admins Use kubectl to apply it to your cluster. $ kubectl apply -f cluster-group.yaml clusterrolebinding.rbac.authorization.k8s.io/oidc-cluster-admin created Checkout the Kubernetes Guide for full details on Role/RoleBinding and ClusterRole/ClusterRoleBinding authorization support in your cluster. Athenz Role Configuration \u00b6 Make sure your Athenz domain associated with your ClientID identified service has the role referenced in the above configuration and the users who should be authorized as cluster administrators are members in that role. Based on our example above: $ zms-cli -o yaml -d athenz.prod show-role eks-cluster-admins name: athenz.prod:role.eks-cluster-admins modified: \"2022-01-21T22:17:59.291Z\" rolemembers: - membername: user.john active: true approved: true OIDC ID Token Support \u00b6 Install the zts-idtoken utility to obtain OIDC ID Tokens from AWS ZTS instance and request an ID token from ZTS. The returned value from the zts-idtoken utility is the id token that we need to submit to AWS EKS. The utility assumes you are using X.509 key/cert to authenticate to the ZTS Server. The issued ID tokens are valid for 1 hour only. $ zts-idtoken -zts <athenz-zts-endpoint-uri> -svc-key-file <service-key> -svc-cert-file <service-cert> -client-id athenz.prod.eks -nonce as324sdfa3 -scope \"openid roles\" -redirect-uri <redirect-uri> eyJraWQiOiJ6dHMuZWMudXM.....td2VzdC0yLjAiLCJhbGciOi We can now use the id token as the value of the --token argument for kubectl to manage our AWS EKS cluster: $ kubectl --token=eyJraWQiOiJ6dHMuZWMudXM.....td2VzdC0yLjAiLCJhbGciOi get pods -n sia NAME READY STATUS RESTARTS AGE sia-agent-cfl4n 1/1 Running 0 35d sia-agent-dwbhn 1/1 Running 0 35d","title":"Athenz OIDC Authentication Provider Support for AWS EKS"},{"location":"oidc_aws_eks/#athenz-oidc-authentication-provider-support-for-aws-eks","text":"AWS EKS can be configured to use Athenz as OIDC Authentication Provider to authorize access to configured EKS clusters.","title":"Athenz OIDC Authentication Provider Support for AWS EKS"},{"location":"oidc_aws_eks/#athenz-configuration","text":"OIDC Spec requires that each client is uniquely identified within the OIDC Provider and has a redirect URI configuration property set. In the context of Athenz, the EKS cluster administrator first must create a unique service (e.g. athenz.prod.eks : service called eks in the domain athenz.prod ) Once the service is created, it must be registered with its redirect URI. $ zms-cli -d <domain-name> set-service-endpoint <service-name> <redirect-uri>","title":"Athenz Configuration"},{"location":"oidc_aws_eks/#aws-eks-cluster-configuration","text":"In the AWS Console, select EKS service, then choose your cluster from the list. In the cluster view, select the Configuratiion tab and then the Authentication tab. Choose the Associate Identity Provider button. In the dialog box specify the following values (leave others blank): Identity Provider Name: athenz Issuer URL: <athenz-zts-endpoint-uri> e.g. https://zts.athenz.io:8443/zts/v1 Client ID: <athenz-service-name> e.g. athenz.prod.eks Groups claim: groups Username prefix: athenz Groups prefix: athenz","title":"AWS EKS Cluster Configuration"},{"location":"oidc_aws_eks/#aws-eks-cluster-role-binding","text":"Next we need to set up and bind a role with subjects authenticated by the Athenz OIDC Provider. In this example, we'll use the cluster-admin role and allow any user in the athenz.prod domain eks-cluster-admins role to assume the capabilities authorized by the cluster-admin role. Create the following yaml called cluster-group.yaml . It binds an ID token from Athenz provider having the groups claim of eks-cluster-admins to be authorized as cluster admins in EKS. kind : ClusterRoleBinding apiVersion : rbac.authorization.k8s.io/v1 metadata : name : oidc-cluster-admin roleRef : apiGroup : rbac.authorization.k8s.io kind : ClusterRole name : cluster-admin subjects : - kind : Group name : athenz:eks-cluster-admins Use kubectl to apply it to your cluster. $ kubectl apply -f cluster-group.yaml clusterrolebinding.rbac.authorization.k8s.io/oidc-cluster-admin created Checkout the Kubernetes Guide for full details on Role/RoleBinding and ClusterRole/ClusterRoleBinding authorization support in your cluster.","title":"AWS EKS Cluster Role Binding"},{"location":"oidc_aws_eks/#athenz-role-configuration","text":"Make sure your Athenz domain associated with your ClientID identified service has the role referenced in the above configuration and the users who should be authorized as cluster administrators are members in that role. Based on our example above: $ zms-cli -o yaml -d athenz.prod show-role eks-cluster-admins name: athenz.prod:role.eks-cluster-admins modified: \"2022-01-21T22:17:59.291Z\" rolemembers: - membername: user.john active: true approved: true","title":"Athenz Role Configuration"},{"location":"oidc_aws_eks/#oidc-id-token-support","text":"Install the zts-idtoken utility to obtain OIDC ID Tokens from AWS ZTS instance and request an ID token from ZTS. The returned value from the zts-idtoken utility is the id token that we need to submit to AWS EKS. The utility assumes you are using X.509 key/cert to authenticate to the ZTS Server. The issued ID tokens are valid for 1 hour only. $ zts-idtoken -zts <athenz-zts-endpoint-uri> -svc-key-file <service-key> -svc-cert-file <service-cert> -client-id athenz.prod.eks -nonce as324sdfa3 -scope \"openid roles\" -redirect-uri <redirect-uri> eyJraWQiOiJ6dHMuZWMudXM.....td2VzdC0yLjAiLCJhbGciOi We can now use the id token as the value of the --token argument for kubectl to manage our AWS EKS cluster: $ kubectl --token=eyJraWQiOiJ6dHMuZWMudXM.....td2VzdC0yLjAiLCJhbGciOi get pods -n sia NAME READY STATUS RESTARTS AGE sia-agent-cfl4n 1/1 Running 0 35d sia-agent-dwbhn 1/1 Running 0 35d","title":"OIDC ID Token Support"},{"location":"principal_authentication/","text":"Principal Authentication \u00b6 Authority Work Configuration Provided Authorities Unix User Authority Principal Authority Kerberos Authority Certificate Authority Role Authority LDAP Authority For a principal (either user or service) to authenticate himself/herself in Athenz, the server must have the appropriate authentication authority implementation configured. Athenz has implementation of several authorities that support variety of authentication methods. The system administrator may decide to configure and use one of the provided authorities or implement a completely new one to satisfy their requirements. Authority Work \u00b6 The job of the Authority is authenticate a specific request and, if valid, generate and return an object representing the authenticated Principal. The Authority interface is defined in the following file: Authority The system administrator can configure a list of authorities for supporting principal authentication. During startup, the server will call the initialize() method for all configured authorities. If the authority requires access to any of the service public keys registered within Athenz, then it needs to implement the AuthorityKeyStore interface as well and provide an implementation of the setKeyStore() method. The server implements the KeyStore interface and will automatically call the setKeyStore() method to pass its implementation to the authority. AuthorityKeyStore When processing a request the server goes through the list of authorities in their configured order and processes until it receives a successful principal object. As soon as a successful response is received from the authenticate method, the server will stop processing other authorities in the list and continue with the authorization check. If no authority returns an authenticated principal, the server returns 401 Unauthenticated response to the calling client. The Authority defines if the authentication details are based on a header or certificate: getCredSource() . If the returned value is HEADER then the Athenz server will retrieve the header, identified by the value returned by the getHeader() method, that the authority is looking for and if a value is present, it will call the authenticate() method to see if the request contains valid credentials or not. The returned principal object contains the Authority object that was used for authentication. This allows the Athenz servers, if necessary, to decide if further checks and/or restrictions are necessary. Configuration \u00b6 Both ZMS and ZTS Servers expect to find the list of authority classes in their respective system properties: ZMS: athenz.zms.authority_classes ZTS: athenz.zts.authority_classes The value of the property must be a comma separated (no spaces) list of authority class names. For example, -Dathenz.zms.authority_classes=com.yahoo.athenz.auth.impl.PrincipalAuthority,com.yahoo.athenz.auth.impl.UserAuthority If you're installing and running Athenz services using the binary packages provided, you can configure the list of authorities in the conf/zms_server/zms.properties or conf/zts_server/zts.properties files for ZMS and ZTS servers respectively: athenz.zms.authority_classes=com.yahoo.athenz.auth.impl.PrincipalAuthority,com.yahoo.athenz.auth.impl.UserAuthority athenz.zts.authority_classes=com.yahoo.athenz.auth.impl.PrincipalAuthority,com.yahoo.athenz.auth.impl.UserAuthority Provided Authorities \u00b6 Here is the list of Athenz provided authorities with brief description of each one. Unix User Authority \u00b6 Class: com.yahoo.athenz.auth.impl.UserAuthority This authority uses the Unix pam login profile to authenticate users. The user that the ZMS process runs as must have read access to the /etc/shadow file. There are two options available: Run the process as root using sudo. This is only recommended for a local development installation. Create a special Unix group that has read access to the /etc/shadow file and set the user that the ZMS process will be running as a member of that group. User Authority is typically not allowed to carry out any authorized operation. It is required that the user first must obtain an X509 certificate for his/her identity and use that certificate to carry out the authorized request. Principal Authority \u00b6 Class: com.yahoo.athenz.auth.impl.PrincipalAuthority This authority uses Athenz generated NTokens. It accepts NTokens, parses to extract the signature and the private key details that were used to sign this token: domain, service, and key id. Then it requests the corresponding public key and verifies the signature. Principal Authority is one of primary authorities in Athenz. It is used to validate NTokens that were issued by ZTS and service tokens generated by SIA Providers. By default, when authenticating an NToken, the authority validates that the IP address in the NToken matches to the IP address of the request. This provides extra security that changes to domain data are not carried out by NTokens that possible have been stolen. Kerberos Authority \u00b6 Class: com.yahoo.athenz.auth.impl.KerberosAuthority This authority supports environments with Kerberos servers. This authority expects to find the Kerberos Ticket in the Authorization header. There are several system properties that must be set for proper initialization of this authority: athenz.auth.kerberos.service_principal - Kerberos service principal athenz.auth.kerberos.keytab_location - Kerberos keytab location athenz.auth.kerberos.jaas_cfg_section - JAAS configuration section. If using a jaas.conf file then that path is specified by the system property java.security.auth.login.config For full details check out the implementation of the Kerberos Authority: Kerberos Authority Certificate Authority \u00b6 Class: com.yahoo.athenz.auth.impl.CertificateAuthority The certificate authority expects that the server has been configured with a truststore that only includes the CA cert that it tasked with issuing principal certificates. The Authority only looks at the CommonName component of the certificate and expects it to include the service name in the {domain}.{service} format. For example: Certificate Subject DN: c=US;o=Some Athenz Company;cn=sports.fantasy The authenticated principal in this case is service fantasy in domain sports . LDAP Authority \u00b6 Class: com.yahoo.athenz.auth.impl.LDAPAuthority Lightweight Directory Access Protocol (LDAP) authority uses the bind operation to authenticate users. The authentication mechanism used is simple where plain text username and passwords are used. The hostname , port number and base DN property of the LDAP server needs to be provided. An example of base dn is: LDAP Server Base DN: dc=example,dc=com","title":"Principal Authentication"},{"location":"principal_authentication/#principal-authentication","text":"Authority Work Configuration Provided Authorities Unix User Authority Principal Authority Kerberos Authority Certificate Authority Role Authority LDAP Authority For a principal (either user or service) to authenticate himself/herself in Athenz, the server must have the appropriate authentication authority implementation configured. Athenz has implementation of several authorities that support variety of authentication methods. The system administrator may decide to configure and use one of the provided authorities or implement a completely new one to satisfy their requirements.","title":"Principal Authentication"},{"location":"principal_authentication/#authority-work","text":"The job of the Authority is authenticate a specific request and, if valid, generate and return an object representing the authenticated Principal. The Authority interface is defined in the following file: Authority The system administrator can configure a list of authorities for supporting principal authentication. During startup, the server will call the initialize() method for all configured authorities. If the authority requires access to any of the service public keys registered within Athenz, then it needs to implement the AuthorityKeyStore interface as well and provide an implementation of the setKeyStore() method. The server implements the KeyStore interface and will automatically call the setKeyStore() method to pass its implementation to the authority. AuthorityKeyStore When processing a request the server goes through the list of authorities in their configured order and processes until it receives a successful principal object. As soon as a successful response is received from the authenticate method, the server will stop processing other authorities in the list and continue with the authorization check. If no authority returns an authenticated principal, the server returns 401 Unauthenticated response to the calling client. The Authority defines if the authentication details are based on a header or certificate: getCredSource() . If the returned value is HEADER then the Athenz server will retrieve the header, identified by the value returned by the getHeader() method, that the authority is looking for and if a value is present, it will call the authenticate() method to see if the request contains valid credentials or not. The returned principal object contains the Authority object that was used for authentication. This allows the Athenz servers, if necessary, to decide if further checks and/or restrictions are necessary.","title":"Authority Work"},{"location":"principal_authentication/#configuration","text":"Both ZMS and ZTS Servers expect to find the list of authority classes in their respective system properties: ZMS: athenz.zms.authority_classes ZTS: athenz.zts.authority_classes The value of the property must be a comma separated (no spaces) list of authority class names. For example, -Dathenz.zms.authority_classes=com.yahoo.athenz.auth.impl.PrincipalAuthority,com.yahoo.athenz.auth.impl.UserAuthority If you're installing and running Athenz services using the binary packages provided, you can configure the list of authorities in the conf/zms_server/zms.properties or conf/zts_server/zts.properties files for ZMS and ZTS servers respectively: athenz.zms.authority_classes=com.yahoo.athenz.auth.impl.PrincipalAuthority,com.yahoo.athenz.auth.impl.UserAuthority athenz.zts.authority_classes=com.yahoo.athenz.auth.impl.PrincipalAuthority,com.yahoo.athenz.auth.impl.UserAuthority","title":"Configuration"},{"location":"principal_authentication/#provided-authorities","text":"Here is the list of Athenz provided authorities with brief description of each one.","title":"Provided Authorities"},{"location":"principal_authentication/#unix-user-authority","text":"Class: com.yahoo.athenz.auth.impl.UserAuthority This authority uses the Unix pam login profile to authenticate users. The user that the ZMS process runs as must have read access to the /etc/shadow file. There are two options available: Run the process as root using sudo. This is only recommended for a local development installation. Create a special Unix group that has read access to the /etc/shadow file and set the user that the ZMS process will be running as a member of that group. User Authority is typically not allowed to carry out any authorized operation. It is required that the user first must obtain an X509 certificate for his/her identity and use that certificate to carry out the authorized request.","title":"Unix User Authority"},{"location":"principal_authentication/#principal-authority","text":"Class: com.yahoo.athenz.auth.impl.PrincipalAuthority This authority uses Athenz generated NTokens. It accepts NTokens, parses to extract the signature and the private key details that were used to sign this token: domain, service, and key id. Then it requests the corresponding public key and verifies the signature. Principal Authority is one of primary authorities in Athenz. It is used to validate NTokens that were issued by ZTS and service tokens generated by SIA Providers. By default, when authenticating an NToken, the authority validates that the IP address in the NToken matches to the IP address of the request. This provides extra security that changes to domain data are not carried out by NTokens that possible have been stolen.","title":"Principal Authority"},{"location":"principal_authentication/#kerberos-authority","text":"Class: com.yahoo.athenz.auth.impl.KerberosAuthority This authority supports environments with Kerberos servers. This authority expects to find the Kerberos Ticket in the Authorization header. There are several system properties that must be set for proper initialization of this authority: athenz.auth.kerberos.service_principal - Kerberos service principal athenz.auth.kerberos.keytab_location - Kerberos keytab location athenz.auth.kerberos.jaas_cfg_section - JAAS configuration section. If using a jaas.conf file then that path is specified by the system property java.security.auth.login.config For full details check out the implementation of the Kerberos Authority: Kerberos Authority","title":"Kerberos Authority"},{"location":"principal_authentication/#certificate-authority","text":"Class: com.yahoo.athenz.auth.impl.CertificateAuthority The certificate authority expects that the server has been configured with a truststore that only includes the CA cert that it tasked with issuing principal certificates. The Authority only looks at the CommonName component of the certificate and expects it to include the service name in the {domain}.{service} format. For example: Certificate Subject DN: c=US;o=Some Athenz Company;cn=sports.fantasy The authenticated principal in this case is service fantasy in domain sports .","title":"Certificate Authority"},{"location":"principal_authentication/#ldap-authority","text":"Class: com.yahoo.athenz.auth.impl.LDAPAuthority Lightweight Directory Access Protocol (LDAP) authority uses the bind operation to authenticate users. The authentication mechanism used is simple where plain text username and passwords are used. The hostname , port number and base DN property of the LDAP server needs to be provided. An example of base dn is: LDAP Server Base DN: dc=example,dc=com","title":"LDAP Authority"},{"location":"principal_groups/","text":"To simplify management of principals in roles, the users and services can be included in Groups. Then, the Group can be added as a principal to any role within Athenz thus granting the members of that group access to the configured resources. For example, if you need to add your development team members to multiple roles in your domain, you can create a group called dev-team , add those users into that group and then include the group as a member in the corresponding roles. When you need to remove or add a member, then you only need to modify the membership of your dev-team group. The groups cannot contain other groups. Resource URI \u00b6 The groups are identified in Athenz with the following resource uri: <domain>:group.<group-name> Group Management \u00b6 The group name can only include alpha numeric characters including - and _. Currently, groups can only be provisioned with zms-cli command line utility: zms-cli -d <domain-name> add-group <group-name> <member> [<member> ...] Once provisioned, they can be added to any role as a regular member. For example, if I need to create a group called dev-team in my sports domain and add it to my readers role in fantasy domain, I would execute the following zms-cli commands: zms-cli -d sports add-group dev-team user.hga user.pgote zms-cli -d fantasy add-member readers sports:group.dev-team Similar to roles api, groups can be managed by adding and removing members: zms-cli -d <domain-name> add-group-member <group-name> <member> [<member> ...] zms-cli -d <domain-name> delete-group-member <group-name> <member> [<member> ...] To enforce the least privilege access principle, there are several restrictions placed on groups: You cannot use wildcards * when adding members to a group. The ZMS Server will verify that all users and services are valid before they can be added to a group. Groups are not allowed to be added to admin groups. We strongly recommend limiting the number of users who are identified as domain administrators. Groups cannot include other groups (no inheritance). However, a role can include multiple groups as a member, and those groups could be from different domains. Groups cannot be references in policies. They can only be added as members of a role. Groups cannot be deleted if they're referenced in other roles. The domain administrator must first remove the group as a member (the role might be in a different domain) before deleting it. Groups do not support temporary members. If you need to give temporary access to a specific principal, that principal with expiration must be added to the role directly. Governance / Audit Support \u00b6 Similar to roles, groups support multiple features to satisfy auditing and governance requirements: Audit Enabled Mode \u00b6 If the domain is marked as audit enabled, then specific groups within that domain can also be set in audit enabled mode thus requiring an explicit approval process for any member addition to that group. zms-cli -d <domain-name> set-group-audit-enabled <group-name> true Unlike a regular group, when any one of the domain administrators adds a user in an audit enabled group, it will be added in pending/inactive state until it is approved by one of the organization approvers configured for the domain. Review Enabled Mode \u00b6 The domain administrator can also mark a group as review enabled thus requiring two domain administrator approvals before a principal is added to a group. zms-cli -d <domain-name> set-group-review-enabled <group-name> true Self Service Mode \u00b6 The users can only add themselves to any self-served groups. Their access is not active until one of the domain administrators approves the request. zms-cli -d <domain-name> set-group-self-serve <group-name> true","title":"Principal Groups"},{"location":"principal_groups/#resource-uri","text":"The groups are identified in Athenz with the following resource uri: <domain>:group.<group-name>","title":"Resource URI"},{"location":"principal_groups/#group-management","text":"The group name can only include alpha numeric characters including - and _. Currently, groups can only be provisioned with zms-cli command line utility: zms-cli -d <domain-name> add-group <group-name> <member> [<member> ...] Once provisioned, they can be added to any role as a regular member. For example, if I need to create a group called dev-team in my sports domain and add it to my readers role in fantasy domain, I would execute the following zms-cli commands: zms-cli -d sports add-group dev-team user.hga user.pgote zms-cli -d fantasy add-member readers sports:group.dev-team Similar to roles api, groups can be managed by adding and removing members: zms-cli -d <domain-name> add-group-member <group-name> <member> [<member> ...] zms-cli -d <domain-name> delete-group-member <group-name> <member> [<member> ...] To enforce the least privilege access principle, there are several restrictions placed on groups: You cannot use wildcards * when adding members to a group. The ZMS Server will verify that all users and services are valid before they can be added to a group. Groups are not allowed to be added to admin groups. We strongly recommend limiting the number of users who are identified as domain administrators. Groups cannot include other groups (no inheritance). However, a role can include multiple groups as a member, and those groups could be from different domains. Groups cannot be references in policies. They can only be added as members of a role. Groups cannot be deleted if they're referenced in other roles. The domain administrator must first remove the group as a member (the role might be in a different domain) before deleting it. Groups do not support temporary members. If you need to give temporary access to a specific principal, that principal with expiration must be added to the role directly.","title":"Group Management"},{"location":"principal_groups/#governance-audit-support","text":"Similar to roles, groups support multiple features to satisfy auditing and governance requirements:","title":"Governance / Audit Support"},{"location":"principal_groups/#audit-enabled-mode","text":"If the domain is marked as audit enabled, then specific groups within that domain can also be set in audit enabled mode thus requiring an explicit approval process for any member addition to that group. zms-cli -d <domain-name> set-group-audit-enabled <group-name> true Unlike a regular group, when any one of the domain administrators adds a user in an audit enabled group, it will be added in pending/inactive state until it is approved by one of the organization approvers configured for the domain.","title":"Audit Enabled Mode"},{"location":"principal_groups/#review-enabled-mode","text":"The domain administrator can also mark a group as review enabled thus requiring two domain administrator approvals before a principal is added to a group. zms-cli -d <domain-name> set-group-review-enabled <group-name> true","title":"Review Enabled Mode"},{"location":"principal_groups/#self-service-mode","text":"The users can only add themselves to any self-served groups. Their access is not active until one of the domain administrators approves the request. zms-cli -d <domain-name> set-group-self-serve <group-name> true","title":"Self Service Mode"},{"location":"private_key_store/","text":"Private Key Store \u00b6 Private Key Store Interfaces Configuration Provided Implementation File Based Private Key Store Athenz servers (both ZMS and ZTS) require a unique private key to sign their respective tokens. There are 2 distinct operations that require the use of signatures: X509 Certificates / Access Token signatures Policy Document signatures The private key could be unique per host (if you have multiple ZMS and/or ZTS servers in your production environment) or per data center location. By default the server ships with a file based private key store which expects to find the private key in PEM format in the configured file. The system administrator may decide to configure and use this implementation or otherwise implement a completely new one to satisfy their requirements (e.g. the private keys are to be stored in some external system rather than a file). Private Key Store Interfaces \u00b6 To provide ZMS/ZTS servers with private keys, the following two interfaces must be implemented: PrivateKeyStoreFactory The job of the PrivateKeyStoreFactory class is to implement a single create() method which returns an instance of PrivateKeyStore class implementation. PrivateKeyStore The job of the PrivateKeyStore class is to return a private key for a given host in a PEM format. The hostname is passed as the first argument to the getPrivateKey() method. Each private key in Athenz is identified by a unique key identifier. This allows each service to have multiple active private/public key pairs to support per host keys with key rotation capability. The getPrivateKey() method is passed a StringBuilder object that the implementation must update and return the corresponding key identifier for the public key returned from this method. During server startup, Athenz servers will load the configured private key store factory class and invoke the create method. Then it will use the PrivateKeyStore object returned to retrieve the private key for the host. If the private key store does not return a PrivateKey (returns null), then the server will continue to run. This is necessary since it's possible that an environment may choose to run only ZMS Servers for centralized authorization thus no need to sign and distribute policy documents and only supports TLS certificates for principal authentication. Configuration \u00b6 Both ZMS and ZTS Servers expect to find the configured private key store factory class names in their respective system properties: ZMS: athenz.zms.private_key_store_factory_class ZTS: athenz.zts.private_key_store_factory_class For example, -Dathenz.zms.private_key_store_factory_class=com.yahoo.athenz.zms.pkey.file.FilePrivateKeyStoreFactory If you're installing and running Athenz services using the binary packages provided, you can configure the private key store factory class in the conf/zms_server/zms.properties or conf/zts_server/zts.properties files for ZMS and ZTS servers respectively: athenz.zms.private_key_store_factory_class=com.yahoo.athenz.auth.impl.FilePrivateKeyStoreFactory athenz.zts.private_key_store_factory_class=com.yahoo.athenz.auth.impl.FilePrivateKeyStoreFactory Provided Implementation \u00b6 Here is the list of Athenz provided private key store implementations with brief description of each one. File Based Private Key Store \u00b6 Class: com.yahoo.athenz.auth.impl.FilePrivateKeyStoreFactory This factory class creates and returns a single private key regardless of the hostname passed to the getPrivateKey() method. The private key file and its corresponding id can be configured by using the following system properties: Key File: athenz.auth.private_key_store.private_key Key-Id: athenz.auth.private_key_store.private_key_id The key file must be a PEM encoded either RSA or EC private key.","title":"Private Key Store"},{"location":"private_key_store/#private-key-store","text":"Private Key Store Interfaces Configuration Provided Implementation File Based Private Key Store Athenz servers (both ZMS and ZTS) require a unique private key to sign their respective tokens. There are 2 distinct operations that require the use of signatures: X509 Certificates / Access Token signatures Policy Document signatures The private key could be unique per host (if you have multiple ZMS and/or ZTS servers in your production environment) or per data center location. By default the server ships with a file based private key store which expects to find the private key in PEM format in the configured file. The system administrator may decide to configure and use this implementation or otherwise implement a completely new one to satisfy their requirements (e.g. the private keys are to be stored in some external system rather than a file).","title":"Private Key Store"},{"location":"private_key_store/#private-key-store-interfaces","text":"To provide ZMS/ZTS servers with private keys, the following two interfaces must be implemented: PrivateKeyStoreFactory The job of the PrivateKeyStoreFactory class is to implement a single create() method which returns an instance of PrivateKeyStore class implementation. PrivateKeyStore The job of the PrivateKeyStore class is to return a private key for a given host in a PEM format. The hostname is passed as the first argument to the getPrivateKey() method. Each private key in Athenz is identified by a unique key identifier. This allows each service to have multiple active private/public key pairs to support per host keys with key rotation capability. The getPrivateKey() method is passed a StringBuilder object that the implementation must update and return the corresponding key identifier for the public key returned from this method. During server startup, Athenz servers will load the configured private key store factory class and invoke the create method. Then it will use the PrivateKeyStore object returned to retrieve the private key for the host. If the private key store does not return a PrivateKey (returns null), then the server will continue to run. This is necessary since it's possible that an environment may choose to run only ZMS Servers for centralized authorization thus no need to sign and distribute policy documents and only supports TLS certificates for principal authentication.","title":"Private Key Store Interfaces"},{"location":"private_key_store/#configuration","text":"Both ZMS and ZTS Servers expect to find the configured private key store factory class names in their respective system properties: ZMS: athenz.zms.private_key_store_factory_class ZTS: athenz.zts.private_key_store_factory_class For example, -Dathenz.zms.private_key_store_factory_class=com.yahoo.athenz.zms.pkey.file.FilePrivateKeyStoreFactory If you're installing and running Athenz services using the binary packages provided, you can configure the private key store factory class in the conf/zms_server/zms.properties or conf/zts_server/zts.properties files for ZMS and ZTS servers respectively: athenz.zms.private_key_store_factory_class=com.yahoo.athenz.auth.impl.FilePrivateKeyStoreFactory athenz.zts.private_key_store_factory_class=com.yahoo.athenz.auth.impl.FilePrivateKeyStoreFactory","title":"Configuration"},{"location":"private_key_store/#provided-implementation","text":"Here is the list of Athenz provided private key store implementations with brief description of each one.","title":"Provided Implementation"},{"location":"private_key_store/#file-based-private-key-store","text":"Class: com.yahoo.athenz.auth.impl.FilePrivateKeyStoreFactory This factory class creates and returns a single private key regardless of the hostname passed to the getPrivateKey() method. The private key file and its corresponding id can be configured by using the following system properties: Key File: athenz.auth.private_key_store.private_key Key-Id: athenz.auth.private_key_store.private_key_id The key file must be a PEM encoded either RSA or EC private key.","title":"File Based Private Key Store"},{"location":"provider_github_actions/","text":"Service Identity Provider for GitHub Actions \u00b6 The document describes support for issuing Athenz Identity x.509 certificates to workloads launched with GitHub Actions. Request Attestation Data \u00b6 The attestation data for the x.509 certificate identity registration request would be the OIDC token that a workflow can obtain from GitHub. The OIDC token must be requested for ZTS audience (e.g. https://zts.athenz.io:4443/zts/v1 ) so that if compromised the token cannot be used for any other operation in the GitHub repository. To obtain OIDC token within GitHub actions: OIDC_TOKEN=$(curl -sLS \"${ACTIONS_ID_TOKEN_REQUEST_URL}&audience=https://zts.athenz.io:4443/zts/v1\" -H \"User-Agent: actions/oidc-client\" -H \"Authorization: Bearer $ACTIONS_ID_TOKEN_REQUEST_TOKEN\") OIDC_JWT=$(echo $OIDC_TOKEN | jq -j '.value') Here is a sample payload of an OID Token: { \"jti\" : \"15a2c4d7-f60e-460d-b034-dbd49e757a0a\" , \"sub\" : \"repo:AthenZ/athenz:ref:refs/heads/main\" , \"aud\" : \"https:/zts.athenz.io:4443/zts/v1\" , \"ref\" : \"refs/heads/main\" , \"sha\" : \"40a1653d3e20c5e70421a0493038ac4029834257\" , \"repository\" : \"AthenZ/athenz\" , \"repository_owner\" : \"athenz\" , \"repository_owner_id\" : \"34124938490324394\" , \"run_id\" : \"774951243124123438620\" , \"run_number\" : \"8\" , \"run_attempt\" : \"1\" , \"repository_visibility\" : \"internal\" , \"repository_id\" : \"134123432143214\" , \"actor_id\" : \"1467933413241234324312836\" , \"actor\" : \"athenz\" , \"workflow\" : \"GitHub Actions Demo\" , \"head_ref\" : \"\" , \"base_ref\" : \"\" , \"event_name\" : \"push\" , \"ref_protected\" : \"false\" , \"ref_type\" : \"branch\" , \"workflow_ref\" : \"AthenZ/athenz/.github/workflows/github-actions-demo.yml@refs/heads/main\" , \"workflow_sha\" : \"40a1653d3e20c5e70421a0493038ac4029834257\" , \"job_workflow_ref\" : \"AthenZ/athenz/.github/workflows/github-actions-demo.yml@refs/heads/main\" , \"job_workflow_sha\" : \"40a1653d3e20c5e70421a0493038ac4029834257\" , \"runner_environment\" : \"github-hosted\" , \"enterprise_id\" : \"134345756456453645\" , \"enterprise\" : \"athenz\" , \"iss\" : \"https://token.actions.githubusercontent.com\" , \"nbf\" : 1706833037 , \"exp\" : 1706833937 , \"iat\" : 1706833637 } Sequence Diagram For Obtaining Identity Certificates \u00b6 Athenz Identities For GitHub Action \u00b6 The requirement for the provider is to issue a unique Athenz identity for a given repo/branch. Since the names of the GitHub organization/repository components are much more extensive than what Athenz supports and GitHub Actions supports a variety of events that trigger workflows (e.g. push on a tag, release, deployment, etc.), we cannot automatically generate dynamic service names based on those components. Instead, the domain administrator will register a service for any GitHub action they desire in their own domain. This will give them the flexibility to create as many unique service identities they require for each repo/branch/event, or they can just create two (one main and one pr) if they choose using wildcards in actions/resources which match perfectly to event names and subjects in OIDC tokens. To configure a service to be launched by a GitHub Action, the corresponding roles and policies will need to be created in the tenant\u2019s domain. For example, news.prod domain administrator wants to deploy a service called api for its main branch and api-pr for workflows deployed in GitHub Actions. The policy will include the full repo path that is returned in the sub claim in the token and is in the following format for push and pull_requests events: event_name : push subject : repo :< org - name >/< repo - name >: ref : refs /heads/ < branch > \" event_name: pull_request subject: repo:<org-name>/<repo-name>:pull_request\" In the corresponding Athenz policy the following values will be represented as follows: action : github .< event_name > resource : < subject > Domain Name: news.prod Service Name: api Role Name: github.actions.api Member: news.prod.api Service Name: api-pr Role Name: github.actions.api-pr Member: news.prod.api-pr Policy Name: github.actions Assertions: grant github.push to github.actions.api on news.prod:repo:yahoo-news/api:ref:refs/heads/main grant github.pull_request to github.actions.api-pr on news.prod:repo:yahoo-news/api:pull_request To simplify the setup process, the domain administrator should provide a GitHub-Actions template where the user will just need to provide the service name, event_type and resource values to automatically create the necessary services, roles and policies. Service Identity GitHub Actions Provider \u00b6 The provider will be implemented as an in-service class based provider. The provider will run as part of the ZTS Service deployment. No changes are required for the current deployment model. Register Instance \u00b6 The provider will carry out the following checks during the instance registration process: Obtain the public keys from GitHub to validate the OIDC token. It will cache the keys to avoid unnecessary calls. It will also limit the frequency of how often it will connect to GitHub to fetch the public keys. For example, if it receives a token with a key id that is not in its cache, it will attempt to update the local cache by contacting GitHub. However, if the key id is not found and another request is received with the same key id, it will not attempt to fetch a fresh set of keys from GitHub until the configured timeout has passed. Validate the signature of the OIDC token and parse the claims. As part of this validation, the library verifies that the token is not expired. Validate the following claims from the token: Audience (aud) - must be our configured server e.g. https://zts.athenz.io:4443/zts/v1 Enterprise (enterprise) - matches the configured enterprise value. If the enterprise value is not configured this check is skipped Issue Time (iat) - the timestamp must be within the configured number of minutes (default 5 mins). Issuer (iss) - matches the configured GitHub issuer Run ID (run_id) - identifies the instance id for the certificate request by including with the organization and repository names in the following format: : : Extract the following two attributes for the authorization check: Subject (sub) - subject for the event Event Name (event_name) - name of the event Carry out an authorization check with action \u201cGitHub. \u201d and the resource \u201c : \u201d The identity will be issued for the min(requested number of minutes, max expiry) where max expiry will have a default configuration value of 6 hours. (That is the max time for a GitHub actions job). Refresh Instance \u00b6 The provider does not support refreshing identity x.509 certificates. Each job will register and use its credentials every time it runs. SSH Host Certificates \u00b6 The provider does not support ssh host certificates. Service Identity Agent for GitHub Actions \u00b6 A new sia agent is implemented for the GitHub actions. It output the necessary action/resource to be used when creating assertions in a policy for the given workflow before obtaining the identity service for the given job. This would allow the user to run the tool the first time to get the subject/event_name and possibly other details that are included in the OIDC token without running any curl commands directly. ZMS Server Configuration Changes \u00b6 The following changes are necessary for the ZMS server to support GitHub Actions provider: Register sys.auth.github-actions as a service with the class provider url pointing to the implementation of the GitHub actions provider class. Add the provider identity (e.g. sys.auth.github-actions) to the providers role in the sys.auth domain to be authorized as an official provider. Create a role called provider.sys.auth.github-actions that includes sys.auth.github-actions as a member and create a policy that allows launch action to that role on the resource dns.<dns-domain-suffix> . This allows adding sanDNS values in the certificate in the format <service-name>.<domain-name>.<dns-domain-suffix> ZTS Server Configuration Changes \u00b6 The following changes are necessary for the ZTS server to support GitHub Actions provider: ZTS enforces IP ranges where services are authorized to request identities for service identities from a given provider. It is expected that the worker nodes for a team will be configured to run in their own private AWS accounts, for example, and as such the team needs to provide the NAT gateway IP addresses for the account, so they can be authorized.","title":"Service Identity Provider for GitHub Actions"},{"location":"provider_github_actions/#service-identity-provider-for-github-actions","text":"The document describes support for issuing Athenz Identity x.509 certificates to workloads launched with GitHub Actions.","title":"Service Identity Provider for GitHub Actions"},{"location":"provider_github_actions/#request-attestation-data","text":"The attestation data for the x.509 certificate identity registration request would be the OIDC token that a workflow can obtain from GitHub. The OIDC token must be requested for ZTS audience (e.g. https://zts.athenz.io:4443/zts/v1 ) so that if compromised the token cannot be used for any other operation in the GitHub repository. To obtain OIDC token within GitHub actions: OIDC_TOKEN=$(curl -sLS \"${ACTIONS_ID_TOKEN_REQUEST_URL}&audience=https://zts.athenz.io:4443/zts/v1\" -H \"User-Agent: actions/oidc-client\" -H \"Authorization: Bearer $ACTIONS_ID_TOKEN_REQUEST_TOKEN\") OIDC_JWT=$(echo $OIDC_TOKEN | jq -j '.value') Here is a sample payload of an OID Token: { \"jti\" : \"15a2c4d7-f60e-460d-b034-dbd49e757a0a\" , \"sub\" : \"repo:AthenZ/athenz:ref:refs/heads/main\" , \"aud\" : \"https:/zts.athenz.io:4443/zts/v1\" , \"ref\" : \"refs/heads/main\" , \"sha\" : \"40a1653d3e20c5e70421a0493038ac4029834257\" , \"repository\" : \"AthenZ/athenz\" , \"repository_owner\" : \"athenz\" , \"repository_owner_id\" : \"34124938490324394\" , \"run_id\" : \"774951243124123438620\" , \"run_number\" : \"8\" , \"run_attempt\" : \"1\" , \"repository_visibility\" : \"internal\" , \"repository_id\" : \"134123432143214\" , \"actor_id\" : \"1467933413241234324312836\" , \"actor\" : \"athenz\" , \"workflow\" : \"GitHub Actions Demo\" , \"head_ref\" : \"\" , \"base_ref\" : \"\" , \"event_name\" : \"push\" , \"ref_protected\" : \"false\" , \"ref_type\" : \"branch\" , \"workflow_ref\" : \"AthenZ/athenz/.github/workflows/github-actions-demo.yml@refs/heads/main\" , \"workflow_sha\" : \"40a1653d3e20c5e70421a0493038ac4029834257\" , \"job_workflow_ref\" : \"AthenZ/athenz/.github/workflows/github-actions-demo.yml@refs/heads/main\" , \"job_workflow_sha\" : \"40a1653d3e20c5e70421a0493038ac4029834257\" , \"runner_environment\" : \"github-hosted\" , \"enterprise_id\" : \"134345756456453645\" , \"enterprise\" : \"athenz\" , \"iss\" : \"https://token.actions.githubusercontent.com\" , \"nbf\" : 1706833037 , \"exp\" : 1706833937 , \"iat\" : 1706833637 }","title":"Request Attestation Data"},{"location":"provider_github_actions/#sequence-diagram-for-obtaining-identity-certificates","text":"","title":"Sequence Diagram For Obtaining Identity Certificates"},{"location":"provider_github_actions/#athenz-identities-for-github-action","text":"The requirement for the provider is to issue a unique Athenz identity for a given repo/branch. Since the names of the GitHub organization/repository components are much more extensive than what Athenz supports and GitHub Actions supports a variety of events that trigger workflows (e.g. push on a tag, release, deployment, etc.), we cannot automatically generate dynamic service names based on those components. Instead, the domain administrator will register a service for any GitHub action they desire in their own domain. This will give them the flexibility to create as many unique service identities they require for each repo/branch/event, or they can just create two (one main and one pr) if they choose using wildcards in actions/resources which match perfectly to event names and subjects in OIDC tokens. To configure a service to be launched by a GitHub Action, the corresponding roles and policies will need to be created in the tenant\u2019s domain. For example, news.prod domain administrator wants to deploy a service called api for its main branch and api-pr for workflows deployed in GitHub Actions. The policy will include the full repo path that is returned in the sub claim in the token and is in the following format for push and pull_requests events: event_name : push subject : repo :< org - name >/< repo - name >: ref : refs /heads/ < branch > \" event_name: pull_request subject: repo:<org-name>/<repo-name>:pull_request\" In the corresponding Athenz policy the following values will be represented as follows: action : github .< event_name > resource : < subject > Domain Name: news.prod Service Name: api Role Name: github.actions.api Member: news.prod.api Service Name: api-pr Role Name: github.actions.api-pr Member: news.prod.api-pr Policy Name: github.actions Assertions: grant github.push to github.actions.api on news.prod:repo:yahoo-news/api:ref:refs/heads/main grant github.pull_request to github.actions.api-pr on news.prod:repo:yahoo-news/api:pull_request To simplify the setup process, the domain administrator should provide a GitHub-Actions template where the user will just need to provide the service name, event_type and resource values to automatically create the necessary services, roles and policies.","title":"Athenz Identities For GitHub Action"},{"location":"provider_github_actions/#service-identity-github-actions-provider","text":"The provider will be implemented as an in-service class based provider. The provider will run as part of the ZTS Service deployment. No changes are required for the current deployment model.","title":"Service Identity GitHub Actions Provider"},{"location":"provider_github_actions/#register-instance","text":"The provider will carry out the following checks during the instance registration process: Obtain the public keys from GitHub to validate the OIDC token. It will cache the keys to avoid unnecessary calls. It will also limit the frequency of how often it will connect to GitHub to fetch the public keys. For example, if it receives a token with a key id that is not in its cache, it will attempt to update the local cache by contacting GitHub. However, if the key id is not found and another request is received with the same key id, it will not attempt to fetch a fresh set of keys from GitHub until the configured timeout has passed. Validate the signature of the OIDC token and parse the claims. As part of this validation, the library verifies that the token is not expired. Validate the following claims from the token: Audience (aud) - must be our configured server e.g. https://zts.athenz.io:4443/zts/v1 Enterprise (enterprise) - matches the configured enterprise value. If the enterprise value is not configured this check is skipped Issue Time (iat) - the timestamp must be within the configured number of minutes (default 5 mins). Issuer (iss) - matches the configured GitHub issuer Run ID (run_id) - identifies the instance id for the certificate request by including with the organization and repository names in the following format: : : Extract the following two attributes for the authorization check: Subject (sub) - subject for the event Event Name (event_name) - name of the event Carry out an authorization check with action \u201cGitHub. \u201d and the resource \u201c : \u201d The identity will be issued for the min(requested number of minutes, max expiry) where max expiry will have a default configuration value of 6 hours. (That is the max time for a GitHub actions job).","title":"Register Instance"},{"location":"provider_github_actions/#refresh-instance","text":"The provider does not support refreshing identity x.509 certificates. Each job will register and use its credentials every time it runs.","title":"Refresh Instance"},{"location":"provider_github_actions/#ssh-host-certificates","text":"The provider does not support ssh host certificates.","title":"SSH Host Certificates"},{"location":"provider_github_actions/#service-identity-agent-for-github-actions","text":"A new sia agent is implemented for the GitHub actions. It output the necessary action/resource to be used when creating assertions in a policy for the given workflow before obtaining the identity service for the given job. This would allow the user to run the tool the first time to get the subject/event_name and possibly other details that are included in the OIDC token without running any curl commands directly.","title":"Service Identity Agent for GitHub Actions"},{"location":"provider_github_actions/#zms-server-configuration-changes","text":"The following changes are necessary for the ZMS server to support GitHub Actions provider: Register sys.auth.github-actions as a service with the class provider url pointing to the implementation of the GitHub actions provider class. Add the provider identity (e.g. sys.auth.github-actions) to the providers role in the sys.auth domain to be authorized as an official provider. Create a role called provider.sys.auth.github-actions that includes sys.auth.github-actions as a member and create a policy that allows launch action to that role on the resource dns.<dns-domain-suffix> . This allows adding sanDNS values in the certificate in the format <service-name>.<domain-name>.<dns-domain-suffix>","title":"ZMS Server Configuration Changes"},{"location":"provider_github_actions/#zts-server-configuration-changes","text":"The following changes are necessary for the ZTS server to support GitHub Actions provider: ZTS enforces IP ranges where services are authorized to request identities for service identities from a given provider. It is expected that the worker nodes for a team will be configured to run in their own private AWS accounts, for example, and as such the team needs to provide the NAT gateway IP addresses for the account, so they can be authorized.","title":"ZTS Server Configuration Changes"},{"location":"reg_service_guide/","text":"Once a domain has been registered in Athenz, the administrator will register service identities that are specified in domain roles and policy assertions. The latter can reference those roles having access to specified resources. Athenz supports service authentication with two types of credentials: X.509 Certificates (preferred approach) Instructions Public/Private Key Pairs Before you can register the service identity, you'll need to generate keys. In this section we'll cover how to create the keys and register the service identity. Key Generation \u00b6 The registration process requires the domain administrator to generate a private/public RSA key pair (must be at least 2048 bit) for the service. The following are the keys and the services that use those keys: private key - The SIA server/utility uses the private key to generate a ServiceToken identifying the service. public key - ZMS/ZTS then use the public key to validate the ServiceToken generated by SIA. The openssl command-line utility is used to generate the key pair: $ umask 077 $ openssl genrsa -out service_private.key 2048 $ openssl rsa -in service_private.key -pubout > service_public.key If using the zms-cli client utility to register the service identity, the public key file must have an extension of .pem or .key. Private Keys \u00b6 The private key file must be installed on all hosts where the service will be running. The reason the use of X.509 Certificates is the preferred approach is because to securely install the private key on all hosts presents a challenge. Each key pair has a key identifier that will be included in the generated ServiceTokens as the value of the k component. If the service\u2019s private key has been compromised or the service has a policy to periodically rotate the keys, the service administrator will generate a new key pair, remove the public key with the old identifier, and register a new public key with a different key identifier. Typically, a service would start with \"0\" as its first identifier and increment when required. Key Rotation \u00b6 If the service\u2019s private key has been compromised or the service has a policy to periodically rotate the keys, the service administrator will generate a new key pair, remove the public key with identifier 0 and register a new public key with a different key identifier. As mentioned above, the key identifier is included in generated Service Tokens as the value of the k component. See the instructions below how to add and delete public keys for a service. Service Identity Registration \u00b6 To register a new service identity, select your domain in Athenz UI and choose the Services tab. Select Add Service link on the left side of the screen underneath the Roles/Services/Policies tabs. Enter the Service name, and optional description, the public key ID, and the actual public key contents in pem format: Add new public key \u00b6 Once the services view is displayed, Select the Public Keys icon on the same line as the service to see all the registered public key. Once that view is open, click on the Add Key link on the right hand side. Enter the Key Id and the Key Value which must be a PEM encoded public key. Click Submit to complete your update. Delete an existing public key \u00b6 Once the services view is displayed, Select the Public Keys icon on the same line as the service to see all the registered public key. Once that view is open, click on the Delete trash can icon on the right hand side of the public key.","title":"Using Public/Private Key Pairs"},{"location":"reg_service_guide/#key-generation","text":"The registration process requires the domain administrator to generate a private/public RSA key pair (must be at least 2048 bit) for the service. The following are the keys and the services that use those keys: private key - The SIA server/utility uses the private key to generate a ServiceToken identifying the service. public key - ZMS/ZTS then use the public key to validate the ServiceToken generated by SIA. The openssl command-line utility is used to generate the key pair: $ umask 077 $ openssl genrsa -out service_private.key 2048 $ openssl rsa -in service_private.key -pubout > service_public.key If using the zms-cli client utility to register the service identity, the public key file must have an extension of .pem or .key.","title":"Key Generation"},{"location":"reg_service_guide/#private-keys","text":"The private key file must be installed on all hosts where the service will be running. The reason the use of X.509 Certificates is the preferred approach is because to securely install the private key on all hosts presents a challenge. Each key pair has a key identifier that will be included in the generated ServiceTokens as the value of the k component. If the service\u2019s private key has been compromised or the service has a policy to periodically rotate the keys, the service administrator will generate a new key pair, remove the public key with the old identifier, and register a new public key with a different key identifier. Typically, a service would start with \"0\" as its first identifier and increment when required.","title":"Private Keys"},{"location":"reg_service_guide/#key-rotation","text":"If the service\u2019s private key has been compromised or the service has a policy to periodically rotate the keys, the service administrator will generate a new key pair, remove the public key with identifier 0 and register a new public key with a different key identifier. As mentioned above, the key identifier is included in generated Service Tokens as the value of the k component. See the instructions below how to add and delete public keys for a service.","title":"Key Rotation"},{"location":"reg_service_guide/#service-identity-registration","text":"To register a new service identity, select your domain in Athenz UI and choose the Services tab. Select Add Service link on the left side of the screen underneath the Roles/Services/Policies tabs. Enter the Service name, and optional description, the public key ID, and the actual public key contents in pem format:","title":"Service Identity Registration"},{"location":"reg_service_guide/#add-new-public-key","text":"Once the services view is displayed, Select the Public Keys icon on the same line as the service to see all the registered public key. Once that view is open, click on the Add Key link on the right hand side. Enter the Key Id and the Key Value which must be a PEM encoded public key. Click Submit to complete your update.","title":"Add new public key"},{"location":"reg_service_guide/#delete-an-existing-public-key","text":"Once the services view is displayed, Select the Public Keys icon on the same line as the service to see all the registered public key. Once that view is open, click on the Delete trash can icon on the right hand side of the public key.","title":"Delete an existing public key"},{"location":"review_enabled_roles/","text":"Athenz now supports configuring roles in domains as review-enabled thus requiring two domain administrator approvals before a principal is added to a role. Role Setup \u00b6 To designate a role as review-enabled, the domain administrator may use either Athenz UI or zms-cli utility. To use Athenz UI, the domain administrator will login to their domain role view and choose the Review Enabled slider for the appropriate role. For example, in the following case, the db_reader_access role is configured as review-served. zms-cli -d <domain-name> set-role-review-enabled <role-name> true The show-role command will display the review attribute if it's enabled for a role: $ zms-cli -d home.johndoe set-role-review-enabled read-access true [domain home.johndoe role read-access review-enabled attribute successfully updated] $ zms-cli -d home.johndoe show-role read-access role: - name: read-access review_enabled: true members: - user.janedoe Adding Users to Review Enabled Roles \u00b6 Unlike a regular role, when any one of the domain administrators adds a user in a review enabled role, it will be added in pending/inactive state until it is approved by one of the other domain administrators. For example, in this use case, the domain administrator would like to add user.bob principal to the db_reader_access role which is configured as review enabled. When the domain administrator adds the principal id to the role, it will be added in the Pending Approval column. It will be in pending state until one of the other domain administrators reviews and either approves or rejects the request. Domain Administrator Approval \u00b6 Once the pending request is processed, all domain administrators will receive an email notification stating that user.pgote would like to be added to the db_reader_access role and they need to either approve or reject the request. The email will include a link to the Athenz UI workflow page which can also be accessed by clicking on the notifications icon in the Athenz UI toolbar: Once in the approval view page, the domain administrator may either approve or reject the request. The domain administrator will need to provide a justification in the Audit Reference field and optionally specify an expiration date (even if the user didn't request one). Once approved, the principal will become an active/approved member of the role. If rejected, the principal's name will be removed from the Pending Approval column. ** Important ** The domain administrator that submitted the original request is not authorized to approve his/her own request. It must be approved by another domain administrator. This requires that the domain must have at least 2 administrators. Deleting Users from Review Enabled Roles \u00b6 Additional domain administrator approver workflow only applies to adding users in review enabled roles. The domain administrators have the authorization to remove any principal from a review enabled role without further approval process.","title":"Review Enabled Roles"},{"location":"review_enabled_roles/#role-setup","text":"To designate a role as review-enabled, the domain administrator may use either Athenz UI or zms-cli utility. To use Athenz UI, the domain administrator will login to their domain role view and choose the Review Enabled slider for the appropriate role. For example, in the following case, the db_reader_access role is configured as review-served. zms-cli -d <domain-name> set-role-review-enabled <role-name> true The show-role command will display the review attribute if it's enabled for a role: $ zms-cli -d home.johndoe set-role-review-enabled read-access true [domain home.johndoe role read-access review-enabled attribute successfully updated] $ zms-cli -d home.johndoe show-role read-access role: - name: read-access review_enabled: true members: - user.janedoe","title":"Role Setup"},{"location":"review_enabled_roles/#adding-users-to-review-enabled-roles","text":"Unlike a regular role, when any one of the domain administrators adds a user in a review enabled role, it will be added in pending/inactive state until it is approved by one of the other domain administrators. For example, in this use case, the domain administrator would like to add user.bob principal to the db_reader_access role which is configured as review enabled. When the domain administrator adds the principal id to the role, it will be added in the Pending Approval column. It will be in pending state until one of the other domain administrators reviews and either approves or rejects the request.","title":"Adding Users to Review Enabled Roles"},{"location":"review_enabled_roles/#domain-administrator-approval","text":"Once the pending request is processed, all domain administrators will receive an email notification stating that user.pgote would like to be added to the db_reader_access role and they need to either approve or reject the request. The email will include a link to the Athenz UI workflow page which can also be accessed by clicking on the notifications icon in the Athenz UI toolbar: Once in the approval view page, the domain administrator may either approve or reject the request. The domain administrator will need to provide a justification in the Audit Reference field and optionally specify an expiration date (even if the user didn't request one). Once approved, the principal will become an active/approved member of the role. If rejected, the principal's name will be removed from the Pending Approval column. ** Important ** The domain administrator that submitted the original request is not authorized to approve his/her own request. It must be approved by another domain administrator. This requires that the domain must have at least 2 administrators.","title":"Domain Administrator Approval"},{"location":"review_enabled_roles/#deleting-users-from-review-enabled-roles","text":"Additional domain administrator approver workflow only applies to adding users in review enabled roles. The domain administrators have the authorization to remove any principal from a review enabled role without further approval process.","title":"Deleting Users from Review Enabled Roles"},{"location":"role_cert_expiration/","text":"By default, Athenz ZTS server allows principals to request role certificates with a maximum expiry of 30 days. However, the domain administrator has the capability to specify a maximum expiry limit for a given role or the full domain. This allows the domain administrators to control access to specific roles (or domains) such that the principals do not request role certificates that are valid for up-to 30 days but instead are valid only for the configured number of minutes. Role Level Certificate Expiry Support \u00b6 The domain administrator may specify maximum role certificate expiry setting in minutes for a specific role: zms-cli -d <domain-name> set-role-cert-expiry-mins <role-name> <max-expiry-mins> If the domain administrator has specified a max role certificate expiry mins of 120 to db.writers role, then ZTS will only issue a role certificate with a maximum expiry of 120 mins even if the principal is requesting a longer one. If the principal is requesting a role certificate with a smaller expiry that 120 mins, for example 60 mins, then it will be honored and the role certificate will be issued for 60 mins. If the role does not have a max certificate expiry setting configured, then ZTS will lookup to see if there is a max role certificate expiry setting specified for the domain and use that if it's smaller than the requested certificate expiry value. If the domain administrator specifies a role certificate expiry at both role and domain levels, then the role level always overrides the domain setting for the role - regardless if it's shorter or longer than the domain configured value. You can look at the currently configured value for a specific role using zms-cli -d <domain-name> show-role <role-name> command. To reset the configured limit back to its default behavior, set the limit to 0: zms-cli -d <domain-name> set-role-cert-expiry-mins <role-name> 0 Domain Level Role Certificate Expiry Support \u00b6 The domain administrator may specify maximum role certificate expiry setting in minutes for the full domain: zms-cli -d <domain-name> set-domain-role-cert-expiry-mins <max-expiry-mins> If the domain administrator has specified a max role certificate expiry mins of 360 to sales domain, then ZTS will only issue role certificates with a maximum expiry of 360 mins even if the principal is requesting a longer one. The exception to this rule is if the domain administrator has also specified a value for the role. If the domain administrator specifies a role certificate expiry at both role and domain levels, then the role level always overrides the domain setting for the role - regardless if it's shorter or longer than the domain configured value. If the principal is requesting a role certificate with a smaller expiry that 360 mins configured for the domain, for example 120 mins, and there are no per-role certificate expiry settings configured, then it will be honored and the role certificate will be issued for 120 mins. You can look at the currently configured value for a specific domain using zms-cli -d <domain-name> show-domain command. To reset the configured limit back to its default behavior, set the limit to 0: zms-cli -d <domain-name> set-domain-role-cert-expiry-mins 0","title":"Role Certificate Limit Expiry Support"},{"location":"role_cert_expiration/#role-level-certificate-expiry-support","text":"The domain administrator may specify maximum role certificate expiry setting in minutes for a specific role: zms-cli -d <domain-name> set-role-cert-expiry-mins <role-name> <max-expiry-mins> If the domain administrator has specified a max role certificate expiry mins of 120 to db.writers role, then ZTS will only issue a role certificate with a maximum expiry of 120 mins even if the principal is requesting a longer one. If the principal is requesting a role certificate with a smaller expiry that 120 mins, for example 60 mins, then it will be honored and the role certificate will be issued for 60 mins. If the role does not have a max certificate expiry setting configured, then ZTS will lookup to see if there is a max role certificate expiry setting specified for the domain and use that if it's smaller than the requested certificate expiry value. If the domain administrator specifies a role certificate expiry at both role and domain levels, then the role level always overrides the domain setting for the role - regardless if it's shorter or longer than the domain configured value. You can look at the currently configured value for a specific role using zms-cli -d <domain-name> show-role <role-name> command. To reset the configured limit back to its default behavior, set the limit to 0: zms-cli -d <domain-name> set-role-cert-expiry-mins <role-name> 0","title":"Role Level Certificate Expiry Support"},{"location":"role_cert_expiration/#domain-level-role-certificate-expiry-support","text":"The domain administrator may specify maximum role certificate expiry setting in minutes for the full domain: zms-cli -d <domain-name> set-domain-role-cert-expiry-mins <max-expiry-mins> If the domain administrator has specified a max role certificate expiry mins of 360 to sales domain, then ZTS will only issue role certificates with a maximum expiry of 360 mins even if the principal is requesting a longer one. The exception to this rule is if the domain administrator has also specified a value for the role. If the domain administrator specifies a role certificate expiry at both role and domain levels, then the role level always overrides the domain setting for the role - regardless if it's shorter or longer than the domain configured value. If the principal is requesting a role certificate with a smaller expiry that 360 mins configured for the domain, for example 120 mins, and there are no per-role certificate expiry settings configured, then it will be honored and the role certificate will be issued for 120 mins. You can look at the currently configured value for a specific domain using zms-cli -d <domain-name> show-domain command. To reset the configured limit back to its default behavior, set the limit to 0: zms-cli -d <domain-name> set-domain-role-cert-expiry-mins 0","title":"Domain Level Role Certificate Expiry Support"},{"location":"role_delegation/","text":"Athenz supports two types of roles that an administrator can create in their domains: regular and delegated. The regular role just includes list of principals that may assume that role. The delegated type specifies the trusted domain who has assumed the management of the members for that role. The delegation scenario involves two domains: The \"provider-domain\" is the domain of the service, where the policies and rules are declared, The \"tenant-domain\" (a.k.a. \"trusted-domain\") is the domain in which principals are assigned to the role. The delegation requires agreement from both domains: The provider-domain administrator specifies a role as \"delegated\" to a specific tenant-domain. The tenant-domain administrator creates a rule to assume that role and maps it to one if its local regular roles for principal membership. Definition of required roles and rules \u00b6 The keywords PROVIDER_DOMAIN , TENANT_DOMAIN , PROVIDER_ROLE and TENANT_ROLE are place-holders for the actual id's. Steps for establishing a delegated role: In the provider-domain: Create the role PROVIDER_ROLE as \"delegated\" to the domain TENANT_DOMAIN . Create various rules for PROVIDER_ROLE as usual. In the tenant-domain: Create role TENANT_ROLE Create this rule: Allow Action= assume_role Role= TENANT_ROLE Resource= PROVIDER_DOMAIN:role.PROVIDER_ROLE Assign members to \u201cTENANT_ROLE\u201d as usual. Use Case: Domain Administration Delegation \u00b6 A product team has a top level domain called sales with its configured set of administrators. They also have created a subdomain sales.api for the sales API subproduct. Since Athenz subdomains are completely independent, sales.api has its own admin role and set of administrators. However, in the case of sales product these two domains must have the same set of administrators and the product owner does not want to maintain and manage the admin role members in two places. The sales.api domain wants to delegate administration privileges to the parent sales domain. Step 1: sales.api change: create an admin role for the delegation \u00b6 Since Athenz does not allow administrators to remove or modify the admin role and policy for a domain, first we're going to create a role that will be delegated to the parent sales domain: Select Add Role link on the left side of the screen underneath the Roles tab name. Select a role type as Delegated and enter the role name and tenant-domain name: Step 2: sales.api change: create an admin policy for the delegated role \u00b6 Next we're going to create a new policy that provides the same admin privileges to the delegated sales.admin role. The admin policy uses * for the action and * for the resource. Step 3: sales change: create a policy to assume the sales.admin role \u00b6 Now, the domain administrator for sales domain must agree to assume that role by creating a special policy in its domain. The unique requirements for this policy are the action which must be set to assume_role and the resource which must be set to the full role name ({domain-name}:role.{role-name} format) that is being delegated to this domain. You have a choice to delegate the membership to any of your local roles. In this use case since we want to have a single domain admin role, we're going to delegate the sales.admin role from the sales.api subdomain to the admin role in sales domain. Step 4: verify delegated role membership in sales.api domain \u00b6 First, let's check the members of the admin role in the sales domain - it shows two principals as members: user.janedoe and user.johndoe. For delegated roles, Athenz Web UI automatically retrieves the members of the role in the tenant-domain that this role is delegated to and displays them as members without the capability to modify the list. Now any sales domain administrator is automatically an administrator of the sales.api subdomain as well.","title":"Role Delegation"},{"location":"role_delegation/#definition-of-required-roles-and-rules","text":"The keywords PROVIDER_DOMAIN , TENANT_DOMAIN , PROVIDER_ROLE and TENANT_ROLE are place-holders for the actual id's. Steps for establishing a delegated role: In the provider-domain: Create the role PROVIDER_ROLE as \"delegated\" to the domain TENANT_DOMAIN . Create various rules for PROVIDER_ROLE as usual. In the tenant-domain: Create role TENANT_ROLE Create this rule: Allow Action= assume_role Role= TENANT_ROLE Resource= PROVIDER_DOMAIN:role.PROVIDER_ROLE Assign members to \u201cTENANT_ROLE\u201d as usual.","title":"Definition of required roles and rules"},{"location":"role_delegation/#use-case-domain-administration-delegation","text":"A product team has a top level domain called sales with its configured set of administrators. They also have created a subdomain sales.api for the sales API subproduct. Since Athenz subdomains are completely independent, sales.api has its own admin role and set of administrators. However, in the case of sales product these two domains must have the same set of administrators and the product owner does not want to maintain and manage the admin role members in two places. The sales.api domain wants to delegate administration privileges to the parent sales domain.","title":"Use Case: Domain Administration Delegation"},{"location":"role_delegation/#step-1-salesapi-change-create-an-admin-role-for-the-delegation","text":"Since Athenz does not allow administrators to remove or modify the admin role and policy for a domain, first we're going to create a role that will be delegated to the parent sales domain: Select Add Role link on the left side of the screen underneath the Roles tab name. Select a role type as Delegated and enter the role name and tenant-domain name:","title":"Step 1: sales.api change: create an admin role for the delegation"},{"location":"role_delegation/#step-2-salesapi-change-create-an-admin-policy-for-the-delegated-role","text":"Next we're going to create a new policy that provides the same admin privileges to the delegated sales.admin role. The admin policy uses * for the action and * for the resource.","title":"Step 2: sales.api change: create an admin policy for the delegated role"},{"location":"role_delegation/#step-3-sales-change-create-a-policy-to-assume-the-salesadmin-role","text":"Now, the domain administrator for sales domain must agree to assume that role by creating a special policy in its domain. The unique requirements for this policy are the action which must be set to assume_role and the resource which must be set to the full role name ({domain-name}:role.{role-name} format) that is being delegated to this domain. You have a choice to delegate the membership to any of your local roles. In this use case since we want to have a single domain admin role, we're going to delegate the sales.admin role from the sales.api subdomain to the admin role in sales domain.","title":"Step 3: sales change: create a policy to assume the sales.admin role"},{"location":"role_delegation/#step-4-verify-delegated-role-membership-in-salesapi-domain","text":"First, let's check the members of the admin role in the sales domain - it shows two principals as members: user.janedoe and user.johndoe. For delegated roles, Athenz Web UI automatically retrieves the members of the role in the tenant-domain that this role is delegated to and displays them as members without the capability to modify the list. Now any sales domain administrator is automatically an administrator of the sales.api subdomain as well.","title":"Step 4: verify delegated role membership in sales.api domain"},{"location":"self_serve_roles/","text":"Athenz now supports configuring roles in domains as self-served thus allowing users to request domain administrators to approve their request to be added to a role. Athenz can send email notifications for administrators. See Email Notifications section to enable notifications. Role Setup \u00b6 To designate a role as self-served, the domain administrator may use either Athenz UI or zms-cli utility. To use Athenz UI, the domain administrator will login to their domain role view and choose the Self Served slider for the appropriate role. For example, in the following case, the db_reader_access role is configured as self-served. The equivalent setup using zms-cli would be: zms-cli -d <domain-name> set-role-self-serve <role-name> true User Access Request \u00b6 The users can only add themselves (not other users or services) to any self-served roles. Their access is not active until one of the domain administrators approves the request. For example, in this use case, user.johndoe would like to be added to the db_reader_access role which is configured as self-served. When the user adds his principal id to the role, it will be added in the Pending Approval column. Domain Administrator Approval \u00b6 Once the pending request is processed, all domain administrators will receive an email notification (if notifications are enabled ) stating that user.johndoe would like to be added to the db_reader_access role and they need to either approve or reject the request. The email will include a link to the Athenz UI workflow page which can also be accessed by clicking on the notifications icon in the Athenz UI toolbar: Once in the approval view page, the domain administrator may either approve or reject the request. The domain administrator will need to provide a justification in the Audit Reference field and optionally specify an expiration date (even if the user didn't request one). Once approved, the principal will become an active/approved member of the role. If rejected, the principal's name will be removed from the Pending Approval column.","title":"Self-Served Roles"},{"location":"self_serve_roles/#role-setup","text":"To designate a role as self-served, the domain administrator may use either Athenz UI or zms-cli utility. To use Athenz UI, the domain administrator will login to their domain role view and choose the Self Served slider for the appropriate role. For example, in the following case, the db_reader_access role is configured as self-served. The equivalent setup using zms-cli would be: zms-cli -d <domain-name> set-role-self-serve <role-name> true","title":"Role Setup"},{"location":"self_serve_roles/#user-access-request","text":"The users can only add themselves (not other users or services) to any self-served roles. Their access is not active until one of the domain administrators approves the request. For example, in this use case, user.johndoe would like to be added to the db_reader_access role which is configured as self-served. When the user adds his principal id to the role, it will be added in the Pending Approval column.","title":"User Access Request"},{"location":"self_serve_roles/#domain-administrator-approval","text":"Once the pending request is processed, all domain administrators will receive an email notification (if notifications are enabled ) stating that user.johndoe would like to be added to the db_reader_access role and they need to either approve or reject the request. The email will include a link to the Athenz UI workflow page which can also be accessed by clicking on the notifications icon in the Athenz UI toolbar: Once in the approval view page, the domain administrator may either approve or reject the request. The domain administrator will need to provide a justification in the Audit Reference field and optionally specify an expiration date (even if the user didn't request one). Once approved, the principal will become an active/approved member of the role. If rejected, the principal's name will be removed from the Pending Approval column.","title":"Domain Administrator Approval"},{"location":"server_side_x509_credentials/","text":"In order to authenticate x.509 client certificates on Athenz enabled services, your server needs to be configured to authenticate TLS client certificates along with updated trust store with Athenz CA certificates. This section contains some examples how to setup your server to enable TLS client certificate authentication. Get Athenz CA Certificates \u00b6 First, get the CA Certificates of your Athenz instances and place them in a truststore. For our example, the truststore will be named athenz_certificate_bundle.jks . You must configure your container to recognize this truststure. If you are using other containers, you can set the SSL properties at the JVM level via system properties. -Djavax.net.ssl.trustStore=/home/example/athenz_certificate_bundle.jks Enable TLS client authentication in your container \u00b6 If you are using your own application server, you would need to set setNeedClientAuth to true. For example: SSLServerSocketFactory ssf = sc . getServerSocketFactory (); SSLServerSocket sslserversocket = ( SSLServerSocket ) ssf . createServerSocket ( 4443 ); sslserversocket . setNeedClientAuth ( true ); Please follow specific documentations provided by your container vendor on how to require client side TLS authentication. Extract Certificate and Verify \u00b6 If your trust store only has Athenz CA certificates, no need to extract and verify the issuer. If not, please follow below code example for verification. The client certificate is accessible from jakarta.servlet.request.X509Certificate HttpServletRequest attribute. Here is how you can get access to the TLS certificate: import java.security.cert.X509Certificate ; import jakarta.servlet.http.HttpServletRequest ; public static final String JAVAX_CERT_ATTR = \"jakarta.servlet.request.X509Certificate\" ; X509Certificate [] certs = ( X509Certificate [] ) servletRequest . getAttribute ( JAVAX_CERT_ATTR ); X509Certificate x509cert = null ; if ( null != certs && certs . length != 0 ) { for ( X509Certificate cert : certs ) { if ( null != cert ) { //find the first occurrence of non-null certificate x509cert = cert ; break ; } } } Then, validate the certificate issuers against a pre-configured set of Athenz CA issuers. Here is an example of how you may build the list of valid certificates from a truststore and then check that the issuer is valid. private static final String DEFAULT_ISSUERS_FILE_NAME = \"/home/example/athenz_certificate_bundle.jks\" ; private static Set < String > X509_ISSUERS = new HashSet <> (); X509Certificate [] certs = ( X509Certificate [] ) request . getAttribute ( JAVAX_CERT_ATTR ); X509Certificate x509cert = null ; if ( null != certs && certs . length != 0 ) { for ( X509Certificate cert : certs ) { if ( null != cert ) { //find the first occurrence of none null certificate x509cert = cert ; if ( LOG . isDebugEnabled ()) { LOG . debug ( \"Found x509 cert\" ); } break ; } } } if ( null == x509cert ) { // fail as x509cert is missing LOG . error ( \"x509 certificate is missing\" ); response . sendError ( HttpServletResponse . SC_UNAUTHORIZED ); return ; } // validate the certificate against CAs X500Principal issuerx500Principal = x509cert . getIssuerX500Principal (); String issuer = issuerx500Principal . getName (); if ( LOG . isDebugEnabled ()) { LOG . debug ( \"Found x509 cert issuer: {}\" , issuer ); } if ( issuer == null || issuer . isEmpty () || ! X509_ISSUERS . contains ( issuer )) { //fail LOG . error ( \"Issuer is missing or not apart of authorized Athenz CA\" ); response . sendError ( HttpServletResponse . SC_UNAUTHORIZED ); return ; } private final void setX509CAIssuers ( final String issuersFileName ) { if ( issuersFileName == null || issuersFileName . isEmpty ()) { return ; } try { Path path = Paths . get ( issuersFileName ); if ( ! path . isAbsolute ()) { path = Paths . get ( getClass (). getClassLoader (). getResource ( issuersFileName ). toURI ()); } KeyStore ks = null ; try ( InputStream in = new FileInputStream ( path . toString ())) { ks = KeyStore . getInstance ( KeyStore . getDefaultType ()); ks . load ( in , null ); } for ( Enumeration <?> e = ks . aliases (); e . hasMoreElements (); ) { String alias = ( String ) e . nextElement (); X509Certificate cert = ( X509Certificate ) ks . getCertificate ( alias ); X500Principal issuerx500Principal = cert . getIssuerX500Principal (); String issuer = issuerx500Principal . getName (); X509_ISSUERS . add ( issuer ); if ( LOG . isDebugEnabled ()) { LOG . debug ( \"issuer: {} \" , issuer ); } } } catch ( Throwable e ) { LOG . error ( \"Unable to set issuers from file \" + issuersFileName , e ); } }","title":"Server Side Service Identity Authentication"},{"location":"server_side_x509_credentials/#get-athenz-ca-certificates","text":"First, get the CA Certificates of your Athenz instances and place them in a truststore. For our example, the truststore will be named athenz_certificate_bundle.jks . You must configure your container to recognize this truststure. If you are using other containers, you can set the SSL properties at the JVM level via system properties. -Djavax.net.ssl.trustStore=/home/example/athenz_certificate_bundle.jks","title":"Get Athenz CA Certificates"},{"location":"server_side_x509_credentials/#enable-tls-client-authentication-in-your-container","text":"If you are using your own application server, you would need to set setNeedClientAuth to true. For example: SSLServerSocketFactory ssf = sc . getServerSocketFactory (); SSLServerSocket sslserversocket = ( SSLServerSocket ) ssf . createServerSocket ( 4443 ); sslserversocket . setNeedClientAuth ( true ); Please follow specific documentations provided by your container vendor on how to require client side TLS authentication.","title":"Enable TLS client authentication in your container"},{"location":"server_side_x509_credentials/#extract-certificate-and-verify","text":"If your trust store only has Athenz CA certificates, no need to extract and verify the issuer. If not, please follow below code example for verification. The client certificate is accessible from jakarta.servlet.request.X509Certificate HttpServletRequest attribute. Here is how you can get access to the TLS certificate: import java.security.cert.X509Certificate ; import jakarta.servlet.http.HttpServletRequest ; public static final String JAVAX_CERT_ATTR = \"jakarta.servlet.request.X509Certificate\" ; X509Certificate [] certs = ( X509Certificate [] ) servletRequest . getAttribute ( JAVAX_CERT_ATTR ); X509Certificate x509cert = null ; if ( null != certs && certs . length != 0 ) { for ( X509Certificate cert : certs ) { if ( null != cert ) { //find the first occurrence of non-null certificate x509cert = cert ; break ; } } } Then, validate the certificate issuers against a pre-configured set of Athenz CA issuers. Here is an example of how you may build the list of valid certificates from a truststore and then check that the issuer is valid. private static final String DEFAULT_ISSUERS_FILE_NAME = \"/home/example/athenz_certificate_bundle.jks\" ; private static Set < String > X509_ISSUERS = new HashSet <> (); X509Certificate [] certs = ( X509Certificate [] ) request . getAttribute ( JAVAX_CERT_ATTR ); X509Certificate x509cert = null ; if ( null != certs && certs . length != 0 ) { for ( X509Certificate cert : certs ) { if ( null != cert ) { //find the first occurrence of none null certificate x509cert = cert ; if ( LOG . isDebugEnabled ()) { LOG . debug ( \"Found x509 cert\" ); } break ; } } } if ( null == x509cert ) { // fail as x509cert is missing LOG . error ( \"x509 certificate is missing\" ); response . sendError ( HttpServletResponse . SC_UNAUTHORIZED ); return ; } // validate the certificate against CAs X500Principal issuerx500Principal = x509cert . getIssuerX500Principal (); String issuer = issuerx500Principal . getName (); if ( LOG . isDebugEnabled ()) { LOG . debug ( \"Found x509 cert issuer: {}\" , issuer ); } if ( issuer == null || issuer . isEmpty () || ! X509_ISSUERS . contains ( issuer )) { //fail LOG . error ( \"Issuer is missing or not apart of authorized Athenz CA\" ); response . sendError ( HttpServletResponse . SC_UNAUTHORIZED ); return ; } private final void setX509CAIssuers ( final String issuersFileName ) { if ( issuersFileName == null || issuersFileName . isEmpty ()) { return ; } try { Path path = Paths . get ( issuersFileName ); if ( ! path . isAbsolute ()) { path = Paths . get ( getClass (). getClassLoader (). getResource ( issuersFileName ). toURI ()); } KeyStore ks = null ; try ( InputStream in = new FileInputStream ( path . toString ())) { ks = KeyStore . getInstance ( KeyStore . getDefaultType ()); ks . load ( in , null ); } for ( Enumeration <?> e = ks . aliases (); e . hasMoreElements (); ) { String alias = ( String ) e . nextElement (); X509Certificate cert = ( X509Certificate ) ks . getCertificate ( alias ); X500Principal issuerx500Principal = cert . getIssuerX500Principal (); String issuer = issuerx500Principal . getName (); X509_ISSUERS . add ( issuer ); if ( LOG . isDebugEnabled ()) { LOG . debug ( \"issuer: {} \" , issuer ); } } } catch ( Throwable e ) { LOG . error ( \"Unable to set issuers from file \" + issuersFileName , e ); } }","title":"Extract Certificate and Verify"},{"location":"service_authentication/","text":"Athenz Service Identity X.509 Certificates \u00b6 Copper Argos Using Service Registered Public/Private Key Pairs Using Instance Register Authentication Tokens Athenz Service Identity x.509 certificates are used to establish standard mutual TLS communication with other Athenz Enabled Services. The services running on the instance can obtain X.509 certificates from ZTS using one of the approaches listed below. Copper Argos \u00b6 This is the preferred method of obtaining certificates for services. There is a provider registered in Athenz (e.g. K8S) that is responsible for deploying these instances and validating the identity certificate requests from these instances when contacted by ZTS. Refer to our Copper Argos guide for full details. Using Service Registered Public/Private Key Pairs \u00b6 In this method, we're creating a public/private key pair where the caller holds on to the private key and registers the public key in Athenz. To authenticate the service, the caller generates a token signed by its private key and sends that to the ZTS server along with its X.509 certificate request (CSR). The ZTS Server validates the service token using the registered public key and issues the X.509 certificate for the service. When using this approach we strongly recommend using a different private key per instance (you generate the private key on the host itself and make sure it's secure and never leaves the host) so that each instance has a unique private key/certificate pair. Create a public/private key pair for your service and register the public key in Athenz. Refer Service Registration for complete details on registering services in Athenz. Store your private key securely. You can store that in a file on the host and make sure only service is authorized to access that file. Download latest zts-svccert utility binary release from Maven Central : click on the Browse button, choose the latest version directory and then download the athenz-utils-<latest-version>-bin.tar.gz . $ tar xvfz athenz-utils-X.Y-bin.tar.gz Use the private key to obtain X.509 certificate from ZTS using zts-svccert utility. You need to make sure to pass the correct key-version argument that matches to the key identifier that was used to register the public key for the service in Athenz. zts-svccert -domain <domain> -service <service> -private-key <private key file> -key-version <version> -zts <zts_url> -dns-domain <dns-name> -cert-file <output certificate file> The certificates and keys should be periodically refreshed. Using Instance Register Authentication Tokens \u00b6 The primary disadvantage of using the public/private key pair for fetching service x.509 certificate details is the number of unique public keys that need to be registered per service since we strongly recommend of having a unique private key per instance. An alternative approach to registering public/private key pairs is first to request ZTS to issue an instance registration token and then use that token when requesting a service identity x.509 certificate. In this process, you're still required to request a unique token per instance, but it no longer requires Athenz to register the corresponding public key. During this process, ZTS verifies that the caller has update capabilities over the service, and the service has been configured to be \"launched\" by ZTS Server. Once the user has been authorized, ZTS generates a signed json web token (JWT) for that instance and returns the token back to the client. The client then uses that token as its credentials when requesting and refreshing service identity certificates from ZTS. Download latest zts-svccert utility binary release from Maven Central : click on the Browse button, choose the latest version directory and then download the athenz-utils-<latest-version>-bin.tar.gz . $ tar xvfz athenz-utils-X.Y-bin.tar.gz Use zts-svccert with the caller's identity credentials that is authorized to manage the required service to request x.509 certificates from the Athenz pre-registered sys.auth.zts provider. zts-svccert -use-instance-register-token -zts <zts_url> <principal-credentials> -private-key <private-key-path> -provider <provider-name> -domain <domain> -service <service> -instance <instance-id> -dns-domain <dns-name> -cert-file <output certificate file> The certificates and keys should be periodically refreshed.","title":"Athenz Service Identity X.509 Certificate"},{"location":"service_authentication/#athenz-service-identity-x509-certificates","text":"Copper Argos Using Service Registered Public/Private Key Pairs Using Instance Register Authentication Tokens Athenz Service Identity x.509 certificates are used to establish standard mutual TLS communication with other Athenz Enabled Services. The services running on the instance can obtain X.509 certificates from ZTS using one of the approaches listed below.","title":"Athenz Service Identity X.509 Certificates"},{"location":"service_authentication/#copper-argos","text":"This is the preferred method of obtaining certificates for services. There is a provider registered in Athenz (e.g. K8S) that is responsible for deploying these instances and validating the identity certificate requests from these instances when contacted by ZTS. Refer to our Copper Argos guide for full details.","title":"Copper Argos"},{"location":"service_authentication/#using-service-registered-publicprivate-key-pairs","text":"In this method, we're creating a public/private key pair where the caller holds on to the private key and registers the public key in Athenz. To authenticate the service, the caller generates a token signed by its private key and sends that to the ZTS server along with its X.509 certificate request (CSR). The ZTS Server validates the service token using the registered public key and issues the X.509 certificate for the service. When using this approach we strongly recommend using a different private key per instance (you generate the private key on the host itself and make sure it's secure and never leaves the host) so that each instance has a unique private key/certificate pair. Create a public/private key pair for your service and register the public key in Athenz. Refer Service Registration for complete details on registering services in Athenz. Store your private key securely. You can store that in a file on the host and make sure only service is authorized to access that file. Download latest zts-svccert utility binary release from Maven Central : click on the Browse button, choose the latest version directory and then download the athenz-utils-<latest-version>-bin.tar.gz . $ tar xvfz athenz-utils-X.Y-bin.tar.gz Use the private key to obtain X.509 certificate from ZTS using zts-svccert utility. You need to make sure to pass the correct key-version argument that matches to the key identifier that was used to register the public key for the service in Athenz. zts-svccert -domain <domain> -service <service> -private-key <private key file> -key-version <version> -zts <zts_url> -dns-domain <dns-name> -cert-file <output certificate file> The certificates and keys should be periodically refreshed.","title":"Using Service Registered Public/Private Key Pairs"},{"location":"service_authentication/#using-instance-register-authentication-tokens","text":"The primary disadvantage of using the public/private key pair for fetching service x.509 certificate details is the number of unique public keys that need to be registered per service since we strongly recommend of having a unique private key per instance. An alternative approach to registering public/private key pairs is first to request ZTS to issue an instance registration token and then use that token when requesting a service identity x.509 certificate. In this process, you're still required to request a unique token per instance, but it no longer requires Athenz to register the corresponding public key. During this process, ZTS verifies that the caller has update capabilities over the service, and the service has been configured to be \"launched\" by ZTS Server. Once the user has been authorized, ZTS generates a signed json web token (JWT) for that instance and returns the token back to the client. The client then uses that token as its credentials when requesting and refreshing service identity certificates from ZTS. Download latest zts-svccert utility binary release from Maven Central : click on the Browse button, choose the latest version directory and then download the athenz-utils-<latest-version>-bin.tar.gz . $ tar xvfz athenz-utils-X.Y-bin.tar.gz Use zts-svccert with the caller's identity credentials that is authorized to manage the required service to request x.509 certificates from the Athenz pre-registered sys.auth.zts provider. zts-svccert -use-instance-register-token -zts <zts_url> <principal-credentials> -private-key <private-key-path> -provider <provider-name> -domain <domain> -service <service> -instance <instance-id> -dns-domain <dns-name> -cert-file <output certificate file> The certificates and keys should be periodically refreshed.","title":"Using Instance Register Authentication Tokens"},{"location":"service_x509_credentials/","text":"Once a domain has been registered in Athenz, the administrator will register service identities that are specified in domain roles and policy assertions. The latter can reference those roles having access to specified resources. Athenz supports service authentication with two types of credentials: X.509 Certificates (preferred approach) Public/Private Key Pairs Instructions To contact Athenz Services (ZMS/ZTS) or other Athenz Enabled services, the client service must first obtain an Athenz CA issued X.509 certificate. In this section we'll cover how to register the service identity and obtain X.509 certificates based on what environment your service will be running in. Use Case 1: Service Running in AWS EC2 \u00b6 If the service is running in AWS, Service Identity Agent (SIA) running on the instance is responsible for generating a private key for the service and obtaining a x.509 certificate from ZTS Service. The files are located in the following locations: private-key: /var/lib/sia/keys/<domain>.<service>.key.pem certificate: /var/lib/sia/certs/<domain>.<service>.cert.pem The certificate is valid for 30 days and SIA agent automatically will refresh the certificate daily. Follow these steps for full details how to configure SIA agent running in AWS as part of the foundation image. Use Case 2: Service running on-prem within an Athenz Enabled Framework (K8S) \u00b6 If the service is running within an Athenz enabled framework then it must already have access to service identity x.509 certificate that was generated for the service. Refer to the documentation provided by the framework to see where the files are located. Use Case 3: Service Running in AWS ECS (Elastic Container Service) \u00b6 If the service is running in AWS ECS, Service Identity Agent (SIA) included in your image is responsible for generating a private key for the service and obtaining a x.509 certificate from ZTS Service. The files are located in the following locations: private-key: /var/lib/sia/keys/<domain>.<service>.key.pem certificate: /var/lib/sia/certs/<domain>.<service>.cert.pem The certificate is valid for 30 days and SIA agent automatically will refresh the certificate daily. Follow these steps for full details how to configure SIA agent running in AWS as part of your image. Use Case 4: Service Running in AWS Lambda Function \u00b6 If the service is running in AWS Lambda function, the function being invoked will be responsible for generating a private key and then a csr for its request. It will submit that request to the ZTS Server to retrieve its X.509 certificate which then it can use along with its generated private key to establish TLS connections to other Athenz enabled services. Athenz Team provides functions/methods in Go and Java programming languages to quickly generate a private key and request its corresponding X.509 certificate from ZTS Server. The certificate is valid for 30 days. The short lifetime and stateless nature of the function means it cannot rotate its certificates. It just gets new ones when needed. Follow these steps for full details how to obtain service x.509 credentials within your function. Use Case 5: Service Running in AWS Fargate \u00b6 If the service is running in AWS Fargate, Service Identity Agent (SIA) included in your image is responsible for generating a private key for the service and obtaining a x.509 certificate from ZTS Service. The files are located in the following locations: private-key: /var/lib/sia/keys/<domain>.<service>.key.pem certificate: /var/lib/sia/certs/<domain>.<service>.cert.pem The certificate is valid for 7 days and SIA agent automatically will refresh the certificate daily. Follow these steps for full details how to configure SIA agent running in AWS as part of your image. Use Case 6: Service Running in AWS EKS \u00b6 If the service is running in AWS EKS, Service Identity Agent (SIA) included in your image is responsible for generating a private key for the service and obtaining a x.509 certificate from ZTS Service. The files are located in the following locations: private-key: /var/lib/sia/keys/<domain>.<service>.key.pem certificate: /var/lib/sia/certs/<domain>.<service>.cert.pem The certificate is valid for 7 days and SIA agent automatically will refresh the certificate daily. Follow these steps for full details how to configure SIA agent running in AWS as part of your image.","title":"Using X.509 Certificates"},{"location":"service_x509_credentials/#use-case-1-service-running-in-aws-ec2","text":"If the service is running in AWS, Service Identity Agent (SIA) running on the instance is responsible for generating a private key for the service and obtaining a x.509 certificate from ZTS Service. The files are located in the following locations: private-key: /var/lib/sia/keys/<domain>.<service>.key.pem certificate: /var/lib/sia/certs/<domain>.<service>.cert.pem The certificate is valid for 30 days and SIA agent automatically will refresh the certificate daily. Follow these steps for full details how to configure SIA agent running in AWS as part of the foundation image.","title":"Use Case 1: Service Running in AWS EC2"},{"location":"service_x509_credentials/#use-case-2-service-running-on-prem-within-an-athenz-enabled-framework-k8s","text":"If the service is running within an Athenz enabled framework then it must already have access to service identity x.509 certificate that was generated for the service. Refer to the documentation provided by the framework to see where the files are located.","title":"Use Case 2: Service running on-prem within an Athenz Enabled Framework (K8S)"},{"location":"service_x509_credentials/#use-case-3-service-running-in-aws-ecs-elastic-container-service","text":"If the service is running in AWS ECS, Service Identity Agent (SIA) included in your image is responsible for generating a private key for the service and obtaining a x.509 certificate from ZTS Service. The files are located in the following locations: private-key: /var/lib/sia/keys/<domain>.<service>.key.pem certificate: /var/lib/sia/certs/<domain>.<service>.cert.pem The certificate is valid for 30 days and SIA agent automatically will refresh the certificate daily. Follow these steps for full details how to configure SIA agent running in AWS as part of your image.","title":"Use Case 3: Service Running in AWS ECS (Elastic Container Service)"},{"location":"service_x509_credentials/#use-case-4-service-running-in-aws-lambda-function","text":"If the service is running in AWS Lambda function, the function being invoked will be responsible for generating a private key and then a csr for its request. It will submit that request to the ZTS Server to retrieve its X.509 certificate which then it can use along with its generated private key to establish TLS connections to other Athenz enabled services. Athenz Team provides functions/methods in Go and Java programming languages to quickly generate a private key and request its corresponding X.509 certificate from ZTS Server. The certificate is valid for 30 days. The short lifetime and stateless nature of the function means it cannot rotate its certificates. It just gets new ones when needed. Follow these steps for full details how to obtain service x.509 credentials within your function.","title":"Use Case 4: Service Running in AWS Lambda Function"},{"location":"service_x509_credentials/#use-case-5-service-running-in-aws-fargate","text":"If the service is running in AWS Fargate, Service Identity Agent (SIA) included in your image is responsible for generating a private key for the service and obtaining a x.509 certificate from ZTS Service. The files are located in the following locations: private-key: /var/lib/sia/keys/<domain>.<service>.key.pem certificate: /var/lib/sia/certs/<domain>.<service>.cert.pem The certificate is valid for 7 days and SIA agent automatically will refresh the certificate daily. Follow these steps for full details how to configure SIA agent running in AWS as part of your image.","title":"Use Case 5: Service Running in AWS Fargate"},{"location":"service_x509_credentials/#use-case-6-service-running-in-aws-eks","text":"If the service is running in AWS EKS, Service Identity Agent (SIA) included in your image is responsible for generating a private key for the service and obtaining a x.509 certificate from ZTS Service. The files are located in the following locations: private-key: /var/lib/sia/keys/<domain>.<service>.key.pem certificate: /var/lib/sia/certs/<domain>.<service>.cert.pem The certificate is valid for 7 days and SIA agent automatically will refresh the certificate daily. Follow these steps for full details how to configure SIA agent running in AWS as part of your image.","title":"Use Case 6: Service Running in AWS EKS"},{"location":"service_x509_credentials_aws/","text":"Bootstrapping AWS EC2 instances with Athenz Service x.509 Identities requires the instances to have network connectivity to both Athenz ZTS and AWS STS Services. Domain Registration \u00b6 Identify your Athenz domain before you can proceed by using Athenz UI. You may create a top-level domain or a sub domain using Athenz UI or zms-cli. Only Athenz System Administrators can create top level domains (members of the sys.auth domain's admin role). To create a top-level domain using zms-cli run the following: zms-cli add-domakn <domain-name> <unique-product-id> <domain-admins separated by space> If you already have top-level domain and need to create a sub domain using Athenz UI: click the \"Create\u201d link next to \"My Domains\" label in the top right corner and then click on \u201cSub Domain\u201d tab and follow the on screen instruction. Or using zms-cli: zms-cli add-doman <top-doman.sub-domain-name> <domain-admins separated by space> AWS Account ID Registration \u00b6 To register an AWS Account with a domain, run the following command: zms-cli -d <domain-name> set-aws-account <aws-account-id> Athenz Service Identity Registration \u00b6 Create a service identity for your AWS EC2 instances in your Athenz domain. This full service identity name <domain>.<service> will be the IAM role name that you will need to create in AWS IAM and set up a trust relationship with your EC2 Instance Role. In the Athenz UI, select your domain, select the Services tab and then choose Add a Service link in the top left corner. You must provide a service name and an optional description for your service. Athenz Service Identity Authorization \u00b6 Before ZTS can validate and issue X.509 TLS Certificates to the AWS EC2 instance, it must validate that the service owner has authorized its service to be launched by AWS EC2 Provider. In the Athenz UI select your service that was created in the previous step and click on the icon in the Providers column: Then, click on the Allow button to authorize your service to be launched by AWS EC2 provider. IAM Role Setup \u00b6 There are two IAM roles required for instances to obtain Athenz X.509 certificates: EC2 Instance Profile Role Athenz Service Identity Assume Role It is assumed that at this point you have already configured the first EC2 Instance Profile IAM Role that your EC2 instance will be launched with. The second Athenz Service Identity IAM Assume Role must be created and must have the <domain>.<service> name. This role will not have any permissions but instead will have a trust relationship with your EC2 instance role such that your EC2 instance role can assume this role. In the AWS Console, select IAM from the Services drop down and then click on the Roles link in the left sidebar. Choose the Create Role button. Under the AWS Service type, select EC2 , then EC2 again for the use case and finally choose Next: Permissions button in the bottom right corner. In the Attach permissions policy screen do not choose any permissions and just click on the Next: Review button in the bottom right corner to continue. Specify the Role name in the <domain>.<service> format and choose Create Role to complete the process. In the Roles list view, choose the role just created and choose the Trust Relationships tab. Click on Edit trust relationship button and append a block containing the following policy to the Statement block (Replace the <account-id> and <ec2-instance-role> values with their corresponding values for your environment: { \"Effect\": \"Allow\", \"Principal\": { \"AWS\": \"arn:aws:iam::<account-id>:role/<ec2-instance-role>\" }, \"Action\": \"sts:AssumeRole\" } Once correctly updated, your EC2 instance role must appear in the Trusted entities table: Setup for Services with Region Specific Instance Profile Roles \u00b6 The IAM Role setup is identical when you have the same service being deployed in multiple regions with role names that are specific to each region. Since IAM roles are global, you only need to create a single Athenz IAM Role in the <domain>.<service> format. Then, when you're setting up your trust relationship, you'll authorize all your region specific profile roles to have the capability to assume the Athenz <domain>.<service> role. Installing SIA \u00b6 The AWS SIA source is part of the Athenz project and can be found in: provider/aws/sia-ec2 Follow the readme for instructions on how to install it. SIA Configuration Setup \u00b6 When building your image, you can include the following configuration file called sia_config in the /etc/sia directory. It must include the following required fields: { \"version\": \"1.0.0\", \"service\": \"<service name>\", \"accounts\": [ { \"domain\": \"<domain name>\", \"account\": \"<aws account id associated with domain name>\" } ] } The domain/account/service values here must match to the IAM Role created earlier. For example, if the service identity name is api in domain sports whose corresponding aws account id is 123456789 , then the sia_config file will be as follows: { \"version\": \"1.0.0\", \"service\": \"api\", \"accounts\": [ { \"domain\": \"sports\", \"account\": \"123456789\" } ] } Private Key File Ownership \u00b6 By default SIA agent runs as root and the private key is only readable by root. If your service is running as another user, you can configure SIA agent to automatically change the ownership of the private key file to the configured user. For example, if you want the private key to be owned by ec2-user , then your sia_config configuration file would be as follows: { \"version\": \"1.0.0\", \"service\": \"api\", \"accounts\": [ { \"domain\": \"sports\", \"account\": \"123456789\", \"user\": \"ec2-user\" } ] } Private Key and Certificate Setup \u00b6 By default, the private key for the service identity is available in the /var/lib/sia/keys directory and has the name <domain>.<service>.key.pem . The private key is in PKCS#1 format. The corresponding X.509 certificate is in the /var/lib/sia/certs directory and has the name <domain>.<service>.cert.pem . The certificate is valid for 30 days and will be refreshed automatically by SIA every day. It is the responsibility of the application owner to update their container/application to refresh and use the latest certificate before it expires. In the same /var/lib/sia/certs directory SIA will also generate the Athenz CA certificate file called ca.cert.pem . Role Certificate Support \u00b6 In addition to requesting Athenz service identity certificate, SIA provides the capability to request Athenz Role Certificates as well. If you want to change the default behavior or request SIA to automatically retrieve role certificates for your service, as part of building your ami image, you can include the following additional fields in the configuration file: { \"version\": \"1.0.0\", \"service\": \"<service name>\", \"accounts\": [ { \"domain\": \"<domain name>\", \"account\": \"<aws account id associated with domain name>\", \"roles\": { \"<role-domain1>:role.<role-name1>\": { }, \"<role-domain2>:role.<role-name2>\": { } } } ] } The role certificates will also be stored in the /var/lib/sia/certs directory and have the name of <role-domain1>:role.<role-name1>.cert.pem . They are also valid for 30 days and SIA will automatically refresh them once a day. Setup Without SIA Configuration File \u00b6 If a property deploying their service in AWS meets the following 2 requirements: does not need any role certificates to be retrieved by SIA automatically has the option to name their EC2 instance role then they have the option for a simpler setup without including a sia configuration file in their image. In this model, the property would name their EC2 instance role as <domain>.<service>-service . The property must still follow the full steps as described in the IAM Role Setup section to setup the <domain>.<service> role, but the requirement to have a sia_config file is no longer present. When SIA is running and is not able to find the sia_config file, it will check if the instance profile arn has the <domain>.<service>-service format. If it does, then it would drop -service part to parse the rest of the string to extract the Athenz domain and service values and determine the assume role name that it needs to fetch temporary credentials for before contacting ZTS Server. Non Standard Instance Profile Name \u00b6 If a property deploying their service in AWS does not have the capability to name their instance profile role name as <domain>.<service>-service due to legacy requirements, the following steps can be followed to configure SIA to use the non-standard instance profile name. The property must still follow the full steps as described in the IAM Role Setup section to setup the <domain>.<service> role and the trust relationship. The property must install a SIA config file /etc/sia/sia_config specifying the service name that will be deployed on this instance Independent Instance Profile and Role Names \u00b6 It is possible to setup only a single role within AWS IAM in the format <domain>.<service> and name the IAM profile name as <domain>.<service>-service without creating a separate role. However, there is currently no support in the AWS UI console for naming your IAM role and IAM instance profile independently. You can do this with Cloud Formation, Ansible, TF, the AWS API, or the CLI. Here is an example using the CLI - replace <domain> , <service> and <account-id> parameters with their respective values for your environment: aws iam create-role --role-name <domain>.<service> --assume-role-policy-document='{\"Version\":\"2012-10-17\",\"Statement\":[{\"Effect\":\"Allow\",\"Principal\":{\"Service\":\"ec2.amazonaws.com\"},\"Action\":\"sts:AssumeRole\"}]}' aws iam create-instance-profile --instance-profile-name <domain>.<service>-service aws iam update-assume-role-policy --role-name <domain>.<service> --policy-document '{\"Version\":\"2012-10-17\",\"Statement\":[{\"Effect\":\"Allow\",\"Principal\":{\"Service\":\"ec2.amazonaws.com\"},\"Action\":\"sts:AssumeRole\"},{\"Effect\":\"Allow\",\"Principal\":{\"AWS\":\"arn:aws:iam::<account-id>:role/<domain>.<service>\"},\"Action\":\"sts:AssumeRole\"}]}' aws iam add-role-to-instance-profile --instance-profile-name <domain>.<service>-service --role-name <domain>.<service> However, this model is not recommended from security perspective if your <domain>.<service> role has access to other AWS services. Temporary credentials for that role are sent to Athenz ZTS service as your authentication credentials and, as such, you do not want to expose those additional access capabilities to the ZTS Server. Troubleshooting \u00b6 SIA process outputs all of its messages to syslog, so if there are any issues with your configuration, it will be reported in syslog. You can execute: sudo grep siad /var/log/messages and see what operation sia was not able to complete successfully. The agent is configured to run every 20 seconds in case of a failure, so you'll most likely see the same block being repeated multiple times. ZTS server allows instances to obtain x.509 certificates only during the first 30 minutes after the initial bootstrap time so even if you address the configuration issues, once the 30 mins have passed, the instance will no longer be able to obtain its x.509 service identity certificate. The only option at that time is to terminate and launch a new instance.","title":"Athenz Service Identity X.509 Certificate for AWS EC2 instances"},{"location":"service_x509_credentials_aws/#domain-registration","text":"Identify your Athenz domain before you can proceed by using Athenz UI. You may create a top-level domain or a sub domain using Athenz UI or zms-cli. Only Athenz System Administrators can create top level domains (members of the sys.auth domain's admin role). To create a top-level domain using zms-cli run the following: zms-cli add-domakn <domain-name> <unique-product-id> <domain-admins separated by space> If you already have top-level domain and need to create a sub domain using Athenz UI: click the \"Create\u201d link next to \"My Domains\" label in the top right corner and then click on \u201cSub Domain\u201d tab and follow the on screen instruction. Or using zms-cli: zms-cli add-doman <top-doman.sub-domain-name> <domain-admins separated by space>","title":"Domain Registration"},{"location":"service_x509_credentials_aws/#aws-account-id-registration","text":"To register an AWS Account with a domain, run the following command: zms-cli -d <domain-name> set-aws-account <aws-account-id>","title":"AWS Account ID Registration"},{"location":"service_x509_credentials_aws/#athenz-service-identity-registration","text":"Create a service identity for your AWS EC2 instances in your Athenz domain. This full service identity name <domain>.<service> will be the IAM role name that you will need to create in AWS IAM and set up a trust relationship with your EC2 Instance Role. In the Athenz UI, select your domain, select the Services tab and then choose Add a Service link in the top left corner. You must provide a service name and an optional description for your service.","title":"Athenz Service Identity Registration"},{"location":"service_x509_credentials_aws/#athenz-service-identity-authorization","text":"Before ZTS can validate and issue X.509 TLS Certificates to the AWS EC2 instance, it must validate that the service owner has authorized its service to be launched by AWS EC2 Provider. In the Athenz UI select your service that was created in the previous step and click on the icon in the Providers column: Then, click on the Allow button to authorize your service to be launched by AWS EC2 provider.","title":"Athenz Service Identity Authorization"},{"location":"service_x509_credentials_aws/#iam-role-setup","text":"There are two IAM roles required for instances to obtain Athenz X.509 certificates: EC2 Instance Profile Role Athenz Service Identity Assume Role It is assumed that at this point you have already configured the first EC2 Instance Profile IAM Role that your EC2 instance will be launched with. The second Athenz Service Identity IAM Assume Role must be created and must have the <domain>.<service> name. This role will not have any permissions but instead will have a trust relationship with your EC2 instance role such that your EC2 instance role can assume this role. In the AWS Console, select IAM from the Services drop down and then click on the Roles link in the left sidebar. Choose the Create Role button. Under the AWS Service type, select EC2 , then EC2 again for the use case and finally choose Next: Permissions button in the bottom right corner. In the Attach permissions policy screen do not choose any permissions and just click on the Next: Review button in the bottom right corner to continue. Specify the Role name in the <domain>.<service> format and choose Create Role to complete the process. In the Roles list view, choose the role just created and choose the Trust Relationships tab. Click on Edit trust relationship button and append a block containing the following policy to the Statement block (Replace the <account-id> and <ec2-instance-role> values with their corresponding values for your environment: { \"Effect\": \"Allow\", \"Principal\": { \"AWS\": \"arn:aws:iam::<account-id>:role/<ec2-instance-role>\" }, \"Action\": \"sts:AssumeRole\" } Once correctly updated, your EC2 instance role must appear in the Trusted entities table:","title":"IAM Role Setup"},{"location":"service_x509_credentials_aws/#setup-for-services-with-region-specific-instance-profile-roles","text":"The IAM Role setup is identical when you have the same service being deployed in multiple regions with role names that are specific to each region. Since IAM roles are global, you only need to create a single Athenz IAM Role in the <domain>.<service> format. Then, when you're setting up your trust relationship, you'll authorize all your region specific profile roles to have the capability to assume the Athenz <domain>.<service> role.","title":"Setup for Services with Region Specific Instance Profile Roles"},{"location":"service_x509_credentials_aws/#installing-sia","text":"The AWS SIA source is part of the Athenz project and can be found in: provider/aws/sia-ec2 Follow the readme for instructions on how to install it.","title":"Installing SIA"},{"location":"service_x509_credentials_aws/#sia-configuration-setup","text":"When building your image, you can include the following configuration file called sia_config in the /etc/sia directory. It must include the following required fields: { \"version\": \"1.0.0\", \"service\": \"<service name>\", \"accounts\": [ { \"domain\": \"<domain name>\", \"account\": \"<aws account id associated with domain name>\" } ] } The domain/account/service values here must match to the IAM Role created earlier. For example, if the service identity name is api in domain sports whose corresponding aws account id is 123456789 , then the sia_config file will be as follows: { \"version\": \"1.0.0\", \"service\": \"api\", \"accounts\": [ { \"domain\": \"sports\", \"account\": \"123456789\" } ] }","title":"SIA Configuration Setup"},{"location":"service_x509_credentials_aws/#private-key-file-ownership","text":"By default SIA agent runs as root and the private key is only readable by root. If your service is running as another user, you can configure SIA agent to automatically change the ownership of the private key file to the configured user. For example, if you want the private key to be owned by ec2-user , then your sia_config configuration file would be as follows: { \"version\": \"1.0.0\", \"service\": \"api\", \"accounts\": [ { \"domain\": \"sports\", \"account\": \"123456789\", \"user\": \"ec2-user\" } ] }","title":"Private Key File Ownership"},{"location":"service_x509_credentials_aws/#private-key-and-certificate-setup","text":"By default, the private key for the service identity is available in the /var/lib/sia/keys directory and has the name <domain>.<service>.key.pem . The private key is in PKCS#1 format. The corresponding X.509 certificate is in the /var/lib/sia/certs directory and has the name <domain>.<service>.cert.pem . The certificate is valid for 30 days and will be refreshed automatically by SIA every day. It is the responsibility of the application owner to update their container/application to refresh and use the latest certificate before it expires. In the same /var/lib/sia/certs directory SIA will also generate the Athenz CA certificate file called ca.cert.pem .","title":"Private Key and Certificate Setup"},{"location":"service_x509_credentials_aws/#role-certificate-support","text":"In addition to requesting Athenz service identity certificate, SIA provides the capability to request Athenz Role Certificates as well. If you want to change the default behavior or request SIA to automatically retrieve role certificates for your service, as part of building your ami image, you can include the following additional fields in the configuration file: { \"version\": \"1.0.0\", \"service\": \"<service name>\", \"accounts\": [ { \"domain\": \"<domain name>\", \"account\": \"<aws account id associated with domain name>\", \"roles\": { \"<role-domain1>:role.<role-name1>\": { }, \"<role-domain2>:role.<role-name2>\": { } } } ] } The role certificates will also be stored in the /var/lib/sia/certs directory and have the name of <role-domain1>:role.<role-name1>.cert.pem . They are also valid for 30 days and SIA will automatically refresh them once a day.","title":"Role Certificate Support"},{"location":"service_x509_credentials_aws/#setup-without-sia-configuration-file","text":"If a property deploying their service in AWS meets the following 2 requirements: does not need any role certificates to be retrieved by SIA automatically has the option to name their EC2 instance role then they have the option for a simpler setup without including a sia configuration file in their image. In this model, the property would name their EC2 instance role as <domain>.<service>-service . The property must still follow the full steps as described in the IAM Role Setup section to setup the <domain>.<service> role, but the requirement to have a sia_config file is no longer present. When SIA is running and is not able to find the sia_config file, it will check if the instance profile arn has the <domain>.<service>-service format. If it does, then it would drop -service part to parse the rest of the string to extract the Athenz domain and service values and determine the assume role name that it needs to fetch temporary credentials for before contacting ZTS Server.","title":"Setup Without SIA Configuration File"},{"location":"service_x509_credentials_aws/#non-standard-instance-profile-name","text":"If a property deploying their service in AWS does not have the capability to name their instance profile role name as <domain>.<service>-service due to legacy requirements, the following steps can be followed to configure SIA to use the non-standard instance profile name. The property must still follow the full steps as described in the IAM Role Setup section to setup the <domain>.<service> role and the trust relationship. The property must install a SIA config file /etc/sia/sia_config specifying the service name that will be deployed on this instance","title":"Non Standard Instance Profile Name"},{"location":"service_x509_credentials_aws/#independent-instance-profile-and-role-names","text":"It is possible to setup only a single role within AWS IAM in the format <domain>.<service> and name the IAM profile name as <domain>.<service>-service without creating a separate role. However, there is currently no support in the AWS UI console for naming your IAM role and IAM instance profile independently. You can do this with Cloud Formation, Ansible, TF, the AWS API, or the CLI. Here is an example using the CLI - replace <domain> , <service> and <account-id> parameters with their respective values for your environment: aws iam create-role --role-name <domain>.<service> --assume-role-policy-document='{\"Version\":\"2012-10-17\",\"Statement\":[{\"Effect\":\"Allow\",\"Principal\":{\"Service\":\"ec2.amazonaws.com\"},\"Action\":\"sts:AssumeRole\"}]}' aws iam create-instance-profile --instance-profile-name <domain>.<service>-service aws iam update-assume-role-policy --role-name <domain>.<service> --policy-document '{\"Version\":\"2012-10-17\",\"Statement\":[{\"Effect\":\"Allow\",\"Principal\":{\"Service\":\"ec2.amazonaws.com\"},\"Action\":\"sts:AssumeRole\"},{\"Effect\":\"Allow\",\"Principal\":{\"AWS\":\"arn:aws:iam::<account-id>:role/<domain>.<service>\"},\"Action\":\"sts:AssumeRole\"}]}' aws iam add-role-to-instance-profile --instance-profile-name <domain>.<service>-service --role-name <domain>.<service> However, this model is not recommended from security perspective if your <domain>.<service> role has access to other AWS services. Temporary credentials for that role are sent to Athenz ZTS service as your authentication credentials and, as such, you do not want to expose those additional access capabilities to the ZTS Server.","title":"Independent Instance Profile and Role Names"},{"location":"service_x509_credentials_aws/#troubleshooting","text":"SIA process outputs all of its messages to syslog, so if there are any issues with your configuration, it will be reported in syslog. You can execute: sudo grep siad /var/log/messages and see what operation sia was not able to complete successfully. The agent is configured to run every 20 seconds in case of a failure, so you'll most likely see the same block being repeated multiple times. ZTS server allows instances to obtain x.509 certificates only during the first 30 minutes after the initial bootstrap time so even if you address the configuration issues, once the 30 mins have passed, the instance will no longer be able to obtain its x.509 service identity certificate. The only option at that time is to terminate and launch a new instance.","title":"Troubleshooting"},{"location":"service_x509_credentials_aws_ecs/","text":"Domain Registration \u00b6 Identify your Athenz domain before you can proceed by visiting Athenz UI. Follow the instructions documented for EC2 instances to register your domain if one doesn't exist already. AWS Account ID Registration \u00b6 To register an AWS Account with a domain, run the following command: zms-cli -d <domain-name> set-aws-account <aws-account-id> Athenz Service Identity Registration \u00b6 Create a service identity for your AWS ECS containers in your Athenz domain. This full service identity name <domain>.<service> will be the IAM role name that you will need to create in AWS IAM and set up a trust relationship with your ECS Container Role. In the Athenz UI, select your domain, select the Services tab and then choose Add a Service link in the top left corner. You must provide a service name and an optional description for your service. Athenz Service Identity Authorization Role and Policy \u00b6 Before ZTS can validate and issue X.509 TLS Certificates to the AWS ECS, it must validate that the service owner has authorized its service to be launched by AWS ECS Provider. In the Athenz UI select your service that was created in the previous step and click on the icon in the Providers column: Then, click on the Allow button to authorize your service to be launched by AWS ECS provider. ECS Container Metadata Support \u00b6 In AWS the ECS must be configured with metadata support. This is required such that SIA agent can retrieve the Task ID that is used to identify the container uniquely. You need to set the ECS_ENABLE_CONTAINER_METADATA container agent variable to true . You can set this variable in the /etc/ecs/ecs.config configuration file and restart the ecs agent. You can also set it as a Docker environment variable at run time when the agent container is started. For more information, see Amazon ECS Container Metadata . IAM Role Setup \u00b6 There are two IAM roles required for instances to obtain Athenz X.509 certificates: ECS Container Profile Role Athenz Service Identity Assume Role It is assumed that at this point you have already configured the first ECS Container Profile IAM Role that your container will be launched with. The second Athenz Service Identity IAM Assume Role must be created and must have the <domain>.<service> name. This role will not have any permissions but instead will have a trust relationship with your ECS container role such that your ECS container role can assume this role. In the AWS Console, select IAM from the Services drop down and then click on the Roles link in the left sidebar. Choose the Create Role button. Under the AWS Service type, select EC2 , then EC2 again for the use case and finally choose Next: Permissions button in the bottom right corner. In the Attach permissions policy screen do not choose any permissions and just click on the Next: Review button in the bottom right corner to continue. Specify the Role name in the <domain>.<service> format and choose Create Role to complete the process. In the Roles list view, choose the role just created and choose the Trust Relationships tab. Click on Edit trust relationship button and append a block containing the following policy to the Statement block (Replace the <account-id> and <ecs-container-role> values with their corresponding values for your environment: { \"Effect\": \"Allow\", \"Principal\": { \"AWS\": \"arn:aws:iam::<account-id>:role/<ecs-container-role>\" }, \"Action\": \"sts:AssumeRole\" } Once correctly updated, your ECS container role must appear in the Trusted entities table: Installing SIA in Container \u00b6 The AWS SIA source is part of the Athenz project and can be found in: provider/aws/sia-ec2 Follow the readme for instructions on how to install it. Typically you run the siad binary in your container and let it run continuously to register and refresh your service certificate daily since systemd does not run in a typical docker image. If you only want to run siad as a command line utility that just registers and refreshes the service and role certificates when executed, you can use the following command line options (Register must be called once within the first 30 mins when the instance is bootstrapped): Instance Register: /usr/sbin/siad -cmd post Service Certificate Refresh: /usr/sbin/siad -cmd rotate Role Certificate Refresh: /usr/sbin/siad -cmd rolecert SIA Configuration Setup \u00b6 When building your container image, you must include the following configuration file called sia_config in the /etc/sia directory. It must include the following required fields: { \"version\": \"1.0.0\", \"service\": \"<service name>\", \"accounts\": [ { \"domain\": \"<domain name>\", \"account\": \"<aws account id associated with domain name>\" } ] } The domain/account/service values here must match to the IAM Role created earlier. For example, if the service identity name is api in domain sports whose corresponding aws account id is 123456789 , then the sia_config file will be as follows: { \"version\": \"1.0.0\", \"service\": \"api\", \"accounts\": [ { \"domain\": \"sports\", \"account\": \"123456789\" } ] } Private Key File Ownership \u00b6 By default SIA agent runs as root and the private key is only readable by root. If your service is running as another user, you can configure SIA agent to automatically change the ownership of the private key file to the configured user. For example, if you want the private key to be owned by ec2-user , then your sia_config configuration file would be as follows: { \"version\": \"1.0.0\", \"service\": \"api\", \"accounts\": [ { \"domain\": \"sports\", \"account\": \"123456789\", \"user\": \"ec2-user\" } ] } Private Key and Certificate Setup \u00b6 By default, the private key for the service identity is available in the /var/lib/sia/keys directory and has the name <domain>.<service>.key.pem . The private key is in PKCS#1 format. The corresponding X.509 certificate is in the /var/lib/sia/certs directory and has the name <domain>.<service>.cert.pem . The certificate is valid for 30 days and will be refreshed automatically by SIA every day. It is the responsibility of the application owner to update their container/application to refresh and use the latest certificate before it expires. In the same /var/lib/sia/certs directory SIA will also generate the Athenz CA certificate file called ca.cert.pem . In addition to requesting Athenz service identity certificate, SIA provides the capability to request Athenz Role Certificates as well. If you want to change the default behavior or request SIA to automatically retrieve role certificates for your service, as part of building your ami image, you can include the following additional fields in the configuration file: { \"version\": \"1.0.0\", \"service\": \"<service name>\", \"accounts\": [ { \"domain\": \"<domain name>\", \"account\": \"<aws account id associated with domain name>\", \"roles\": { \"<role-domain1>:role.<role-name1>\": { }, \"<role-domain2>:role.<role-name2>\": { } } } ] } The role certificates will also be stored in the /var/lib/sia/certs directory and have the name of <role-domain1>:role.<role-name1>.cert.pem . They are also valid for 30 days and SIA will automatically refresh them once a day.","title":"Athenz Service Identity X.509 Certificate for AWS ECS containers"},{"location":"service_x509_credentials_aws_ecs/#domain-registration","text":"Identify your Athenz domain before you can proceed by visiting Athenz UI. Follow the instructions documented for EC2 instances to register your domain if one doesn't exist already.","title":"Domain Registration"},{"location":"service_x509_credentials_aws_ecs/#aws-account-id-registration","text":"To register an AWS Account with a domain, run the following command: zms-cli -d <domain-name> set-aws-account <aws-account-id>","title":"AWS Account ID Registration"},{"location":"service_x509_credentials_aws_ecs/#athenz-service-identity-registration","text":"Create a service identity for your AWS ECS containers in your Athenz domain. This full service identity name <domain>.<service> will be the IAM role name that you will need to create in AWS IAM and set up a trust relationship with your ECS Container Role. In the Athenz UI, select your domain, select the Services tab and then choose Add a Service link in the top left corner. You must provide a service name and an optional description for your service.","title":"Athenz Service Identity Registration"},{"location":"service_x509_credentials_aws_ecs/#athenz-service-identity-authorization-role-and-policy","text":"Before ZTS can validate and issue X.509 TLS Certificates to the AWS ECS, it must validate that the service owner has authorized its service to be launched by AWS ECS Provider. In the Athenz UI select your service that was created in the previous step and click on the icon in the Providers column: Then, click on the Allow button to authorize your service to be launched by AWS ECS provider.","title":"Athenz Service Identity Authorization Role and Policy"},{"location":"service_x509_credentials_aws_ecs/#ecs-container-metadata-support","text":"In AWS the ECS must be configured with metadata support. This is required such that SIA agent can retrieve the Task ID that is used to identify the container uniquely. You need to set the ECS_ENABLE_CONTAINER_METADATA container agent variable to true . You can set this variable in the /etc/ecs/ecs.config configuration file and restart the ecs agent. You can also set it as a Docker environment variable at run time when the agent container is started. For more information, see Amazon ECS Container Metadata .","title":"ECS Container Metadata Support"},{"location":"service_x509_credentials_aws_ecs/#iam-role-setup","text":"There are two IAM roles required for instances to obtain Athenz X.509 certificates: ECS Container Profile Role Athenz Service Identity Assume Role It is assumed that at this point you have already configured the first ECS Container Profile IAM Role that your container will be launched with. The second Athenz Service Identity IAM Assume Role must be created and must have the <domain>.<service> name. This role will not have any permissions but instead will have a trust relationship with your ECS container role such that your ECS container role can assume this role. In the AWS Console, select IAM from the Services drop down and then click on the Roles link in the left sidebar. Choose the Create Role button. Under the AWS Service type, select EC2 , then EC2 again for the use case and finally choose Next: Permissions button in the bottom right corner. In the Attach permissions policy screen do not choose any permissions and just click on the Next: Review button in the bottom right corner to continue. Specify the Role name in the <domain>.<service> format and choose Create Role to complete the process. In the Roles list view, choose the role just created and choose the Trust Relationships tab. Click on Edit trust relationship button and append a block containing the following policy to the Statement block (Replace the <account-id> and <ecs-container-role> values with their corresponding values for your environment: { \"Effect\": \"Allow\", \"Principal\": { \"AWS\": \"arn:aws:iam::<account-id>:role/<ecs-container-role>\" }, \"Action\": \"sts:AssumeRole\" } Once correctly updated, your ECS container role must appear in the Trusted entities table:","title":"IAM Role Setup"},{"location":"service_x509_credentials_aws_ecs/#installing-sia-in-container","text":"The AWS SIA source is part of the Athenz project and can be found in: provider/aws/sia-ec2 Follow the readme for instructions on how to install it. Typically you run the siad binary in your container and let it run continuously to register and refresh your service certificate daily since systemd does not run in a typical docker image. If you only want to run siad as a command line utility that just registers and refreshes the service and role certificates when executed, you can use the following command line options (Register must be called once within the first 30 mins when the instance is bootstrapped): Instance Register: /usr/sbin/siad -cmd post Service Certificate Refresh: /usr/sbin/siad -cmd rotate Role Certificate Refresh: /usr/sbin/siad -cmd rolecert","title":"Installing SIA in Container"},{"location":"service_x509_credentials_aws_ecs/#sia-configuration-setup","text":"When building your container image, you must include the following configuration file called sia_config in the /etc/sia directory. It must include the following required fields: { \"version\": \"1.0.0\", \"service\": \"<service name>\", \"accounts\": [ { \"domain\": \"<domain name>\", \"account\": \"<aws account id associated with domain name>\" } ] } The domain/account/service values here must match to the IAM Role created earlier. For example, if the service identity name is api in domain sports whose corresponding aws account id is 123456789 , then the sia_config file will be as follows: { \"version\": \"1.0.0\", \"service\": \"api\", \"accounts\": [ { \"domain\": \"sports\", \"account\": \"123456789\" } ] }","title":"SIA Configuration Setup"},{"location":"service_x509_credentials_aws_ecs/#private-key-file-ownership","text":"By default SIA agent runs as root and the private key is only readable by root. If your service is running as another user, you can configure SIA agent to automatically change the ownership of the private key file to the configured user. For example, if you want the private key to be owned by ec2-user , then your sia_config configuration file would be as follows: { \"version\": \"1.0.0\", \"service\": \"api\", \"accounts\": [ { \"domain\": \"sports\", \"account\": \"123456789\", \"user\": \"ec2-user\" } ] }","title":"Private Key File Ownership"},{"location":"service_x509_credentials_aws_ecs/#private-key-and-certificate-setup","text":"By default, the private key for the service identity is available in the /var/lib/sia/keys directory and has the name <domain>.<service>.key.pem . The private key is in PKCS#1 format. The corresponding X.509 certificate is in the /var/lib/sia/certs directory and has the name <domain>.<service>.cert.pem . The certificate is valid for 30 days and will be refreshed automatically by SIA every day. It is the responsibility of the application owner to update their container/application to refresh and use the latest certificate before it expires. In the same /var/lib/sia/certs directory SIA will also generate the Athenz CA certificate file called ca.cert.pem . In addition to requesting Athenz service identity certificate, SIA provides the capability to request Athenz Role Certificates as well. If you want to change the default behavior or request SIA to automatically retrieve role certificates for your service, as part of building your ami image, you can include the following additional fields in the configuration file: { \"version\": \"1.0.0\", \"service\": \"<service name>\", \"accounts\": [ { \"domain\": \"<domain name>\", \"account\": \"<aws account id associated with domain name>\", \"roles\": { \"<role-domain1>:role.<role-name1>\": { }, \"<role-domain2>:role.<role-name2>\": { } } } ] } The role certificates will also be stored in the /var/lib/sia/certs directory and have the name of <role-domain1>:role.<role-name1>.cert.pem . They are also valid for 30 days and SIA will automatically refresh them once a day.","title":"Private Key and Certificate Setup"},{"location":"service_x509_credentials_aws_eks/","text":"Domain Registration \u00b6 Identify your Athenz domain before you can proceed by visiting Athenz UI. Follow the instructions documented for EC2 instances to register your domain if one doesn't exist already. AWS Account ID Registration \u00b6 To register an AWS Account with a domain, run the following command: zms-cli -d <domain-name> set-aws-account <aws-account-id> Athenz Service Identity Registration \u00b6 Create a service identity for your AWS EKS in your Athenz domain. This full service identity name <domain>.<service> will be the IAM role name that you will need to create in AWS IAM and set up a trust relationship with your EKS pod role. In the Athenz UI, select your domain, select the Services tab and then choose Add a Service link in the top left corner. You must provide a service name and an optional description for your service. Athenz Service Identity Authorization Role and Policy \u00b6 Before ZTS can validate and issue X.509 TLS Certificates to the AWS EKS pods, it must validate that the service owner has authorized its service to be launched by AWS EKS Provider. In the Athenz UI select your service that was created in the previous step and click on the icon in the Providers column: Then, click on the Allow button to authorize your service to be launched by AWS EC2/EKS/Fargate provider. IAM Role Setup \u00b6 There are two IAM roles required for instances to obtain Athenz X.509 certificates: EKS Role Athenz Service Identity Assume Role It is assumed that at this point you have already configured the first EKS Role that your pods will be launched with. This recommended name for this role is <domain>.<service>-service since this allows to automatically determine the service name (by stripping the -service suffix) without requiring the administrator to provide a sia_config file as part of the bootstrap. The second Athenz Service Identity IAM Assume Role must be created and must have the <domain>.<service> name. This role will not have any permissions but instead will have a trust relationship with your EKS pod role such that your EKS pod role can assume this role. In the AWS Console, select IAM from the Services drop down and then click on the Roles link in the left sidebar. Choose the Create Role button. Under the AWS Service type, select EKS and choose Next: Permissions button in the bottom right corner. In the Attach permissions policy screen do not choose any permissions and just click on the Next: Review button in the bottom right corner to continue. Specify the Role name in the <domain>.<service> format and choose Create Role to complete the process. In the Roles list view, choose the role just created and choose the Trust Relationships tab. Click on Edit trust relationship button and append a block containing the following policy to the Statement block Replace the <account-id> and <eks-pod-role> values with their corresponding values for your environment: { \"Effect\": \"Allow\", \"Principal\": { \"AWS\": \"arn:aws:iam::<account-id>:role/<eks-pod-role>\" }, \"Action\": \"sts:AssumeRole\" } Once correctly updated, your EKS pod role must appear in the Trusted entities table. Installing SIA in Container \u00b6 The AWS SIA source is part of the Athenz project and can be found in: provider/aws/sia-ec2 Follow the readme for instructions on how to install it. Typically you run the siad binary in your container and let it run continuously to register and refresh your service certificate daily since systemd does not run in a typical docker image. If you only want to run siad as a command line utility that just registers and refreshes the service and role certificates when executed, you can use the following command line options (Register must be called once within the first 30 mins when the instance is bootstrapped): Instance Register: /usr/sbin/siad -cmd post Service Certificate Refresh: /usr/sbin/siad -cmd rotate Role Certificate Refresh: /usr/sbin/siad -cmd rolecert Expiry Time \u00b6 Unlike EC2, Athenz x.509 Certificate for EKS are only issued for 7 days only due to different security requirements.","title":"Athenz Service Identity X.509 Certificate for AWS EKS pods"},{"location":"service_x509_credentials_aws_eks/#domain-registration","text":"Identify your Athenz domain before you can proceed by visiting Athenz UI. Follow the instructions documented for EC2 instances to register your domain if one doesn't exist already.","title":"Domain Registration"},{"location":"service_x509_credentials_aws_eks/#aws-account-id-registration","text":"To register an AWS Account with a domain, run the following command: zms-cli -d <domain-name> set-aws-account <aws-account-id>","title":"AWS Account ID Registration"},{"location":"service_x509_credentials_aws_eks/#athenz-service-identity-registration","text":"Create a service identity for your AWS EKS in your Athenz domain. This full service identity name <domain>.<service> will be the IAM role name that you will need to create in AWS IAM and set up a trust relationship with your EKS pod role. In the Athenz UI, select your domain, select the Services tab and then choose Add a Service link in the top left corner. You must provide a service name and an optional description for your service.","title":"Athenz Service Identity Registration"},{"location":"service_x509_credentials_aws_eks/#athenz-service-identity-authorization-role-and-policy","text":"Before ZTS can validate and issue X.509 TLS Certificates to the AWS EKS pods, it must validate that the service owner has authorized its service to be launched by AWS EKS Provider. In the Athenz UI select your service that was created in the previous step and click on the icon in the Providers column: Then, click on the Allow button to authorize your service to be launched by AWS EC2/EKS/Fargate provider.","title":"Athenz Service Identity Authorization Role and Policy"},{"location":"service_x509_credentials_aws_eks/#iam-role-setup","text":"There are two IAM roles required for instances to obtain Athenz X.509 certificates: EKS Role Athenz Service Identity Assume Role It is assumed that at this point you have already configured the first EKS Role that your pods will be launched with. This recommended name for this role is <domain>.<service>-service since this allows to automatically determine the service name (by stripping the -service suffix) without requiring the administrator to provide a sia_config file as part of the bootstrap. The second Athenz Service Identity IAM Assume Role must be created and must have the <domain>.<service> name. This role will not have any permissions but instead will have a trust relationship with your EKS pod role such that your EKS pod role can assume this role. In the AWS Console, select IAM from the Services drop down and then click on the Roles link in the left sidebar. Choose the Create Role button. Under the AWS Service type, select EKS and choose Next: Permissions button in the bottom right corner. In the Attach permissions policy screen do not choose any permissions and just click on the Next: Review button in the bottom right corner to continue. Specify the Role name in the <domain>.<service> format and choose Create Role to complete the process. In the Roles list view, choose the role just created and choose the Trust Relationships tab. Click on Edit trust relationship button and append a block containing the following policy to the Statement block Replace the <account-id> and <eks-pod-role> values with their corresponding values for your environment: { \"Effect\": \"Allow\", \"Principal\": { \"AWS\": \"arn:aws:iam::<account-id>:role/<eks-pod-role>\" }, \"Action\": \"sts:AssumeRole\" } Once correctly updated, your EKS pod role must appear in the Trusted entities table.","title":"IAM Role Setup"},{"location":"service_x509_credentials_aws_eks/#installing-sia-in-container","text":"The AWS SIA source is part of the Athenz project and can be found in: provider/aws/sia-ec2 Follow the readme for instructions on how to install it. Typically you run the siad binary in your container and let it run continuously to register and refresh your service certificate daily since systemd does not run in a typical docker image. If you only want to run siad as a command line utility that just registers and refreshes the service and role certificates when executed, you can use the following command line options (Register must be called once within the first 30 mins when the instance is bootstrapped): Instance Register: /usr/sbin/siad -cmd post Service Certificate Refresh: /usr/sbin/siad -cmd rotate Role Certificate Refresh: /usr/sbin/siad -cmd rolecert","title":"Installing SIA in Container"},{"location":"service_x509_credentials_aws_eks/#expiry-time","text":"Unlike EC2, Athenz x.509 Certificate for EKS are only issued for 7 days only due to different security requirements.","title":"Expiry Time"},{"location":"service_x509_credentials_aws_fargate/","text":"Domain Registration \u00b6 Identify your Athenz domain before you can proceed by visiting Athenz UI. Follow the instructions documented for EC2 instances to register your domain if one doesn't exist already. AWS Account ID Registration \u00b6 To register an AWS Account with a domain, run the following command: zms-cli -d <domain-name> set-aws-account <aws-account-id> Athenz Service Identity Registration \u00b6 Create a service identity for your AWS Fargate task in your Athenz domain. This full service identity name <domain>.<service> will be the IAM role name that you will need to create in AWS IAM and set up a trust relationship with your Fargate Task Service Role. In the Athenz UI, select your domain, select the Services tab and then choose Add a Service link in the top left corner. You must provide a service name and an optional description for your service. Since this is for AWS Fargate, you do not need to provide a public key as we'll obtain a client certificate based on AWS credentials. Athenz Service Identity Authorization Role and Policy \u00b6 Before ZTS can validate and issue X.509 TLS Certificates to the AWS Fargate tasks, it must validate that the service owner has authorized its service to be launched by AWS Fargate Provider. In the Athenz UI select your service that was created in the previous step and click on the icon in the Providers column: Then, click on the Allow button to authorize your service to be launched by AWS EC2/EKS/Fargate provider. IAM Role Setup \u00b6 There are two IAM roles required for instances to obtain Athenz X.509 certificates: Fargate Task Role Athenz Service Identity Assume Role It is assumed that at this point you have already configured the first Fargate Task Role that your code will be launched with. This recommended name for this role is <domain>.<service>-service since this allows to automatically determine the service name (by stripping the -service suffix) without requiring the administrator to provide a sia_config file as part of the bootstrap. The second Athenz Service Identity IAM Assume Role must be created and must have the <domain>.<service> name. This role will not have any permissions but instead will have a trust relationship with your Fargate task role such that your Fargate task role can assume this role. In the AWS Console, select IAM from the Services drop down and then click on the Roles link in the left sidebar. Choose the Create Role button. Under the AWS Service type, select Elastic Container Service and choose Next: Permissions button in the bottom right corner. In the Attach permissions policy screen do not choose any permissions and just click on the Next: Review button in the bottom right corner to continue. Specify the Role name in the <domain>.<service> format and choose Create Role to complete the process. In the Roles list view, choose the role just created and choose the Trust Relationships tab. Click on Edit trust relationship button and append a block containing the following policy to the Statement block Replace the <account-id> and <fargate-task-role> values with their corresponding values for your environment: { \"Effect\": \"Allow\", \"Principal\": { \"AWS\": \"arn:aws:iam::<account-id>:role/<fargate-task-role>\" }, \"Action\": \"sts:AssumeRole\" } Once correctly updated, your Fargate task role must appear in the Trusted entities table. Installing SIA in Container \u00b6 The AWS SIA source is part of the Athenz project and can be found in: provider/aws/sia-ec2 Follow the readme for instructions on how to install it. Typically you run the siad binary in your container and let it run continuously to register and refresh your service certificate daily since systemd does not run in a typical docker image. If you only want to run siad as a command line utility that just registers and refreshes the service and role certificates when executed, you can use the following command line options (Register must be called once within the first 30 mins when the instance is bootstrapped): Instance Register: /usr/sbin/siad -cmd post Service Certificate Refresh: /usr/sbin/siad -cmd rotate Role Certificate Refresh: /usr/sbin/siad -cmd rolecert Expiry Time \u00b6 Unlike EC2, Athenz x.509 Certificate for Fargate are only issued for 7 days only due to different security requirements.","title":"Athenz Service Identity X.509 Certificate for AWS Fargate tasks"},{"location":"service_x509_credentials_aws_fargate/#domain-registration","text":"Identify your Athenz domain before you can proceed by visiting Athenz UI. Follow the instructions documented for EC2 instances to register your domain if one doesn't exist already.","title":"Domain Registration"},{"location":"service_x509_credentials_aws_fargate/#aws-account-id-registration","text":"To register an AWS Account with a domain, run the following command: zms-cli -d <domain-name> set-aws-account <aws-account-id>","title":"AWS Account ID Registration"},{"location":"service_x509_credentials_aws_fargate/#athenz-service-identity-registration","text":"Create a service identity for your AWS Fargate task in your Athenz domain. This full service identity name <domain>.<service> will be the IAM role name that you will need to create in AWS IAM and set up a trust relationship with your Fargate Task Service Role. In the Athenz UI, select your domain, select the Services tab and then choose Add a Service link in the top left corner. You must provide a service name and an optional description for your service. Since this is for AWS Fargate, you do not need to provide a public key as we'll obtain a client certificate based on AWS credentials.","title":"Athenz Service Identity Registration"},{"location":"service_x509_credentials_aws_fargate/#athenz-service-identity-authorization-role-and-policy","text":"Before ZTS can validate and issue X.509 TLS Certificates to the AWS Fargate tasks, it must validate that the service owner has authorized its service to be launched by AWS Fargate Provider. In the Athenz UI select your service that was created in the previous step and click on the icon in the Providers column: Then, click on the Allow button to authorize your service to be launched by AWS EC2/EKS/Fargate provider.","title":"Athenz Service Identity Authorization Role and Policy"},{"location":"service_x509_credentials_aws_fargate/#iam-role-setup","text":"There are two IAM roles required for instances to obtain Athenz X.509 certificates: Fargate Task Role Athenz Service Identity Assume Role It is assumed that at this point you have already configured the first Fargate Task Role that your code will be launched with. This recommended name for this role is <domain>.<service>-service since this allows to automatically determine the service name (by stripping the -service suffix) without requiring the administrator to provide a sia_config file as part of the bootstrap. The second Athenz Service Identity IAM Assume Role must be created and must have the <domain>.<service> name. This role will not have any permissions but instead will have a trust relationship with your Fargate task role such that your Fargate task role can assume this role. In the AWS Console, select IAM from the Services drop down and then click on the Roles link in the left sidebar. Choose the Create Role button. Under the AWS Service type, select Elastic Container Service and choose Next: Permissions button in the bottom right corner. In the Attach permissions policy screen do not choose any permissions and just click on the Next: Review button in the bottom right corner to continue. Specify the Role name in the <domain>.<service> format and choose Create Role to complete the process. In the Roles list view, choose the role just created and choose the Trust Relationships tab. Click on Edit trust relationship button and append a block containing the following policy to the Statement block Replace the <account-id> and <fargate-task-role> values with their corresponding values for your environment: { \"Effect\": \"Allow\", \"Principal\": { \"AWS\": \"arn:aws:iam::<account-id>:role/<fargate-task-role>\" }, \"Action\": \"sts:AssumeRole\" } Once correctly updated, your Fargate task role must appear in the Trusted entities table.","title":"IAM Role Setup"},{"location":"service_x509_credentials_aws_fargate/#installing-sia-in-container","text":"The AWS SIA source is part of the Athenz project and can be found in: provider/aws/sia-ec2 Follow the readme for instructions on how to install it. Typically you run the siad binary in your container and let it run continuously to register and refresh your service certificate daily since systemd does not run in a typical docker image. If you only want to run siad as a command line utility that just registers and refreshes the service and role certificates when executed, you can use the following command line options (Register must be called once within the first 30 mins when the instance is bootstrapped): Instance Register: /usr/sbin/siad -cmd post Service Certificate Refresh: /usr/sbin/siad -cmd rotate Role Certificate Refresh: /usr/sbin/siad -cmd rolecert","title":"Installing SIA in Container"},{"location":"service_x509_credentials_aws_fargate/#expiry-time","text":"Unlike EC2, Athenz x.509 Certificate for Fargate are only issued for 7 days only due to different security requirements.","title":"Expiry Time"},{"location":"service_x509_credentials_aws_lambda/","text":"Important: Certificate Signing is an expensive operation (both on the client and the server side) so if your application is going to launch large number of instances of your lambda function, then you must not fetch Athenz x.509 certificates directly within your lambda function. The recommended approach for that scenario is have one lambda function to fetch the Athenz X.509 Certificate Identity private key and the public certificate, store them in AWS Parameter Store and update those daily. Then have all other lambda functions authorized based on their IAM credentials to fetch and use that x.509 certificate. Domain Registration \u00b6 Identify your Athenz domain before you can proceed by visiting Athenz UI. Follow the instructions documented for EC2 instances to register your domain if one doesn't exist already. AWS Account ID Registration \u00b6 To register an AWS Account with a domain, run the following command: zms-cli -d <domain-name> set-aws-account <aws-account-id> Athenz Service Identity Registration \u00b6 Create a service identity for your AWS Lambda function in your Athenz domain. This full service identity name <domain>.<service> will be the IAM role name that you will need to create in AWS IAM and set up a trust relationship with your Lambda Function Execution Role. In the Athenz UI, select your domain, select the Services tab and then choose Add a Service link in the top left corner. You must provide a service name and an optional description for your service. Athenz Service Identity Authorization Role and Policy \u00b6 Before ZTS can validate and issue X.509 TLS Certificates to the AWS Lambda, it must validate that the service owner has authorized its service to be launched by AWS Lambda Provider. The following role and policy must be created in your Athenz domain for this authorization: When viewing your domain details, choose the Roles tab and select Add Role link on the left side of the screen underneath the tab names. Role details are as follows (don't forget to press the Add button after specifying the role member before pressing the Submit button): Role Category: Regular Role Name: aws_lambda_launch_provider Add Member(s): athens.aws-lambda.* Then choose the Policies tab and select Add Policy link on the left side of the screen underneath the tab names. Policy details are as follows (make sure to replace <your-service-name> in the Rule Resource with your actual service name): Policy Name: aws_lambda_launch_provider Rule Effect: Allow Rule Action: launch Rule Role: aws_lambda_launch_provider Rule Resource: service.<your-service-name> IAM Role Setup \u00b6 There are two IAM roles required for instances to obtain Athenz X.509 certificates: Lambda Function Execution Role Athenz Service Identity Assume Role It is assumed that at this point you have already configured the first Lambda Function Execution Role that your code will be launched with (roles created through the AWS console are created with /service-role/ path). The second Athenz Service Identity IAM Assume Role must be created and must have the <domain>.<service> name. This role will not have any permissions but instead will have a trust relationship with your Lambda execution role such that your Lambda execution role can assume this role. In the AWS Console, select IAM from the Services drop down and then click on the Roles link in the left sidebar. Choose the Create Role button. Under the AWS Service type, select Lambda and choose Next: Permissions button in the bottom right corner. In the Attach permissions policy screen do not choose any permissions and just click on the Next: Review button in the bottom right corner to continue. Specify the Role name in the <domain>.<service> format and choose Create Role to complete the process. In the Roles list view, choose the role just created and choose the Trust Relationships tab. Click on Edit trust relationship button and append a block containing the following policy to the Statement block Replace the <account-id> and <lambda-execution-role> values with their corresponding values for your environment. For the <lambda-execution-role> make sure to include the full path since roles created through the AWS console are created with /service-role/ path: { \"Effect\": \"Allow\", \"Principal\": { \"AWS\": \"arn:aws:iam::<account-id>:role/<lambda-execution-role>\" }, \"Action\": \"sts:AssumeRole\" } Once correctly updated, your Lambda role must appear in the Trusted entities table: Private Key and Certificate Setup \u00b6 Since we're dealing with functions in this use case, we cannot have a SIA agent daemon running to generate a private key for the service and then retrieve a corresponding x.509 certificate from the ZTS Server. Instead, the function being invoked will be responsible for generating a private key and then a csr for its request. Finally, it will submit that request to the ZTS Server to retrieve its X.509 certificate which then it can use along with its generated private key to establish TLS connections to other Verizon Media Athenz enabled services. Athenz Team provides functions/methods in Go and Java programming languages to quickly generate a private key and request its corresponding X.509 certificate from ZTS Server. Important consideration when dealing with Lambda functions: The code to do this needs to prefetch and cache the certificate in a way that does not block every invocation, as minting a new certificate is somewhat expensive. The short lifetime and stateless nature of the function means it cannot rotate its certificates. It just gets new ones when needed. Java \u00b6 The following function is available in the Athenz ZTS Java Client: /** * For AWS Lambda functions generate a new private key, request a * x.509 certificate based on the requested CSR and return both to * the client in order to establish tls connections with other * Athenz enabled services. * @param domainName name of the athenz domain * @param serviceName name of the athenz service * @param account AWS account name that the function runs in * @param provider name of the provider service for AWS Lambda * @return AWSLambdaIdentity with private key and certificate */ public AWSLambdaIdentity getAWSLambdaServiceCertificate(String domainName, String serviceName, String account, String provider); For example, here is a quick program that can be compiled and packaged into lambda.jar and deployed as a Lambda function in AWS. It retrieves a private key and the corresponding x.509 certificate and returns as output. First you need to update your Java project pom.xml file to indicate the dependency on the Athenz zts java client libraries. Checkout the Maven Central ZTS Java Client Package pages to make sure you're using the latest release version: <dependencies> <dependency> <groupId> com.yahoo.athenz </groupId> <artifactId> athenz-zts-java-client </artifactId> <version> 1.10.4 </version> </dependency> </dependencies> Next, is the Lambda function handler implementation: package com.amazonaws.lambda.demo; import com.amazonaws.services.lambda.runtime.Context; import com.amazonaws.services.lambda.runtime.RequestHandler; import com.yahoo.athenz.zts.AWSLambdaIdentity; import com.yahoo.athenz.zts.ZTSClient; public class LambdaFunctionHandler implements RequestHandler<Object, String> { @Override public String handleRequest(Object input, Context context) { final String athenzDomain = \"athens\"; // replace this with your domain name final String athenzService = \"lambda\"; // replace this with your service name final String awsAccount = \"123456789\"; // replace this with your account number final String athenzProvider = \"<lambada-name>.<lambada region>\"; // replace with labada name and region. for example: \"athens.aws-labmda.us-west-2\" final String ztsUrl = \"https://zts-address/zts/v1\"; // replace this with your zts Url (ending with /zts/v1) final String certDn = \"ou=Athenz,o=Oath\"; // the dn you want included in cert final String certDomain = \"aws.cert.domain\"; // cert domain // our key and cert to display for test purposes String certificate; String privateKey; // generate a private key and retrieve the corresponding // certificate from Athenz ZTS Service try (ZTSClient client = new ZTSClient(ztsUrl)) { ZTSClient.setX509CsrDetails(certDn, certDomain); AWSLambdaIdentity lambdaIdentity = client.getAWSLambdaServiceCertificate(athenzDomain, athenzService, awsAccount, athenzProvider); certificate = lambdaIdentity.getX509Certificate().toString(); privateKey = lambdaIdentity.getPrivateKey().toString(); } // just return our data so we can see it in our aws console return \"Lambda - Private Key: \" + privateKey + \" Certificate: \" + certificate; } } Go \u00b6 The following function is available in the /sia-ec2/util package: func GetAWSLambdaServiceCertificate(ztsUrl, domain, service, account, region string) (tls.Certificate, error) Change the ztsUrl field with your zts (ending with /zts/v1 ). The domain is your Athenz domain name while service is the service name that your Lambda function will run as. The account field is the AWS account id while region is where this function will be running. For example, here is a quick program that can be compiled and packaged into main.zip and deployed as a Lambda function in AWS. It retrieves a private key and the corresponding x.509 certificate and returns as output. package main import ( \"crypto/rsa\" \"encoding/pem\" \"fmt\" \"github.com/aws/aws-lambda-go/lambda\" \"util\" ) type Request struct { Zts string `json:\"zts\"` Region string `json:\"region\"` Domain string `json:\"domain\"` Account string `json:\"account\"` Service string `json:\"service\"` } type Response struct { PrivateKey string `json:\"privatekey\"` X509Certificate string `json:\"certificate\"` Message string `json:\"message\"` } func Handler(req Request) (Response, error) { x509Cert, err := util.GetAWSLambdaServiceCertificate(req.Zts, req.Domain, req.Service, req.Account, req.Region) var resp Response if err != nil { resp.Message = fmt.Sprintf(\"Unable to get certificate: %v\", err) } else { resp.PrivateKey = util.PrivatePem(x509Cert.PrivateKey.(*rsa.PrivateKey)) resp.X509Certificate = string(pem.EncodeToMemory(&pem.Block{Type: \"CERTIFICATE\", Bytes: x509Cert.Certificate[0]})) resp.Message = \"Success\" } return resp, err } func main() { lambda.Start(Handler) } Here is a sample input for this function. Our domain is called athens and the service is called lambda-function-test. { \"zts\": \"https://zts.com:4443/zts/v1\", \"region\": \"us-west-2\", \"domain\": \"athens\", \"service\": \"lambda-function-test\", \"account\": \"123456789\" }","title":"Athenz Service Identity X.509 Certificate for AWS Lambda functions"},{"location":"service_x509_credentials_aws_lambda/#domain-registration","text":"Identify your Athenz domain before you can proceed by visiting Athenz UI. Follow the instructions documented for EC2 instances to register your domain if one doesn't exist already.","title":"Domain Registration"},{"location":"service_x509_credentials_aws_lambda/#aws-account-id-registration","text":"To register an AWS Account with a domain, run the following command: zms-cli -d <domain-name> set-aws-account <aws-account-id>","title":"AWS Account ID Registration"},{"location":"service_x509_credentials_aws_lambda/#athenz-service-identity-registration","text":"Create a service identity for your AWS Lambda function in your Athenz domain. This full service identity name <domain>.<service> will be the IAM role name that you will need to create in AWS IAM and set up a trust relationship with your Lambda Function Execution Role. In the Athenz UI, select your domain, select the Services tab and then choose Add a Service link in the top left corner. You must provide a service name and an optional description for your service.","title":"Athenz Service Identity Registration"},{"location":"service_x509_credentials_aws_lambda/#athenz-service-identity-authorization-role-and-policy","text":"Before ZTS can validate and issue X.509 TLS Certificates to the AWS Lambda, it must validate that the service owner has authorized its service to be launched by AWS Lambda Provider. The following role and policy must be created in your Athenz domain for this authorization: When viewing your domain details, choose the Roles tab and select Add Role link on the left side of the screen underneath the tab names. Role details are as follows (don't forget to press the Add button after specifying the role member before pressing the Submit button): Role Category: Regular Role Name: aws_lambda_launch_provider Add Member(s): athens.aws-lambda.* Then choose the Policies tab and select Add Policy link on the left side of the screen underneath the tab names. Policy details are as follows (make sure to replace <your-service-name> in the Rule Resource with your actual service name): Policy Name: aws_lambda_launch_provider Rule Effect: Allow Rule Action: launch Rule Role: aws_lambda_launch_provider Rule Resource: service.<your-service-name>","title":"Athenz Service Identity Authorization Role and Policy"},{"location":"service_x509_credentials_aws_lambda/#iam-role-setup","text":"There are two IAM roles required for instances to obtain Athenz X.509 certificates: Lambda Function Execution Role Athenz Service Identity Assume Role It is assumed that at this point you have already configured the first Lambda Function Execution Role that your code will be launched with (roles created through the AWS console are created with /service-role/ path). The second Athenz Service Identity IAM Assume Role must be created and must have the <domain>.<service> name. This role will not have any permissions but instead will have a trust relationship with your Lambda execution role such that your Lambda execution role can assume this role. In the AWS Console, select IAM from the Services drop down and then click on the Roles link in the left sidebar. Choose the Create Role button. Under the AWS Service type, select Lambda and choose Next: Permissions button in the bottom right corner. In the Attach permissions policy screen do not choose any permissions and just click on the Next: Review button in the bottom right corner to continue. Specify the Role name in the <domain>.<service> format and choose Create Role to complete the process. In the Roles list view, choose the role just created and choose the Trust Relationships tab. Click on Edit trust relationship button and append a block containing the following policy to the Statement block Replace the <account-id> and <lambda-execution-role> values with their corresponding values for your environment. For the <lambda-execution-role> make sure to include the full path since roles created through the AWS console are created with /service-role/ path: { \"Effect\": \"Allow\", \"Principal\": { \"AWS\": \"arn:aws:iam::<account-id>:role/<lambda-execution-role>\" }, \"Action\": \"sts:AssumeRole\" } Once correctly updated, your Lambda role must appear in the Trusted entities table:","title":"IAM Role Setup"},{"location":"service_x509_credentials_aws_lambda/#private-key-and-certificate-setup","text":"Since we're dealing with functions in this use case, we cannot have a SIA agent daemon running to generate a private key for the service and then retrieve a corresponding x.509 certificate from the ZTS Server. Instead, the function being invoked will be responsible for generating a private key and then a csr for its request. Finally, it will submit that request to the ZTS Server to retrieve its X.509 certificate which then it can use along with its generated private key to establish TLS connections to other Verizon Media Athenz enabled services. Athenz Team provides functions/methods in Go and Java programming languages to quickly generate a private key and request its corresponding X.509 certificate from ZTS Server. Important consideration when dealing with Lambda functions: The code to do this needs to prefetch and cache the certificate in a way that does not block every invocation, as minting a new certificate is somewhat expensive. The short lifetime and stateless nature of the function means it cannot rotate its certificates. It just gets new ones when needed.","title":"Private Key and Certificate Setup"},{"location":"service_x509_credentials_aws_lambda/#java","text":"The following function is available in the Athenz ZTS Java Client: /** * For AWS Lambda functions generate a new private key, request a * x.509 certificate based on the requested CSR and return both to * the client in order to establish tls connections with other * Athenz enabled services. * @param domainName name of the athenz domain * @param serviceName name of the athenz service * @param account AWS account name that the function runs in * @param provider name of the provider service for AWS Lambda * @return AWSLambdaIdentity with private key and certificate */ public AWSLambdaIdentity getAWSLambdaServiceCertificate(String domainName, String serviceName, String account, String provider); For example, here is a quick program that can be compiled and packaged into lambda.jar and deployed as a Lambda function in AWS. It retrieves a private key and the corresponding x.509 certificate and returns as output. First you need to update your Java project pom.xml file to indicate the dependency on the Athenz zts java client libraries. Checkout the Maven Central ZTS Java Client Package pages to make sure you're using the latest release version: <dependencies> <dependency> <groupId> com.yahoo.athenz </groupId> <artifactId> athenz-zts-java-client </artifactId> <version> 1.10.4 </version> </dependency> </dependencies> Next, is the Lambda function handler implementation: package com.amazonaws.lambda.demo; import com.amazonaws.services.lambda.runtime.Context; import com.amazonaws.services.lambda.runtime.RequestHandler; import com.yahoo.athenz.zts.AWSLambdaIdentity; import com.yahoo.athenz.zts.ZTSClient; public class LambdaFunctionHandler implements RequestHandler<Object, String> { @Override public String handleRequest(Object input, Context context) { final String athenzDomain = \"athens\"; // replace this with your domain name final String athenzService = \"lambda\"; // replace this with your service name final String awsAccount = \"123456789\"; // replace this with your account number final String athenzProvider = \"<lambada-name>.<lambada region>\"; // replace with labada name and region. for example: \"athens.aws-labmda.us-west-2\" final String ztsUrl = \"https://zts-address/zts/v1\"; // replace this with your zts Url (ending with /zts/v1) final String certDn = \"ou=Athenz,o=Oath\"; // the dn you want included in cert final String certDomain = \"aws.cert.domain\"; // cert domain // our key and cert to display for test purposes String certificate; String privateKey; // generate a private key and retrieve the corresponding // certificate from Athenz ZTS Service try (ZTSClient client = new ZTSClient(ztsUrl)) { ZTSClient.setX509CsrDetails(certDn, certDomain); AWSLambdaIdentity lambdaIdentity = client.getAWSLambdaServiceCertificate(athenzDomain, athenzService, awsAccount, athenzProvider); certificate = lambdaIdentity.getX509Certificate().toString(); privateKey = lambdaIdentity.getPrivateKey().toString(); } // just return our data so we can see it in our aws console return \"Lambda - Private Key: \" + privateKey + \" Certificate: \" + certificate; } }","title":"Java"},{"location":"service_x509_credentials_aws_lambda/#go","text":"The following function is available in the /sia-ec2/util package: func GetAWSLambdaServiceCertificate(ztsUrl, domain, service, account, region string) (tls.Certificate, error) Change the ztsUrl field with your zts (ending with /zts/v1 ). The domain is your Athenz domain name while service is the service name that your Lambda function will run as. The account field is the AWS account id while region is where this function will be running. For example, here is a quick program that can be compiled and packaged into main.zip and deployed as a Lambda function in AWS. It retrieves a private key and the corresponding x.509 certificate and returns as output. package main import ( \"crypto/rsa\" \"encoding/pem\" \"fmt\" \"github.com/aws/aws-lambda-go/lambda\" \"util\" ) type Request struct { Zts string `json:\"zts\"` Region string `json:\"region\"` Domain string `json:\"domain\"` Account string `json:\"account\"` Service string `json:\"service\"` } type Response struct { PrivateKey string `json:\"privatekey\"` X509Certificate string `json:\"certificate\"` Message string `json:\"message\"` } func Handler(req Request) (Response, error) { x509Cert, err := util.GetAWSLambdaServiceCertificate(req.Zts, req.Domain, req.Service, req.Account, req.Region) var resp Response if err != nil { resp.Message = fmt.Sprintf(\"Unable to get certificate: %v\", err) } else { resp.PrivateKey = util.PrivatePem(x509Cert.PrivateKey.(*rsa.PrivateKey)) resp.X509Certificate = string(pem.EncodeToMemory(&pem.Block{Type: \"CERTIFICATE\", Bytes: x509Cert.Certificate[0]})) resp.Message = \"Success\" } return resp, err } func main() { lambda.Start(Handler) } Here is a sample input for this function. Our domain is called athens and the service is called lambda-function-test. { \"zts\": \"https://zts.com:4443/zts/v1\", \"region\": \"us-west-2\", \"domain\": \"athens\", \"service\": \"lambda-function-test\", \"account\": \"123456789\" }","title":"Go"},{"location":"setup_ui/","text":"Setup Athenz UI \u00b6 Requirements Node.JS Getting Software Server Configuration Setup Development Environment Production Environment Start/Stop UI Server UI Access Requirements \u00b6 The following tools are required to be installed on hosts configured to run UI server. Node.js \u00b6 UI Server is a Node.js 18.x application. Node.js JavaScript Runtime Verify that you have the following or newer versions of node and nodemon binaries installed on your system and are included in your runtime path: $ node --version v18.19.0 $ npm -v 10 .3.0 $ npm install -g nodemon $ nodemon --version 3 .0.3 Getting Software \u00b6 Build the latest UI binary release by following the development instructions . The binary release packages will be created automatically in the assembly subdirectory. Copy the athenz-ui-X.Y-bin.tar.gz to your desired setup directory. $ tar xvfz athenz-ui-X.Y-bin.tar.gz $ cd athenz-ui-X.Y Server Configuration Setup \u00b6 Development Environment \u00b6 To run UI Server, the system administrator must generate the keys, certificates and make necessary changes to the configuration settings. For our configuration script we need the ZMS server hostname and a copy of the server certificate file since ZMS Server is running with a self-signed certificate. From your ZMS Server installation, copy the zms_cert.pem file from the athenz-zms-X.Y/var/zms_server/certs directory to a local directory on the host that will be running the UI Server. For the zms-public-cert-path argument below pass the full path of the zms_cert.pem. For the admin-username argument below pass the system admin that the zms server configured with: e.g. user.john and the admin-fullname is the full name for the administrator: e.g. John Smith . $ cd athenz-ui-X.Y $ bin/setup_dev_ui.sh <zms-hostname> <zms-public-cert-path> <admin-username> <admin-fullname> Running this setup script completes the following tasks: Generate a unique public/private key pair that UI Server will use to sign user's authorized service tokens. The UI has already been authorized to be allowed to carry out the users' requested operations. Generate a self-signed X509 certificate for UI Server HTTPS support Create a new domain called athenz and register the ui service in that domain Production Environment \u00b6 Private/Public Key Pair \u00b6 Generate a unique private/public key pair that UI Server will use to sign user's authorized service tokens. The UI has already been authorized to be allowed to carry out the users' requested operations. From the athenz-ui-X.Y directory execute the following commands: $ cd keys $ openssl genrsa -out athenz.ui-server.pem 2048 $ openssl rsa -in athenz.ui-server.pem -pubout > athenz.ui-server_pub.pem Server X509 Certificate \u00b6 For Athenz UI production server it is strongly recommended purchasing a certificate for HTTPS access from a well known certificate authority. Follow the instructions provided by the Certificate Authority to generate your private key and then the Certificate Request (CSR). Once you have received your X509 certificate name your UI server private key as ui_key.pem and the X509 certificate as ui_cert.pem and copy those files into the keys subdirectory. Register UI Service \u00b6 In order for UI to access ZMS domain data, it must identify itself as a registered service in ZMS. Using the zms-cli utility, we will register a new service in athenz domain: $ cd athenz-ui-X.Y $ bin/<platform>/zms-cli -z https://<zms-server>:4443/zms/v1 add-domain athenz $ bin/<platform>/zms-cli -z https://<zms-server>:4443/zms/v1 -d athenz add-service ui-server 0 keys/athenz.ui-server_pub.pem Generate Athenz Configuration File \u00b6 Generate an Athenz configuration file athenz.conf in athenz-ui-X.Y/config directory to include the ZMS Server URL and the registered public keys that the athenz client libraries and utilities will use to establish connection and validate any data signed by the ZMS Server: $ cd athenz-ui-X.Y $ bin/<platform>/athenz-conf -o config/athenz.conf -z https://<zms-server>:4443/ Start/Stop UI Server \u00b6 Set the following environment variable before starting the UI Server: Development Environment \u00b6 $ cd athenz-ui-X.Y $ export UI_SERVER = <ui-server-host-name> ZMS_SERVER = <zms-server-host-name> NODE_TLS_REJECT_UNAUTHORIZED = 0 $ sudo -E bin/athenz_ui start We're setting the NODE_TLS_REJECT_UNAUTHORIZED environment variable to 0 to disable the certificate verification since we're running with self-signed certificates in our development environment. Production Environment \u00b6 $ cd athenz-ui-X.Y $ export UI_SERVER = <ui-server-host-name> ZMS_SERVER = <zms-server-host-name> $ sudo -E bin/athenz_ui start Based on the sample configuration file provided, Athenz UI Server will be listening on port 443. To stop the UI server, execute the following commands: $ cd athenz-ui-X.Y $ export UI_SERVER = <ui-server-host-name> ZMS_SERVER = <zms-server-host-name> $ sudo -E bin/athenz_ui stop UI Access \u00b6 To access Athenz UI in your browser, visit: https://<ui-server-host-name> Development Environment Restrictions \u00b6 Since the development setup is using self-signed X509 certificates for Athenz ZMS and UI servers, the administrator must add exceptions when accessing Athenz UI or install the self-signed certificates for those two servers into his/her own web browser. The administrator must first access the ZMS Server endpoint in the browser to accept the exception since the Athenz UI contacts ZMS Server to get an authorized token for the user when logging in. The administrator must access: https://<zms-server-host-name>:4443/zms/v1/schema first and accept the certificate exception before accessing Athenz UI. Alternatively, the administrator may decide to install the self-signed certificates for the ZMS and UI servers in their browser. For ZMS Server, the self-signed certificate is called zms_cert.pem and this file is located in the athenz-zms-X.Y/var/zms_server/certs directory. For UI Server, the self-signed certificate is called ui_cert.pem and this file is located in the athenz-ui-X.Y/keys directory.","title":"UI Server"},{"location":"setup_ui/#setup-athenz-ui","text":"Requirements Node.JS Getting Software Server Configuration Setup Development Environment Production Environment Start/Stop UI Server UI Access","title":"Setup Athenz UI"},{"location":"setup_ui/#requirements","text":"The following tools are required to be installed on hosts configured to run UI server.","title":"Requirements"},{"location":"setup_ui/#nodejs","text":"UI Server is a Node.js 18.x application. Node.js JavaScript Runtime Verify that you have the following or newer versions of node and nodemon binaries installed on your system and are included in your runtime path: $ node --version v18.19.0 $ npm -v 10 .3.0 $ npm install -g nodemon $ nodemon --version 3 .0.3","title":"Node.js"},{"location":"setup_ui/#getting-software","text":"Build the latest UI binary release by following the development instructions . The binary release packages will be created automatically in the assembly subdirectory. Copy the athenz-ui-X.Y-bin.tar.gz to your desired setup directory. $ tar xvfz athenz-ui-X.Y-bin.tar.gz $ cd athenz-ui-X.Y","title":"Getting Software"},{"location":"setup_ui/#server-configuration-setup","text":"","title":"Server Configuration Setup"},{"location":"setup_ui/#development-environment","text":"To run UI Server, the system administrator must generate the keys, certificates and make necessary changes to the configuration settings. For our configuration script we need the ZMS server hostname and a copy of the server certificate file since ZMS Server is running with a self-signed certificate. From your ZMS Server installation, copy the zms_cert.pem file from the athenz-zms-X.Y/var/zms_server/certs directory to a local directory on the host that will be running the UI Server. For the zms-public-cert-path argument below pass the full path of the zms_cert.pem. For the admin-username argument below pass the system admin that the zms server configured with: e.g. user.john and the admin-fullname is the full name for the administrator: e.g. John Smith . $ cd athenz-ui-X.Y $ bin/setup_dev_ui.sh <zms-hostname> <zms-public-cert-path> <admin-username> <admin-fullname> Running this setup script completes the following tasks: Generate a unique public/private key pair that UI Server will use to sign user's authorized service tokens. The UI has already been authorized to be allowed to carry out the users' requested operations. Generate a self-signed X509 certificate for UI Server HTTPS support Create a new domain called athenz and register the ui service in that domain","title":"Development Environment"},{"location":"setup_ui/#production-environment","text":"","title":"Production Environment"},{"location":"setup_ui/#privatepublic-key-pair","text":"Generate a unique private/public key pair that UI Server will use to sign user's authorized service tokens. The UI has already been authorized to be allowed to carry out the users' requested operations. From the athenz-ui-X.Y directory execute the following commands: $ cd keys $ openssl genrsa -out athenz.ui-server.pem 2048 $ openssl rsa -in athenz.ui-server.pem -pubout > athenz.ui-server_pub.pem","title":"Private/Public Key Pair"},{"location":"setup_ui/#server-x509-certificate","text":"For Athenz UI production server it is strongly recommended purchasing a certificate for HTTPS access from a well known certificate authority. Follow the instructions provided by the Certificate Authority to generate your private key and then the Certificate Request (CSR). Once you have received your X509 certificate name your UI server private key as ui_key.pem and the X509 certificate as ui_cert.pem and copy those files into the keys subdirectory.","title":"Server X509 Certificate"},{"location":"setup_ui/#register-ui-service","text":"In order for UI to access ZMS domain data, it must identify itself as a registered service in ZMS. Using the zms-cli utility, we will register a new service in athenz domain: $ cd athenz-ui-X.Y $ bin/<platform>/zms-cli -z https://<zms-server>:4443/zms/v1 add-domain athenz $ bin/<platform>/zms-cli -z https://<zms-server>:4443/zms/v1 -d athenz add-service ui-server 0 keys/athenz.ui-server_pub.pem","title":"Register UI Service"},{"location":"setup_ui/#generate-athenz-configuration-file","text":"Generate an Athenz configuration file athenz.conf in athenz-ui-X.Y/config directory to include the ZMS Server URL and the registered public keys that the athenz client libraries and utilities will use to establish connection and validate any data signed by the ZMS Server: $ cd athenz-ui-X.Y $ bin/<platform>/athenz-conf -o config/athenz.conf -z https://<zms-server>:4443/","title":"Generate Athenz Configuration File"},{"location":"setup_ui/#startstop-ui-server","text":"Set the following environment variable before starting the UI Server:","title":"Start/Stop UI Server"},{"location":"setup_ui/#development-environment_1","text":"$ cd athenz-ui-X.Y $ export UI_SERVER = <ui-server-host-name> ZMS_SERVER = <zms-server-host-name> NODE_TLS_REJECT_UNAUTHORIZED = 0 $ sudo -E bin/athenz_ui start We're setting the NODE_TLS_REJECT_UNAUTHORIZED environment variable to 0 to disable the certificate verification since we're running with self-signed certificates in our development environment.","title":"Development Environment"},{"location":"setup_ui/#production-environment_1","text":"$ cd athenz-ui-X.Y $ export UI_SERVER = <ui-server-host-name> ZMS_SERVER = <zms-server-host-name> $ sudo -E bin/athenz_ui start Based on the sample configuration file provided, Athenz UI Server will be listening on port 443. To stop the UI server, execute the following commands: $ cd athenz-ui-X.Y $ export UI_SERVER = <ui-server-host-name> ZMS_SERVER = <zms-server-host-name> $ sudo -E bin/athenz_ui stop","title":"Production Environment"},{"location":"setup_ui/#ui-access","text":"To access Athenz UI in your browser, visit: https://<ui-server-host-name>","title":"UI Access"},{"location":"setup_ui/#development-environment-restrictions","text":"Since the development setup is using self-signed X509 certificates for Athenz ZMS and UI servers, the administrator must add exceptions when accessing Athenz UI or install the self-signed certificates for those two servers into his/her own web browser. The administrator must first access the ZMS Server endpoint in the browser to accept the exception since the Athenz UI contacts ZMS Server to get an authorized token for the user when logging in. The administrator must access: https://<zms-server-host-name>:4443/zms/v1/schema first and accept the certificate exception before accessing Athenz UI. Alternatively, the administrator may decide to install the self-signed certificates for the ZMS and UI servers in their browser. For ZMS Server, the self-signed certificate is called zms_cert.pem and this file is located in the athenz-zms-X.Y/var/zms_server/certs directory. For UI Server, the self-signed certificate is called ui_cert.pem and this file is located in the athenz-ui-X.Y/keys directory.","title":"Development Environment Restrictions"},{"location":"setup_zms/","text":"Setup ZMS (AuthoriZation Management System) \u00b6 Requirements JDK 11 MySQL Server ZMS Server Schema Setup MySQL User and Permissions Getting Software Configuration DB Access Private Key and Server X509 Certificate Setup Development Environment Production Environment User Authentication System Administrators Start/Stop ZMS Server Requirements \u00b6 The following tools are required to be installed on hosts configured to run ZMS server. JDK 11 \u00b6 ZMS Server is written in Java and using embedded Jetty. It requires JDK 11. MySQL Server \u00b6 On a separate host, download and install the latest version of MySQL Server 8.x ZMS Server Schema Setup \u00b6 Copy the zms_server.sql file from the Athenz Git repository (from the servers/zms/schema directory) onto this host and create the database: $ mysql -u root < zms_server.sql MySQL User and Permissions \u00b6 Follow MySQL documentation to create a user and grant this user full privileges over the zms_server database created. For example, let's assume our ZMS Server will be running on zms1.athenz.com host, and we want to create a user called zms_admin with password \"rdvXC7wgvm3g\": $ mysql -u root mysql> CREATE USER 'zms_admin'@'zms1.athenz.com' IDENTIFIED BY 'rdvXC7wgvm3g'; mysql> GRANT ALL PRIVILEGES ON zms_server.* TO 'zms_admin'@'zms1.athenz.com'; mysql> FLUSH PRIVILEGES; We recommend having a strong admin password for better security. Getting Software \u00b6 Build the latest ZMS binary release by following the development instructions . The binary release packages will be created automatically in the assembly subdirectory. Copy the athenz-zms-X.Y-bin.tar.gz to your desired setup directory. $ tar xvfz athenz-zms-X.Y-bin.tar.gz Configuration \u00b6 DB Access \u00b6 In the \"MySQL Server\" section above we installed and configured the schema required for ZMS Server. We also created a zms admin user and granted full access over those tables. Now, we need to configure the ZMS with those access details: $ cd athenz-zms-X.Y $ vi conf/zms_server/zms.properties Make the following changes: Configure the ZMS Server to use JDBC object store implementation. Uncomment the #athenz.zms.object_store_factory_class= line and set it to point to the JDBC Factory class name. It should be set to: athenz.zms.object_store_factory_class=com.yahoo.athenz.zms.store.impl.JDBCObjectStoreFactory Uncomment the #athenz.zms.jdbcstore= line and set it to point to your MySQL Server instance. For example if your DB Server is running on a host called db1.athenz.com, then your line would be: athenz.zms.jdbc_store=jdbc:mysql://db1.athenz.com:3306/zms_server Uncomment the #athenz.zms.jdbc_user= line and set it to the user configured to have full access over zms server database: athenz.zms.jdbc_user=zms_admin Uncomment the #athenz.zms.jdbc_password= line and set it to the configured password the for the jdbc user with full access: athenz.zms.jdbc_password=rdvXC7wgvm3g Storing the password in property file is not secure. The more secure approach is to use a Key Management Store like HashiCorp Vault to store your passwords. Athenz provides a PrivateKeyStoreFactory interface for accessing secrets from your key management store. The recommended approach would to write your own implementation of this interface and configure ZMS server to use that factory to fetch the password for your database access. ZMS Server expect the private key store factory implementation class name in its athenz.zms.private_key_store_factory_class system property. Refer to Private Key Store section for full details how to implement your private key store. When storing the jdbc user password for your database access in your key management store with a given keyname like athenz.admin_db_password and using your own implementation of the PrivateKeyStoreFactory, then the value of the athenz.zms.jdbc_password property would be the key name. For example: athenz.zms.jdbc_password=athenz.admin_db_password The password is retrieved using the getApplicationSecret() of your private key store class that takes keyName ( athenz.admin_db_password in this case) as input and returns key value that is your configured password. Private Key and Server X509 Certificate Setup \u00b6 Development Environment \u00b6 To run ZMS Server, the system administrator must generate the keys and make necessary changes to the configuration settings. $ cd athenz-zms-X.Y $ bin/setup_dev_zms.sh Running this setup script completes the following two tasks: Generate a unique private key that ZMS Server will use to sign any NTokens it issues Generate a self-signed X509 certificate for ZMS Server HTTPS support Production Environment \u00b6 Private Key \u00b6 Generate a unique private key that ZMS Server will use to sign any NTokens it issues. From the athenz-zms-X.Y directory execute the following commands: $ cd var/zms_server/keys $ openssl genrsa -out zms_private.pem 2048 If you have multiple ZMS servers in your environment, your private key must be stored in your key management store and securely installed on all hosts where ZMS servers will be running in the specified directory. Server X509 Certificate \u00b6 While it is still possible to generate and use a self-signed X509 certificate for ZMS Servers, it is recommended to purchase one for your production server from a well known certificate authority. Having such a certificate installed on your ZMS Servers will no longer require to distribute the server's CA certificate to other hosts (e.g. ZTS Servers, Hosts running ZPU). Follow the instructions provided by the Certificate Authority that you're going to purchase your certificate from to generate your private key and then the Certificate Request (CSR). Once you have received your X509 certificate, we just need to add that certificate along with its private key to a keystore for Jetty use. From the athenz-zms-X.Y directory execute the following command: $ openssl pkcs12 -export -out zms_keystore.pkcs12 -in zms_cert.pem -inkey zms_key.pem User Authentication \u00b6 For a user to authenticate himself/herself in ZMS, the server must have the appropriate authentication authority implementation configured. By default, ZMS enables the following two authorities: Unix User Authority - using pam login profile to authenticate users Principal Authority - validating Principal Tokens that are issued when users authenticate using their unix login password. The server also provides other authorities - e.g. Kerberos, TLS Certificate that are not enabled by default. Since the default setup includes Unix Authority, the user that the ZMS process runs as must have read access to the /etc/shadow file. There are two options available: Run the process as root using sudo. This is only recommended for a local development installation. Create a special Unix group that has read access to the /etc/shadow file and set the user that the ZMS process will be running as a member of that group. Checkout the Principal Authentication section for full details on authorities. To add your own authentication authority, modify the athenz.zms.authority_classes=com.yahoo.athenz.auth.impl.PrincipalAuthority,com.yahoo.athenz.auth.impl.UserAuthority line and include comma separated list of authority implementation classes to support. System Administrators \u00b6 When running the server very first time, ZMS Server automatically creates the required domains and sets the running user as the system administrator. The system administrators are the only ones authorized to create top level domains in Athenz. Before running the server very first time, you can configure the set of system administrators by following these steps: $ cd athenz-zms-X.Y $ vi conf/zms_server/zms.properties Modify the athenz.zms.domain_admin=user.admin line and include comma separated list of unix user ids that should be set as Athenz system administrators. e.g. athenz.zms.domain_admin=user.joe,user.john Start/Stop ZMS Server \u00b6 Start the ZMS Server by executing: $ cd athenz-zms-X.Y $ sudo -E bin/zms start See the User Authentication section above regarding an alternative solution of starting ZMS Server without using sudo. If using the Unix Authority to authenticate users against their unix password, make sure the user that the ZMS Server process is running as has read access to the /etc/shadow file. Based on the sample configuration file provided, ZMS Server will be listening on port 4443. Stop the ZMS Server by executing: $ cd athenz-zms-X.Y $ sudo -E bin/zms stop","title":"ZMS Server"},{"location":"setup_zms/#setup-zms-authorization-management-system","text":"Requirements JDK 11 MySQL Server ZMS Server Schema Setup MySQL User and Permissions Getting Software Configuration DB Access Private Key and Server X509 Certificate Setup Development Environment Production Environment User Authentication System Administrators Start/Stop ZMS Server","title":"Setup ZMS (AuthoriZation Management System)"},{"location":"setup_zms/#requirements","text":"The following tools are required to be installed on hosts configured to run ZMS server.","title":"Requirements"},{"location":"setup_zms/#jdk-11","text":"ZMS Server is written in Java and using embedded Jetty. It requires JDK 11.","title":"JDK 11"},{"location":"setup_zms/#mysql-server","text":"On a separate host, download and install the latest version of MySQL Server 8.x","title":"MySQL Server"},{"location":"setup_zms/#zms-server-schema-setup","text":"Copy the zms_server.sql file from the Athenz Git repository (from the servers/zms/schema directory) onto this host and create the database: $ mysql -u root < zms_server.sql","title":"ZMS Server Schema Setup"},{"location":"setup_zms/#mysql-user-and-permissions","text":"Follow MySQL documentation to create a user and grant this user full privileges over the zms_server database created. For example, let's assume our ZMS Server will be running on zms1.athenz.com host, and we want to create a user called zms_admin with password \"rdvXC7wgvm3g\": $ mysql -u root mysql> CREATE USER 'zms_admin'@'zms1.athenz.com' IDENTIFIED BY 'rdvXC7wgvm3g'; mysql> GRANT ALL PRIVILEGES ON zms_server.* TO 'zms_admin'@'zms1.athenz.com'; mysql> FLUSH PRIVILEGES; We recommend having a strong admin password for better security.","title":"MySQL User and Permissions"},{"location":"setup_zms/#getting-software","text":"Build the latest ZMS binary release by following the development instructions . The binary release packages will be created automatically in the assembly subdirectory. Copy the athenz-zms-X.Y-bin.tar.gz to your desired setup directory. $ tar xvfz athenz-zms-X.Y-bin.tar.gz","title":"Getting Software"},{"location":"setup_zms/#configuration","text":"","title":"Configuration"},{"location":"setup_zms/#db-access","text":"In the \"MySQL Server\" section above we installed and configured the schema required for ZMS Server. We also created a zms admin user and granted full access over those tables. Now, we need to configure the ZMS with those access details: $ cd athenz-zms-X.Y $ vi conf/zms_server/zms.properties Make the following changes: Configure the ZMS Server to use JDBC object store implementation. Uncomment the #athenz.zms.object_store_factory_class= line and set it to point to the JDBC Factory class name. It should be set to: athenz.zms.object_store_factory_class=com.yahoo.athenz.zms.store.impl.JDBCObjectStoreFactory Uncomment the #athenz.zms.jdbcstore= line and set it to point to your MySQL Server instance. For example if your DB Server is running on a host called db1.athenz.com, then your line would be: athenz.zms.jdbc_store=jdbc:mysql://db1.athenz.com:3306/zms_server Uncomment the #athenz.zms.jdbc_user= line and set it to the user configured to have full access over zms server database: athenz.zms.jdbc_user=zms_admin Uncomment the #athenz.zms.jdbc_password= line and set it to the configured password the for the jdbc user with full access: athenz.zms.jdbc_password=rdvXC7wgvm3g Storing the password in property file is not secure. The more secure approach is to use a Key Management Store like HashiCorp Vault to store your passwords. Athenz provides a PrivateKeyStoreFactory interface for accessing secrets from your key management store. The recommended approach would to write your own implementation of this interface and configure ZMS server to use that factory to fetch the password for your database access. ZMS Server expect the private key store factory implementation class name in its athenz.zms.private_key_store_factory_class system property. Refer to Private Key Store section for full details how to implement your private key store. When storing the jdbc user password for your database access in your key management store with a given keyname like athenz.admin_db_password and using your own implementation of the PrivateKeyStoreFactory, then the value of the athenz.zms.jdbc_password property would be the key name. For example: athenz.zms.jdbc_password=athenz.admin_db_password The password is retrieved using the getApplicationSecret() of your private key store class that takes keyName ( athenz.admin_db_password in this case) as input and returns key value that is your configured password.","title":"DB Access"},{"location":"setup_zms/#private-key-and-server-x509-certificate-setup","text":"","title":"Private Key and Server X509 Certificate Setup"},{"location":"setup_zms/#development-environment","text":"To run ZMS Server, the system administrator must generate the keys and make necessary changes to the configuration settings. $ cd athenz-zms-X.Y $ bin/setup_dev_zms.sh Running this setup script completes the following two tasks: Generate a unique private key that ZMS Server will use to sign any NTokens it issues Generate a self-signed X509 certificate for ZMS Server HTTPS support","title":"Development Environment"},{"location":"setup_zms/#production-environment","text":"","title":"Production Environment"},{"location":"setup_zms/#user-authentication","text":"For a user to authenticate himself/herself in ZMS, the server must have the appropriate authentication authority implementation configured. By default, ZMS enables the following two authorities: Unix User Authority - using pam login profile to authenticate users Principal Authority - validating Principal Tokens that are issued when users authenticate using their unix login password. The server also provides other authorities - e.g. Kerberos, TLS Certificate that are not enabled by default. Since the default setup includes Unix Authority, the user that the ZMS process runs as must have read access to the /etc/shadow file. There are two options available: Run the process as root using sudo. This is only recommended for a local development installation. Create a special Unix group that has read access to the /etc/shadow file and set the user that the ZMS process will be running as a member of that group. Checkout the Principal Authentication section for full details on authorities. To add your own authentication authority, modify the athenz.zms.authority_classes=com.yahoo.athenz.auth.impl.PrincipalAuthority,com.yahoo.athenz.auth.impl.UserAuthority line and include comma separated list of authority implementation classes to support.","title":"User Authentication"},{"location":"setup_zms/#system-administrators","text":"When running the server very first time, ZMS Server automatically creates the required domains and sets the running user as the system administrator. The system administrators are the only ones authorized to create top level domains in Athenz. Before running the server very first time, you can configure the set of system administrators by following these steps: $ cd athenz-zms-X.Y $ vi conf/zms_server/zms.properties Modify the athenz.zms.domain_admin=user.admin line and include comma separated list of unix user ids that should be set as Athenz system administrators. e.g. athenz.zms.domain_admin=user.joe,user.john","title":"System Administrators"},{"location":"setup_zms/#startstop-zms-server","text":"Start the ZMS Server by executing: $ cd athenz-zms-X.Y $ sudo -E bin/zms start See the User Authentication section above regarding an alternative solution of starting ZMS Server without using sudo. If using the Unix Authority to authenticate users against their unix password, make sure the user that the ZMS Server process is running as has read access to the /etc/shadow file. Based on the sample configuration file provided, ZMS Server will be listening on port 4443. Stop the ZMS Server by executing: $ cd athenz-zms-X.Y $ sudo -E bin/zms stop","title":"Start/Stop ZMS Server"},{"location":"setup_zpu/","text":"Setup ZPU (ZPE Policy Updater) \u00b6 ZPU is only needed to support decentralized authorization. The policy updater is the utility that retrieves from ZTS the policy files for provisioned domains on a host, which ZPE uses to evaluate access requests. Getting Software Configuration Domain Setting Generate Athenz Configuration File ZTS Certificate TrustStore ZPE Policy Directory Run ZPU Utility Periodic Update Policy File Details Requirements \u00b6 The following tools are required to be installed on hosts configured to run ZPE Policy Updater. Getting Software \u00b6 Download latest ZPU binary release from from Maven Central : click on the Browse button, choose the latest version directory and then download the athenz-utils-<latest-version>-bin.tar.gz . $ tar xvfz athenz-utils-X.Y-bin.tar.gz Configuration \u00b6 To successfully run ZPU, the domain administrator must update a couple of settings files and generate a java truststore the utility. Domain Setting \u00b6 Before running ZPU utility, the system administrator must configure what domains are provisioned on the host so the utility can retrieve the policy files for those domains only. Create a configuration settings file with the following content: { \"domains\" : \"<domain1>,<domain2>\" , \"caCertFile\" : \"<path to caCert file>\" } In the json file, edit the value for the \"domains\" field and specify a comma separated list of domain names. ZTS Certificate TrustStore \u00b6 ZPU needs to access ZTS Server to download all domain policies in order to execute authorization checks. Since ZTS Server is running with a self-signed certificate, we need to generate a truststore for the java http client to use when communicating with the ZTS Server. From your ZTS Server installation, copy the zts_cert.pem file from the athenz-zts-X.Y/var/zts_server/certs directory to another directory that is configured as the value of the caCertFile setting in the zpu configuration file. Generate Athenz Configuration File \u00b6 Generate an Athenz configuration file athenz.conf in a directory to include the ZTS Server URL and the registered public keys that the athenz client libraries and utilities will use to establish connection and validate any data signed by the ZMS and ZTS Servers. To communicate with ZMS over SSL, the utility needs to have access to the ZMS Server's public certificate, so you need to copy the zms_cert.pem file from the athenz-zms-X.Y/var/zms_server/certs directory to a local directory and execute the following cmmmand: $ bin/<platform>/athenz-conf -o <path-to-athenz.conf> -c <path-to-zms_cert.pem> -z https://<zms-server>:4443/ -t https://<zts-server>:8443/ ZPE Policy Directory \u00b6 By default ZPU will save any downloaded policy files in the ${ROOT}/var/zpe directory. You need to make sure this is the directory where ZPE is configured to look for policy files. Run ZPU Utility \u00b6 Set the required Athenz ROOT environment variable to the required directory and from there start the ZPU utility by executing: $ export ROOT = <full-path-to-required-root-directory> $ zpu -athenzConf <Athenz conf file> -zpuConf <zpu conf file> Periodic Update \u00b6 The ZPU utility needs to run periodically so it can automatically download any modified policy files for the configured list of domains. The system administrator should setup this utility to be automatically executed by cron utility at least once every couple of hours. Policy File Details \u00b6 Checkout the ZPU Policy File for details how to manually validate the signatures in the policy file. This would be necessary if you'll be writing your own authorization policy engine library instead of using the Athenz provided one.","title":"ZPU Utility"},{"location":"setup_zpu/#setup-zpu-zpe-policy-updater","text":"ZPU is only needed to support decentralized authorization. The policy updater is the utility that retrieves from ZTS the policy files for provisioned domains on a host, which ZPE uses to evaluate access requests. Getting Software Configuration Domain Setting Generate Athenz Configuration File ZTS Certificate TrustStore ZPE Policy Directory Run ZPU Utility Periodic Update Policy File Details","title":"Setup ZPU (ZPE Policy Updater)"},{"location":"setup_zpu/#requirements","text":"The following tools are required to be installed on hosts configured to run ZPE Policy Updater.","title":"Requirements"},{"location":"setup_zpu/#getting-software","text":"Download latest ZPU binary release from from Maven Central : click on the Browse button, choose the latest version directory and then download the athenz-utils-<latest-version>-bin.tar.gz . $ tar xvfz athenz-utils-X.Y-bin.tar.gz","title":"Getting Software"},{"location":"setup_zpu/#configuration","text":"To successfully run ZPU, the domain administrator must update a couple of settings files and generate a java truststore the utility.","title":"Configuration"},{"location":"setup_zpu/#domain-setting","text":"Before running ZPU utility, the system administrator must configure what domains are provisioned on the host so the utility can retrieve the policy files for those domains only. Create a configuration settings file with the following content: { \"domains\" : \"<domain1>,<domain2>\" , \"caCertFile\" : \"<path to caCert file>\" } In the json file, edit the value for the \"domains\" field and specify a comma separated list of domain names.","title":"Domain Setting"},{"location":"setup_zpu/#zts-certificate-truststore","text":"ZPU needs to access ZTS Server to download all domain policies in order to execute authorization checks. Since ZTS Server is running with a self-signed certificate, we need to generate a truststore for the java http client to use when communicating with the ZTS Server. From your ZTS Server installation, copy the zts_cert.pem file from the athenz-zts-X.Y/var/zts_server/certs directory to another directory that is configured as the value of the caCertFile setting in the zpu configuration file.","title":"ZTS Certificate TrustStore"},{"location":"setup_zpu/#generate-athenz-configuration-file","text":"Generate an Athenz configuration file athenz.conf in a directory to include the ZTS Server URL and the registered public keys that the athenz client libraries and utilities will use to establish connection and validate any data signed by the ZMS and ZTS Servers. To communicate with ZMS over SSL, the utility needs to have access to the ZMS Server's public certificate, so you need to copy the zms_cert.pem file from the athenz-zms-X.Y/var/zms_server/certs directory to a local directory and execute the following cmmmand: $ bin/<platform>/athenz-conf -o <path-to-athenz.conf> -c <path-to-zms_cert.pem> -z https://<zms-server>:4443/ -t https://<zts-server>:8443/","title":"Generate Athenz Configuration File"},{"location":"setup_zpu/#zpe-policy-directory","text":"By default ZPU will save any downloaded policy files in the ${ROOT}/var/zpe directory. You need to make sure this is the directory where ZPE is configured to look for policy files.","title":"ZPE Policy Directory"},{"location":"setup_zpu/#run-zpu-utility","text":"Set the required Athenz ROOT environment variable to the required directory and from there start the ZPU utility by executing: $ export ROOT = <full-path-to-required-root-directory> $ zpu -athenzConf <Athenz conf file> -zpuConf <zpu conf file>","title":"Run ZPU Utility"},{"location":"setup_zpu/#periodic-update","text":"The ZPU utility needs to run periodically so it can automatically download any modified policy files for the configured list of domains. The system administrator should setup this utility to be automatically executed by cron utility at least once every couple of hours.","title":"Periodic Update"},{"location":"setup_zpu/#policy-file-details","text":"Checkout the ZPU Policy File for details how to manually validate the signatures in the policy file. This would be necessary if you'll be writing your own authorization policy engine library instead of using the Athenz provided one.","title":"Policy File Details"},{"location":"setup_zts/","text":"Setup ZTS (authoriZation Token System) \u00b6 Requirements JDK 11 Getting Software Configuration Development Environment Production Environment Start/Stop ZTS Server Requirements \u00b6 The following tools are required to be installed on hosts configured to run ZTS server. JDK 11 \u00b6 ZTS Server is written in Java and using embedded Jetty. It requires JDK 11. Getting Software \u00b6 Build the latest ZTS binary release by following the development instructions . The binary release packages will be created automatically in the assembly subdirectory. Copy the athenz-zts-X.Y-bin.tar.gz to your desired setup directory. $ tar xvfz athenz-zts-X.Y-bin.tar.gz $ cd athenz-zts-X.Y Configuration \u00b6 Development Environment \u00b6 Private Key and Server X509 Certificate Setup \u00b6 To run ZTS Server, the system administrator must generate the keys, certificates and make necessary changes to the configuration settings. Since ZMS Server is running with a self-signed certificate, we need to generate a truststore for the java http client to use when communicating with the ZMS Server. For our configuration script we need the ZMS server hostname and a copy of the server certificate file. From your ZMS Server installation, copy the zms_cert.pem file from the athenz-zms-X.Y/var/zms_server/certs directory to a local directory on the host that will be running the ZTS Server. For the zms-public-cert-path argument below pass the full path of the zms_cert.pem. $ cd athenz-zts-X.Y $ bin/setup_dev_zts.sh <zms-hostname> <zms-public-cert-path> Running this setup script completes the following tasks: Generate a unique private key that ZTS Server will use to sign any ZTokens it issues Generate a self-signed X509 certificate for ZTS Server HTTPS support Generate a truststore for secure communication with the ZMS Server Registers the zts service in Athenz sys.auth domain Generates an Athenz configuration file Athenz CA X.509 Certificate Issuing \u00b6 For authenticating services using X509 certificates, ZTS Servers expect the configured cert signer factory class names in its athenz.zts.cert_signer_factory_class system property. Self Cert Signer com.yahoo.athenz.zts.cert.impl.SelfCertSignerFactory is a sample implementation of cert Signer we have for development environment. You can use SelfCertSigner or have your implementation of Cert Signer. Refer Certificate Signer for full details how to implement your cert signer. Production Environment \u00b6 Private/Public Key Pair \u00b6 Generate a unique private/public key pair that ZTS Server will use to sign any ZTokens it issues. From the athenz-zts-X.Y directory execute the following commands: $ cd var/zts_server/keys $ openssl genrsa -out zts_private.pem 2048 $ openssl rsa -in zts_private.pem -pubout > zts_public.pem Server X509 Certificate \u00b6 While it is still possible to generate and use a self-signed X509 certificate for ZTS Servers, it is recommended to purchase one for your production server from a well known certificate authority. Having such a certificate installed on your ZTS Servers will no longer require to distribute the server's public certificate to other hosts (e.g. Hosts running ZPU). Follow the instructions provided by the Certificate Authority to generate your private key and then the Certificate Request (CSR). Once you have received your X509 certificate, we just need to add that certificate along with its private key to a keystore for Jetty use. From the athenz-zts-X.Y directory execute the following command: $ openssl pkcs12 -export -out zts_keystore.pkcs12 -in zts_cert.pem -inkey zts_key.pem Register ZTS Service \u00b6 In order for ZTS to access ZMS domain data, it must identify itself as a registered service in ZMS. Using the zms-cli utility, we will register a new service in sys.auth domain. Since ZMS Servers should be running with a X509 certificate from a well know certificate authority (not a self-signed one) we don't need to reference the CA cert like we did for the local/development environment setup. $ cd athenz-zts-X.Y $ bin/<platform>/zms-cli -z https://<zms-server>:4443/zms/v1 -d sys.auth add-service zts 0 var/zts_server/keys zts_public.pem Athenz CA X.509 Certificate Issuing \u00b6 For authenticating services using X509 certificates, ZTS Servers expect the configured cert signer factory class names in its athenz.zts.cert_signer_factory_class system property. We already have below implementation of cert Signer: Self Cert Signer com.yahoo.athenz.zts.cert.impl.SelfCertSignerFactory for the dev environment. Crypki Cert Signer com.yahoo.athenz.zts.cert.impl.crypki.HttpCertSignerFactory for the production environment. Crypki is simple service for interacting with an HSM or other PKCS#11 device. You can use HttpCert Signer or have your implementation of Cert Signer. Refer Certificate Signer for full details how to implement your own certificate signer. Generate Athenz Configuration File \u00b6 Generate an Athenz configuration file athenz.conf in athenz-zts-X.Y/conf/zts_server directory to include the ZMS Server URL and the registered public keys that the athenz client libraries and utilities will use to establish connection and validate any data signed by the ZMS Server: $ cd athenz-zts-X.Y $ bin/<platform>/athenz-conf -o conf/zts_server/athenz.conf -z https://<zms-server>:4443/ -t https://<zts-server>:8443/ Start/Stop ZTS Server \u00b6 Start the ZTS Server by executing: $ cd athenz-zts-X.Y $ bin/zts start Based on the sample configuration file provided, ZTS Server will be listening on port 8443. Stop the ZTS Server by executing: $ cd athenz-zts-X.Y $ bin/zts stop","title":"ZTS Server"},{"location":"setup_zts/#setup-zts-authorization-token-system","text":"Requirements JDK 11 Getting Software Configuration Development Environment Production Environment Start/Stop ZTS Server","title":"Setup ZTS (authoriZation Token System)"},{"location":"setup_zts/#requirements","text":"The following tools are required to be installed on hosts configured to run ZTS server.","title":"Requirements"},{"location":"setup_zts/#jdk-11","text":"ZTS Server is written in Java and using embedded Jetty. It requires JDK 11.","title":"JDK 11"},{"location":"setup_zts/#getting-software","text":"Build the latest ZTS binary release by following the development instructions . The binary release packages will be created automatically in the assembly subdirectory. Copy the athenz-zts-X.Y-bin.tar.gz to your desired setup directory. $ tar xvfz athenz-zts-X.Y-bin.tar.gz $ cd athenz-zts-X.Y","title":"Getting Software"},{"location":"setup_zts/#configuration","text":"","title":"Configuration"},{"location":"setup_zts/#development-environment","text":"","title":"Development Environment"},{"location":"setup_zts/#private-key-and-server-x509-certificate-setup","text":"To run ZTS Server, the system administrator must generate the keys, certificates and make necessary changes to the configuration settings. Since ZMS Server is running with a self-signed certificate, we need to generate a truststore for the java http client to use when communicating with the ZMS Server. For our configuration script we need the ZMS server hostname and a copy of the server certificate file. From your ZMS Server installation, copy the zms_cert.pem file from the athenz-zms-X.Y/var/zms_server/certs directory to a local directory on the host that will be running the ZTS Server. For the zms-public-cert-path argument below pass the full path of the zms_cert.pem. $ cd athenz-zts-X.Y $ bin/setup_dev_zts.sh <zms-hostname> <zms-public-cert-path> Running this setup script completes the following tasks: Generate a unique private key that ZTS Server will use to sign any ZTokens it issues Generate a self-signed X509 certificate for ZTS Server HTTPS support Generate a truststore for secure communication with the ZMS Server Registers the zts service in Athenz sys.auth domain Generates an Athenz configuration file","title":"Private Key and Server X509 Certificate Setup"},{"location":"setup_zts/#athenz-ca-x509-certificate-issuing","text":"For authenticating services using X509 certificates, ZTS Servers expect the configured cert signer factory class names in its athenz.zts.cert_signer_factory_class system property. Self Cert Signer com.yahoo.athenz.zts.cert.impl.SelfCertSignerFactory is a sample implementation of cert Signer we have for development environment. You can use SelfCertSigner or have your implementation of Cert Signer. Refer Certificate Signer for full details how to implement your cert signer.","title":"Athenz CA X.509 Certificate Issuing"},{"location":"setup_zts/#production-environment","text":"","title":"Production Environment"},{"location":"setup_zts/#privatepublic-key-pair","text":"Generate a unique private/public key pair that ZTS Server will use to sign any ZTokens it issues. From the athenz-zts-X.Y directory execute the following commands: $ cd var/zts_server/keys $ openssl genrsa -out zts_private.pem 2048 $ openssl rsa -in zts_private.pem -pubout > zts_public.pem","title":"Private/Public Key Pair"},{"location":"setup_zts/#server-x509-certificate","text":"While it is still possible to generate and use a self-signed X509 certificate for ZTS Servers, it is recommended to purchase one for your production server from a well known certificate authority. Having such a certificate installed on your ZTS Servers will no longer require to distribute the server's public certificate to other hosts (e.g. Hosts running ZPU). Follow the instructions provided by the Certificate Authority to generate your private key and then the Certificate Request (CSR). Once you have received your X509 certificate, we just need to add that certificate along with its private key to a keystore for Jetty use. From the athenz-zts-X.Y directory execute the following command: $ openssl pkcs12 -export -out zts_keystore.pkcs12 -in zts_cert.pem -inkey zts_key.pem","title":"Server X509 Certificate"},{"location":"setup_zts/#register-zts-service","text":"In order for ZTS to access ZMS domain data, it must identify itself as a registered service in ZMS. Using the zms-cli utility, we will register a new service in sys.auth domain. Since ZMS Servers should be running with a X509 certificate from a well know certificate authority (not a self-signed one) we don't need to reference the CA cert like we did for the local/development environment setup. $ cd athenz-zts-X.Y $ bin/<platform>/zms-cli -z https://<zms-server>:4443/zms/v1 -d sys.auth add-service zts 0 var/zts_server/keys zts_public.pem","title":"Register ZTS Service"},{"location":"setup_zts/#athenz-ca-x509-certificate-issuing_1","text":"For authenticating services using X509 certificates, ZTS Servers expect the configured cert signer factory class names in its athenz.zts.cert_signer_factory_class system property. We already have below implementation of cert Signer: Self Cert Signer com.yahoo.athenz.zts.cert.impl.SelfCertSignerFactory for the dev environment. Crypki Cert Signer com.yahoo.athenz.zts.cert.impl.crypki.HttpCertSignerFactory for the production environment. Crypki is simple service for interacting with an HSM or other PKCS#11 device. You can use HttpCert Signer or have your implementation of Cert Signer. Refer Certificate Signer for full details how to implement your own certificate signer.","title":"Athenz CA X.509 Certificate Issuing"},{"location":"setup_zts/#generate-athenz-configuration-file","text":"Generate an Athenz configuration file athenz.conf in athenz-zts-X.Y/conf/zts_server directory to include the ZMS Server URL and the registered public keys that the athenz client libraries and utilities will use to establish connection and validate any data signed by the ZMS Server: $ cd athenz-zts-X.Y $ bin/<platform>/athenz-conf -o conf/zts_server/athenz.conf -z https://<zms-server>:4443/ -t https://<zts-server>:8443/","title":"Generate Athenz Configuration File"},{"location":"setup_zts/#startstop-zts-server","text":"Start the ZTS Server by executing: $ cd athenz-zts-X.Y $ bin/zts start Based on the sample configuration file provided, ZTS Server will be listening on port 8443. Stop the ZTS Server by executing: $ cd athenz-zts-X.Y $ bin/zts stop","title":"Start/Stop ZTS Server"},{"location":"system_view/","text":"Architecture - System View \u00b6 System Diagram ZMS ZTS SIA ZPE ZPU System Diagram \u00b6 Before we go into the details of the authorization flow, it's important to understand the subsystems involved. The authorization (AuthZ) system shown in the figure below consists of several logical subsystems, which we will elaborate on in the following section. ZMS (authZ Management System) \u00b6 ZMS is the source of truth for domains, roles, and policies for centralized authorization. In addition to allowing CRUD operations on the basic entities, ZMS provides an API to replicate the entities, per domain, to ZTS. ZMS supports a centralized call to check if a principal has access to a resource both for internal management system checks, as well as a simple centralized deployment. Because ZMS supports service identities, ZMS can authenticate services. For centralized authorization, ZMS may be the only Athenz subsystem that you need to interact with. ZTS (authZ Token System) \u00b6 ZTS, the authentication token service, is only needed to support decentralized or data plane functionality. In many ways, ZTS is like a local replica of ZMS's data to check a principal's authentication and confirm membership in roles within a domain. The authentication is in the form of a signed ZToken that can be presented to any decentralized service that wants to authorize access efficiently. Multiple ZTS instances can be distributed to different locations as needed to scale for issuing tokens. SIA (Service Identity Agent) Provider \u00b6 SIA (Service Identity Agent) Provider is part of the container, although likely built with Athenz libraries. As services are authenticated by their private keys, the job of the SIA Provider is to generate a X509 certificate and sign it with the given private key so that the service can present that certificate to ZMS/ZTS as its identity credentials. The corresponding public key must be registered in ZMS so Athenz services can validate the signature. ZPE (AuthZ Policy Engine) \u00b6 Like ZTS, ZPE, the authorization policy engine is only needed to support decentralized authorization. ZPE is the subsystem of Athenz that evaluates policies for a set of roles to yield an allowed or a denied response. ZPE is a library that your service calls and only refers to a local policy cache for your services domain (a small amount of data). ZPU (AuthZ PolicyEngine Updater) \u00b6 Like ZTS and ZPE, ZPU is only needed to support decentralized authorization. The policy updater is the utility that retrieves from ZTS the policy files for provisioned domains on a host, which ZPE uses to evaluate access requests.","title":"System View"},{"location":"system_view/#architecture-system-view","text":"System Diagram ZMS ZTS SIA ZPE ZPU","title":"Architecture - System View"},{"location":"system_view/#system-diagram","text":"Before we go into the details of the authorization flow, it's important to understand the subsystems involved. The authorization (AuthZ) system shown in the figure below consists of several logical subsystems, which we will elaborate on in the following section.","title":"System Diagram"},{"location":"system_view/#zms-authz-management-system","text":"ZMS is the source of truth for domains, roles, and policies for centralized authorization. In addition to allowing CRUD operations on the basic entities, ZMS provides an API to replicate the entities, per domain, to ZTS. ZMS supports a centralized call to check if a principal has access to a resource both for internal management system checks, as well as a simple centralized deployment. Because ZMS supports service identities, ZMS can authenticate services. For centralized authorization, ZMS may be the only Athenz subsystem that you need to interact with.","title":"ZMS (authZ Management System)"},{"location":"system_view/#zts-authz-token-system","text":"ZTS, the authentication token service, is only needed to support decentralized or data plane functionality. In many ways, ZTS is like a local replica of ZMS's data to check a principal's authentication and confirm membership in roles within a domain. The authentication is in the form of a signed ZToken that can be presented to any decentralized service that wants to authorize access efficiently. Multiple ZTS instances can be distributed to different locations as needed to scale for issuing tokens.","title":"ZTS (authZ Token System)"},{"location":"system_view/#sia-service-identity-agent-provider","text":"SIA (Service Identity Agent) Provider is part of the container, although likely built with Athenz libraries. As services are authenticated by their private keys, the job of the SIA Provider is to generate a X509 certificate and sign it with the given private key so that the service can present that certificate to ZMS/ZTS as its identity credentials. The corresponding public key must be registered in ZMS so Athenz services can validate the signature.","title":"SIA (Service Identity Agent) Provider"},{"location":"system_view/#zpe-authz-policy-engine","text":"Like ZTS, ZPE, the authorization policy engine is only needed to support decentralized authorization. ZPE is the subsystem of Athenz that evaluates policies for a set of roles to yield an allowed or a denied response. ZPE is a library that your service calls and only refers to a local policy cache for your services domain (a small amount of data).","title":"ZPE (AuthZ Policy Engine)"},{"location":"system_view/#zpu-authz-policyengine-updater","text":"Like ZTS and ZPE, ZPU is only needed to support decentralized authorization. The policy updater is the utility that retrieves from ZTS the policy files for provisioned domains on a host, which ZPE uses to evaluate access requests.","title":"ZPU (AuthZ PolicyEngine Updater)"},{"location":"token_expiration/","text":"By default, Athenz ZTS server allows principals to request access tokens with a maximum expiry of 30 days. However, the domain administrator has the capability to specify a maximum expiry limit for a given role or the full domain. This allows the domain administrators to control access to specific roles (or domains) such that the principals do not request tokens that are valid for up-to 30 days but instead are valid only for the configured number of minutes. Role Level Token Expiry Support \u00b6 The domain administrator may specify maximum token expiry setting in minutes for a specific role: zms-cli -d <domain-name> set-role-token-expiry-mins <role-name> <max-expiry-mins> If the domain administrator has specified a max token expiry mins of 30 to db.writers role, then ZTS will only issue access tokens with a maximum expiry of 30 mins even if the principal is requesting a longer one. If the principal is requesting a token with a smaller expiry that 30 mins, for example 15 mins, then it will be honored and the token will be issued for 15 mins. If the principal is requesting a token for multiple roles, then ZTS will lookup the max expiry setting for all the roles and issue a token with the smallest configured value. If none of the roles have a max token expiry setting configured, then ZTS will lookup to see if there is a max token expiry setting specified for the domain and use that if it's smaller than the requested token expiry value. If the domain administrator specifies a token expiry at both role and domain levels, then the role level always overrides the domain setting for the role - regardless if it's shorter or longer than the domain configured value. You can look at the currently configured value for a specific role using zms-cli -d <domain-name> show-role <role-name> command. To reset the configured limit back to its default behavior, set the limit to 0: zms-cli -d <domain-name> set-role-token-expiry-mins <role-name> 0 Domain Level Token Expiry Support \u00b6 The domain administrator may specify maximum token expiry setting in minutes for the full domain: zms-cli -d <domain-name> set-domain-token-expiry-mins <max-expiry-mins> If the domain administrator has specified a max token expiry mins of 90 to sales domain, then ZTS will only issue access tokens with a maximum expiry of 90 mins even if the principal is requesting a longer one. The exception to this rule is if the domain administrator has also specified a value for one of the roles requested in the token. If the domain administrator specifies a token expiry at both role and domain levels, then the role level always overrides the domain setting for the role - regardless if it's shorter or longer than the domain configured value. If the principal is requesting a token with a smaller expiry that 90 mins configured for the domain, for example 60 mins, and there are no per-role token expiry settings configured, then it will be honored and the token will be issued for 60 mins. You can look at the currently configured value for a specific domain using zms-cli -d <domain-name> show-domain command. To reset the configured limit back to its default behavior, set the limit to 0: zms-cli -d <domain-name> set-domain-token-expiry-mins 0","title":"Access token Limit Expiry Support"},{"location":"token_expiration/#role-level-token-expiry-support","text":"The domain administrator may specify maximum token expiry setting in minutes for a specific role: zms-cli -d <domain-name> set-role-token-expiry-mins <role-name> <max-expiry-mins> If the domain administrator has specified a max token expiry mins of 30 to db.writers role, then ZTS will only issue access tokens with a maximum expiry of 30 mins even if the principal is requesting a longer one. If the principal is requesting a token with a smaller expiry that 30 mins, for example 15 mins, then it will be honored and the token will be issued for 15 mins. If the principal is requesting a token for multiple roles, then ZTS will lookup the max expiry setting for all the roles and issue a token with the smallest configured value. If none of the roles have a max token expiry setting configured, then ZTS will lookup to see if there is a max token expiry setting specified for the domain and use that if it's smaller than the requested token expiry value. If the domain administrator specifies a token expiry at both role and domain levels, then the role level always overrides the domain setting for the role - regardless if it's shorter or longer than the domain configured value. You can look at the currently configured value for a specific role using zms-cli -d <domain-name> show-role <role-name> command. To reset the configured limit back to its default behavior, set the limit to 0: zms-cli -d <domain-name> set-role-token-expiry-mins <role-name> 0","title":"Role Level Token Expiry Support"},{"location":"token_expiration/#domain-level-token-expiry-support","text":"The domain administrator may specify maximum token expiry setting in minutes for the full domain: zms-cli -d <domain-name> set-domain-token-expiry-mins <max-expiry-mins> If the domain administrator has specified a max token expiry mins of 90 to sales domain, then ZTS will only issue access tokens with a maximum expiry of 90 mins even if the principal is requesting a longer one. The exception to this rule is if the domain administrator has also specified a value for one of the roles requested in the token. If the domain administrator specifies a token expiry at both role and domain levels, then the role level always overrides the domain setting for the role - regardless if it's shorter or longer than the domain configured value. If the principal is requesting a token with a smaller expiry that 90 mins configured for the domain, for example 60 mins, and there are no per-role token expiry settings configured, then it will be honored and the token will be issued for 60 mins. You can look at the currently configured value for a specific domain using zms-cli -d <domain-name> show-domain command. To reset the configured limit back to its default behavior, set the limit to 0: zms-cli -d <domain-name> set-domain-token-expiry-mins 0","title":"Domain Level Token Expiry Support"},{"location":"zms_api/","text":"ZMS API \u00b6 Introduction \u00b6 The Authorization Management Service (ZMS) API This API has the following attributes: Attribute Value namespace com.yahoo.athenz.zms version 1 Authentication \u00b6 X.509 Certificate Support \u00b6 All ZMS API commands require that the client use a TLS certificate issued by Athenz. Services can use their Athenz Issued Service Identity certificates when communicating with ZMS. Authorization \u00b6 Every write request against ZMS server is authorized against the configured policy data to verify that the principal has been given the rights to make the requested change. Each request description below gives the authorization command that includes the action and resource that the ZMS Server will run the authorization check against. For example, the create subdomain command has the following authorize statement: authorize (\"create\", \"{parent}:domain\"); This indicates that the principal requesting to create subdomain called athens.ci must have grant rights to action \"create\" for resource called \"domain\" in domain \"athens\". API Documentation \u00b6 Please refer to the ZMS OpenAPI documentation","title":"ZMS REST API"},{"location":"zms_api/#zms-api","text":"","title":"ZMS API"},{"location":"zms_api/#introduction","text":"The Authorization Management Service (ZMS) API This API has the following attributes: Attribute Value namespace com.yahoo.athenz.zms version 1","title":"Introduction"},{"location":"zms_api/#authentication","text":"","title":"Authentication"},{"location":"zms_api/#x509-certificate-support","text":"All ZMS API commands require that the client use a TLS certificate issued by Athenz. Services can use their Athenz Issued Service Identity certificates when communicating with ZMS.","title":"X.509 Certificate Support"},{"location":"zms_api/#authorization","text":"Every write request against ZMS server is authorized against the configured policy data to verify that the principal has been given the rights to make the requested change. Each request description below gives the authorization command that includes the action and resource that the ZMS Server will run the authorization check against. For example, the create subdomain command has the following authorize statement: authorize (\"create\", \"{parent}:domain\"); This indicates that the principal requesting to create subdomain called athens.ci must have grant rights to action \"create\" for resource called \"domain\" in domain \"athens\".","title":"Authorization"},{"location":"zms_api/#api-documentation","text":"Please refer to the ZMS OpenAPI documentation","title":"API Documentation"},{"location":"zms_client/","text":"ZMS Client Utility \u00b6 Overview Getting Software Prerequisites Getting Help Specifying ZMS Environments How the ZMS Client Authenticates Listing registered domains in Athenz Displaying Administrators for a Product Domain Adding Domains Parameters Examples Registering Personal Domains Adding and Removing Administrators Adding a Group Role Parameters Example Managing a Group Role Membership Parameters Example Adding a temporary Role Membership with expiration date Parameters Example Adding a Policy Parameters Example Overview \u00b6 The ZMS client utility allows administrators to manage Athenz domains, to check domain details, create personal domains, and add other administrators. Getting Software \u00b6 Download latest ZMS Client utility binary release from Maven Central : click on the Browse button, choose the latest version directory and then download the athenz-utils-<latest-version>-bin.tar.gz . $ tar xvfz athenz-utils-X.Y-bin.tar.gz Prerequisites \u00b6 Before you can use the ZMS client utility, you need to have asked the Athenz administrators to create your top level domain. Getting Help \u00b6 The help argument for the utility will display all commands available through utility. $ zms-cli help To get additional details about a specific command: $ zms - cli help [ command ] For example, to get complete details on how to add a domain including examples: $ zms-cli help add-domain Specifying ZMS Environments \u00b6 Use the -z option to point to the required environment for executing commands. $ zms-cli -z https://zms-server.athenzcompany.com:4443/zms/v1 -d athenz show-domain How the ZMS Client Authenticates \u00b6 The Athenz ZMS server requires the user to provide its UserToken or use a User certificate and private key for MTLS to authenticate with ZMS (depending on the Principal Authority used). ZMS will then authorize the request based on the configured authority. Listing registered domains in Athenz \u00b6 To find out what domains have been provisioned in Athenz, run the following: $ zms-cli list-domain The list-domain command also takes an optional prefix argument to filter the domains and only return those that start with the specified string. For example, if the user wants to list only the domains that have been configured in the athenz product domain, he/she will run the following command: $ zms-cli list-domain athenz domains: - athenz - athenz.ci - athenz.qa Displaying Administrators for a Product Domain \u00b6 To view the full list of administrators for a given domain, run the following: $ zms-cli -d <domain-name> show-role admin For example, to view the Athenz system administrators for the domain media.news : $ zms-cli -d media.news show-role admin Adding Domains \u00b6 The Top Level Product Domains in ZMS are provisioned by Athenz administrators. Once the Product Domain has been created, the designated domain administrators can create any subdomains as necessary. To create a new domain, the administrator uses the add-domain command: $ zms-cli add-domain <product sub domain> [ <admin1> <admin2> ... ] Parameters \u00b6 <domain> The name of the domain to be added, which could either be a product domain or a subdomain. For example, to add a subdomain called storage in the athenz domain, the value for <domain> would be athenz.storage . The parent domain must exist before a subdomain can be created. The domain name can only include any letters, digits and the '-' character. The maximum length of the domain name (including all subdomain parts) is 256 bytes. [<admin1> ...] A space-separated list of administrators for the domain. The user creating the domain is automatically added as an administrator. Examples \u00b6 If user joe executes the command below, the product domain coretech is created and will include user.joe as an administrator: $ zms-cli add-domain coretech When user joe executes the command below, the sub domain athenz.ci is created and will have the administrators yby.joe , yby.john , and yby.jane : $ zms-cli add-domain athenz.ci yby.john yby.jane Registering Personal Domains \u00b6 ZMS supports Personal Domains. These domains are provisioned for users in the User user domain and have the same functionality as Product Domains in Athenz. The Personal Domain uses the syntax user.<user-id> and can have configured number of subdomains (default 2). For example, if your user ID is joe and you'd like to create a Personal Domain, you would run the following command: $ zms-cli add-domain user.joe Then, to create a subdomain called athenz-test in your Personal Domain, you would run the following command: $ zms-cli add-domain user.joe.athenz-test If the user wants to list only his/her personal domains that have been registered, he/she will run the following command: $ zms-cli list-domain user.<user-id> Adding and Removing Administrators \u00b6 Domain administrators are the principals listed as members of the role admin . When you create a domain, the role and corresponding policy role are created. Administrators can manage the list of current domain administrators by adding or removing members in the admin role. To add one or more administrators: $ zms-cli -d <domain> add-member admin <user1> [ <user2> ... ] To remove existing domain administrators: $ zms-cli -d <domain> delete-member admin <user1> [ <user2> ... ] ZMS allows you to remove yourself from the admin role. Once you 've been removed, you' ll need to ask another domain administrator to re - add you to the `admin` role . Adding a Regular Role \u00b6 To add new regular role to a domain, the administrator will execute the following zms-cli command: $ zms-cli -d <domain> add-regular-role <role> <member> [ <member> ... ] Parameters <domain> The name of the domain that the new role belongs to. <role> The name of the new role to be added. <member> [<member> ...] A space-separated list of members for the role. At least one member must be specified. If the member is a regular user, then user's id must be prefixed with user. . Once the group has been created, the administrator can add and/or delete members using the add-member and delete-member commands. Example \u00b6 When the domain administrator executes the command below, a new role called readers will be added to the the domain athenz.ci will have the following members: user - user.john and service - media.sports.storage : $ zms-cli -d athenz.ci add-regular-role readers user.john media.sports.storage Managing a Group Role Membership \u00b6 To add and/or delete members to/from a given role in a domain, the administrator will execute the following zms-cli commands: $ zms-cli -d <domain> add-member <role> <member> [ <member> ... ] $ zms-cli -d <domain> delete-member <role> <member> [ <member> ... ] Parameters <domain> The name of the domain that the role belongs to. <role> The name of the role that will be modified to add or remove members. <member> [<member> ...] A space-separated list of members to be added to the role or to be removed from the role. At least one member must be specified. If the member is a regular user, the user's id must be prefixed with user. . When specifying service identities as members you must provide the full service name in then <domain-name>.<service-name> format. Example To add two new members: service \"media.sports.storage\" and user \"yby.john\", to a role called \"readers\" in the domain \"athenz\", the domain administrator will execute the following command: $ zms-cli -d athenz add-member readers yby.john media.sports.storage To delete member \"media.sports.storage\" from a role called \"writers\" in the domain \"athenz\", the domain administrator will execute the following command: $ zms-cli -d athenz delete-member writers media.sports.storage Adding a temporary Role Membership with expiration date \u00b6 To add a temporary member to a given role in a domain, the administrator will execute the following zms-cli commands: $ zms-cli -d <domain> add-temporary-member <role> <member> <expiration> Parameters <domain> The name of the domain that the role belongs to. <role> The name of the role that will be modified to add. <member> A member to be added to the role. Only one member must be specified. If the member is a regular user, the user's short id must be prefixed with user. . <expiration> Expiration date. It is expected to be in UTC timezone in the form of YYYY-MM-DDTHH:MM:SSZ - for example: 2017-03-02T15:04:00Z Example To add a new member: user user.john , to a role called readers in the domain sports.nhl , with expiration date set to 1PM UTC time on Sep. 3 rd , 2018, the domain administrator will execute the following command: $ zms-cli -d sports.nhl add-temporary-member readers user.john 2018-09-03T13:00:00Z Adding a Policy \u00b6 To add new policy to a domain, the administrator will execute the following zms-cli command: $ zms-cli -d <domain> add-policy <policy> [ <assertion> ] Parameters <domain> The name of the domain that the new policy belongs to. <policy> The name of the new policy to be added. [<assertion>] where <assertion> is '<effect> <action> to <role> on <resource>' The value effect must be either 'grant' or 'deny'. The action is the domain administrator defined action available for the resource (e.g. read, write, delete). The role is the name of the role this assertion applies to. The resource is the name of the resource this assertion applies to. Once the policy has been created, the administrator can add and/or delete assertions using the add-assertion and delete-assertion commands. Example When the domain administrator executes the command below, a new policy called writers will be added to the the domain athenz.ci that will grant write access to all the members of the sports_writers role on articles.sports.* : $ zms-cli -d athenz.ci add-policy writers grant write to sports_writers on 'articles.sports.*'","title":"ZMS Client Utility"},{"location":"zms_client/#zms-client-utility","text":"Overview Getting Software Prerequisites Getting Help Specifying ZMS Environments How the ZMS Client Authenticates Listing registered domains in Athenz Displaying Administrators for a Product Domain Adding Domains Parameters Examples Registering Personal Domains Adding and Removing Administrators Adding a Group Role Parameters Example Managing a Group Role Membership Parameters Example Adding a temporary Role Membership with expiration date Parameters Example Adding a Policy Parameters Example","title":"ZMS Client Utility"},{"location":"zms_client/#overview","text":"The ZMS client utility allows administrators to manage Athenz domains, to check domain details, create personal domains, and add other administrators.","title":"Overview"},{"location":"zms_client/#getting-software","text":"Download latest ZMS Client utility binary release from Maven Central : click on the Browse button, choose the latest version directory and then download the athenz-utils-<latest-version>-bin.tar.gz . $ tar xvfz athenz-utils-X.Y-bin.tar.gz","title":"Getting Software"},{"location":"zms_client/#prerequisites","text":"Before you can use the ZMS client utility, you need to have asked the Athenz administrators to create your top level domain.","title":"Prerequisites"},{"location":"zms_client/#getting-help","text":"The help argument for the utility will display all commands available through utility. $ zms-cli help To get additional details about a specific command: $ zms - cli help [ command ] For example, to get complete details on how to add a domain including examples: $ zms-cli help add-domain","title":"Getting Help"},{"location":"zms_client/#specifying-zms-environments","text":"Use the -z option to point to the required environment for executing commands. $ zms-cli -z https://zms-server.athenzcompany.com:4443/zms/v1 -d athenz show-domain","title":"Specifying ZMS Environments"},{"location":"zms_client/#how-the-zms-client-authenticates","text":"The Athenz ZMS server requires the user to provide its UserToken or use a User certificate and private key for MTLS to authenticate with ZMS (depending on the Principal Authority used). ZMS will then authorize the request based on the configured authority.","title":"How the ZMS Client Authenticates"},{"location":"zms_client/#listing-registered-domains-in-athenz","text":"To find out what domains have been provisioned in Athenz, run the following: $ zms-cli list-domain The list-domain command also takes an optional prefix argument to filter the domains and only return those that start with the specified string. For example, if the user wants to list only the domains that have been configured in the athenz product domain, he/she will run the following command: $ zms-cli list-domain athenz domains: - athenz - athenz.ci - athenz.qa","title":"Listing registered domains in Athenz"},{"location":"zms_client/#displaying-administrators-for-a-product-domain","text":"To view the full list of administrators for a given domain, run the following: $ zms-cli -d <domain-name> show-role admin For example, to view the Athenz system administrators for the domain media.news : $ zms-cli -d media.news show-role admin","title":"Displaying Administrators for a Product Domain"},{"location":"zms_client/#adding-domains","text":"The Top Level Product Domains in ZMS are provisioned by Athenz administrators. Once the Product Domain has been created, the designated domain administrators can create any subdomains as necessary. To create a new domain, the administrator uses the add-domain command: $ zms-cli add-domain <product sub domain> [ <admin1> <admin2> ... ]","title":"Adding Domains"},{"location":"zms_client/#parameters","text":"<domain> The name of the domain to be added, which could either be a product domain or a subdomain. For example, to add a subdomain called storage in the athenz domain, the value for <domain> would be athenz.storage . The parent domain must exist before a subdomain can be created. The domain name can only include any letters, digits and the '-' character. The maximum length of the domain name (including all subdomain parts) is 256 bytes. [<admin1> ...] A space-separated list of administrators for the domain. The user creating the domain is automatically added as an administrator.","title":"Parameters"},{"location":"zms_client/#examples","text":"If user joe executes the command below, the product domain coretech is created and will include user.joe as an administrator: $ zms-cli add-domain coretech When user joe executes the command below, the sub domain athenz.ci is created and will have the administrators yby.joe , yby.john , and yby.jane : $ zms-cli add-domain athenz.ci yby.john yby.jane","title":"Examples"},{"location":"zms_client/#registering-personal-domains","text":"ZMS supports Personal Domains. These domains are provisioned for users in the User user domain and have the same functionality as Product Domains in Athenz. The Personal Domain uses the syntax user.<user-id> and can have configured number of subdomains (default 2). For example, if your user ID is joe and you'd like to create a Personal Domain, you would run the following command: $ zms-cli add-domain user.joe Then, to create a subdomain called athenz-test in your Personal Domain, you would run the following command: $ zms-cli add-domain user.joe.athenz-test If the user wants to list only his/her personal domains that have been registered, he/she will run the following command: $ zms-cli list-domain user.<user-id>","title":"Registering Personal Domains"},{"location":"zms_client/#adding-and-removing-administrators","text":"Domain administrators are the principals listed as members of the role admin . When you create a domain, the role and corresponding policy role are created. Administrators can manage the list of current domain administrators by adding or removing members in the admin role. To add one or more administrators: $ zms-cli -d <domain> add-member admin <user1> [ <user2> ... ] To remove existing domain administrators: $ zms-cli -d <domain> delete-member admin <user1> [ <user2> ... ] ZMS allows you to remove yourself from the admin role. Once you 've been removed, you' ll need to ask another domain administrator to re - add you to the `admin` role .","title":"Adding and Removing Administrators"},{"location":"zms_client/#adding-a-regular-role","text":"To add new regular role to a domain, the administrator will execute the following zms-cli command: $ zms-cli -d <domain> add-regular-role <role> <member> [ <member> ... ]","title":"Adding a Regular Role"},{"location":"zms_client/#example","text":"When the domain administrator executes the command below, a new role called readers will be added to the the domain athenz.ci will have the following members: user - user.john and service - media.sports.storage : $ zms-cli -d athenz.ci add-regular-role readers user.john media.sports.storage","title":"Example"},{"location":"zms_client/#managing-a-group-role-membership","text":"To add and/or delete members to/from a given role in a domain, the administrator will execute the following zms-cli commands: $ zms-cli -d <domain> add-member <role> <member> [ <member> ... ] $ zms-cli -d <domain> delete-member <role> <member> [ <member> ... ]","title":"Managing a Group Role Membership"},{"location":"zms_client/#adding-a-temporary-role-membership-with-expiration-date","text":"To add a temporary member to a given role in a domain, the administrator will execute the following zms-cli commands: $ zms-cli -d <domain> add-temporary-member <role> <member> <expiration>","title":"Adding a temporary Role Membership with expiration date"},{"location":"zms_client/#adding-a-policy","text":"To add new policy to a domain, the administrator will execute the following zms-cli command: $ zms-cli -d <domain> add-policy <policy> [ <assertion> ]","title":"Adding a Policy"},{"location":"zpu_policy_file/","text":"ZPU Policy File \u00b6 Policy File Signature Validation ZTS Signature Validation ZMS Signature Validation Policy File Structure ZPU is only needed to support decentralized authorization. The policy updater is the utility that retrieves from ZTS the policy files for provisioned domains on a host, which ZPE uses to evaluate access requests. The ZPE library automatically parses the policy file, validates it, and uses it for authorization checks. This document describes the format and how to validate the policy file. Policy File Signature Validation \u00b6 The policy file data which is provided in json format is signed by both ZMS and ZTS servers since ZMS is the authority on policy data but the file is downloaded from ZTS servers. ZTS Signature Validation \u00b6 To validate the ZTS signature, the json is presented in the following structure: {\"signedPolicyData\":<zts-data>,\"keyId\":\"<key-id>,\"signature\":\"<signature>\"} a) Extract the <key-id> and fetch the public key with that key identifier from Athenz for service zts in domain sys.auth . For example, using zms-cli command line utility: $ zms-cli -d sys.auth show-public-key zts zts1.0 public-key: keyID: zts1.0 value: LS0tLS1CRUdJTiBQVUJMSUMgS0VZLS0tLS0KTUZrd0V...WS0tLS0tCg-- The public key is encoded in YBase64 encoding so it must be decoded before the public key can be used to validate the signature. Checkout YBase64 class implemenation in athenz-auth-core library for details. b) Validate the signature of the extracted <zts-data> string using Bouncycastle. <signature> field is also YBase64 encoded, so it must be decoded before using in the verify function. 1 ) Load the public key retrieved in step ( a ) and generate a PublicKey object . 2 ) Generate the signature algorithm based on the public key algorithm . ZTS server is using SHA256 digest algorithm with either RSA or ECSDA keys so the pos sible val ues are either RSA_SHA256 or ECDSA_SHA256 . 3 ) Generate a signer and verify the signature ( include proper exception handling ): java . security . Signature signer = java . security . Signature . get Instance ( signatureAlgorithm , BC_PROVIDER ); signer . initVerify ( publicKey ); signer . update ( utf8Bytes ( ztsData )); boolean val id = signer . verify ( signature ); ZMS Signature Validation \u00b6 To validate the ZMS signature, we need to further parse the <zts-data> object we retrieved in the ZTS Signture validation section. That json has the following structure: {\"expires\":\"<expiry-date>\",\"modified\":\"<modified-date>\",\"policyData\":<zms-data>,\"zmsKeyId\":\"<key-id>,\"zmsSignature\":\"<signature>\"} a) Extract the <key-id> and fetch the public key with that key identifier from Athenz for service zms in domain sys.auth . For example, using zms-cli command line utility: $ zms-cli -d sys.auth show-public-key zms zms1.0 public-key: keyID: zms1.0 value: LS0tLS1CRUdJTiBQVUJMSUMgS0VZLS0tLS0KTUZrd0V...WS0tLS0tCg-- The public key is encoded in YBase64 encoding so it must be decoded before the public key can be used to validate the signature. Checkout YBase64 class implemenation in athenz-auth-core library for details. b) Validate the signature of the extracted <zms-data> string using Bouncycastle. <signature> field is also YBase64 encoded, so it must be decoded before using in the verify function. 1 ) Load the public key retrieved in step ( a ) and generate a PublicKey object . 2 ) Generate the signature algorithm based on the public key algorithm . ZMS server is using SHA256 digest algorithm with either RSA or ECSDA keys so the pos sible val ues are either RSA_SHA256 or ECDSA_SHA256 . 3 ) Generate a signer and verify the signature ( include proper exception handling ): java . security . Signature signer = java . security . Signature . get Instance ( signatureAlgorithm , BC_PROVIDER ); signer . initVerify ( publicKey ); signer . update ( utf8Bytes ( zmsData )); boolean val id = signer . verify ( signature ); Policy File Structure \u00b6 Athenz Services are using RDL to represent its objects. These should directly map to json objects: type DomainSignedPolicyData Struct { SignedPolicyData signedPolicyData; //policy data signed by ZMS String signature; //signature generated based on the domain policies object String keyId; //the identifier of the key used to generate the signature } type SignedPolicyData Struct { PolicyData policyData; //list of policies defined in a domain String zmsSignature; //zms signature generated based on the domain policies object String zmsKeyId; //the identifier of the zms key used to generate the signature Timestamp modified; //when the domain itself was last modified Timestamp expires; //timestamp specifying the expiration time for using this set of policies } type PolicyData Struct { DomainName domain; //name of the domain Array<Policy> policies; //list of policies defined in this server } type Policy Struct { ResourceName name; //name of the policy Timestamp modified (optional); //last modification timestamp of this policy Array<Assertion> assertions; //list of defined assertions for this policy } type Assertion Struct { String role; //the subject of the assertion, a role String resource; //the object of the assertion. Must be in the local namespace. Can contain wildcards String action; //the predicate of the assertion. Can contain wildcards AssertionEffect effect (optional, default=ALLOW); //the effect of the assertion in the policy language Int64 id (optional); //assertion id - auto generated by server } type AssertionEffect Enum { ALLOW, DENY } DomainName and ResourceName reference regular Strings. The zts java model classes are available in the athenz-zts-core library. <dependencies> <dependency> <groupId>com.yahoo.athenz</groupId> <artifactId>athenz-zts-core</artifactId> <version>1.7.51</version> </dependency> </dependencies>","title":"ZPU Policy File"},{"location":"zpu_policy_file/#zpu-policy-file","text":"Policy File Signature Validation ZTS Signature Validation ZMS Signature Validation Policy File Structure ZPU is only needed to support decentralized authorization. The policy updater is the utility that retrieves from ZTS the policy files for provisioned domains on a host, which ZPE uses to evaluate access requests. The ZPE library automatically parses the policy file, validates it, and uses it for authorization checks. This document describes the format and how to validate the policy file.","title":"ZPU Policy File"},{"location":"zpu_policy_file/#policy-file-signature-validation","text":"The policy file data which is provided in json format is signed by both ZMS and ZTS servers since ZMS is the authority on policy data but the file is downloaded from ZTS servers.","title":"Policy File Signature Validation"},{"location":"zpu_policy_file/#zts-signature-validation","text":"To validate the ZTS signature, the json is presented in the following structure: {\"signedPolicyData\":<zts-data>,\"keyId\":\"<key-id>,\"signature\":\"<signature>\"} a) Extract the <key-id> and fetch the public key with that key identifier from Athenz for service zts in domain sys.auth . For example, using zms-cli command line utility: $ zms-cli -d sys.auth show-public-key zts zts1.0 public-key: keyID: zts1.0 value: LS0tLS1CRUdJTiBQVUJMSUMgS0VZLS0tLS0KTUZrd0V...WS0tLS0tCg-- The public key is encoded in YBase64 encoding so it must be decoded before the public key can be used to validate the signature. Checkout YBase64 class implemenation in athenz-auth-core library for details. b) Validate the signature of the extracted <zts-data> string using Bouncycastle. <signature> field is also YBase64 encoded, so it must be decoded before using in the verify function. 1 ) Load the public key retrieved in step ( a ) and generate a PublicKey object . 2 ) Generate the signature algorithm based on the public key algorithm . ZTS server is using SHA256 digest algorithm with either RSA or ECSDA keys so the pos sible val ues are either RSA_SHA256 or ECDSA_SHA256 . 3 ) Generate a signer and verify the signature ( include proper exception handling ): java . security . Signature signer = java . security . Signature . get Instance ( signatureAlgorithm , BC_PROVIDER ); signer . initVerify ( publicKey ); signer . update ( utf8Bytes ( ztsData )); boolean val id = signer . verify ( signature );","title":"ZTS Signature Validation"},{"location":"zpu_policy_file/#zms-signature-validation","text":"To validate the ZMS signature, we need to further parse the <zts-data> object we retrieved in the ZTS Signture validation section. That json has the following structure: {\"expires\":\"<expiry-date>\",\"modified\":\"<modified-date>\",\"policyData\":<zms-data>,\"zmsKeyId\":\"<key-id>,\"zmsSignature\":\"<signature>\"} a) Extract the <key-id> and fetch the public key with that key identifier from Athenz for service zms in domain sys.auth . For example, using zms-cli command line utility: $ zms-cli -d sys.auth show-public-key zms zms1.0 public-key: keyID: zms1.0 value: LS0tLS1CRUdJTiBQVUJMSUMgS0VZLS0tLS0KTUZrd0V...WS0tLS0tCg-- The public key is encoded in YBase64 encoding so it must be decoded before the public key can be used to validate the signature. Checkout YBase64 class implemenation in athenz-auth-core library for details. b) Validate the signature of the extracted <zms-data> string using Bouncycastle. <signature> field is also YBase64 encoded, so it must be decoded before using in the verify function. 1 ) Load the public key retrieved in step ( a ) and generate a PublicKey object . 2 ) Generate the signature algorithm based on the public key algorithm . ZMS server is using SHA256 digest algorithm with either RSA or ECSDA keys so the pos sible val ues are either RSA_SHA256 or ECDSA_SHA256 . 3 ) Generate a signer and verify the signature ( include proper exception handling ): java . security . Signature signer = java . security . Signature . get Instance ( signatureAlgorithm , BC_PROVIDER ); signer . initVerify ( publicKey ); signer . update ( utf8Bytes ( zmsData )); boolean val id = signer . verify ( signature );","title":"ZMS Signature Validation"},{"location":"zpu_policy_file/#policy-file-structure","text":"Athenz Services are using RDL to represent its objects. These should directly map to json objects: type DomainSignedPolicyData Struct { SignedPolicyData signedPolicyData; //policy data signed by ZMS String signature; //signature generated based on the domain policies object String keyId; //the identifier of the key used to generate the signature } type SignedPolicyData Struct { PolicyData policyData; //list of policies defined in a domain String zmsSignature; //zms signature generated based on the domain policies object String zmsKeyId; //the identifier of the zms key used to generate the signature Timestamp modified; //when the domain itself was last modified Timestamp expires; //timestamp specifying the expiration time for using this set of policies } type PolicyData Struct { DomainName domain; //name of the domain Array<Policy> policies; //list of policies defined in this server } type Policy Struct { ResourceName name; //name of the policy Timestamp modified (optional); //last modification timestamp of this policy Array<Assertion> assertions; //list of defined assertions for this policy } type Assertion Struct { String role; //the subject of the assertion, a role String resource; //the object of the assertion. Must be in the local namespace. Can contain wildcards String action; //the predicate of the assertion. Can contain wildcards AssertionEffect effect (optional, default=ALLOW); //the effect of the assertion in the policy language Int64 id (optional); //assertion id - auto generated by server } type AssertionEffect Enum { ALLOW, DENY } DomainName and ResourceName reference regular Strings. The zts java model classes are available in the athenz-zts-core library. <dependencies> <dependency> <groupId>com.yahoo.athenz</groupId> <artifactId>athenz-zts-core</artifactId> <version>1.7.51</version> </dependency> </dependencies>","title":"Policy File Structure"},{"location":"zts_access_token_guide/","text":"Access Tokens are used to authorize access to service provider resources. The Access Token contains the set of roles (identified in the token as scopes) a client belongs to for a specified domain. So, when a client wants to access a resource, this client must obtain the appropriate Access Token from ZTS and use the token in the header of the subsequent HTTP client request. If enabled, the service will also return an ID Token if requested. ID Token identifies the authenticated principal for a given Athenz Service Identity. Support for accessing OAuth2 access/id tokens is based on Client Credentials authentication workflow as defined in RFC6749: The OAuth 2.0 Authorization Framework . Access/ID Token Request \u00b6 Request \u00b6 To request an access token from ZTS Server, the client will send a POST request with application/x-www-form-urlencoded content-type to /oauth2/token endpoint. The request body must contain the following parameters: grant_type : Value MUST be set to \"client_credentials\" scope : list of scopes/roles requested in the access token. The caller can either specify to include all roles the principal has access to in a specific domain (e.g. <domain-name>:domain) or ask for specific roles only (e.g. <domain-name>:role.<role1>). Scopes are separated by spaces. To request an ID token, the scope must include 'openid' and audience service name (e.g. <domain-name>:service.<service-name>). The domain name in id token request match the domain name in the access token scope. expires_in : requested expiry time for access token in seconds For example, when a principal requests an access token only for accessing demo domain and wants to include all roles it has access to in that domain, the request would be: POST /zts/v1/oauth2/token HTTP/1.1 Host: <zts-address> Content-Type: application/x-www-form-urlencoded grant_type=client_credentials&scope=demo%3Adomain If the principal requests an access token only for accessing demo domain and wants to include readers and writers roles it has access to in that domain, the request would be: POST /zts/v1/oauth2/token HTTP/1.1 Host: <zts-address> Content-Type: application/x-www-form-urlencoded grant_type=client_credentials&scope=demo%3Arole.readers+sherpa%3Arole.writers If the principal requests an access token along with an id token for accessing demo domain for backend service and wants to include readers and writers roles it has access to in that domain, the request would be: POST /zts/v1/oauth2/token HTTP/1.1 Host: <zts-address> Content-Type: application/x-www-form-urlencoded grant_type=client_credentials&scope=openid+demo%3Aservice.backend+demo%3Arole.readers+demo%3Arole.writers Response \u00b6 If the access token request is valid and authorized, the ZTS server issues an access token (and id token if requested). The response contains the following json document: { \"access_token\":\"<generated-token>\", \"id_token\":\"<generated-token>\", \"token_type\":\"Bearer\", \"expires_in\":3600 } Access Token format \u00b6 An access token is a JSON web token (JWT) encoded in Base64 URL-encoded format that contains a header, payload, and signature. An application server can authorize the principal to access specific resources based on the scopes (roles) defined in the access token. Access Token Header \u00b6 The Access token header contains the Athenz ZTS Server Private key id and the algorithm used to sign the payload. { \"alg\": \"ES256\", \"kid\": \"<zts server private key id>\" } Access Token Payload \u00b6 The Access Token Payload contains the following claims: ver : version of the access token iss : token issuer aud : the audience (the Athenz Domain name) that the access token is intended for uid : unique identifier for the principal (same as client Id) sub : subject of the access token (same as client Id) iat : token issue time in seconds (Unix time) exp : token expiry time in seconds (Unix time) scp : array of scopes are granted to this access token. This is the list of roles that principal can assume in the audience domain client_id : client ID (Athenz Principal) of the client that requested the access token Here is an example of an access token that alpha.api retrieved to access some resource in beta domain. The principal alpha.api is authorized to assume readers and writers roles in the beta domain. { \"ver\": 1, \"iss\": \"athenz\", \"aud\": \"beta\", \"client_id\": \"alpha.api\", \"uid\": \"alpha.api\", \"sub\": \"alpha.api\", \"iat\": 1554491974, \"exp\": 1554495574, \"scp\": [ \"readers\", \"writers\" ] } Access Token Validation \u00b6 You can use any standards based JWT library to validate the access token generated by ZTS Server. You can also implement your own verifier by following the RFC7519: Section 7.2: Validating a JWT . ID Token format \u00b6 An ID token is a JSON web token (JWT) encoded in Base64 URL-encoded format that contains a header, payload, and signature. The ID token, if enabled, can be issued for clients to authenticate themselves along with their access token to the requested Athenz service. ZTS Server never issues ID Tokens on its own. They're always returned along with access tokens. ID Token Header \u00b6 The ID token header contains the Athenz ZTS Server Private key id and the algorithm used to sign the payload. { \"alg\": \"ES256\", \"kid\": \"<zts server private key id>\" } ID Token Payload \u00b6 The ID Token Payload contains the following claims: ver : version of the id token iss : token issuer aud : the audience (the Athenz Service name) that the id token is intended for sub : subject of the id token - athenz pricnipal name requesting the token iat : token issue time in seconds (Unix time) exp : token expiry time in seconds (Unix time) auth_time: authentication time in seconds (Unix time) Here is an example of an id token that alpha.api retrieved for its authorization request to beta.backend service. { \"ver\": 1, \"iss\": \"athenz\", \"aud\": \"beta.backend\", \"sub\": \"alpha.api\", \"iat\": 1554491974, \"auth_time\": 1554491974, \"exp\": 1554495574 } ID Token Validation \u00b6 You can use any standards based JWT library to validate the id token generated by ZTS Server. You can also implement your own verifier by following the RFC7519: Section 7.2: Validating a JWT . Fetching Access Tokens with Java Client Library \u00b6 First you need to update your Java project pom.xml file to indicate the dependency on the Athenz zts java client library. Checkout the Maven Central ZTS Java Client Package page to make sure you're using the latest release version (You must use 1.8.37 or newer version of the client library). ZTS Client Object \u00b6 ZTS Client Library provides several constructors. The recommended approach is to use an SSL context that includes service's Athenz issued CA certificate. ZTSClient object must be closed to release any allocated resources. ZTSClient class implements Closeable interface. However, to correctly handle auto-refresh of access tokens, the client used to fetch the token cannot be closed since the background tasks need to use the same client to refresh the access token. Our general recommendation is that you create a single ZTSClient object and use that for all requests (it is thread safe) and then close the client when your application is shutting down. ** Important ** During the shutdown of the application, ZTSClient.cancelPrefetch() must be called to stop the timer thread that automatically fetches and refreshes any cached tokens in the ZTS Client. Athenz Issued CA certificate \u00b6 You will need to provide the ZTSClient with the ZTS Server's URL and an SSLContext. The following examples will show how to generate an SSLContext /** * Constructs a new ZTSClient object with the given SSLContext object * and ZTS Server Url. Default read and connect timeout values are * 30000ms (30sec). The application can change these values by using the * athenz.zts.client.read_timeout and athenz.zts.client.connect_timeout * system properties. The values specified for timeouts must be in milliseconds. * @param ztsUrl ZTS Server's URL * @param sslContext SSLContext that includes service's private key and x.509 certificate * for authenticating requests */ public ZTSClient ( String ztsUrl , SSLContext sslContext ); First update your pom.xml to include dependency on athenz-cert-refresher package which provides support to create a SSLContext object based on our private key and certificate: < dependency > < groupId > com . yahoo . athenz </ groupId > < artifactId > athenz - cert - refresher </ artifactId > < version > VERSION - NUMBER </ version > </ dependency > The SSLContext contains a KeyRefresher with the following arguments: - The service private key - The service public key - The path of the truststore containing the CA certificate - The password for the truststore containing the CA certificate For example: // Create our SSL Context object based on our private key and // certificate and jdk truststore KeyRefresher keyRefresher = Utils . generateKeyRefresher ( trustStorePath , trustStorePassword , certPath , keyPath ); SSLContext sslContext = Utils . buildSSLContext ( keyRefresher . getKeyManagerProxy (), keyRefresher . getTrustManagerProxy ()); keyRefresher . startup (); ZTSClient ztsClient = new ZTSClient ( ztsUrl , sslContext ); Obtaining an Access Token \u00b6 To obtain an Access Token, the application would use the following method from the ZTSClient class: /** * For the specified requester(user/service) return the corresponding Access Token that * includes the list of roles that the principal has access to in the specified domain * @param domainName name of the domain * @param roleNames (optional) only interested in roles with these names * @param expiryTime (optional) specifies that the returned Access must be * at least valid for specified number of seconds. Pass 0 to use * server default timeout. * @return ZTS generated Access Token Response object. ZTSClientException will be thrown in case of failure */ public AccessTokenResponse getAccessToken ( String domainName , List < String > roleNames , long expiryTime ); In the simplest case, the method only requires the caller to specify the domain that the application will be accessing. Thus, it needs an Access Token for that domain. For example, if the alpha.storage service identifier is trying to access a resource from a domain beta , then the API call to retrieve the access token valid for 4 hours would be the following: AccessTokenResponse tokenResponse = null ; try { tokenResponse = ztsClient . getAccessToken ( \"beta\" , null , 14400 ); } catch ( ZTSClientException ex ) { // log error using ex.getCode() and ex.getMessage() } final String accessToken = tokenResponse . getAccess_token (); Then the client will include the retrieved Access Token value as one of its headers when submitting its request to the provider service. Token Caching \u00b6 The ZTS Client Library automatically caches any tokens returned by the ZTS Server, so any subsequent requests for an Access Token for the same domain are fulfilled from the local cache as opposed to connecting to the ZTS Server every time. This provides better performance by reusing the same Access Token because they\u2019re valid for two hours by default. The client library will only return cached Access Tokens if they\u2019re valid for at least \u00bc of the requested timeout in minutes (default 30 minutes). Least Privilege Access \u00b6 By default, the method getAccess returns all the roles that the given service identity can access within a domain. The method, however, has the roleNames parameter that allow applications to request access tokens for specific roles within a domain. Thus, the server need only check and return an access token for the specified roles. For example, the service has access to several roles within the alpha domain but is only interested in two roles readers and searchers . With this use case, the api call would be: AccessTokenResponse tokenResponse = null ; List < String > roles = new ArrayList <> (); roles . add ( \"readers); roles.add(\" searchers \"); try { tokenResponse = ztsClient.getAccessToken(\" alpha \", roles, 14400); } catch (ZTSClientException ex) { // log error using ex.getCode() and ex.getMessage() } final String accessToken = tokenResponse.getAccess_token(); Command Line Utility to Fetch Access Tokens \u00b6 Athenz team also provides a command line utility called zts-accesstoken that can be used to fetch access/id tokens from the ZTS Server for a given domain and/or specific roles. $ zts-accesstoken -domain alpha.prod -service api -svc-key-file beta.api.key.pem -svc-cert-file beta.api.cert.pem -zts https://<zts-address>/zts/v1 Check out the zts-accesstoken user guide for full details. Troubleshooting \u00b6 When communicating with ZTS Server to obtain an Access Token, the ZTS Server will return the following 4xx error codes if it's unable to successfully process the request: 400 The domain name specified in the request to issue an access token is inconsistent with other scopes. 401 The request could not be successfully authenticated. 403 The service identity does not have access to any resources in the specified domain. 404 The domain specified in the request to issue an Access Token for does not exist.","title":"Obtaining OAuth2 Access Tokens from ZTS"},{"location":"zts_access_token_guide/#accessid-token-request","text":"","title":"Access/ID Token Request"},{"location":"zts_access_token_guide/#request","text":"To request an access token from ZTS Server, the client will send a POST request with application/x-www-form-urlencoded content-type to /oauth2/token endpoint. The request body must contain the following parameters: grant_type : Value MUST be set to \"client_credentials\" scope : list of scopes/roles requested in the access token. The caller can either specify to include all roles the principal has access to in a specific domain (e.g. <domain-name>:domain) or ask for specific roles only (e.g. <domain-name>:role.<role1>). Scopes are separated by spaces. To request an ID token, the scope must include 'openid' and audience service name (e.g. <domain-name>:service.<service-name>). The domain name in id token request match the domain name in the access token scope. expires_in : requested expiry time for access token in seconds For example, when a principal requests an access token only for accessing demo domain and wants to include all roles it has access to in that domain, the request would be: POST /zts/v1/oauth2/token HTTP/1.1 Host: <zts-address> Content-Type: application/x-www-form-urlencoded grant_type=client_credentials&scope=demo%3Adomain If the principal requests an access token only for accessing demo domain and wants to include readers and writers roles it has access to in that domain, the request would be: POST /zts/v1/oauth2/token HTTP/1.1 Host: <zts-address> Content-Type: application/x-www-form-urlencoded grant_type=client_credentials&scope=demo%3Arole.readers+sherpa%3Arole.writers If the principal requests an access token along with an id token for accessing demo domain for backend service and wants to include readers and writers roles it has access to in that domain, the request would be: POST /zts/v1/oauth2/token HTTP/1.1 Host: <zts-address> Content-Type: application/x-www-form-urlencoded grant_type=client_credentials&scope=openid+demo%3Aservice.backend+demo%3Arole.readers+demo%3Arole.writers","title":"Request"},{"location":"zts_access_token_guide/#response","text":"If the access token request is valid and authorized, the ZTS server issues an access token (and id token if requested). The response contains the following json document: { \"access_token\":\"<generated-token>\", \"id_token\":\"<generated-token>\", \"token_type\":\"Bearer\", \"expires_in\":3600 }","title":"Response"},{"location":"zts_access_token_guide/#access-token-format","text":"An access token is a JSON web token (JWT) encoded in Base64 URL-encoded format that contains a header, payload, and signature. An application server can authorize the principal to access specific resources based on the scopes (roles) defined in the access token.","title":"Access Token format"},{"location":"zts_access_token_guide/#access-token-header","text":"The Access token header contains the Athenz ZTS Server Private key id and the algorithm used to sign the payload. { \"alg\": \"ES256\", \"kid\": \"<zts server private key id>\" }","title":"Access Token Header"},{"location":"zts_access_token_guide/#access-token-payload","text":"The Access Token Payload contains the following claims: ver : version of the access token iss : token issuer aud : the audience (the Athenz Domain name) that the access token is intended for uid : unique identifier for the principal (same as client Id) sub : subject of the access token (same as client Id) iat : token issue time in seconds (Unix time) exp : token expiry time in seconds (Unix time) scp : array of scopes are granted to this access token. This is the list of roles that principal can assume in the audience domain client_id : client ID (Athenz Principal) of the client that requested the access token Here is an example of an access token that alpha.api retrieved to access some resource in beta domain. The principal alpha.api is authorized to assume readers and writers roles in the beta domain. { \"ver\": 1, \"iss\": \"athenz\", \"aud\": \"beta\", \"client_id\": \"alpha.api\", \"uid\": \"alpha.api\", \"sub\": \"alpha.api\", \"iat\": 1554491974, \"exp\": 1554495574, \"scp\": [ \"readers\", \"writers\" ] }","title":"Access Token Payload"},{"location":"zts_access_token_guide/#access-token-validation","text":"You can use any standards based JWT library to validate the access token generated by ZTS Server. You can also implement your own verifier by following the RFC7519: Section 7.2: Validating a JWT .","title":"Access Token Validation"},{"location":"zts_access_token_guide/#id-token-format","text":"An ID token is a JSON web token (JWT) encoded in Base64 URL-encoded format that contains a header, payload, and signature. The ID token, if enabled, can be issued for clients to authenticate themselves along with their access token to the requested Athenz service. ZTS Server never issues ID Tokens on its own. They're always returned along with access tokens.","title":"ID Token format"},{"location":"zts_access_token_guide/#id-token-header","text":"The ID token header contains the Athenz ZTS Server Private key id and the algorithm used to sign the payload. { \"alg\": \"ES256\", \"kid\": \"<zts server private key id>\" }","title":"ID Token Header"},{"location":"zts_access_token_guide/#id-token-payload","text":"The ID Token Payload contains the following claims: ver : version of the id token iss : token issuer aud : the audience (the Athenz Service name) that the id token is intended for sub : subject of the id token - athenz pricnipal name requesting the token iat : token issue time in seconds (Unix time) exp : token expiry time in seconds (Unix time) auth_time: authentication time in seconds (Unix time) Here is an example of an id token that alpha.api retrieved for its authorization request to beta.backend service. { \"ver\": 1, \"iss\": \"athenz\", \"aud\": \"beta.backend\", \"sub\": \"alpha.api\", \"iat\": 1554491974, \"auth_time\": 1554491974, \"exp\": 1554495574 }","title":"ID Token Payload"},{"location":"zts_access_token_guide/#id-token-validation","text":"You can use any standards based JWT library to validate the id token generated by ZTS Server. You can also implement your own verifier by following the RFC7519: Section 7.2: Validating a JWT .","title":"ID Token Validation"},{"location":"zts_access_token_guide/#fetching-access-tokens-with-java-client-library","text":"First you need to update your Java project pom.xml file to indicate the dependency on the Athenz zts java client library. Checkout the Maven Central ZTS Java Client Package page to make sure you're using the latest release version (You must use 1.8.37 or newer version of the client library).","title":"Fetching Access Tokens with Java Client Library"},{"location":"zts_access_token_guide/#zts-client-object","text":"ZTS Client Library provides several constructors. The recommended approach is to use an SSL context that includes service's Athenz issued CA certificate. ZTSClient object must be closed to release any allocated resources. ZTSClient class implements Closeable interface. However, to correctly handle auto-refresh of access tokens, the client used to fetch the token cannot be closed since the background tasks need to use the same client to refresh the access token. Our general recommendation is that you create a single ZTSClient object and use that for all requests (it is thread safe) and then close the client when your application is shutting down. ** Important ** During the shutdown of the application, ZTSClient.cancelPrefetch() must be called to stop the timer thread that automatically fetches and refreshes any cached tokens in the ZTS Client.","title":"ZTS Client Object"},{"location":"zts_access_token_guide/#athenz-issued-ca-certificate","text":"You will need to provide the ZTSClient with the ZTS Server's URL and an SSLContext. The following examples will show how to generate an SSLContext /** * Constructs a new ZTSClient object with the given SSLContext object * and ZTS Server Url. Default read and connect timeout values are * 30000ms (30sec). The application can change these values by using the * athenz.zts.client.read_timeout and athenz.zts.client.connect_timeout * system properties. The values specified for timeouts must be in milliseconds. * @param ztsUrl ZTS Server's URL * @param sslContext SSLContext that includes service's private key and x.509 certificate * for authenticating requests */ public ZTSClient ( String ztsUrl , SSLContext sslContext ); First update your pom.xml to include dependency on athenz-cert-refresher package which provides support to create a SSLContext object based on our private key and certificate: < dependency > < groupId > com . yahoo . athenz </ groupId > < artifactId > athenz - cert - refresher </ artifactId > < version > VERSION - NUMBER </ version > </ dependency > The SSLContext contains a KeyRefresher with the following arguments: - The service private key - The service public key - The path of the truststore containing the CA certificate - The password for the truststore containing the CA certificate For example: // Create our SSL Context object based on our private key and // certificate and jdk truststore KeyRefresher keyRefresher = Utils . generateKeyRefresher ( trustStorePath , trustStorePassword , certPath , keyPath ); SSLContext sslContext = Utils . buildSSLContext ( keyRefresher . getKeyManagerProxy (), keyRefresher . getTrustManagerProxy ()); keyRefresher . startup (); ZTSClient ztsClient = new ZTSClient ( ztsUrl , sslContext );","title":"Athenz Issued CA certificate"},{"location":"zts_access_token_guide/#obtaining-an-access-token","text":"To obtain an Access Token, the application would use the following method from the ZTSClient class: /** * For the specified requester(user/service) return the corresponding Access Token that * includes the list of roles that the principal has access to in the specified domain * @param domainName name of the domain * @param roleNames (optional) only interested in roles with these names * @param expiryTime (optional) specifies that the returned Access must be * at least valid for specified number of seconds. Pass 0 to use * server default timeout. * @return ZTS generated Access Token Response object. ZTSClientException will be thrown in case of failure */ public AccessTokenResponse getAccessToken ( String domainName , List < String > roleNames , long expiryTime ); In the simplest case, the method only requires the caller to specify the domain that the application will be accessing. Thus, it needs an Access Token for that domain. For example, if the alpha.storage service identifier is trying to access a resource from a domain beta , then the API call to retrieve the access token valid for 4 hours would be the following: AccessTokenResponse tokenResponse = null ; try { tokenResponse = ztsClient . getAccessToken ( \"beta\" , null , 14400 ); } catch ( ZTSClientException ex ) { // log error using ex.getCode() and ex.getMessage() } final String accessToken = tokenResponse . getAccess_token (); Then the client will include the retrieved Access Token value as one of its headers when submitting its request to the provider service.","title":"Obtaining an Access Token"},{"location":"zts_access_token_guide/#token-caching","text":"The ZTS Client Library automatically caches any tokens returned by the ZTS Server, so any subsequent requests for an Access Token for the same domain are fulfilled from the local cache as opposed to connecting to the ZTS Server every time. This provides better performance by reusing the same Access Token because they\u2019re valid for two hours by default. The client library will only return cached Access Tokens if they\u2019re valid for at least \u00bc of the requested timeout in minutes (default 30 minutes).","title":"Token Caching"},{"location":"zts_access_token_guide/#least-privilege-access","text":"By default, the method getAccess returns all the roles that the given service identity can access within a domain. The method, however, has the roleNames parameter that allow applications to request access tokens for specific roles within a domain. Thus, the server need only check and return an access token for the specified roles. For example, the service has access to several roles within the alpha domain but is only interested in two roles readers and searchers . With this use case, the api call would be: AccessTokenResponse tokenResponse = null ; List < String > roles = new ArrayList <> (); roles . add ( \"readers); roles.add(\" searchers \"); try { tokenResponse = ztsClient.getAccessToken(\" alpha \", roles, 14400); } catch (ZTSClientException ex) { // log error using ex.getCode() and ex.getMessage() } final String accessToken = tokenResponse.getAccess_token();","title":"Least Privilege Access"},{"location":"zts_access_token_guide/#command-line-utility-to-fetch-access-tokens","text":"Athenz team also provides a command line utility called zts-accesstoken that can be used to fetch access/id tokens from the ZTS Server for a given domain and/or specific roles. $ zts-accesstoken -domain alpha.prod -service api -svc-key-file beta.api.key.pem -svc-cert-file beta.api.cert.pem -zts https://<zts-address>/zts/v1 Check out the zts-accesstoken user guide for full details.","title":"Command Line Utility to Fetch Access Tokens"},{"location":"zts_access_token_guide/#troubleshooting","text":"When communicating with ZTS Server to obtain an Access Token, the ZTS Server will return the following 4xx error codes if it's unable to successfully process the request: 400 The domain name specified in the request to issue an access token is inconsistent with other scopes. 401 The request could not be successfully authenticated. 403 The service identity does not have access to any resources in the specified domain. 404 The domain specified in the request to issue an Access Token for does not exist.","title":"Troubleshooting"},{"location":"zts_accesstoken/","text":"Overview Getting Software Prerequisites Usage Overview \u00b6 ZTS OAuth2 Access Token Client application in Go to request an access token from ZTS Server for the given identity to access a role in a provider domain. Getting Software \u00b6 Download latest ZTS OAuth2 Access Token Client package from Maven Central : click on the Browse button, choose the latest version directory and then download the athenz-utils-<latest-version>-bin.tar.gz . $ tar xvfz athenz-utils-X.Y-bin.tar.gz Prerequisites \u00b6 Before you can use the ZTS AccessToken utility, you need to have asked the Athenz administrators to create your top level domain. Usage \u00b6 An access token from ZTS service can be fetched using Service Identity x.509 certificates. The optional expire-time argument specifies how long the access token should be valid for. The value must be specified in minutes. The default if no value is specified is 120 minutes. The optional roles argument requests an access token for the given roles only (comma separated) as opposed to all the roles the service identity has access to in the requested domain. The optional service argument requests an id token for the given service. The full domain.service value will be set as the audience for the id token. Using Athenz Identity X.509 Certificates \u00b6 $ zts-accesstoken -domain <domain> [-roles <roles>] [-service <service>] -svc-key-file <private-key-file> -svc-cert-file <service-cert-file> -zts <ZTS url> [-expire-time <expire-time-in-mins>]","title":"ZTS OAuth2 Access Token Client"},{"location":"zts_accesstoken/#overview","text":"ZTS OAuth2 Access Token Client application in Go to request an access token from ZTS Server for the given identity to access a role in a provider domain.","title":"Overview"},{"location":"zts_accesstoken/#getting-software","text":"Download latest ZTS OAuth2 Access Token Client package from Maven Central : click on the Browse button, choose the latest version directory and then download the athenz-utils-<latest-version>-bin.tar.gz . $ tar xvfz athenz-utils-X.Y-bin.tar.gz","title":"Getting Software"},{"location":"zts_accesstoken/#prerequisites","text":"Before you can use the ZTS AccessToken utility, you need to have asked the Athenz administrators to create your top level domain.","title":"Prerequisites"},{"location":"zts_accesstoken/#usage","text":"An access token from ZTS service can be fetched using Service Identity x.509 certificates. The optional expire-time argument specifies how long the access token should be valid for. The value must be specified in minutes. The default if no value is specified is 120 minutes. The optional roles argument requests an access token for the given roles only (comma separated) as opposed to all the roles the service identity has access to in the requested domain. The optional service argument requests an id token for the given service. The full domain.service value will be set as the audience for the id token.","title":"Usage"},{"location":"zts_accesstoken/#using-athenz-identity-x509-certificates","text":"$ zts-accesstoken -domain <domain> [-roles <roles>] [-service <service>] -svc-key-file <private-key-file> -svc-cert-file <service-cert-file> -zts <ZTS url> [-expire-time <expire-time-in-mins>]","title":"Using Athenz Identity X.509 Certificates"},{"location":"zts_api/","text":"ZTS API \u00b6 Introduction \u00b6 The Authorization Token Service (ZTS) API This API has the following attributes: Attribute Value namespace com.yahoo.athenz.zts version 1 Authentication \u00b6 X.509 Certificate Support \u00b6 All ZTS API commands require that the client use a TLS certificate issued by Athenz. Services can use their Athenz Issued Service Identity certificates when communicating with ZTS. Authorization \u00b6 Limited number of ZTS API endpoints are authorized against the configured policy data to verify that the principal has been given the rights to make the requested change. Each request description below gives the authorization command that includes the action and resource that the ZTS Server will run the authorization check against. For example, to delete an instance from the local database we have the following authorize statement: authorize(\"delete\", \"{domain}:instance.{instanceId}\"); This indicates that the principal requesting to delete instance id host001 from athenz.ci domain must have grant rights to action \"delete\" for resource called \"instance.host001\" in domain \"athenz.ci\". API Documentation \u00b6 Please refer to the ZTS OpenAPI documentation","title":"ZTS REST API"},{"location":"zts_api/#zts-api","text":"","title":"ZTS API"},{"location":"zts_api/#introduction","text":"The Authorization Token Service (ZTS) API This API has the following attributes: Attribute Value namespace com.yahoo.athenz.zts version 1","title":"Introduction"},{"location":"zts_api/#authentication","text":"","title":"Authentication"},{"location":"zts_api/#x509-certificate-support","text":"All ZTS API commands require that the client use a TLS certificate issued by Athenz. Services can use their Athenz Issued Service Identity certificates when communicating with ZTS.","title":"X.509 Certificate Support"},{"location":"zts_api/#authorization","text":"Limited number of ZTS API endpoints are authorized against the configured policy data to verify that the principal has been given the rights to make the requested change. Each request description below gives the authorization command that includes the action and resource that the ZTS Server will run the authorization check against. For example, to delete an instance from the local database we have the following authorize statement: authorize(\"delete\", \"{domain}:instance.{instanceId}\"); This indicates that the principal requesting to delete instance id host001 from athenz.ci domain must have grant rights to action \"delete\" for resource called \"instance.host001\" in domain \"athenz.ci\".","title":"Authorization"},{"location":"zts_api/#api-documentation","text":"Please refer to the ZTS OpenAPI documentation","title":"API Documentation"},{"location":"zts_rolecert/","text":"Overview Getting Software Prerequisites Usage Overview \u00b6 ZTS Role Certificate Client utility uses Athenz Service Identity certificate to request a X509 Certificate for the requested role from ZTS Server. Once ZTS validates the service identity certificate, it will issue a new 30-day X509 Certificate for the role. Unlike access tokens, role certificates are issued for a given role only. Getting Software \u00b6 Download latest ZTS Role Certificate Client utility binary release from Maven Central : click on the Browse button, choose the latest version directory and then download the athenz-utils-<latest-version>-bin.tar.gz . $ tar xvfz athenz-utils-X.Y-bin.tar.gz Prerequisites \u00b6 Before you can use the ZTS RoleCertificate utility, you need to have asked the Athenz administrators to create your top level domain. Usage \u00b6 Role X.509 certificates can only be requested using Athenz x.509 Identity certificates. Typically you configure your service identity agent (SIA) to automatically fetch and refresh the role certificates. Requesting Role Certificates \u00b6 $ zts-rolecert -svc-key-file <key-file> -svc-cert-file <cert-file> -zts https://zts-server.athenzcompany.com:4443/zts/v1 -role-domain <domain> -role-name <name> -dns-domain <dns-domain> [-role-cert-file <output-cert-file>]","title":"ZTS Role Certificate Client Utility"},{"location":"zts_rolecert/#overview","text":"ZTS Role Certificate Client utility uses Athenz Service Identity certificate to request a X509 Certificate for the requested role from ZTS Server. Once ZTS validates the service identity certificate, it will issue a new 30-day X509 Certificate for the role. Unlike access tokens, role certificates are issued for a given role only.","title":"Overview"},{"location":"zts_rolecert/#getting-software","text":"Download latest ZTS Role Certificate Client utility binary release from Maven Central : click on the Browse button, choose the latest version directory and then download the athenz-utils-<latest-version>-bin.tar.gz . $ tar xvfz athenz-utils-X.Y-bin.tar.gz","title":"Getting Software"},{"location":"zts_rolecert/#prerequisites","text":"Before you can use the ZTS RoleCertificate utility, you need to have asked the Athenz administrators to create your top level domain.","title":"Prerequisites"},{"location":"zts_rolecert/#usage","text":"Role X.509 certificates can only be requested using Athenz x.509 Identity certificates. Typically you configure your service identity agent (SIA) to automatically fetch and refresh the role certificates.","title":"Usage"},{"location":"zts_rolecert/#requesting-role-certificates","text":"$ zts-rolecert -svc-key-file <key-file> -svc-cert-file <cert-file> -zts https://zts-server.athenzcompany.com:4443/zts/v1 -role-domain <domain> -role-name <name> -dns-domain <dns-domain> [-role-cert-file <output-cert-file>]","title":"Requesting Role Certificates"},{"location":"design/azure_identity_access_tokens/","text":"Azure Identity Access Tokens \u00b6 Integration with Azure's user managed identities serves two purposes in Athenz: Athenz users can obtain access tokens for Azure APIs, for their Azure identities, through ZTS and by being part of designated Athenz roles. ZTS can access Azure APIs to run an instance provider component internally, supporting any number of tenants with an Azure subscription in an easy manner. Design \u00b6 Azure allows its users to exchange ID tokens signed by a designated issuer for access tokens for a configured user managed identity: Azure reference documentation . This API for federated identities is a bit limited; only the iss , sub and aud claims are relevant: The designated issuer must match the iss claim. The aud is encouraged to be api://AzureADTokenExchange . This means the issuer must use the sub claim to differentiate between exchange ID tokens for different Azure identities. As the main goal here is to allow Athenz users to translate their Athenz credentials into Azure access tokens, and we want to use Athenz role membership to control who has access to what federated Azure identities, we propose the following configuration of the federated identity credentials in Azure: ZTS issues ID tokens with its configured OAuth issuer in the iss claim. Each Azure identity is linked to a single Athenz role; this link is established by using the full role ARN, e.g., coretech:role.azure-client , as the expected sub of the exchange tokens. ZTS uses the suggested api://AzureADTokenExchange for the aud claim. We also want the Athenz users to be able to obtain credentials for an Azure identity by its name and enclosing resource group , rather than the UUID-type client ID of the credential. This requires ZTS to have read access to the user managed identities of the user's Azure subscription, which we solve by configuring a dedicated \"Athenz Azure client\" identity in the Azure subscription, with the required read privileges. Giving this identity read privileges to VM instance metadata also allows ZTS to run the Azure instance provider (below), which is easier than setting up a webserver which runs the provider code within each Azure subscription. Required setup \u00b6 To enable the Azure integration, there is some configuration on the Athenz side for the Athenz system administrators. Users must do some setup in both Athenz and Azure for onboarding, and also for each new Azure identity to assume. Athenz \u00b6 Globally, for the whole Athenz system: Create a system role athenz.azure:role.azure-client . This represents ZTS, and will allow access to Azure APIs needed to verify VM instance identity requests and look up Azure identities. Ensure all instance providers are members of this role, so they can read VM data. The Azure Access Token Provider obtains ID tokens for this role without memership checks. Required configuration for the ZTS server (which also runs the instance providers): athenz.zts.external_creds_providers=gcp,azure (Azure is not enabled by default.) athenz.zts.oauth_issuer=<ZTS API URL> athenz.zts.azure_resource_uri=api://<ZTS HOSTNAME> athenz.zts.azure_dns_suffix=... (System-specific.) For each domain that uses Azure as a cloud provider: Specify Azure subscription , tenant and client on the domain; these are system meta attributes, see the below RDL changes for details. For each user managed Azure identity to assume, create a designated role under the domain. Members of this role will be able to acquire an access token for the linked Azure identity from ZTS, for configured scope(s): Create a policy ALLOW azure.scope_access to <identity> on <scope> , e.g. allow the linked role default scope access: ALLOW azure.scope_access to azure-log-reader on https://management.azure.com/.default . Not implemented, but a suggestion for later: Create a policy ALLOW azure.assume_identity to XXX on <resource group>.<client name> that can be used by ZMS to list accessible identities for a user, like for AWS and GCP. Azure \u00b6 For each Azure tenant: Create the \"Athenz Azure client\" user managed identity, which ZTS assumes when reading data (VMs and user managed identities, see above): Add a federated credential which allows ZTS to assume the identity with: issuer: <ZTS API URL> subject: athenz.azure:role.azure-client audience: api://AzureADTokenExchange Create and assign it a role with permissions: Microsoft.ManagedIdentity/userAssignedIdentities/read Microsoft.Compute/virtualMachines/read Note the ID of the created identity, and register it on the corresponding Athenz domain, together with the tenant and subscription IDs (see above). Create an app registration to use as the token audience for VM metadata (required configuration for the SIA agent on Azure VMs), with: sign-in-audience: AzureADMultipleOrgs identifier-uris: api://<ZTS HOSTNAME> Set up additional user managed identities with custom roles, as required: Add a federated credential which allows members of the designated Athenz role to assume the identity: issuer: <ZTS API URL> subject: <domain>:role.<role> audience: api://AzureADTokenExchange Note the resource group and name of the identity; these are used when obtaining access tokens through Athenz, see below. Multiple subscriptions within the same tenant can share the same client setup. RDL Struct Updates \u00b6 DomainMeta has two new system meta attribute fields azureTenant and azureClient : type DomainMeta Struct { ... String azureSubscription (optional); //associated azure subscription id (system attribute - uniqueness check - if enabled) String azureTenant (optional); //associated azure tenant id (system attribute) String azureClient (optional); //associated azure client id (system attribute) ... } API Changes \u00b6 Configuring domain for Azure \u00b6 The new DomainMeta fields are updated like azureSubscription , through PUT \"/domain/{name}/meta/system/{attribute}\" . The payload must now contain all three fields (above)\u2014not just the azureSubscription . Obtaining Azure access tokens \u00b6 To get an access token for the example user managed identity log-reader in the Azure resource group system , associated with the Athenz role azure-log-reader under the Athenz domain coretech , simply do: POST <ZTS API URL>/external/azure/coretech/creds { \"clientId\": \"coretech.azure\", \"attributes\": { \"athenzRole\": \"azure-log-reader\", \"azureResourceGroup\": \"system\", \"azureClientName\": \"log-reader\", \u201cazureScope\": <optional: defaults to \"https://management.azure.com/.default\"> } } Note 1: The :clientId: should be <domain>.azure , although it is not really used for anything. This was done to match the GCP setup. Note 2: It is also possible to specify \"azureClientId\" instead of \"azureResourceGroup\" and \"azureClientName\" . When this is specified, ZTS skips the client ID lookup, and uses the supplied value instead.","title":"Azure Identity Access Tokens"},{"location":"design/azure_identity_access_tokens/#azure-identity-access-tokens","text":"Integration with Azure's user managed identities serves two purposes in Athenz: Athenz users can obtain access tokens for Azure APIs, for their Azure identities, through ZTS and by being part of designated Athenz roles. ZTS can access Azure APIs to run an instance provider component internally, supporting any number of tenants with an Azure subscription in an easy manner.","title":"Azure Identity Access Tokens"},{"location":"design/azure_identity_access_tokens/#design","text":"Azure allows its users to exchange ID tokens signed by a designated issuer for access tokens for a configured user managed identity: Azure reference documentation . This API for federated identities is a bit limited; only the iss , sub and aud claims are relevant: The designated issuer must match the iss claim. The aud is encouraged to be api://AzureADTokenExchange . This means the issuer must use the sub claim to differentiate between exchange ID tokens for different Azure identities. As the main goal here is to allow Athenz users to translate their Athenz credentials into Azure access tokens, and we want to use Athenz role membership to control who has access to what federated Azure identities, we propose the following configuration of the federated identity credentials in Azure: ZTS issues ID tokens with its configured OAuth issuer in the iss claim. Each Azure identity is linked to a single Athenz role; this link is established by using the full role ARN, e.g., coretech:role.azure-client , as the expected sub of the exchange tokens. ZTS uses the suggested api://AzureADTokenExchange for the aud claim. We also want the Athenz users to be able to obtain credentials for an Azure identity by its name and enclosing resource group , rather than the UUID-type client ID of the credential. This requires ZTS to have read access to the user managed identities of the user's Azure subscription, which we solve by configuring a dedicated \"Athenz Azure client\" identity in the Azure subscription, with the required read privileges. Giving this identity read privileges to VM instance metadata also allows ZTS to run the Azure instance provider (below), which is easier than setting up a webserver which runs the provider code within each Azure subscription.","title":"Design"},{"location":"design/azure_identity_access_tokens/#required-setup","text":"To enable the Azure integration, there is some configuration on the Athenz side for the Athenz system administrators. Users must do some setup in both Athenz and Azure for onboarding, and also for each new Azure identity to assume.","title":"Required setup"},{"location":"design/azure_identity_access_tokens/#athenz","text":"Globally, for the whole Athenz system: Create a system role athenz.azure:role.azure-client . This represents ZTS, and will allow access to Azure APIs needed to verify VM instance identity requests and look up Azure identities. Ensure all instance providers are members of this role, so they can read VM data. The Azure Access Token Provider obtains ID tokens for this role without memership checks. Required configuration for the ZTS server (which also runs the instance providers): athenz.zts.external_creds_providers=gcp,azure (Azure is not enabled by default.) athenz.zts.oauth_issuer=<ZTS API URL> athenz.zts.azure_resource_uri=api://<ZTS HOSTNAME> athenz.zts.azure_dns_suffix=... (System-specific.) For each domain that uses Azure as a cloud provider: Specify Azure subscription , tenant and client on the domain; these are system meta attributes, see the below RDL changes for details. For each user managed Azure identity to assume, create a designated role under the domain. Members of this role will be able to acquire an access token for the linked Azure identity from ZTS, for configured scope(s): Create a policy ALLOW azure.scope_access to <identity> on <scope> , e.g. allow the linked role default scope access: ALLOW azure.scope_access to azure-log-reader on https://management.azure.com/.default . Not implemented, but a suggestion for later: Create a policy ALLOW azure.assume_identity to XXX on <resource group>.<client name> that can be used by ZMS to list accessible identities for a user, like for AWS and GCP.","title":"Athenz"},{"location":"design/azure_identity_access_tokens/#azure","text":"For each Azure tenant: Create the \"Athenz Azure client\" user managed identity, which ZTS assumes when reading data (VMs and user managed identities, see above): Add a federated credential which allows ZTS to assume the identity with: issuer: <ZTS API URL> subject: athenz.azure:role.azure-client audience: api://AzureADTokenExchange Create and assign it a role with permissions: Microsoft.ManagedIdentity/userAssignedIdentities/read Microsoft.Compute/virtualMachines/read Note the ID of the created identity, and register it on the corresponding Athenz domain, together with the tenant and subscription IDs (see above). Create an app registration to use as the token audience for VM metadata (required configuration for the SIA agent on Azure VMs), with: sign-in-audience: AzureADMultipleOrgs identifier-uris: api://<ZTS HOSTNAME> Set up additional user managed identities with custom roles, as required: Add a federated credential which allows members of the designated Athenz role to assume the identity: issuer: <ZTS API URL> subject: <domain>:role.<role> audience: api://AzureADTokenExchange Note the resource group and name of the identity; these are used when obtaining access tokens through Athenz, see below. Multiple subscriptions within the same tenant can share the same client setup.","title":"Azure"},{"location":"design/azure_identity_access_tokens/#rdl-struct-updates","text":"DomainMeta has two new system meta attribute fields azureTenant and azureClient : type DomainMeta Struct { ... String azureSubscription (optional); //associated azure subscription id (system attribute - uniqueness check - if enabled) String azureTenant (optional); //associated azure tenant id (system attribute) String azureClient (optional); //associated azure client id (system attribute) ... }","title":"RDL Struct Updates"},{"location":"design/azure_identity_access_tokens/#api-changes","text":"","title":"API Changes"},{"location":"design/azure_identity_access_tokens/#configuring-domain-for-azure","text":"The new DomainMeta fields are updated like azureSubscription , through PUT \"/domain/{name}/meta/system/{attribute}\" . The payload must now contain all three fields (above)\u2014not just the azureSubscription .","title":"Configuring domain for Azure"},{"location":"design/azure_identity_access_tokens/#obtaining-azure-access-tokens","text":"To get an access token for the example user managed identity log-reader in the Azure resource group system , associated with the Athenz role azure-log-reader under the Athenz domain coretech , simply do: POST <ZTS API URL>/external/azure/coretech/creds { \"clientId\": \"coretech.azure\", \"attributes\": { \"athenzRole\": \"azure-log-reader\", \"azureResourceGroup\": \"system\", \"azureClientName\": \"log-reader\", \u201cazureScope\": <optional: defaults to \"https://management.azure.com/.default\"> } } Note 1: The :clientId: should be <domain>.azure , although it is not really used for anything. This was done to match the GCP setup. Note 2: It is also possible to specify \"azureClientId\" instead of \"azureResourceGroup\" and \"azureClientName\" . When this is specified, ZTS skips the client ID lookup, and uses the supplied value instead.","title":"Obtaining Azure access tokens"},{"location":"design/resource_ownership/","text":"Resource Ownership in Athenz \u00b6 The following are the use cases that we\u2019re trying to solve with the introduction of resource ownership in Athenz: The domain administrator is using TF to manage domain data (could be using a personal account or some service identity). The administrator wants to block access to those resources to be modified using Athenz UI and/or zms-cli since that will create a drift in TF state. The administrator should have the capability to override the ownership and make changes in case of emergency situations (e.g. TF deleted a service identity from a role but it needs to be re-added asap). This capability must be available using zms-cli and preferably from Athenz UI as well. In Athenz UI I should be prompted that the user should not proceed with the move unless explicitly specified. The roles/policies are created and managed by another service built on-top of Athenz. The operator wants those resources not to be visible in Athenz UI based on the ownership state and only make them available in their respective solution UIs. Resource ownership should support partial ownership. For example, with roles and groups, TF can manage either members or meta so the server must support and enforce ownership at that level and not just at the object level. This indicates that there might be multiple owners of the same resources Questionable ones: List resources (roles/groups/services/policies) in a domain by the specified ownership field - is there a use case for this? UI should be able to retrieve all objects, look at the resource owner field and make a decision to display or not Design \u00b6 RDL Struct Updates \u00b6 type ResourceDomainOwnership Struct { SimpleName metaOwner (optional); //owner of the object's meta attribute SimpleName objectOwner (optional); //owner of the object itself - checked for object deletion } type ResourceRoleOwnership Struct { SimpleName metaOwner (optional); //owner of the object's meta attribute SimpleName membersOwner (optional); //owner of the object's members attribute SimpleName objectOwner (optional); //owner of the object itself - checked for object deletion } type ResourceGroupOwnership Struct { SimpleName metaOwner (optional); //owner of the object's meta attribute SimpleName membersOwner (optional); //owner of the object's members attribute SimpleName objectOwner (optional); //owner of the object itself - checked for object deletion } type ResourceServiceIdentityOwnership Struct { SimpleName publicKeysOwner (optional); //owner of the object's public keys attribute SimpleName hostsOwner (optional); //owner of the object's hosts attribute SimpleName objectOwner (optional); //owner of the object itself - checked for object deletion } type ResourcePolicyOwnership Struct { SimpleName assertionsOwner (optional); //owner of the object's assertions attribute SimpleName objectOwner (optional); //owner of the object itself - checked for object deletion } type DomainMeta Struct { String description (optional); //a description of the domain \u2026 String environment (optional, x_allowempty=\"true\"); //domain environment e.g. production, staging, etc ResourceDomainOwnership resourceOwnership (optional); // read-only attribute containing list of resource owners } type RoleMeta Struct { Bool selfServe (optional, default=false); //Flag indicates whether or not role allows self service. Users can add themselves in the role, but it has to be approved by domain admins to be effective. \u2026 Int32 maxMembers (optional); //Maximum number of members allowed in the group ResourceRoleOwnership resourceOwnership (optional); // read-only attribute containing list of resource owners } type GroupMeta Struct { Bool selfServe (optional, default=false); //Flag indicates whether or not a group allows self service. Users can add themselves in the group, but it has to be approved by domain admins to be effective. \u2026 Int32 maxMembers (optional); //Maximum number of members allowed in the group ResourceGroupOwnership resourceOwnership (optional); // read-only attribute containing list of resource owners } type Policy Struct { ResourceName name; //name of the policy \u2026 Map<TagKey,TagValueList> tags (optional); //key-value pair tags, tag might contain multiple values ResourcePolicyOwnership resourceOwnership (optional); // read-only attribute containing list of resource owners } type ServiceIdentity Struct { ServiceName name; //the full name of the service, i.e. \"sports.storage\" \u2026. Map<TagKey,TagValueList> tags (optional); //key-value pair tags, tag might contain multiple values ResourceServiceOwnership resourceOwnership (optional); // read-only attribute containing list of resource owners. } API Changes \u00b6 The ownership is passed using Athenz-Resource-Owner header value. The owner has the syntax of SimpleName as defined in the ZMS RDL and must less than 32 characters. For example, all the PUT apis for the objects listed above will be updated accordingly. resource Membership PUT \"/domain/{domainName}/role/{roleName}/member/{memberName}\" { DomainName domainName; //name of the domain EntityName roleName; //name of the role MemberName memberName; //name of the user to be added as a member String auditRef (header=\"Y-Audit-Ref\"); //Audit param required(not empty) if domain auditEnabled is true. Bool returnObj (optional, default=false, header=\"Athenz-Return-Object\"); //Return object param updated object back. String resourceOwner (header=\"Athenz-Resource-Owner\"); //Resource owner for the object type or component Membership membership; //Membership object (must contain role/member names as specified in the URI) authenticate; expected NO_CONTENT, OK; exceptions { ResourceError NOT_FOUND; ResourceError BAD_REQUEST; ResourceError FORBIDDEN; ResourceError UNAUTHORIZED; ResourceError CONFLICT; ResourceError TOO_MANY_REQUESTS; } } Resource Ownership \u00b6 There is a corresponding API for each of the object types: domain, role, group, service and policy. Here is the example for roles: // Set the resource ownership for the given role resource ResourceRoleOwnership PUT \"/domain/{domainName}/role/{roleName}/ownership\" { DomainName domainName; //name of the domain EntityName roleName; //name of the role ResourceRoleOwnership resourceOwnership; //resource ownership to be set for the given role authorize (\"update\", \"{domainName}:meta.role.ownership.{roleName}\"); expected NO_CONTENT; exceptions { ResourceError BAD_REQUEST; ResourceError NOT_FOUND; ResourceError FORBIDDEN; ResourceError UNAUTHORIZED; ResourceError TOO_MANY_REQUESTS; } } Resource Ownership Set \u00b6 Resource Ownership can be set in two ways: Using the putResourceOwnership API. Using this api, the domain administrator can set or update any of the existing resource owners set for a given object Set by the server when the appropriate api is called with the Athenz-Resource-Owner header set and there is no current owner set For example, the caller issues putMembership call against sports:role.readers role and includes the header Athenz-Resource-Owner: TF . The server will process the request if the role readers does not have the resource ownership set for members field, it will update the resource ownership and set the membersOwner to TF. Resource Ownership Verification \u00b6 When processing an API for an object that may have a resource ownership set, the server will extract the object first and see if the given resource ownership field is set. - If the resource ownership is not set the request is processed - If the resource ownership is set and the request does not include the Athenz-Resource-Owner header then the request is rejected. - If the resource ownership is set and the request includes the Athenz-Resource-Owner header then the request is processed if the values match otherwise it is rejected. When the request is rejected due to resource ownership verification failure, the server will respond with HTTP 409 Conflict status code. Resource Ownership Verification Override \u00b6 As mentioned above, there might be cases where the resource ownership should be ignored and the change should be applied to the domain. The server supports a special value for the Athenz-Resource-Owner header: ignore . If the request includes this header, then the request is processed regardless or not the resource ownership is set. So the ignore is treated as a special value indicating to the server to skip any resource ownership checks. The value can be configured by the system adminstrator by using the athenz.zms.resource_owner_ignore_value system property. UI Changes \u00b6 The Athenz UI will need to be updated to provide the following functionality: Provide a configuration option by default to exclude objects with the given ownership from the list views. For example, if I enable ownerObject: TF to be excluded from the list, then the UI will retrieve all the objects, but by default do not display any objects that have the resourceOwnership set with the ownerObject set to TF. However, it must provide the capability to display all entries if requested. Handling of entries that have resource ownership set. A couple of options present: Handle errors after request rejection If the UI tries to update an object and ZMS rejects the request with ownership error (HTTP 409 status code), the UI should clearly notify the user that the request was rejected due to ownership error and provide the option to override the ownership. If the ownership override option was selected, the request must be submitted to ZMS with the Athenz-Resource-Owner: ignore header. Check resource ownership in advance The UI can look at the current resourceOwnership attribute of the entry and let the user know in advance that they\u2019re modifying an entry that they shouldn\u2019t modify. If the user still wants to modify the entry and override the current ownership, the request must be submitted to ZMS with the Athenz-Resource-Owner: ignore header.","title":"Resource Ownership in Athenz"},{"location":"design/resource_ownership/#resource-ownership-in-athenz","text":"The following are the use cases that we\u2019re trying to solve with the introduction of resource ownership in Athenz: The domain administrator is using TF to manage domain data (could be using a personal account or some service identity). The administrator wants to block access to those resources to be modified using Athenz UI and/or zms-cli since that will create a drift in TF state. The administrator should have the capability to override the ownership and make changes in case of emergency situations (e.g. TF deleted a service identity from a role but it needs to be re-added asap). This capability must be available using zms-cli and preferably from Athenz UI as well. In Athenz UI I should be prompted that the user should not proceed with the move unless explicitly specified. The roles/policies are created and managed by another service built on-top of Athenz. The operator wants those resources not to be visible in Athenz UI based on the ownership state and only make them available in their respective solution UIs. Resource ownership should support partial ownership. For example, with roles and groups, TF can manage either members or meta so the server must support and enforce ownership at that level and not just at the object level. This indicates that there might be multiple owners of the same resources Questionable ones: List resources (roles/groups/services/policies) in a domain by the specified ownership field - is there a use case for this? UI should be able to retrieve all objects, look at the resource owner field and make a decision to display or not","title":"Resource Ownership in Athenz"},{"location":"design/resource_ownership/#design","text":"","title":"Design"},{"location":"design/resource_ownership/#rdl-struct-updates","text":"type ResourceDomainOwnership Struct { SimpleName metaOwner (optional); //owner of the object's meta attribute SimpleName objectOwner (optional); //owner of the object itself - checked for object deletion } type ResourceRoleOwnership Struct { SimpleName metaOwner (optional); //owner of the object's meta attribute SimpleName membersOwner (optional); //owner of the object's members attribute SimpleName objectOwner (optional); //owner of the object itself - checked for object deletion } type ResourceGroupOwnership Struct { SimpleName metaOwner (optional); //owner of the object's meta attribute SimpleName membersOwner (optional); //owner of the object's members attribute SimpleName objectOwner (optional); //owner of the object itself - checked for object deletion } type ResourceServiceIdentityOwnership Struct { SimpleName publicKeysOwner (optional); //owner of the object's public keys attribute SimpleName hostsOwner (optional); //owner of the object's hosts attribute SimpleName objectOwner (optional); //owner of the object itself - checked for object deletion } type ResourcePolicyOwnership Struct { SimpleName assertionsOwner (optional); //owner of the object's assertions attribute SimpleName objectOwner (optional); //owner of the object itself - checked for object deletion } type DomainMeta Struct { String description (optional); //a description of the domain \u2026 String environment (optional, x_allowempty=\"true\"); //domain environment e.g. production, staging, etc ResourceDomainOwnership resourceOwnership (optional); // read-only attribute containing list of resource owners } type RoleMeta Struct { Bool selfServe (optional, default=false); //Flag indicates whether or not role allows self service. Users can add themselves in the role, but it has to be approved by domain admins to be effective. \u2026 Int32 maxMembers (optional); //Maximum number of members allowed in the group ResourceRoleOwnership resourceOwnership (optional); // read-only attribute containing list of resource owners } type GroupMeta Struct { Bool selfServe (optional, default=false); //Flag indicates whether or not a group allows self service. Users can add themselves in the group, but it has to be approved by domain admins to be effective. \u2026 Int32 maxMembers (optional); //Maximum number of members allowed in the group ResourceGroupOwnership resourceOwnership (optional); // read-only attribute containing list of resource owners } type Policy Struct { ResourceName name; //name of the policy \u2026 Map<TagKey,TagValueList> tags (optional); //key-value pair tags, tag might contain multiple values ResourcePolicyOwnership resourceOwnership (optional); // read-only attribute containing list of resource owners } type ServiceIdentity Struct { ServiceName name; //the full name of the service, i.e. \"sports.storage\" \u2026. Map<TagKey,TagValueList> tags (optional); //key-value pair tags, tag might contain multiple values ResourceServiceOwnership resourceOwnership (optional); // read-only attribute containing list of resource owners. }","title":"RDL Struct Updates"},{"location":"design/resource_ownership/#api-changes","text":"The ownership is passed using Athenz-Resource-Owner header value. The owner has the syntax of SimpleName as defined in the ZMS RDL and must less than 32 characters. For example, all the PUT apis for the objects listed above will be updated accordingly. resource Membership PUT \"/domain/{domainName}/role/{roleName}/member/{memberName}\" { DomainName domainName; //name of the domain EntityName roleName; //name of the role MemberName memberName; //name of the user to be added as a member String auditRef (header=\"Y-Audit-Ref\"); //Audit param required(not empty) if domain auditEnabled is true. Bool returnObj (optional, default=false, header=\"Athenz-Return-Object\"); //Return object param updated object back. String resourceOwner (header=\"Athenz-Resource-Owner\"); //Resource owner for the object type or component Membership membership; //Membership object (must contain role/member names as specified in the URI) authenticate; expected NO_CONTENT, OK; exceptions { ResourceError NOT_FOUND; ResourceError BAD_REQUEST; ResourceError FORBIDDEN; ResourceError UNAUTHORIZED; ResourceError CONFLICT; ResourceError TOO_MANY_REQUESTS; } }","title":"API Changes"},{"location":"design/resource_ownership/#resource-ownership","text":"There is a corresponding API for each of the object types: domain, role, group, service and policy. Here is the example for roles: // Set the resource ownership for the given role resource ResourceRoleOwnership PUT \"/domain/{domainName}/role/{roleName}/ownership\" { DomainName domainName; //name of the domain EntityName roleName; //name of the role ResourceRoleOwnership resourceOwnership; //resource ownership to be set for the given role authorize (\"update\", \"{domainName}:meta.role.ownership.{roleName}\"); expected NO_CONTENT; exceptions { ResourceError BAD_REQUEST; ResourceError NOT_FOUND; ResourceError FORBIDDEN; ResourceError UNAUTHORIZED; ResourceError TOO_MANY_REQUESTS; } }","title":"Resource Ownership"},{"location":"design/resource_ownership/#resource-ownership-set","text":"Resource Ownership can be set in two ways: Using the putResourceOwnership API. Using this api, the domain administrator can set or update any of the existing resource owners set for a given object Set by the server when the appropriate api is called with the Athenz-Resource-Owner header set and there is no current owner set For example, the caller issues putMembership call against sports:role.readers role and includes the header Athenz-Resource-Owner: TF . The server will process the request if the role readers does not have the resource ownership set for members field, it will update the resource ownership and set the membersOwner to TF.","title":"Resource Ownership Set"},{"location":"design/resource_ownership/#resource-ownership-verification","text":"When processing an API for an object that may have a resource ownership set, the server will extract the object first and see if the given resource ownership field is set. - If the resource ownership is not set the request is processed - If the resource ownership is set and the request does not include the Athenz-Resource-Owner header then the request is rejected. - If the resource ownership is set and the request includes the Athenz-Resource-Owner header then the request is processed if the values match otherwise it is rejected. When the request is rejected due to resource ownership verification failure, the server will respond with HTTP 409 Conflict status code.","title":"Resource Ownership Verification"},{"location":"design/resource_ownership/#resource-ownership-verification-override","text":"As mentioned above, there might be cases where the resource ownership should be ignored and the change should be applied to the domain. The server supports a special value for the Athenz-Resource-Owner header: ignore . If the request includes this header, then the request is processed regardless or not the resource ownership is set. So the ignore is treated as a special value indicating to the server to skip any resource ownership checks. The value can be configured by the system adminstrator by using the athenz.zms.resource_owner_ignore_value system property.","title":"Resource Ownership Verification Override"},{"location":"design/resource_ownership/#ui-changes","text":"The Athenz UI will need to be updated to provide the following functionality: Provide a configuration option by default to exclude objects with the given ownership from the list views. For example, if I enable ownerObject: TF to be excluded from the list, then the UI will retrieve all the objects, but by default do not display any objects that have the resourceOwnership set with the ownerObject set to TF. However, it must provide the capability to display all entries if requested. Handling of entries that have resource ownership set. A couple of options present: Handle errors after request rejection If the UI tries to update an object and ZMS rejects the request with ownership error (HTTP 409 status code), the UI should clearly notify the user that the request was rejected due to ownership error and provide the option to override the ownership. If the ownership override option was selected, the request must be submitted to ZMS with the Athenz-Resource-Owner: ignore header. Check resource ownership in advance The UI can look at the current resourceOwnership attribute of the entry and let the user know in advance that they\u2019re modifying an entry that they shouldn\u2019t modify. If the user still wants to modify the entry and override the current ownership, the request must be submitted to ZMS with the Athenz-Resource-Owner: ignore header.","title":"UI Changes"}]}