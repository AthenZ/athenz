{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Athenz is a set of services and libraries supporting service authentication and role-based authorization (RBAC) for provisioning and configuration (centralized authorization) use cases as well as serving/runtime (decentralized authorization) use cases. Athenz authorization system utilizes x.509 certificates and Access Tokens. The name \"Athenz\" is derived from \"AuthNZ\" (N for authentication and Z for authorization). It provides support for the following three major functional areas. Service Authentication \u00b6 Athenz provides secure identity in the form of short lived X.509 certificate and a certificate and IP-based distributed system to handle for every workload or service deployed in private (e.g. Openstack, K8S, Screwdriver) on-box enforcement. or public cloud (e.g. AWS EC2, ECS, Fargate, Lambda). Using these X.509 certificates clients and services establish secure connections and through mutual TLS authentication verify each other's identity. The service identity certificates are valid for 30 days only and the service identity agents (SIA) part of those frameworks automatically refresh them daily. The term service within Athenz is more generic than a traditional service. A service identity could represent a command, job, daemon, workflow, as well as both an application client and an application service. Since Athenz service authentication is based on X.509 certificates , it is important that you have a good understanding what X.509 certificates are and how they're used to establish secure connections in Internet protocols such as TLS . Role-Based Authorization (RBAC) \u00b6 Once the client is authenticated with its x.509 certificate, the service their own role-based access control systems that have no central store can then check if the given client is authorized to carry out the requested and often rely on network ACLs and manual updating. action. Athenz provides fine-grained role-based access control (RBAC) support for a centralized management system with support for control-plane access control decisions and a decentralized enforcement mechanism suitable for data-plane access control decisions. It also provides a delegated management model that supports multi-tenant and self-service concepts. AWS Temporary Credentials Support \u00b6 When working with AWS, Athenz provides support to access AWS services from on-prem services with using AWS temporary credentials rather than static credentials. Athenz ZTS server can be used to request AWS temporary credentials for configured AWS IAM roles.","title":"About"},{"location":"#service-authentication","text":"Athenz provides secure identity in the form of short lived X.509 certificate and a certificate and IP-based distributed system to handle for every workload or service deployed in private (e.g. Openstack, K8S, Screwdriver) on-box enforcement. or public cloud (e.g. AWS EC2, ECS, Fargate, Lambda). Using these X.509 certificates clients and services establish secure connections and through mutual TLS authentication verify each other's identity. The service identity certificates are valid for 30 days only and the service identity agents (SIA) part of those frameworks automatically refresh them daily. The term service within Athenz is more generic than a traditional service. A service identity could represent a command, job, daemon, workflow, as well as both an application client and an application service. Since Athenz service authentication is based on X.509 certificates , it is important that you have a good understanding what X.509 certificates are and how they're used to establish secure connections in Internet protocols such as TLS .","title":"Service Authentication"},{"location":"#role-based-authorization-rbac","text":"Once the client is authenticated with its x.509 certificate, the service their own role-based access control systems that have no central store can then check if the given client is authorized to carry out the requested and often rely on network ACLs and manual updating. action. Athenz provides fine-grained role-based access control (RBAC) support for a centralized management system with support for control-plane access control decisions and a decentralized enforcement mechanism suitable for data-plane access control decisions. It also provides a delegated management model that supports multi-tenant and self-service concepts.","title":"Role-Based Authorization (RBAC)"},{"location":"#aws-temporary-credentials-support","text":"When working with AWS, Athenz provides support to access AWS services from on-prem services with using AWS temporary credentials rather than static credentials. Athenz ZTS server can be used to request AWS temporary credentials for configured AWS IAM roles.","title":"AWS Temporary Credentials Support"},{"location":"athenz_templates/","text":"Introducing Athenz Templates \u00b6 Templates are a collection of predefined roles, policies and services that can be applied on a domain. Imagine in a real world scenario if you are creating a solution for any organization(Openstack, Kubernetes) and subsequently want to set up provisioning rules(a static set of roles and policies) for the solution, rather than requiring each domain admin to create each of these roles and policies manually, you can pre-bundle the roles and policies as a template and Athenz will automatically apply them for you while creating or updating a domain. Templates \u00b6 Creating and updating templates \u00b6 All templates will be managed by the Athenz System Administrators. To create / update templates, the administrators should create a file named solution_templates.json and store it in their data repository. The file should follow the format below { \"<template_name>\": { \"metadata\": {}, \"roles\": [<athenz-roles>], \"policies\": [<athenz-policies>], \"services\": [<athenz-services>] } } A sample file can be found at servers/zms/conf/solution_templates.json Template Entities \u00b6 A Template consists of metadata, services, roles and role metadata, policies with assertions. Please find the explanation for every entity below MetaData \u00b6 Metadata contains critical fields to represent vital characteristics of a template. Look at the sample structure below for one of the templates in use. \"metadata\": { \"latestVersion\": 1, \"timestamp\": \"2020-06-16T00:00:00.000Z\", \"description\": \"Description of template\", \"keywordsToReplace\": \"_env_,_track_\", \"autoUpdate\": false } A - Description - description of the template (restrict it to 140 characters if possible) B - latestVersion - to manage versioning. Everytime there is a change in the template including a template metadata change, Make sure to bump up the latestVersion field by 1. C - Timestamp - recorded timestamp when you update(including metadata change) a template. This is purely to help you time track template changes. D - keywordsToReplace - this field is a comma separated placeholder you can add to your role/policy name which will be auto replaced on the fly. for ex: keywordsToReplace will be set to \u201c env , track \u201d for a role name \u201c domain :role.some-role. env .track. track .emitters\". You should leave keywordsToReplace field empty if you do not have any placeholders in your role or policy name. (for ex: \"keywordsToReplace\": \"\",) Note: domain is the only exception here. When applying a template to a domain, the server will automatically include the correct domain name in role/policy names by replacing the domain placeholder with the appropriate value so do not worry about adding it. Example structure of roles/policies which uses multiple placeholders: \"roles\": [ { \"name\": \"_domain_:role.some-role._env_.track._track_.emitters\", \"modified\": \"1970-01-01T00:00:00.000Z\" } ], \"policies\": [ { \"name\": \"_domain_:policy.some-policy._env_.track._track_.emitters\", \"modified\": \"1970-01-01T00:00:00.000Z\", \"assertions\": [ { \"resource\": \"some-resource._env_:role.track._track_.emitters\", \"role\": \"_domain_:role.some-role._env_.track._track_.emitters\", \"action\": \"assume_role\" } ] } ] Roles \u00b6 Roles can have attributes like name, modified timestamp, Role Meta attributes (check the complete role meta attributes list below) and roleMembers. By default roles that are created by the template will not have any members unless the role members are hard-coded in the template (check the example structure below). The domain administrator will need to add members to those roles after the domain is created or the template has been applied to a domain. Now if you notice role members array in the image below, members can also have placeholders which have to be added to keywordsToReplace. Sample structure for Roles with role members: \"roles\": [ { \"name\": \"_domain_:role.aws_instance_launch_provider\", \"modified\": \"1970-01-01T00:00:00.000Z\", \"roleMembers\": [ { \"memberName\": \"athens.aws.*\" } ] }, { \"name\": \"_domain_:role.aws.ssh_login\", \"modified\": \"1970-01-01T00:00:00.000Z\" }, { \"name\": \"_domain_:role.aws_ssh_cert_request\", \"modified\": \"1970-01-01T00:00:00.000Z\", \"roleMembers\": [ { \"memberName\": \"_domain_._service_\" } ] } ] Allowed Role Meta Attributes: \"selfServe\": \"false\", \"memberExpiryDays\": 90, \"tokenExpiryMins\": 30, \"certExpiryMins\": 10, \"serviceExpiryDays\": 50, \"memberReviewDays\": 65, \"serviceReviewDays\": 15, \"reviewEnabled\": true Policies \u00b6 Array of policies with name, modified timestamp and array of assertions. Check the sample Json below. \"policies\": [ { \"name\": \"_domain_:policy.aws_instance_launch_provider\", \"modified\": \"1970-01-01T00:00:00.000Z\", \"assertions\": [ { \"resource\": \"_domain_:service._service_\", \"role\": \"_domain_:role.aws_instance_launch_provider\", \"action\": \"launch\" } ] }, { \"name\": \"_domain_:policy.aws.ssh_login\", \"modified\": \"1970-01-01T00:00:00.000Z\", \"assertions\": [ { \"resource\": \"_domain_:aws._service_.*\", \"role\": \"_domain_:role.aws.ssh_login\", \"action\": \"ssh_login\", \"effect\": \"DENY\" } ] } Applying Templates \u00b6 Templates can be applied via ZMS CLI and via Athenz UI. let's take a look at a few examples on how to apply different types of templates. Example 1 \u00b6 Templates with placeholders in role and policy names (aka comma separated values in keywordsToReplace under template metadata field) will have to pass the key value pair for all placeholders via CLI. However, Athenz UI will automatically detect the placeholders and prompt the user to enter those placeholder values without which you cannot apply a template CLI zms-cli -d some-domain set-domain-template some-template-name env=ecli track=clit UI Example 2 \u00b6 Templates with static role and policy names i.e. no placeholders zms-cli -d some-domain set-domain-template other-template-name UI The update button with blue background means there is a latest version of the template available to apply and the update button with white background means there is no new version but you can still apply if you accidentally deleted a policy or role which is part of the template and wanted to patch it up. Auto Update \u00b6 Auto update flag in templates lets the zms server to patch up the changes made to roles and policies automatically. This way the template creator does not need to communicate the tenant domains to patch them up manually through Athenz UI or CLI. AutoUpdate runs on zms servers during application startup in an uninterrupted fashion and applies roles and policies for all eligible templates. This feature will work only for templates with no placeholders at the moment i.e. the metadata section in the template should have the following values keywordsToReplace=\"\" and autoUpdate set to true. Note: it is important to bump up the latestVersion flag to apply any changes in the template including metadata changes like autoUpdate and keywordsToReplace. FAQ \u00b6 1 - What happens if i set the auto-update flag to true in template metadata but did not bump up the version? Auto update will not kick in if the server does not detect a version bump in the template. 2 - Is there a way to apply a template for the first time on a newly created domain in UI? No. you can only update a template in the UI using the apply template button. You have to apply template for the first time via Cli 3 - What happens if i pass a template name that is invalid via CLI? If any of the template names is invalid, the request will be rejected with a Bad Request error message indicating the invalid template name. If the template is not found, then the request will be rejected with a Not Found error message indicating the template name that\u2019s not registered in ZMS. 4 - What is the difference between current version and latest version in the UI? Current version is the template version already applied on your domain and the latest version is a new version that is available for you to apply. You will see a dark blue button in the UI when there is a latest version. 5 - What should i do if i deleted a role or policy which is part of a template by accident? Go to the UI and click on the update button(with white background if the template already has the latest version) and the roles and policies will be recreated. 6 - What if I accidentally created a bunch of roles and policies while experimenting with a template and wanted to delete it? One has to manually clean it up. 7 - What are the different zms-cli commands to manage templates? Template commands: list-server-template list-domain-template show-server-template template set-domain-template template [template ...] [param-key=param-value ...] delete-domain-template template","title":"Athenz Templates"},{"location":"athenz_templates/#introducing-athenz-templates","text":"Templates are a collection of predefined roles, policies and services that can be applied on a domain. Imagine in a real world scenario if you are creating a solution for any organization(Openstack, Kubernetes) and subsequently want to set up provisioning rules(a static set of roles and policies) for the solution, rather than requiring each domain admin to create each of these roles and policies manually, you can pre-bundle the roles and policies as a template and Athenz will automatically apply them for you while creating or updating a domain.","title":"Introducing Athenz Templates"},{"location":"athenz_templates/#templates","text":"","title":"Templates"},{"location":"athenz_templates/#creating-and-updating-templates","text":"All templates will be managed by the Athenz System Administrators. To create / update templates, the administrators should create a file named solution_templates.json and store it in their data repository. The file should follow the format below { \"<template_name>\": { \"metadata\": {}, \"roles\": [<athenz-roles>], \"policies\": [<athenz-policies>], \"services\": [<athenz-services>] } } A sample file can be found at servers/zms/conf/solution_templates.json","title":"Creating and updating templates"},{"location":"athenz_templates/#template-entities","text":"A Template consists of metadata, services, roles and role metadata, policies with assertions. Please find the explanation for every entity below","title":"Template Entities"},{"location":"athenz_templates/#metadata","text":"Metadata contains critical fields to represent vital characteristics of a template. Look at the sample structure below for one of the templates in use. \"metadata\": { \"latestVersion\": 1, \"timestamp\": \"2020-06-16T00:00:00.000Z\", \"description\": \"Description of template\", \"keywordsToReplace\": \"_env_,_track_\", \"autoUpdate\": false } A - Description - description of the template (restrict it to 140 characters if possible) B - latestVersion - to manage versioning. Everytime there is a change in the template including a template metadata change, Make sure to bump up the latestVersion field by 1. C - Timestamp - recorded timestamp when you update(including metadata change) a template. This is purely to help you time track template changes. D - keywordsToReplace - this field is a comma separated placeholder you can add to your role/policy name which will be auto replaced on the fly. for ex: keywordsToReplace will be set to \u201c env , track \u201d for a role name \u201c domain :role.some-role. env .track. track .emitters\". You should leave keywordsToReplace field empty if you do not have any placeholders in your role or policy name. (for ex: \"keywordsToReplace\": \"\",) Note: domain is the only exception here. When applying a template to a domain, the server will automatically include the correct domain name in role/policy names by replacing the domain placeholder with the appropriate value so do not worry about adding it. Example structure of roles/policies which uses multiple placeholders: \"roles\": [ { \"name\": \"_domain_:role.some-role._env_.track._track_.emitters\", \"modified\": \"1970-01-01T00:00:00.000Z\" } ], \"policies\": [ { \"name\": \"_domain_:policy.some-policy._env_.track._track_.emitters\", \"modified\": \"1970-01-01T00:00:00.000Z\", \"assertions\": [ { \"resource\": \"some-resource._env_:role.track._track_.emitters\", \"role\": \"_domain_:role.some-role._env_.track._track_.emitters\", \"action\": \"assume_role\" } ] } ]","title":"MetaData"},{"location":"athenz_templates/#roles","text":"Roles can have attributes like name, modified timestamp, Role Meta attributes (check the complete role meta attributes list below) and roleMembers. By default roles that are created by the template will not have any members unless the role members are hard-coded in the template (check the example structure below). The domain administrator will need to add members to those roles after the domain is created or the template has been applied to a domain. Now if you notice role members array in the image below, members can also have placeholders which have to be added to keywordsToReplace. Sample structure for Roles with role members: \"roles\": [ { \"name\": \"_domain_:role.aws_instance_launch_provider\", \"modified\": \"1970-01-01T00:00:00.000Z\", \"roleMembers\": [ { \"memberName\": \"athens.aws.*\" } ] }, { \"name\": \"_domain_:role.aws.ssh_login\", \"modified\": \"1970-01-01T00:00:00.000Z\" }, { \"name\": \"_domain_:role.aws_ssh_cert_request\", \"modified\": \"1970-01-01T00:00:00.000Z\", \"roleMembers\": [ { \"memberName\": \"_domain_._service_\" } ] } ] Allowed Role Meta Attributes: \"selfServe\": \"false\", \"memberExpiryDays\": 90, \"tokenExpiryMins\": 30, \"certExpiryMins\": 10, \"serviceExpiryDays\": 50, \"memberReviewDays\": 65, \"serviceReviewDays\": 15, \"reviewEnabled\": true","title":"Roles"},{"location":"athenz_templates/#policies","text":"Array of policies with name, modified timestamp and array of assertions. Check the sample Json below. \"policies\": [ { \"name\": \"_domain_:policy.aws_instance_launch_provider\", \"modified\": \"1970-01-01T00:00:00.000Z\", \"assertions\": [ { \"resource\": \"_domain_:service._service_\", \"role\": \"_domain_:role.aws_instance_launch_provider\", \"action\": \"launch\" } ] }, { \"name\": \"_domain_:policy.aws.ssh_login\", \"modified\": \"1970-01-01T00:00:00.000Z\", \"assertions\": [ { \"resource\": \"_domain_:aws._service_.*\", \"role\": \"_domain_:role.aws.ssh_login\", \"action\": \"ssh_login\", \"effect\": \"DENY\" } ] }","title":"Policies"},{"location":"athenz_templates/#applying-templates","text":"Templates can be applied via ZMS CLI and via Athenz UI. let's take a look at a few examples on how to apply different types of templates.","title":"Applying Templates"},{"location":"athenz_templates/#example-1","text":"Templates with placeholders in role and policy names (aka comma separated values in keywordsToReplace under template metadata field) will have to pass the key value pair for all placeholders via CLI. However, Athenz UI will automatically detect the placeholders and prompt the user to enter those placeholder values without which you cannot apply a template","title":"Example 1"},{"location":"athenz_templates/#example-2","text":"Templates with static role and policy names i.e. no placeholders zms-cli -d some-domain set-domain-template other-template-name","title":"Example 2"},{"location":"athenz_templates/#auto-update","text":"Auto update flag in templates lets the zms server to patch up the changes made to roles and policies automatically. This way the template creator does not need to communicate the tenant domains to patch them up manually through Athenz UI or CLI. AutoUpdate runs on zms servers during application startup in an uninterrupted fashion and applies roles and policies for all eligible templates. This feature will work only for templates with no placeholders at the moment i.e. the metadata section in the template should have the following values keywordsToReplace=\"\" and autoUpdate set to true. Note: it is important to bump up the latestVersion flag to apply any changes in the template including metadata changes like autoUpdate and keywordsToReplace.","title":"Auto Update"},{"location":"athenz_templates/#faq","text":"","title":"FAQ"},{"location":"auth_flow/","text":"Architecture - Authorization Flow \u00b6 Use Cases Manage Access Control / Permissions for Resources Real-Time Service Security Authorization Flow Centralized Access Control (Control-Plane) Principals Authenticated Service Decentralized Access Control (Data-Plane) Policy Engine Reserved Domains Management Scenarios Simple Centralized Scenario Multi-tenancy Scenario Service Authentication Use Cases \u00b6 Manage Access Control and Permissions for Resources \u00b6 Athenz allows you to manage access control and permissions to resources through the centralized authori**z**ation **m**anagement **s**ervice (ZMS) and domain configuration that defines resources, roles, and actions. The diagram below shows a simplification of the use case without domain configuration. Your domain configuration file gives you fine control over who can access resources and what actions can be taken. ZMS manages your domain files and provides a RESTful API that allows you to create and modify domain configurations. This gives you the ability to control user access , tenancy , and secure editorial content and infrastructure assets . Real-Time Service Security \u00b6 Athenz provides endpoint protection for services, so a service such as Sports in the diagram below doesn't need to set network ACLs for other services wanting to access data. Instead, services are authorized by Athenz to access resources from another service based on the permissions defined by the domain administrator. Authorization Flow \u00b6 Centralized Access Control (Control-Plane) \u00b6 A traditional centralized mechanism works as expected for services that are not dealing with the decentralized authorization: the server with resources can simply ask the ZMS directly about access, passing the service identity and resource/action information to get a simple boolean answer. This does not scale well enough for data-plane access, since a central service must be consulted, but requires no local installation of the ZPE and related storage and synchronization logic. It is suitable for provisioning and configuration use cases where the number of requests processed by the server are small and the latency for authorization checks is not important. Principals \u00b6 In Athenz, actors that can assume a role are called principals. Principals can be users or services, and users can be those looking for resources from a service or use the ZMS management console. In the following sections, we'll look at centralized authorization for the service principal we just discussed. Authenticated Service To contact Athenz Services (ZMS/ZTS) or other Athenz Enabled services, the client service must first obtain an Athenz CA issued X.509 certificate. The services establish standard mutual TLS communication with other Athenz Enabled Services. Once the mutual TLS authentication is established, the provider service contacts Athenz Management Service directly to determine if a specific authenticated service has been authorized to carry out the given action on the requested resource. The application receives a simple boolean answer whether or not the request should be processed or rejected. The domain administrator can create a separate service that only has access for the given provider, thus provider having access to the service's identity will not have access to any other resource. Refer Service Authentication for full details on X.509 certificate based authentication. Decentralized Access Control (Data-Plane) \u00b6 A more interesting scenario introduces the local policy engine (ZPE), and a few supporting changes. Rather than directly asking for an access check with a principal identity, the identity is instead used to get a ZToken, and that is presented to the target service until it expires. This mechanism allows a service to make a completely local access check against ZPE, given a ZToken and locally cached policies. Specifically, as shown in the diagram below, the client service/user presents an X.509 certificate from SIA Provider to get an authorization token (ZToken) from ZTS, and then presents the ZToken to a target service to access its resources. That service can make use of a local ZPE to validate the role assertions in the ZToken, and then correlate them to the asynchronously updated Policies for the domain involved. The ZPE can make the decision locally, without going off box. It has no knowledge about specific users, only roles, and because roles and policies are always in the domain, the amount of data to distribute to the machine is small. Policy Engine \u00b6 The Policy Engine (ZPE) only needs to deal with policies and their roles, actions, and resources. Concepts like groups would only affect how a principal can assume a role, so is involved in getting the ZToken, but not using it in the ZPE. When evaluating policies, the relevant assertions of all relevant policies must be considered. Assertions are treated like a big \"OR\" with the default effect of \"Allow\", whereas any single \"Deny\" will override any other assertions. The policies can have prefix-matching wildcards, so that glob-style matching needs to be part of the \"is this assertion relevant\" logic. The policies must be fetched from ZTS for the ZPE to operate. Additionally, the policies must be refreshed as they change. It is expected that policies will change at a much lower frequency than user/role assignments, so a daily pull may be fine for this. The policies are not sensitive (secret) information, but their integrity is important, so the policies fetched (per domain) is signed by both ZMS and ZTS servers. This requires a predictable serialization of the policy data structures. That will be fields in the order the schema specifies, serialized to JSON, then signed. The actual fetch is performed by a locally running distribution agent, which could be implemented as a cron job or other async fetching mechanism. The resulting policies could be atomically changed per domain. Because the ZPE only will have policies for the domains of services running on the same host/container, there will be relatively few of them. The API for getting signed policies actually gets many policies in a single list, which is signed as a whole according to the ordering rules above. Reserved Domains \u00b6 The following domains are reserved and are automatically provisioned during server startup: user - The reserved domain for authenticated users. sys - The reserved domain for managing system activities sys.auth - The Athenz domain itself, which is where policies governing the top level domains reside. Management Scenarios \u00b6 Simple Centralized Scenario \u00b6 In the simplest scenario, one would perform the following actions. Note that even in this case, the management calls themselves are protected by Athenz, so for example one property admin cannot modify another property's domain. Set up domains as a super admin Assign domain administrators for the domain Create services in the domain Create roles, as the domain admin, to model the expected activity. Assign users and services as needed. Create policies, with references to resources that are the target of various actions The services would implement the access check calls to enforce access based on the ZMS \"access check\" API. This may happen in a container or filter. Multi-tenancy Scenario \u00b6 Setting up a tenant in a provider requires the concepts of a cross-domain \"trust relation\". Such a trust relation can be implemented as follows: A Policy is set up in the group-defining domain (Domain-A) that asserts that one of its local Roles can \u201cassume\u201d a role in the target Domain. The role used in this policy is arbitrary, under the control of Domain-A, who can add/remove users from it as it needs. A Role is created in the target Domain-B, but instead of specifying users, the trusted domain is set to Domain-A. Domain-B can then set up whatever policies it needs to protect relevant resources, by referring to its special role as the principal At access check time, when the policy is encountered that indicates a role that is trusted, that role (in another Domain) must then be consulted to determine who can assume the role. Service Authentication \u00b6 Refer Service Authentication for full details on X.509 cerificate based authentication.","title":"Authorization Flow"},{"location":"auth_flow/#architecture-authorization-flow","text":"Use Cases Manage Access Control / Permissions for Resources Real-Time Service Security Authorization Flow Centralized Access Control (Control-Plane) Principals Authenticated Service Decentralized Access Control (Data-Plane) Policy Engine Reserved Domains Management Scenarios Simple Centralized Scenario Multi-tenancy Scenario Service Authentication","title":"Architecture - Authorization Flow"},{"location":"auth_flow/#use-cases","text":"","title":"Use Cases"},{"location":"auth_flow/#manage-access-control-and-permissions-for-resources","text":"Athenz allows you to manage access control and permissions to resources through the centralized authori**z**ation **m**anagement **s**ervice (ZMS) and domain configuration that defines resources, roles, and actions. The diagram below shows a simplification of the use case without domain configuration. Your domain configuration file gives you fine control over who can access resources and what actions can be taken. ZMS manages your domain files and provides a RESTful API that allows you to create and modify domain configurations. This gives you the ability to control user access , tenancy , and secure editorial content and infrastructure assets .","title":"Manage Access Control and Permissions for Resources"},{"location":"auth_flow/#real-time-service-security","text":"Athenz provides endpoint protection for services, so a service such as Sports in the diagram below doesn't need to set network ACLs for other services wanting to access data. Instead, services are authorized by Athenz to access resources from another service based on the permissions defined by the domain administrator.","title":"Real-Time Service Security"},{"location":"auth_flow/#authorization-flow","text":"","title":"Authorization Flow"},{"location":"auth_flow/#centralized-access-control-control-plane","text":"A traditional centralized mechanism works as expected for services that are not dealing with the decentralized authorization: the server with resources can simply ask the ZMS directly about access, passing the service identity and resource/action information to get a simple boolean answer. This does not scale well enough for data-plane access, since a central service must be consulted, but requires no local installation of the ZPE and related storage and synchronization logic. It is suitable for provisioning and configuration use cases where the number of requests processed by the server are small and the latency for authorization checks is not important.","title":"Centralized Access Control (Control-Plane)"},{"location":"auth_flow/#principals","text":"In Athenz, actors that can assume a role are called principals. Principals can be users or services, and users can be those looking for resources from a service or use the ZMS management console. In the following sections, we'll look at centralized authorization for the service principal we just discussed.","title":"Principals"},{"location":"auth_flow/#decentralized-access-control-data-plane","text":"A more interesting scenario introduces the local policy engine (ZPE), and a few supporting changes. Rather than directly asking for an access check with a principal identity, the identity is instead used to get a ZToken, and that is presented to the target service until it expires. This mechanism allows a service to make a completely local access check against ZPE, given a ZToken and locally cached policies. Specifically, as shown in the diagram below, the client service/user presents an X.509 certificate from SIA Provider to get an authorization token (ZToken) from ZTS, and then presents the ZToken to a target service to access its resources. That service can make use of a local ZPE to validate the role assertions in the ZToken, and then correlate them to the asynchronously updated Policies for the domain involved. The ZPE can make the decision locally, without going off box. It has no knowledge about specific users, only roles, and because roles and policies are always in the domain, the amount of data to distribute to the machine is small.","title":"Decentralized Access Control (Data-Plane)"},{"location":"auth_flow/#policy-engine","text":"The Policy Engine (ZPE) only needs to deal with policies and their roles, actions, and resources. Concepts like groups would only affect how a principal can assume a role, so is involved in getting the ZToken, but not using it in the ZPE. When evaluating policies, the relevant assertions of all relevant policies must be considered. Assertions are treated like a big \"OR\" with the default effect of \"Allow\", whereas any single \"Deny\" will override any other assertions. The policies can have prefix-matching wildcards, so that glob-style matching needs to be part of the \"is this assertion relevant\" logic. The policies must be fetched from ZTS for the ZPE to operate. Additionally, the policies must be refreshed as they change. It is expected that policies will change at a much lower frequency than user/role assignments, so a daily pull may be fine for this. The policies are not sensitive (secret) information, but their integrity is important, so the policies fetched (per domain) is signed by both ZMS and ZTS servers. This requires a predictable serialization of the policy data structures. That will be fields in the order the schema specifies, serialized to JSON, then signed. The actual fetch is performed by a locally running distribution agent, which could be implemented as a cron job or other async fetching mechanism. The resulting policies could be atomically changed per domain. Because the ZPE only will have policies for the domains of services running on the same host/container, there will be relatively few of them. The API for getting signed policies actually gets many policies in a single list, which is signed as a whole according to the ordering rules above.","title":"Policy Engine"},{"location":"auth_flow/#reserved-domains","text":"The following domains are reserved and are automatically provisioned during server startup: user - The reserved domain for authenticated users. sys - The reserved domain for managing system activities sys.auth - The Athenz domain itself, which is where policies governing the top level domains reside.","title":"Reserved Domains"},{"location":"auth_flow/#management-scenarios","text":"","title":"Management Scenarios"},{"location":"auth_flow/#simple-centralized-scenario","text":"In the simplest scenario, one would perform the following actions. Note that even in this case, the management calls themselves are protected by Athenz, so for example one property admin cannot modify another property's domain. Set up domains as a super admin Assign domain administrators for the domain Create services in the domain Create roles, as the domain admin, to model the expected activity. Assign users and services as needed. Create policies, with references to resources that are the target of various actions The services would implement the access check calls to enforce access based on the ZMS \"access check\" API. This may happen in a container or filter.","title":"Simple Centralized Scenario"},{"location":"auth_flow/#multi-tenancy-scenario","text":"Setting up a tenant in a provider requires the concepts of a cross-domain \"trust relation\". Such a trust relation can be implemented as follows: A Policy is set up in the group-defining domain (Domain-A) that asserts that one of its local Roles can \u201cassume\u201d a role in the target Domain. The role used in this policy is arbitrary, under the control of Domain-A, who can add/remove users from it as it needs. A Role is created in the target Domain-B, but instead of specifying users, the trusted domain is set to Domain-A. Domain-B can then set up whatever policies it needs to protect relevant resources, by referring to its special role as the principal At access check time, when the policy is encountered that indicates a role that is trusted, that role (in another Domain) must then be consulted to determine who can assume the role.","title":"Multi-tenancy Scenario"},{"location":"auth_flow/#service-authentication","text":"Refer Service Authentication for full details on X.509 cerificate based authentication.","title":"Service Authentication"},{"location":"aws_athenz_setup/","text":"Athenz Setup on AWS \u00b6 Build the Project ZMS Setup ZTS Setup UI Setup Build the Project \u00b6 mvn clean install Make sure to have the following tar files: aws-setup/zms-setup/tars/athenz-zms-bin.tar.gz aws-setup/zts-setup/tars/athenz-zts-bin.tar.gz aws-setup/ui-setup/tars/athenz-ui-bin.tar.gz ZMS Setup \u00b6 Refer AWS ZMS Setup for details ZTS Setup \u00b6 Refer AWS ZTS Setup for details UI Setup \u00b6 Refer AWS UI Setup for details","title":"Introduction"},{"location":"aws_athenz_setup/#athenz-setup-on-aws","text":"Build the Project ZMS Setup ZTS Setup UI Setup","title":"Athenz Setup on AWS"},{"location":"aws_athenz_setup/#build-the-project","text":"mvn clean install Make sure to have the following tar files: aws-setup/zms-setup/tars/athenz-zms-bin.tar.gz aws-setup/zts-setup/tars/athenz-zts-bin.tar.gz aws-setup/ui-setup/tars/athenz-ui-bin.tar.gz","title":"Build the Project"},{"location":"aws_athenz_setup/#zms-setup","text":"Refer AWS ZMS Setup for details","title":"ZMS Setup"},{"location":"aws_athenz_setup/#zts-setup","text":"Refer AWS ZTS Setup for details","title":"ZTS Setup"},{"location":"aws_athenz_setup/#ui-setup","text":"Refer AWS UI Setup for details","title":"UI Setup"},{"location":"aws_temp_creds/","text":"This feature allows any service to obtain temporary session credentials for a role defined in AWS IAM to carry out operations against AWS Services. For example, your service might need to access its own S3 bucket to push some data to AWS. Instead of using an IAM user's credentials to access that S3 bucket, the administrator will define a role providing access to that S3 bucket and then configure their service to retrieve temporary session credentials for that role through ZTS Server. Connection Details \u00b6 To obtain temporary credentials, the client must contact ZTS Server running in AWS. Client X.509 Certificate Requirements \u00b6 To contact ZTS running in AWS to obtain temporary credentials, the client service must authenticate itself using Athenz issued client X.509 certificates. The steps are different depending on where your client service is running. Follow these steps to obtain a service x.509 certificate for your client service. AWS Account ID Registration \u00b6 To register an AWS Account with a domain, run the following command: zms-cli -d <domain-name> set-aws-account <aws-account-id> AWS Configuration Setup \u00b6 To obtain temporary credentials for a given role through ZTS Server, the administrator must follow through these steps: 1. You must already have a role created in AWS IAM that you would like to obtain temporary credentials for. 2. In AWS, setup a trust relationship for your role such that ZTS can assume that role. On the IAM Roles page, choose the role that you want to modify and click on the Trust Relationships tab. Click on the Edit Trust Relationship button and append the following section to the current document's Statement element (don't forget to make sure to convert the Statement element into an array and add necessary commas): { \"Effect\": \"Allow\", \"Principal\": { \"AWS\": \"arn:aws:iam::<account-id>:role/athenz-zts-service\" }, \"Action\": \"sts:AssumeRole\" } If configured correctly, the Trust Relationships tab should show athenz-zts-service as one of entries in the Trusted Entities table. Expiration Period \u00b6 AWS announced that they have extended the federated api access to AWS resources from the default 1 hour to up to 12 hours . To change the expiration period for a role, click on the Edit link in the role configuration screen in IAM and choose either one of the predefined duration or specify a custom one. Once the role is configured with a longer duration period. use the ZTS client api as described in the Obtaining AWS Temporary Credentials section to specify the requested duration for the temporary credentials. External ID Condition \u00b6 By including an external id condition in the AssumeRole policy, the account administrator secures its roles to be accessed by unauthorized principals in case ZTS has been compromised since AWS STS will reject any assume role requests unless the external id is specified as part of the request. Once an external id has been chosen, the AssumeRole policy configured for the role can be updated to include the external id condition. For example, to configure an external id hockey for our role we'll have the following policy: { \"Effect\": \"Allow\", \"Principal\": { \"AWS\": \"arn:aws:iam::<account-id>:role/athenz-zts-service\" }, \"Action\": \"sts:AssumeRole\", \"Condition\": { \"StringEquals\": { \"sts:ExternalId\": \"hockey\" } } } If configured correctly, the Trust Relationships tab should show athenz-zts-service as one of entries in the Trusted Entities table with a condition field specified. Once the role is configured with an external id condition, use the ZTS client api as described in the Obtaining AWS Temporary Credentials section to specify the external id for the temporary credentials. The external ID must be kept securely. Your application will need to fetch the external id and then use it in the API call to fetch AWS temporary credentials. Athenz AWS Assume Role Configuration Setup \u00b6 1. In ZMS, create a role in your domain with any service identities that may request temporary credentials for the AWS role. Go to Athenz UI, choose your Athenz domain and click on the Add Role link in the top left corner. 2. In ZMS, create a policy authorizing your Athenz role members to assume the AWS role. When creating the policy the action must be assume_aws_role , choose the role as created in the previous step and specify the IAM role name as the resource. 3. Make sure your role contains all the service identities that may request temporary credentials for this role. 4. The changes will propagate from ZMS to ZTS running within AWS within 2 minutes, and then you can use the ZTS Client library or its REST API to request temporary credentials. Obtaining AWS Temporary Credentials \u00b6 We're going to look at how to obtain AWS Temporary Credentials with the use of the ZTS Client Library in Java and directly with ZTS Server's REST API. By default the AWS Temporary Credentials returned are valid only for 1 hour. If configured, it can be extended upto 12 hours - see Expiration period section for full details. The client must refresh the credentials before they expire. REST API \u00b6 To obtain a AWS Temporary Credentials, the application would use the following endpoint from ZTS Server running in AWS: GET /zts/v1/domain/{domainName}/role/{awsRoleName}/creds?durationSeconds={durationSeconds}&externalId={externalId} durationSeconds and externalId query arguments are optional. For example, with our setup as described above, sherpa.api is our service identity and we have retrieved the X.509 certificate for this service. The file locations are as follows: private-key: /var/lib/sia/keys/sherpa.api.key.pem certificate: /var/lib/sia/certs/sherpa.api.cert.pem The following request would retrieve AWS temporary session credentials for the sherpa.property domain's aws IAM role s3-uploader : curl --key /var/lib/sia/keys/sherpa.api.key.pem --cert /var/lib/sia/certs/sherpa.api.cert.pem https://your.zts/zts/v1/domain/sherpa.property/role/s3-uploader/creds Note that the awsRoleName URL parameter is the name of the IAM role you want to assume, not the Athenz role created in ZMS. Expiration Period \u00b6 The following request would retrieve AWS temporary session credentials for the sherpa.property domain's aws iam role s3-uploader with duration set to 6 hours (6 * 60 * 60 = 21600 seconds): curl --key /var/lib/sia/keys/sherpa.api.key.pem --cert /var/lib/sia/certs/sherpa.api.cert.pem https://your.zts/zts/v1/domain/sherpa.property/role/s3-uploader/creds?durationSeconds=21600 External ID Condition \u00b6 If we had configured our AssumeRole policy for the s3-uploader role with an external id of hockey then our request would be: curl --key /var/lib/sia/keys/sherpa.api.key.pem --cert /var/lib/sia/certs/sherpa.api.cert.pem https://your.zts/zts/v1/domain/sherpa.property/role/s3-uploader/creds?externalId=hockey Case Sensitivity \u00b6 While object names (e.g. in your assume_aws_role policy statement) in Athenz are all normalized to lower case, role names in IAM are case sensitive . When calling ZTS to fetch temporary credentials using AssumeRole, the awsRoleName parameter must match exactly (including case) the role name configured in IAM or the request will be denied. Java \u00b6 First you need to update your Java project pom.xml file to indicate the dependency on the Athenz cert refresher and zts java client libraries. Checkout the Bintray Athenz Cert Refresher Package and Bintray ZTS Java Client Package pages to make sure you're using the latest release version: <dependencies> <dependency> <groupId> com.yahoo.athenz </groupId> <artifactId> athenz-zts-java-client </artifactId> <version> VERSION-NUMBER </version> </dependency> <dependency> <groupId> com.yahoo.athenz </groupId> <artifactId> athenz-cert-refresher </artifactId> <version> VERSION-NUMBER </version> </dependency> </dependencies> To obtain a AWS Temporary Credentials Provider, the application would use the following constructor: /** * Constructs a new AWSCredentialsProvider object with the given SSLContext object, * ZTS Server Url, Athenz domain name and AWS Role Name to retrieve temporary * credentials for. The constructor will automatically create and use the ZTS * client object for retrieving credentials. This object must be closed so * the ZTS client object is closed as well. * @param ztsUrl ZTS Server's URL * @param sslContext SSLContext that includes service's private key and x.509 certificate * for authenticating requests * @param domainName name of the Athenz domain * @param roleName is the name of the IAM role * @param minExpiryTime (optional) specifies that the returned creds must be * at least valid (min/lower bound) for specified number of seconds * @param maxExpiryTime (optional) specifies that the returned creds must be * at most valid (max/upper bound) for specified number of seconds. * @param externalId (optional) external id to satisfy configured assume role condition */ public AWSCredentialsProviderImpl ( String ztsUrl , SSLContext sslContext , String domainName , String roleName , String externalId , Integer minExpiryTime , Integer maxExpiryTime ) For example, with our setup as described above, sherpa.api is our service identity and we have retrieved the X.509 certificate for this service. The file location are as follows: private-key: /var/lib/sia/keys/sherpa.api.key.pem certificate: /var/lib/sia/certs/sherpa.api.cert.pem The ZTS server is running with a public X.509 certificate so we're going to use the standard jdk truststore for our connection which has a default password of changeit . The following request would retrieve AWS temporary session credentials for the sherpa.property domain's aws iam role s3-uploader : import javax.net.ssl.SSLContext ; import com.oath.auth.KeyRefresher ; import com.oath.auth.Utils ; import com.yahoo.athenz.zts.AWSCredentialsProviderImpl ; final String ztsUrl = \"https://your.zts/zts/v1\" ; final String keyPath = \"/var/lib/sia/keys/sherpa.api.key.pem\" ; final String certPath = \"/var/lib/sia/certs/sherpa.api.cert.pem\" ; final String trustStorePath = javaHome + \"/jre/lib/security/cacerts\" ; final String trustStorePassword = \"changeit\" ; try { // Create our SSL Context object based on our private key and // certificate and jdk truststore KeyRefresher keyRefresher = Utils . generateKeyRefresher ( trustStorePath , trustStorePassword , certPath , keyPath ); // Default refresh period is every hour. keyRefresher . startup (); // Can be adjusted to use other values in milliseconds. // keyRefresher.startup(900000); SSLContext sslContext = Utils . buildSSLContext ( keyRefresher . getKeyManagerProxy (), keyRefresher . getTrustManagerProxy ()); // obtain temporary credential provider for our domain and role // without external id and default period of 1 hour AWSCredentialsProviderImpl awsCredProvider = new AWSCredentialsProviderImpl ( ztsUrl , sslContext , \"sherpa.property\" , \"s3-uploader\" , null , null , null ); // retrieve and display aws temporary creds. Typically you just pass // the AWSCredentialsProvider object to any AWS api that requires it. // for example, when creating an AWS S3 client // AmazonS3 s3client = AmazonS3ClientBuilder.standard() // .withCredentials(awsCredProvider) // .withRegion(getRegion()) // .build(); try { AWSCredentials awsCreds = awsCredProvider . getCredentials (); if ( awsCreds == null ) { System . out . println ( \"Error: AWS Credentials are not available\" ); // handle failure } System . out . println ( \"AWS Temporary Credentials:\\n\" ); System . out . println ( \"\\tAccess Key Id : \" + awsCreds . getAWSAccessKeyId ()); System . out . println ( \"\\tSecret Key : \" + awsCreds . getAWSSecretKey ()); } catch ( ZTSClientException ex ) { System . out . println ( \"Unable to retrieve AWS credentials: \" + ex . getMessage ()); // handle failure } // once we're done with our api and we no longer need our // provider we need to make sure to close it awsCredProvider . close (); } catch ( Exception ex ) { // handle failure } ** Important ** During the shutdown of the application, ZTSClient.cancelPrefetch() must be called to stop the timer thread that automatically fetches and refreshes any cached tokens in the ZTS Client. Expiration Period \u00b6 The following request would retrieve AWS temporary session credentials for the sherpa.property domain's aws iam role s3-uploader with duration set to 6 hours (6 * 60 * 60 = 21600 seconds) and a minimum timeout of 15 minutes. This indicates that the client will cache the token for 5 hours and 45 minutes. // obtain temporary credential provider for our domain and role AWSCredentialsProviderImpl awsCredProvider = new AWSCredentialsProviderImpl ( ztsUrl , sslContext , \"sherpa.property\" , \"s3-uploader\" , 900 , 21600 , null ); External ID Condition \u00b6 If we had configured our AssumeRole policy for the s3-uploader role with an external id of hockey then our request would be: // obtain temporary credential provider for our domain and role externalId = retrieveExternalIDFromYkeykey(); // would return \"hockey\" AWSCredentialsProviderImpl awsCredProvider = new AWSCredentialsProviderImpl(ztsUrl, sslContext, \"sherpa.property\", \"s3-uploader\", null, null, externalId); Go \u00b6 To obtain a AWS Temporary Credentials, the application would use the Athenz ZTS Go Client. For example, with our setup as described above, sherpa.api is our service identity and we have retrieved the X.509 certificate for this service. The file location are as follows: private-key: /var/lib/sia/keys/sherpa.api.key.pem certificate: /var/lib/sia/certs/sherpa.api.cert.pem First you need to update your Go project to indicate the dependency on the Athenz zts go client libraries: import ( \"github.com/AthenZ/athenz/clients/go/zts\" \"github.com/AthenZ/athenz/libs/go/athenzutils\" ) The ZTS server is running with a public X.509 certificate so we're not going to specify CA certificates for our request: ztsUrl := \"https://your.zts/zts/v1\" key := \"/var/lib/sia/keys/sherpa.api.key.pem\" cert := \"/var/lib/sia/certs/sherpa.api.cert.pem\" ztsClient, err := athenzutils.ZtsClient(ztsUrl, key, cert, \"\", false) if err != nil { log.Fatalf(\"Fatal: Error creating zts client: %v\", err) } domain := \"sherpa.property\" role := \"s3-uploader\" externalId := \"hockey\" awsCreds, err := ztsClient.GetAWSTemporaryCredentials(zts.DomainName(domain), zts.AWSArnRoleName(role), nil, externalId) if err != nil { log.Fatalf(\"Fatal: Error fetching AWS Credentials: %v\\n\", err) } fmt.Println(\"[default]\") fmt.Printf(\"aws_access_key_id=%s\\n\", awsCreds.AccessKeyId) fmt.Printf(\"aws_secret_access_key=%s\\n\", awsCreds.SecretAccessKey) fmt.Printf(\"aws_session_token=%s\\n\", awsCreds.SessionToken) Using AWS Temporary Credentials \u00b6 If you want to use the AWS temporary credentials with aws command line utilities, they can be set as environment variables or be added to the ~/.aws/credentials file for a given profile. The settings must include all three components returned by the api: access key id secret access key session token The following example shows the use of environment variables with temporary credentials: $ export AWS_ACCESS_KEY_ID={YOUR_ACCESS_KEY_ID} $ export AWS_SECRET_ACCESS_KEY={YOUR_SECRET_ACCESS_KEY} $ export AWS_SESSION_TOKEN={YOUR_SESSION_TOKEN} $ aws ec2 describe-instances --region us-west-1 The following example shows the use of the aws credentials file using default profile: $ cat ~/.aws/credentials [default] aws_access_key_id={YOUR_ACCESS_KEY_ID} aws_secret_access_key={YOUR_SECRET_ACCESS_KEY} aws_session_token={YOUR_SESSION_TOKEN} Checkout Using Temporary Security Credentials to Request Access to AWS Resources for full details how to use temporary credentials in AWS. ** Important ** When passing the role name that you're trying to assume in the aws-builder-creds utility as the value to the -r argument, it must be the AWS IAM Role name and not the role name in your Athenz domain. Troubleshooting \u00b6 ZTS Server returns a unique error message indicating what part of the configuration is causing the failure to fetch AWS temporary credentials. Athenz Domain Configuration \u00b6 getAWSTemporaryCredentials: unable to retrieve AWS account for: <domainName> The domain, identified in the <domainName> field, does not have AWS account id configured. Follow the steps in the AWS Account ID Registration section to register your AWS account id for your domain. Athenz Role Configuration \u00b6 getAWSTemporaryCredentials: Forbidden (ASSUME_AWS_ROLE on <resource-name> for <principal>) This error indicates that the principal, identified in the <principal> field, requesting the temporary credentials is not authorized. There are two common issues that generate this error message: The caller is using the athenz role name as the value for the role name parameter (-r in the aws-builder-creds utility). The value for this parameter must be the AWS IAM role name and not the Athenz role name. Make sure the <principal> is included as a member in the role that you had setup in the Athenz AWS Assume Role Configuration Setup section in this document. AWS Configuration \u00b6 getAWSTemporaryCredentials: unable to assume role <roleName> in domain <domainName> for principal <principal> This error indicates that AWS STS refused to issue temporary credentials to the Athenz ZTS service. This usually indicates that either the role name specified in the request is incorrect (you must specify the IAM Role name you're trying to assume and not the Athenz Role Name) or the role in IAM does not have the trust relationship setup for ZTS service as described in the AWS Configuration Setup section in this document. If you have configured a non-default duration or an external id for your role make sure you're passing the correct values in the API. AWS STS will reject the assume role request if the external id is not passed or a duration value is passed that is longer than the configured period.","title":"AWS Temp Credentials"},{"location":"aws_temp_creds/#connection-details","text":"To obtain temporary credentials, the client must contact ZTS Server running in AWS.","title":"Connection Details"},{"location":"aws_temp_creds/#client-x509-certificate-requirements","text":"To contact ZTS running in AWS to obtain temporary credentials, the client service must authenticate itself using Athenz issued client X.509 certificates. The steps are different depending on where your client service is running. Follow these steps to obtain a service x.509 certificate for your client service.","title":"Client X.509 Certificate Requirements"},{"location":"aws_temp_creds/#aws-account-id-registration","text":"To register an AWS Account with a domain, run the following command: zms-cli -d <domain-name> set-aws-account <aws-account-id>","title":"AWS Account ID Registration"},{"location":"aws_temp_creds/#aws-configuration-setup","text":"To obtain temporary credentials for a given role through ZTS Server, the administrator must follow through these steps: 1. You must already have a role created in AWS IAM that you would like to obtain temporary credentials for. 2. In AWS, setup a trust relationship for your role such that ZTS can assume that role. On the IAM Roles page, choose the role that you want to modify and click on the Trust Relationships tab. Click on the Edit Trust Relationship button and append the following section to the current document's Statement element (don't forget to make sure to convert the Statement element into an array and add necessary commas): { \"Effect\": \"Allow\", \"Principal\": { \"AWS\": \"arn:aws:iam::<account-id>:role/athenz-zts-service\" }, \"Action\": \"sts:AssumeRole\" } If configured correctly, the Trust Relationships tab should show athenz-zts-service as one of entries in the Trusted Entities table.","title":"AWS Configuration Setup"},{"location":"aws_temp_creds/#expiration-period","text":"AWS announced that they have extended the federated api access to AWS resources from the default 1 hour to up to 12 hours . To change the expiration period for a role, click on the Edit link in the role configuration screen in IAM and choose either one of the predefined duration or specify a custom one. Once the role is configured with a longer duration period. use the ZTS client api as described in the Obtaining AWS Temporary Credentials section to specify the requested duration for the temporary credentials.","title":"Expiration Period"},{"location":"aws_temp_creds/#external-id-condition","text":"By including an external id condition in the AssumeRole policy, the account administrator secures its roles to be accessed by unauthorized principals in case ZTS has been compromised since AWS STS will reject any assume role requests unless the external id is specified as part of the request. Once an external id has been chosen, the AssumeRole policy configured for the role can be updated to include the external id condition. For example, to configure an external id hockey for our role we'll have the following policy: { \"Effect\": \"Allow\", \"Principal\": { \"AWS\": \"arn:aws:iam::<account-id>:role/athenz-zts-service\" }, \"Action\": \"sts:AssumeRole\", \"Condition\": { \"StringEquals\": { \"sts:ExternalId\": \"hockey\" } } } If configured correctly, the Trust Relationships tab should show athenz-zts-service as one of entries in the Trusted Entities table with a condition field specified. Once the role is configured with an external id condition, use the ZTS client api as described in the Obtaining AWS Temporary Credentials section to specify the external id for the temporary credentials. The external ID must be kept securely. Your application will need to fetch the external id and then use it in the API call to fetch AWS temporary credentials.","title":"External ID Condition"},{"location":"aws_temp_creds/#athenz-aws-assume-role-configuration-setup","text":"1. In ZMS, create a role in your domain with any service identities that may request temporary credentials for the AWS role. Go to Athenz UI, choose your Athenz domain and click on the Add Role link in the top left corner. 2. In ZMS, create a policy authorizing your Athenz role members to assume the AWS role. When creating the policy the action must be assume_aws_role , choose the role as created in the previous step and specify the IAM role name as the resource. 3. Make sure your role contains all the service identities that may request temporary credentials for this role. 4. The changes will propagate from ZMS to ZTS running within AWS within 2 minutes, and then you can use the ZTS Client library or its REST API to request temporary credentials.","title":"Athenz AWS Assume Role Configuration Setup"},{"location":"aws_temp_creds/#obtaining-aws-temporary-credentials","text":"We're going to look at how to obtain AWS Temporary Credentials with the use of the ZTS Client Library in Java and directly with ZTS Server's REST API. By default the AWS Temporary Credentials returned are valid only for 1 hour. If configured, it can be extended upto 12 hours - see Expiration period section for full details. The client must refresh the credentials before they expire.","title":"Obtaining AWS Temporary Credentials"},{"location":"aws_temp_creds/#rest-api","text":"To obtain a AWS Temporary Credentials, the application would use the following endpoint from ZTS Server running in AWS: GET /zts/v1/domain/{domainName}/role/{awsRoleName}/creds?durationSeconds={durationSeconds}&externalId={externalId} durationSeconds and externalId query arguments are optional. For example, with our setup as described above, sherpa.api is our service identity and we have retrieved the X.509 certificate for this service. The file locations are as follows: private-key: /var/lib/sia/keys/sherpa.api.key.pem certificate: /var/lib/sia/certs/sherpa.api.cert.pem The following request would retrieve AWS temporary session credentials for the sherpa.property domain's aws IAM role s3-uploader : curl --key /var/lib/sia/keys/sherpa.api.key.pem --cert /var/lib/sia/certs/sherpa.api.cert.pem https://your.zts/zts/v1/domain/sherpa.property/role/s3-uploader/creds Note that the awsRoleName URL parameter is the name of the IAM role you want to assume, not the Athenz role created in ZMS.","title":"REST API"},{"location":"aws_temp_creds/#expiration-period_1","text":"The following request would retrieve AWS temporary session credentials for the sherpa.property domain's aws iam role s3-uploader with duration set to 6 hours (6 * 60 * 60 = 21600 seconds): curl --key /var/lib/sia/keys/sherpa.api.key.pem --cert /var/lib/sia/certs/sherpa.api.cert.pem https://your.zts/zts/v1/domain/sherpa.property/role/s3-uploader/creds?durationSeconds=21600","title":"Expiration Period"},{"location":"aws_temp_creds/#external-id-condition_1","text":"If we had configured our AssumeRole policy for the s3-uploader role with an external id of hockey then our request would be: curl --key /var/lib/sia/keys/sherpa.api.key.pem --cert /var/lib/sia/certs/sherpa.api.cert.pem https://your.zts/zts/v1/domain/sherpa.property/role/s3-uploader/creds?externalId=hockey","title":"External ID Condition"},{"location":"aws_temp_creds/#case-sensitivity","text":"While object names (e.g. in your assume_aws_role policy statement) in Athenz are all normalized to lower case, role names in IAM are case sensitive . When calling ZTS to fetch temporary credentials using AssumeRole, the awsRoleName parameter must match exactly (including case) the role name configured in IAM or the request will be denied.","title":"Case Sensitivity"},{"location":"aws_temp_creds/#java","text":"First you need to update your Java project pom.xml file to indicate the dependency on the Athenz cert refresher and zts java client libraries. Checkout the Bintray Athenz Cert Refresher Package and Bintray ZTS Java Client Package pages to make sure you're using the latest release version: <dependencies> <dependency> <groupId> com.yahoo.athenz </groupId> <artifactId> athenz-zts-java-client </artifactId> <version> VERSION-NUMBER </version> </dependency> <dependency> <groupId> com.yahoo.athenz </groupId> <artifactId> athenz-cert-refresher </artifactId> <version> VERSION-NUMBER </version> </dependency> </dependencies> To obtain a AWS Temporary Credentials Provider, the application would use the following constructor: /** * Constructs a new AWSCredentialsProvider object with the given SSLContext object, * ZTS Server Url, Athenz domain name and AWS Role Name to retrieve temporary * credentials for. The constructor will automatically create and use the ZTS * client object for retrieving credentials. This object must be closed so * the ZTS client object is closed as well. * @param ztsUrl ZTS Server's URL * @param sslContext SSLContext that includes service's private key and x.509 certificate * for authenticating requests * @param domainName name of the Athenz domain * @param roleName is the name of the IAM role * @param minExpiryTime (optional) specifies that the returned creds must be * at least valid (min/lower bound) for specified number of seconds * @param maxExpiryTime (optional) specifies that the returned creds must be * at most valid (max/upper bound) for specified number of seconds. * @param externalId (optional) external id to satisfy configured assume role condition */ public AWSCredentialsProviderImpl ( String ztsUrl , SSLContext sslContext , String domainName , String roleName , String externalId , Integer minExpiryTime , Integer maxExpiryTime ) For example, with our setup as described above, sherpa.api is our service identity and we have retrieved the X.509 certificate for this service. The file location are as follows: private-key: /var/lib/sia/keys/sherpa.api.key.pem certificate: /var/lib/sia/certs/sherpa.api.cert.pem The ZTS server is running with a public X.509 certificate so we're going to use the standard jdk truststore for our connection which has a default password of changeit . The following request would retrieve AWS temporary session credentials for the sherpa.property domain's aws iam role s3-uploader : import javax.net.ssl.SSLContext ; import com.oath.auth.KeyRefresher ; import com.oath.auth.Utils ; import com.yahoo.athenz.zts.AWSCredentialsProviderImpl ; final String ztsUrl = \"https://your.zts/zts/v1\" ; final String keyPath = \"/var/lib/sia/keys/sherpa.api.key.pem\" ; final String certPath = \"/var/lib/sia/certs/sherpa.api.cert.pem\" ; final String trustStorePath = javaHome + \"/jre/lib/security/cacerts\" ; final String trustStorePassword = \"changeit\" ; try { // Create our SSL Context object based on our private key and // certificate and jdk truststore KeyRefresher keyRefresher = Utils . generateKeyRefresher ( trustStorePath , trustStorePassword , certPath , keyPath ); // Default refresh period is every hour. keyRefresher . startup (); // Can be adjusted to use other values in milliseconds. // keyRefresher.startup(900000); SSLContext sslContext = Utils . buildSSLContext ( keyRefresher . getKeyManagerProxy (), keyRefresher . getTrustManagerProxy ()); // obtain temporary credential provider for our domain and role // without external id and default period of 1 hour AWSCredentialsProviderImpl awsCredProvider = new AWSCredentialsProviderImpl ( ztsUrl , sslContext , \"sherpa.property\" , \"s3-uploader\" , null , null , null ); // retrieve and display aws temporary creds. Typically you just pass // the AWSCredentialsProvider object to any AWS api that requires it. // for example, when creating an AWS S3 client // AmazonS3 s3client = AmazonS3ClientBuilder.standard() // .withCredentials(awsCredProvider) // .withRegion(getRegion()) // .build(); try { AWSCredentials awsCreds = awsCredProvider . getCredentials (); if ( awsCreds == null ) { System . out . println ( \"Error: AWS Credentials are not available\" ); // handle failure } System . out . println ( \"AWS Temporary Credentials:\\n\" ); System . out . println ( \"\\tAccess Key Id : \" + awsCreds . getAWSAccessKeyId ()); System . out . println ( \"\\tSecret Key : \" + awsCreds . getAWSSecretKey ()); } catch ( ZTSClientException ex ) { System . out . println ( \"Unable to retrieve AWS credentials: \" + ex . getMessage ()); // handle failure } // once we're done with our api and we no longer need our // provider we need to make sure to close it awsCredProvider . close (); } catch ( Exception ex ) { // handle failure } ** Important ** During the shutdown of the application, ZTSClient.cancelPrefetch() must be called to stop the timer thread that automatically fetches and refreshes any cached tokens in the ZTS Client.","title":"Java"},{"location":"aws_temp_creds/#expiration-period_2","text":"The following request would retrieve AWS temporary session credentials for the sherpa.property domain's aws iam role s3-uploader with duration set to 6 hours (6 * 60 * 60 = 21600 seconds) and a minimum timeout of 15 minutes. This indicates that the client will cache the token for 5 hours and 45 minutes. // obtain temporary credential provider for our domain and role AWSCredentialsProviderImpl awsCredProvider = new AWSCredentialsProviderImpl ( ztsUrl , sslContext , \"sherpa.property\" , \"s3-uploader\" , 900 , 21600 , null );","title":"Expiration Period"},{"location":"aws_temp_creds/#external-id-condition_2","text":"If we had configured our AssumeRole policy for the s3-uploader role with an external id of hockey then our request would be: // obtain temporary credential provider for our domain and role externalId = retrieveExternalIDFromYkeykey(); // would return \"hockey\" AWSCredentialsProviderImpl awsCredProvider = new AWSCredentialsProviderImpl(ztsUrl, sslContext, \"sherpa.property\", \"s3-uploader\", null, null, externalId);","title":"External ID Condition"},{"location":"aws_temp_creds/#go","text":"To obtain a AWS Temporary Credentials, the application would use the Athenz ZTS Go Client. For example, with our setup as described above, sherpa.api is our service identity and we have retrieved the X.509 certificate for this service. The file location are as follows: private-key: /var/lib/sia/keys/sherpa.api.key.pem certificate: /var/lib/sia/certs/sherpa.api.cert.pem First you need to update your Go project to indicate the dependency on the Athenz zts go client libraries: import ( \"github.com/AthenZ/athenz/clients/go/zts\" \"github.com/AthenZ/athenz/libs/go/athenzutils\" ) The ZTS server is running with a public X.509 certificate so we're not going to specify CA certificates for our request: ztsUrl := \"https://your.zts/zts/v1\" key := \"/var/lib/sia/keys/sherpa.api.key.pem\" cert := \"/var/lib/sia/certs/sherpa.api.cert.pem\" ztsClient, err := athenzutils.ZtsClient(ztsUrl, key, cert, \"\", false) if err != nil { log.Fatalf(\"Fatal: Error creating zts client: %v\", err) } domain := \"sherpa.property\" role := \"s3-uploader\" externalId := \"hockey\" awsCreds, err := ztsClient.GetAWSTemporaryCredentials(zts.DomainName(domain), zts.AWSArnRoleName(role), nil, externalId) if err != nil { log.Fatalf(\"Fatal: Error fetching AWS Credentials: %v\\n\", err) } fmt.Println(\"[default]\") fmt.Printf(\"aws_access_key_id=%s\\n\", awsCreds.AccessKeyId) fmt.Printf(\"aws_secret_access_key=%s\\n\", awsCreds.SecretAccessKey) fmt.Printf(\"aws_session_token=%s\\n\", awsCreds.SessionToken)","title":"Go"},{"location":"aws_temp_creds/#using-aws-temporary-credentials","text":"If you want to use the AWS temporary credentials with aws command line utilities, they can be set as environment variables or be added to the ~/.aws/credentials file for a given profile. The settings must include all three components returned by the api: access key id secret access key session token The following example shows the use of environment variables with temporary credentials: $ export AWS_ACCESS_KEY_ID={YOUR_ACCESS_KEY_ID} $ export AWS_SECRET_ACCESS_KEY={YOUR_SECRET_ACCESS_KEY} $ export AWS_SESSION_TOKEN={YOUR_SESSION_TOKEN} $ aws ec2 describe-instances --region us-west-1 The following example shows the use of the aws credentials file using default profile: $ cat ~/.aws/credentials [default] aws_access_key_id={YOUR_ACCESS_KEY_ID} aws_secret_access_key={YOUR_SECRET_ACCESS_KEY} aws_session_token={YOUR_SESSION_TOKEN} Checkout Using Temporary Security Credentials to Request Access to AWS Resources for full details how to use temporary credentials in AWS. ** Important ** When passing the role name that you're trying to assume in the aws-builder-creds utility as the value to the -r argument, it must be the AWS IAM Role name and not the role name in your Athenz domain.","title":"Using AWS Temporary Credentials"},{"location":"aws_temp_creds/#troubleshooting","text":"ZTS Server returns a unique error message indicating what part of the configuration is causing the failure to fetch AWS temporary credentials.","title":"Troubleshooting"},{"location":"aws_temp_creds/#athenz-domain-configuration","text":"getAWSTemporaryCredentials: unable to retrieve AWS account for: <domainName> The domain, identified in the <domainName> field, does not have AWS account id configured. Follow the steps in the AWS Account ID Registration section to register your AWS account id for your domain.","title":"Athenz Domain Configuration"},{"location":"aws_temp_creds/#athenz-role-configuration","text":"getAWSTemporaryCredentials: Forbidden (ASSUME_AWS_ROLE on <resource-name> for <principal>) This error indicates that the principal, identified in the <principal> field, requesting the temporary credentials is not authorized. There are two common issues that generate this error message: The caller is using the athenz role name as the value for the role name parameter (-r in the aws-builder-creds utility). The value for this parameter must be the AWS IAM role name and not the Athenz role name. Make sure the <principal> is included as a member in the role that you had setup in the Athenz AWS Assume Role Configuration Setup section in this document.","title":"Athenz Role Configuration"},{"location":"aws_temp_creds/#aws-configuration","text":"getAWSTemporaryCredentials: unable to assume role <roleName> in domain <domainName> for principal <principal> This error indicates that AWS STS refused to issue temporary credentials to the Athenz ZTS service. This usually indicates that either the role name specified in the request is incorrect (you must specify the IAM Role name you're trying to assume and not the Athenz Role Name) or the role in IAM does not have the trust relationship setup for ZTS service as described in the AWS Configuration Setup section in this document. If you have configured a non-default duration or an external id for your role make sure you're passing the correct values in the API. AWS STS will reject the assume role request if the external id is not passed or a duration value is passed that is longer than the configured period.","title":"AWS Configuration"},{"location":"aws_ui_setup/","text":"Setup UI on AWS \u00b6 IAM role setup VPC setup S3 bucket for UI data Generate and upload service private key Upload server X.509 cert and key Upload ZMS CA Certs Upload ZMS Public key Update ZMS DATA BUCKET Register UI Service Packer Packer VPC setup Build UI Image Deploy UI IAM role setup \u00b6 Create EC2 profile role for UI using cloudformation template . This template creates a role named athenz.ui-service VPC Setup \u00b6 Setup VPC using the cloudformation template and giving the following mandatory parameters: Route53HostedZoneName Route53RecordName S3AccessLogBucketName (Created during ZMS Setup) Environment The other parameters are set by default. Change them as per your requirement NOTE - Modifying the other defaults might require subsequent changes. Following resources will be created after executing the template 1. 2 availability zones 1. Public & Private subnets for ui in each availability zone 1. 2 NAT gateways and elastic IPs 1. NACL's for the subnets 1. Internet gateways for all public subnets 1. Route tables for all subnets 1. Elastic load balancer 1. Route 53 DNS entry 1. UI server & ELB security groups Create S3 bucket to store UI data \u00b6 Create S3 bucket for storing ui certificates & keys with appropriate policy as follows: { \"Version\": \"2012-10-17\", \"Statement\": [ { \"Sid\": \"\", \"Effect\": \"Allow\", \"Principal\": { \"AWS\": \"arn:aws:iam::<aws_account_id>:role/athenz.ui-service\" }, \"Action\": \"s3:GetObject\", \"Resource\": \"arn:aws:s3::: <bucket-name> /*\" } ] } Also enable Default Encryption for your bucket. NOTE - athenz.ui-service is the EC2 role created using IAM template above Generate and upload service private key \u00b6 Generate a unique private key that UI Server will use to sign user's authorized service tokens. The UI has already been authorized to be allowed to carry out the users' requested operations. openssl genrsa -out service_private_key 2048 openssl rsa -in service_private_key -pubout > ui_service_x509_key_public Upload the service private key with name service_private_key onto the s3 bucket Upload server X.509 cert and key \u00b6 NOTE - For Athenz UI production server it is strongly recommended to purchase a certificate for HTTPS access from a well known certificate authority.Follow the instructions provided by the Certificate Authority to generate your private key and then the Certificate Request (CSR). However if you want to use the self signed certificate, you can generate a self signed certificate as below: openssl req -newkey rsa:2048 -nodes -keyout service_x509_key -x509 -days 365 -out service_x509_cer Verify your certs openssl x509 -in service_x509_cert -text -noout Once you have received your X509 certificate and key, Upload the certificate on s3 bucket with name service_x509_cert Upload the private key with name service_x509_key Upload ZMS CA Certs \u00b6 Upload ZMS CA Cert with key zms_service_x509_ca_certs . They will be needed so that UI can communicate securely with ZMS Upload ZMS Public key \u00b6 Upload ZMS public key with name zms_service_x509_key_public.pem It is required to generate athenz.conf file at /opt/athenz-ui/conf/athenz.conf to include the ZMS Server URL and the registered public keys that the athenz client libraries and utilities will use to establish connection and validate any data signed by the ZMS Server. Update ZMS Data Bucket \u00b6 Upload UI service public key to ZMS Data Bucket with key ui_service_x509_key_public.pem Register UI Service \u00b6 In order for UI to access ZMS domain data, it must identify itself as a registered service in ZMS. Use zms-cli utility to register a new service in athenz domain. If ZMS Servers are running with a X509 certificate from a well known certificate authority (not a self-signed one) we don't need to reference the CA cert like we are doing below for self signed certs. Login into your zms-server instance as domain admin you created during zms setup and run the below commands: - Download ZMS CA Certs(If using self signed certs) aws s3 cp s3://<zms_bucket_name>/zms_service_x509_ca_certs /tmp/zms_service_x509_ca_certs - Download UI public key aws s3 cp s3://<zms_bucket_name>/ui_service_x509_key_public.pem/tmp/ui_service_x509_key_public.pem - Add a new domain named `athenz` /opt/zms/bin/zms-cli -c /tmp/service_x509_ca_certs -z <zms_url> -add-domain athenz - Register Service using zms-cli /opt/zms/bin/zms-cli -c /tmp/service_x509_ca_certs -z <zms_url> -d athenz add-service ui 0 /tmp/ui_service_x509_key_public.pem For e.g. If your zms server is running at https://athenz.zms.com:4443 then pass https://athenz.zms.com:4443/zms/v1 . Packer \u00b6 Packer VPC Setup \u00b6 Packer VPC was set during zms setup, update packer.json accordingly: { \"subnet_id\":\"<packer_public_subnet_id>\", \"vpc_id\": \"<vpc_id>\", \"aws_region\": \"<aws-region where you created the resources>\", \"aws_ami_name\": \"ui-aws-cd-image\", \"aws_access_key\": \"{{env `AWS_ACCESS_KEY_ID`}}\", \"aws_secret_key\": \"{{env `AWS_SECRET_ACCESS_KEY`}}\", \"aws_session_token\": \"{{env `AWS_SESSION_TOKEN`}}\", \"ssh_keypair_name\":\"<EC2_SSH_Key_Name>\", \"ssh_private_key_file\":\"<PATH_TO_SSH_KEYPAIR>\", \"source_ami\": \"ami-02c71d7a\" } Build UI image \u00b6 Build the image with packer using the following command cd /aws-setup/ui-setup packer build packer/aws/packer.json Deploy UI \u00b6 Run cloudformation template to bring up the ui-instances in 2 availability zones. The imageID parameter should be set to the image created in above step. The UI Server is now up and running. NOTE - If using self-signed X509 certificates for Athenz ZMS and UI servers, the administrator must add exceptions when accessing Athenz UI or install the self-signed certificates for those two servers into his/her own web browser. The administrator must first access the ZMS Server endpoint in the browser to accept the exception since the Athenz UI contacts ZMS Server to get an authorized token for the user when logging in. Alternatively, the administrator may decide to install the self-signed certificates for the ZMS and UI servers in their browser.","title":"UI Server"},{"location":"aws_ui_setup/#setup-ui-on-aws","text":"IAM role setup VPC setup S3 bucket for UI data Generate and upload service private key Upload server X.509 cert and key Upload ZMS CA Certs Upload ZMS Public key Update ZMS DATA BUCKET Register UI Service Packer Packer VPC setup Build UI Image Deploy UI","title":"Setup UI on AWS"},{"location":"aws_ui_setup/#iam-role-setup","text":"Create EC2 profile role for UI using cloudformation template . This template creates a role named athenz.ui-service","title":"IAM role setup"},{"location":"aws_ui_setup/#vpc-setup","text":"Setup VPC using the cloudformation template and giving the following mandatory parameters: Route53HostedZoneName Route53RecordName S3AccessLogBucketName (Created during ZMS Setup) Environment The other parameters are set by default. Change them as per your requirement NOTE - Modifying the other defaults might require subsequent changes. Following resources will be created after executing the template 1. 2 availability zones 1. Public & Private subnets for ui in each availability zone 1. 2 NAT gateways and elastic IPs 1. NACL's for the subnets 1. Internet gateways for all public subnets 1. Route tables for all subnets 1. Elastic load balancer 1. Route 53 DNS entry 1. UI server & ELB security groups","title":"VPC Setup"},{"location":"aws_ui_setup/#create-s3-bucket-to-store-ui-data","text":"Create S3 bucket for storing ui certificates & keys with appropriate policy as follows: { \"Version\": \"2012-10-17\", \"Statement\": [ { \"Sid\": \"\", \"Effect\": \"Allow\", \"Principal\": { \"AWS\": \"arn:aws:iam::<aws_account_id>:role/athenz.ui-service\" }, \"Action\": \"s3:GetObject\", \"Resource\": \"arn:aws:s3::: <bucket-name> /*\" } ] } Also enable Default Encryption for your bucket. NOTE - athenz.ui-service is the EC2 role created using IAM template above","title":"Create S3 bucket to store UI data"},{"location":"aws_ui_setup/#generate-and-upload-service-private-key","text":"Generate a unique private key that UI Server will use to sign user's authorized service tokens. The UI has already been authorized to be allowed to carry out the users' requested operations. openssl genrsa -out service_private_key 2048 openssl rsa -in service_private_key -pubout > ui_service_x509_key_public Upload the service private key with name service_private_key onto the s3 bucket","title":"Generate and upload service private key"},{"location":"aws_ui_setup/#upload-server-x509-cert-and-key","text":"NOTE - For Athenz UI production server it is strongly recommended to purchase a certificate for HTTPS access from a well known certificate authority.Follow the instructions provided by the Certificate Authority to generate your private key and then the Certificate Request (CSR). However if you want to use the self signed certificate, you can generate a self signed certificate as below: openssl req -newkey rsa:2048 -nodes -keyout service_x509_key -x509 -days 365 -out service_x509_cer Verify your certs openssl x509 -in service_x509_cert -text -noout Once you have received your X509 certificate and key, Upload the certificate on s3 bucket with name service_x509_cert Upload the private key with name service_x509_key","title":"Upload server X.509 cert and key"},{"location":"aws_ui_setup/#upload-zms-ca-certs","text":"Upload ZMS CA Cert with key zms_service_x509_ca_certs . They will be needed so that UI can communicate securely with ZMS","title":"Upload ZMS CA Certs"},{"location":"aws_ui_setup/#upload-zms-public-key","text":"Upload ZMS public key with name zms_service_x509_key_public.pem It is required to generate athenz.conf file at /opt/athenz-ui/conf/athenz.conf to include the ZMS Server URL and the registered public keys that the athenz client libraries and utilities will use to establish connection and validate any data signed by the ZMS Server.","title":"Upload ZMS Public key"},{"location":"aws_ui_setup/#update-zms-data-bucket","text":"Upload UI service public key to ZMS Data Bucket with key ui_service_x509_key_public.pem","title":"Update ZMS Data Bucket"},{"location":"aws_ui_setup/#register-ui-service","text":"In order for UI to access ZMS domain data, it must identify itself as a registered service in ZMS. Use zms-cli utility to register a new service in athenz domain. If ZMS Servers are running with a X509 certificate from a well known certificate authority (not a self-signed one) we don't need to reference the CA cert like we are doing below for self signed certs. Login into your zms-server instance as domain admin you created during zms setup and run the below commands: - Download ZMS CA Certs(If using self signed certs) aws s3 cp s3://<zms_bucket_name>/zms_service_x509_ca_certs /tmp/zms_service_x509_ca_certs - Download UI public key aws s3 cp s3://<zms_bucket_name>/ui_service_x509_key_public.pem/tmp/ui_service_x509_key_public.pem - Add a new domain named `athenz` /opt/zms/bin/zms-cli -c /tmp/service_x509_ca_certs -z <zms_url> -add-domain athenz - Register Service using zms-cli /opt/zms/bin/zms-cli -c /tmp/service_x509_ca_certs -z <zms_url> -d athenz add-service ui 0 /tmp/ui_service_x509_key_public.pem For e.g. If your zms server is running at https://athenz.zms.com:4443 then pass https://athenz.zms.com:4443/zms/v1 .","title":"Register UI Service"},{"location":"aws_ui_setup/#packer","text":"","title":"Packer"},{"location":"aws_ui_setup/#packer-vpc-setup","text":"Packer VPC was set during zms setup, update packer.json accordingly: { \"subnet_id\":\"<packer_public_subnet_id>\", \"vpc_id\": \"<vpc_id>\", \"aws_region\": \"<aws-region where you created the resources>\", \"aws_ami_name\": \"ui-aws-cd-image\", \"aws_access_key\": \"{{env `AWS_ACCESS_KEY_ID`}}\", \"aws_secret_key\": \"{{env `AWS_SECRET_ACCESS_KEY`}}\", \"aws_session_token\": \"{{env `AWS_SESSION_TOKEN`}}\", \"ssh_keypair_name\":\"<EC2_SSH_Key_Name>\", \"ssh_private_key_file\":\"<PATH_TO_SSH_KEYPAIR>\", \"source_ami\": \"ami-02c71d7a\" }","title":"Packer VPC Setup"},{"location":"aws_ui_setup/#build-ui-image","text":"Build the image with packer using the following command cd /aws-setup/ui-setup packer build packer/aws/packer.json","title":"Build UI image"},{"location":"aws_ui_setup/#deploy-ui","text":"Run cloudformation template to bring up the ui-instances in 2 availability zones. The imageID parameter should be set to the image created in above step. The UI Server is now up and running. NOTE - If using self-signed X509 certificates for Athenz ZMS and UI servers, the administrator must add exceptions when accessing Athenz UI or install the self-signed certificates for those two servers into his/her own web browser. The administrator must first access the ZMS Server endpoint in the browser to accept the exception since the Athenz UI contacts ZMS Server to get an authorized token for the user when logging in. Alternatively, the administrator may decide to install the self-signed certificates for the ZMS and UI servers in their browser.","title":"Deploy UI"},{"location":"aws_zms_setup/","text":"Setup ZMS on AWS \u00b6 IAM Role Setup S3 Bucket for ELB Access Logs VPC setup RDS Setup Create Aurora MySQL Cluster Schema Setup S3 Bucket to Store ZMS Data Generate and Upload Service Private Key Upload Server X.509 Cert and Key Upload RDS CA Certs Upload Truststore Password Upload ZMS DB User Password Create S3 Bucket for Audit logs Configure Variables and Properties aws_init.sh zms.properties Database Access User Authentication Domain Admins athenz.properties Truststore and Keystore Settings Packer Packer VPC setup Build ZMS Image Deploy ZMS IAM Role Setup \u00b6 Create an EC2 profile role for ZMS using the following cloudformation template . This template creates a role named athenz.zms-service . S3 Bucket for ELB Access Logs \u00b6 Create a S3 bucket needed to store ELB access logs with the following bucket policy: { \"Version\": \"2012-10-17\", \"Statement\": [ { \"Sid\": \"\", \"Effect\": \"Allow\", \"Principal\": { \"AWS\": \"arn:aws:iam::<aws-account-id>:root\" }, \"Action\": \"s3:PutObject\", \"Resource\": \"arn:aws:s3:::<your bucket name>/*/AWSLogs/<aws-account-id>/*\" } ] } Refer to AWS ELB Documentation for more details on bucket policy. VPC Setup \u00b6 Setup a VPC using the following cloudformation template by giving the these mandatory parameters: Route53HostedZoneName Route53RecordName S3AccessLogBucketName (Created in the previous step) Environment The other parameters are set by default. Change them as per your requirements. NOTE - Modifying the other defaults might require subsequent changes. Following resources will be created after executing the template: 1. 2 availability zones 1. Public & Private subnets for each availability zone 1. 2 NAT gateways and elastic IPs 1. NACL's for the subnets 1. Internet gateways for all public subnets 1. Route tables for all subnets 1. Elastic load balancer 1. Route 53 DNS entry 1. ZMS Server and ELB security groups RDS Setup \u00b6 Create Aurora MySQL cluster \u00b6 Setup an Aurora MySQL compatible cluster using the following cloudformation template by giving the following mandatory parameters: Route53HostedZoneName Route53RecordName DatabaseUsername DatabasePassword Environment The other parameters are set by default. Change them as per your requirements. Schema Setup \u00b6 Create an EC2 instance in private subnet and ssh login into it. After logging in, install the mysql package and use the following command to connect to the cluster mysql -h <RDS_CLUSTER_ENDPOINT> -P 3306 -u <DB_USER> -p Copy the zms_server.sql file from the Athenz Git repository onto this host and create the database using the following command: mysql -h <RDS_CLUSTER_ENDPOINT> -P 3306 -u <DB_USER> -p < zms_server.sql Create a user with full privileges on zms database created above. For e.g. if your ZMS Server will be running on zms1.athenz.com and the user to be created is athenz-zms having password athenz-pass : CREATE USER 'athenz-zms'@'zms1.athenz.com' IDENTIFIED BY 'athenz-pass'; GRANT ALL PRIVILEGES ON zms_server TO 'athenz-zms'@'zms1.athenz.com'; FLUSH PRIVILEGES; Create S3 Bucket to Store ZMS Data \u00b6 Create a S3 bucket for storing zms certificates & keys among other configuration data with an appropriate policy as follows: { \"Version\": \"2012-10-17\", \"Statement\": [ { \"Sid\": \"\", \"Effect\": \"Allow\", \"Principal\": { \"AWS\": \"arn:aws:iam::<aws_account_id>:role/athenz.zms-service\" }, \"Action\": \"s3:GetObject\", \"Resource\": \"arn:aws:s3:::<bucket-name>/*\" } ] } Also enable Default Encryption for your bucket. NOTE - athenz.zms-service is the EC2 role created using IAM template above Generate and Upload Service Private Key and Id \u00b6 Generate a unique private key that ZMS Server will use to sign any X509 certificates it issues: openssl genrsa -out service_private_key 2048 openssl rsa -in service_private_key -pubout > zms_service_x509_key_public Upload the service private key with name service_private_key onto the s3 bucket. Upload the service private key id with name service_private_key_id onto the s3 bucket. This file just contains the id of private key. It is not mandatory as the id defaults to 0 if not specified. Upload Server X.509 Cert and Key \u00b6 NOTE - While it is still possible to generate and use a self-signed X509 certificate for ZMS Server, it is recommended to purchase one for your production server from a well known certificate authority. Having such a certificate installed on your ZMS Servers will no longer require to distribute the server's CA certificate to other hosts (e.g. ZTS Servers, Hosts running ZPU). Follow the instructions provided by the Certificate Authority that you're going to purchase your certificate from to generate your private key and Certificate Request (CSR). Submit your CSR to your CA to generate a x.509 certificate for your ZMS server. If you are using self signed certs then run the following commands: openssl genrsa -des3 -out zms_ca_key 4096 (Create ZMS CA Key) openssl req -x509 -new -nodes -key zms_ca_key -sha256 -days 1024 -out service_x509_ca_certs (Generate CA Cert) openssl genrsa -out service_x509_key 2048 (Generate your private key) openssl req -new -key service_x509_key -out service_x509_csr (Generate your CSR) openssl x509 -req -in service_x509_csr -CA service_x509_ca_certs -CAkey zms_ca_key -CAcreateserial -out service_x509_cert -days 730 -sha256 (Generate your Certificate) Verify your certs openssl x509 -in service_x509_ca_certs -text -noout openssl x509 -in service_x509_cert -text -noout Once you have received your X509 certificate and key: - Upload the certificate to s3 bucket with name service_x509_cert - Upload the private key with name service_x509_key - Upload the Root CA cert with name service_x509_ca_certs Upload RDS CA Certs \u00b6 RDS Certs are needed if you have set athenz.zms.jdbc_use_ssl= property in zms.properties to true . By default it is set to false Upload the RDS CA Certs with a filename service_rds_ca_certs . For details on AWS RDS Certs, Please refer to RDS SSL Certificates in AWS Upload truststore password \u00b6 Upload password you want to use for truststore with a filename service_x509_store_pwd Upload ZMS DB User Password \u00b6 Create a file containing only the password for ZMS Database user( athenz-zms ) created above during RDS schema setup Upload the file to bucket with name db_user_data Create S3 Bucket for Audit Logs \u00b6 Create another bucket for audit logs having the following bucket policy: { \"Version\": \"2012-10-17\", \"Statement\": [ { \"Sid\": \"\", \"Effect\": \"Allow\", \"Principal\": { \"AWS\": [ \"arn:aws:iam::<account-id>:role/athenz.zms-service\" ] }, \"Action\": [ \"s3:AbortMultipartUpload\", \"s3:GetBucketLocation\", \"s3:GetObject\", \"s3:ListBucket\", \"s3:ListBucketMultipartUploads\", \"s3:PutObject\" ], \"Resource\": [ \"arn:aws:s3:::<audit_log_bucket_name>\", \"arn:aws:s3:::<audit_log_bucket_name>/*\" ] } ] } Configure Variables and Properties \u00b6 Edit aws_init.sh \u00b6 Update the bucket names, domain admin and RDS Endpoint in athenz/aws-setup/zms-setup/build/bin/aws_init.sh by editing the below lines: export ZMS_DATA_BUCKET_NAME=\"<The name of your zms data bucket>\" export ZMS_AUDIT_LOG_BUCKET_NAME=\"<The name of your zms audit data bucket>\" export DOMAIN_ADMINS=\"<zms-admin-name>\" export RDS_MASTER=\"<zms-rds-database-cluster-endpoint>\" When running the server very first time, ZMS Server automatically creates the required domains and sets the running user as the system administrator. The system administrators are the only ones authorized to create top level domains in Athenz. Before running the server very first time, you can configure the set of system administrators who are authorized to create top level domains in Athenz. Set DOMAIN_ADMINS to unix user id that you want to add as Athenz system administrator. The password for this user is uploaded to ZMS Data S3 Bucket created above with name admin_pass . Create a file containing password for ZMS Domain Admin Upload the file to bucket with name admin_pass The other variables are for truststore & keystore setup. We recommend to use the defaults but if you change then update the corresponding values in athenz.properties file discussed later. Edit zms.properties file \u00b6 The following properties need to be edited in zms.properties file located at athenz/aws-setup/zms-setup/build/conf/zms.properties Database Access \u00b6 Modify the following settings if RDS username & RDS password filename (stored on S3) are different from defaults suggested above. athenz.zms.object_store_factory_class=com.yahoo.athenz.zms.store.impl.JDBCObjectStoreFactory athenz.zms.jdbc_user=athenz-zms athenz.zms.jdbc_password=db_user_data User Authentication \u00b6 For a user to authenticate himself/herself in ZMS, the server must have the appropriate authentication authority implementation configured. By default, ZMS enables the following two authorities: Unix User Authority - using pam login profile to authenticate users Principal Authority - validating Principal Tokens that are issued when users authenticate using their unix login password. This is set using the following properties athenz.zms.authority_classes=com.yahoo.athenz.auth.impl.PrincipalAuthority,com.yahoo.athenz.auth.impl.UserAuthority The server also provides other authorities - e.g. Kerberos, TLS Certificate, that are not enabled by default. To add your own authentication authority modify the: athenz.zms.authority_classes=com.yahoo.athenz.auth.impl.PrincipalAuthority,com.yahoo.athenz.auth.impl.UserAuthority line in zms.properties file and include comma separated list of authority implementation classes to support. Domain Admins \u00b6 Modify the below setting and set it to unix user you passed as domain admin in aws_init_file in above steps. athenz.zms.domain_admin=user.zms-admin Edit athenz.properties file \u00b6 The following properties need to be edited in athenz.properties file located at athenz/aws-setup/zms-setup/build/conf/athenz.properties Truststore and Keystore Settings \u00b6 If you modified the truststore and keystore paths and password in the aws_init.sh file then change the below settings in athenz.properties file accordingly: athenz.ssl_key_store=/opt/zms/conf/zms_keystore.pkcs12 //path to the keystore file that contains the server's certificate athenz.ssl_key_store_type=PKCS12 //specifies the type for the keystore specified in the athenz.ssl_key_store_password=service_x509_store_pwd //S3 bucket key name for Password for the keystore specified in the athenz.ssl_key_store property athenz.ssl_trust_store=/opt/zms/conf/zms_truststore.jks //path to the trust store file that contains CA certificates trusted by this Jetty instance athenz.ssl_trust_store_type=JKS //specifies the type for the truststore specified athenz.ssl_trust_store_password=service_x509_store_pwd //password for the truststore Packer \u00b6 Packer VPC Setup \u00b6 Setup packer vpc by using the cloudformation template and update packer.json file accordingly. { \"subnet_id\":\"<packer_public_subnet_id>\", \"vpc_id\": \"<vpc_id>\", \"aws_region\": \"<aws-region where you created the resources>\", \"aws_ami_name\": \"zms-aws-cd-image\", \"aws_access_key\": \"{{env `AWS_ACCESS_KEY_ID`}}\", \"aws_secret_key\": \"{{env `AWS_SECRET_ACCESS_KEY`}}\", \"aws_session_token\": \"{{env `AWS_SESSION_TOKEN`}}\", \"ssh_keypair_name\":\"<EC2_SSH_Key_Name>\", \"ssh_private_key_file\":\"<PATH_TO_SSH_KEYPAIR>\", \"source_ami\": \"ami-02c71d7a\" } Build ZMS image \u00b6 Build the image with packer using the following command: cd /aws-setup/zms-setup packer build packer/aws/packer.json Deploy ZMS \u00b6 Run cloudformation template to bring up the zms-instances in 2 availability zones. The imageID parameter should be set to the image created in previous step. The ZMS Server is now up and running.","title":"ZMS Server"},{"location":"aws_zms_setup/#setup-zms-on-aws","text":"IAM Role Setup S3 Bucket for ELB Access Logs VPC setup RDS Setup Create Aurora MySQL Cluster Schema Setup S3 Bucket to Store ZMS Data Generate and Upload Service Private Key Upload Server X.509 Cert and Key Upload RDS CA Certs Upload Truststore Password Upload ZMS DB User Password Create S3 Bucket for Audit logs Configure Variables and Properties aws_init.sh zms.properties Database Access User Authentication Domain Admins athenz.properties Truststore and Keystore Settings Packer Packer VPC setup Build ZMS Image Deploy ZMS","title":"Setup ZMS on AWS"},{"location":"aws_zms_setup/#iam-role-setup","text":"Create an EC2 profile role for ZMS using the following cloudformation template . This template creates a role named athenz.zms-service .","title":"IAM Role Setup"},{"location":"aws_zms_setup/#s3-bucket-for-elb-access-logs","text":"Create a S3 bucket needed to store ELB access logs with the following bucket policy: { \"Version\": \"2012-10-17\", \"Statement\": [ { \"Sid\": \"\", \"Effect\": \"Allow\", \"Principal\": { \"AWS\": \"arn:aws:iam::<aws-account-id>:root\" }, \"Action\": \"s3:PutObject\", \"Resource\": \"arn:aws:s3:::<your bucket name>/*/AWSLogs/<aws-account-id>/*\" } ] } Refer to AWS ELB Documentation for more details on bucket policy.","title":"S3 Bucket for ELB Access Logs"},{"location":"aws_zms_setup/#vpc-setup","text":"Setup a VPC using the following cloudformation template by giving the these mandatory parameters: Route53HostedZoneName Route53RecordName S3AccessLogBucketName (Created in the previous step) Environment The other parameters are set by default. Change them as per your requirements. NOTE - Modifying the other defaults might require subsequent changes. Following resources will be created after executing the template: 1. 2 availability zones 1. Public & Private subnets for each availability zone 1. 2 NAT gateways and elastic IPs 1. NACL's for the subnets 1. Internet gateways for all public subnets 1. Route tables for all subnets 1. Elastic load balancer 1. Route 53 DNS entry 1. ZMS Server and ELB security groups","title":"VPC Setup"},{"location":"aws_zms_setup/#rds-setup","text":"","title":"RDS Setup"},{"location":"aws_zms_setup/#create-aurora-mysql-cluster","text":"Setup an Aurora MySQL compatible cluster using the following cloudformation template by giving the following mandatory parameters: Route53HostedZoneName Route53RecordName DatabaseUsername DatabasePassword Environment The other parameters are set by default. Change them as per your requirements.","title":"Create Aurora MySQL cluster"},{"location":"aws_zms_setup/#schema-setup","text":"Create an EC2 instance in private subnet and ssh login into it. After logging in, install the mysql package and use the following command to connect to the cluster mysql -h <RDS_CLUSTER_ENDPOINT> -P 3306 -u <DB_USER> -p Copy the zms_server.sql file from the Athenz Git repository onto this host and create the database using the following command: mysql -h <RDS_CLUSTER_ENDPOINT> -P 3306 -u <DB_USER> -p < zms_server.sql Create a user with full privileges on zms database created above. For e.g. if your ZMS Server will be running on zms1.athenz.com and the user to be created is athenz-zms having password athenz-pass : CREATE USER 'athenz-zms'@'zms1.athenz.com' IDENTIFIED BY 'athenz-pass'; GRANT ALL PRIVILEGES ON zms_server TO 'athenz-zms'@'zms1.athenz.com'; FLUSH PRIVILEGES;","title":"Schema Setup"},{"location":"aws_zms_setup/#create-s3-bucket-to-store-zms-data","text":"Create a S3 bucket for storing zms certificates & keys among other configuration data with an appropriate policy as follows: { \"Version\": \"2012-10-17\", \"Statement\": [ { \"Sid\": \"\", \"Effect\": \"Allow\", \"Principal\": { \"AWS\": \"arn:aws:iam::<aws_account_id>:role/athenz.zms-service\" }, \"Action\": \"s3:GetObject\", \"Resource\": \"arn:aws:s3:::<bucket-name>/*\" } ] } Also enable Default Encryption for your bucket. NOTE - athenz.zms-service is the EC2 role created using IAM template above","title":"Create S3 Bucket to Store ZMS Data"},{"location":"aws_zms_setup/#generate-and-upload-service-private-key-and-id","text":"Generate a unique private key that ZMS Server will use to sign any X509 certificates it issues: openssl genrsa -out service_private_key 2048 openssl rsa -in service_private_key -pubout > zms_service_x509_key_public Upload the service private key with name service_private_key onto the s3 bucket. Upload the service private key id with name service_private_key_id onto the s3 bucket. This file just contains the id of private key. It is not mandatory as the id defaults to 0 if not specified.","title":"Generate and Upload Service Private Key and Id"},{"location":"aws_zms_setup/#upload-server-x509-cert-and-key","text":"NOTE - While it is still possible to generate and use a self-signed X509 certificate for ZMS Server, it is recommended to purchase one for your production server from a well known certificate authority. Having such a certificate installed on your ZMS Servers will no longer require to distribute the server's CA certificate to other hosts (e.g. ZTS Servers, Hosts running ZPU). Follow the instructions provided by the Certificate Authority that you're going to purchase your certificate from to generate your private key and Certificate Request (CSR). Submit your CSR to your CA to generate a x.509 certificate for your ZMS server. If you are using self signed certs then run the following commands: openssl genrsa -des3 -out zms_ca_key 4096 (Create ZMS CA Key) openssl req -x509 -new -nodes -key zms_ca_key -sha256 -days 1024 -out service_x509_ca_certs (Generate CA Cert) openssl genrsa -out service_x509_key 2048 (Generate your private key) openssl req -new -key service_x509_key -out service_x509_csr (Generate your CSR) openssl x509 -req -in service_x509_csr -CA service_x509_ca_certs -CAkey zms_ca_key -CAcreateserial -out service_x509_cert -days 730 -sha256 (Generate your Certificate) Verify your certs openssl x509 -in service_x509_ca_certs -text -noout openssl x509 -in service_x509_cert -text -noout Once you have received your X509 certificate and key: - Upload the certificate to s3 bucket with name service_x509_cert - Upload the private key with name service_x509_key - Upload the Root CA cert with name service_x509_ca_certs","title":"Upload Server X.509 Cert and Key"},{"location":"aws_zms_setup/#upload-rds-ca-certs","text":"RDS Certs are needed if you have set athenz.zms.jdbc_use_ssl= property in zms.properties to true . By default it is set to false Upload the RDS CA Certs with a filename service_rds_ca_certs . For details on AWS RDS Certs, Please refer to RDS SSL Certificates in AWS","title":"Upload RDS CA Certs"},{"location":"aws_zms_setup/#upload-truststore-password","text":"Upload password you want to use for truststore with a filename service_x509_store_pwd","title":"Upload truststore password"},{"location":"aws_zms_setup/#upload-zms-db-user-password","text":"Create a file containing only the password for ZMS Database user( athenz-zms ) created above during RDS schema setup Upload the file to bucket with name db_user_data","title":"Upload ZMS DB User Password"},{"location":"aws_zms_setup/#create-s3-bucket-for-audit-logs","text":"Create another bucket for audit logs having the following bucket policy: { \"Version\": \"2012-10-17\", \"Statement\": [ { \"Sid\": \"\", \"Effect\": \"Allow\", \"Principal\": { \"AWS\": [ \"arn:aws:iam::<account-id>:role/athenz.zms-service\" ] }, \"Action\": [ \"s3:AbortMultipartUpload\", \"s3:GetBucketLocation\", \"s3:GetObject\", \"s3:ListBucket\", \"s3:ListBucketMultipartUploads\", \"s3:PutObject\" ], \"Resource\": [ \"arn:aws:s3:::<audit_log_bucket_name>\", \"arn:aws:s3:::<audit_log_bucket_name>/*\" ] } ] }","title":"Create S3 Bucket for Audit Logs"},{"location":"aws_zms_setup/#configure-variables-and-properties","text":"","title":"Configure Variables and Properties"},{"location":"aws_zms_setup/#edit-aws_initsh","text":"Update the bucket names, domain admin and RDS Endpoint in athenz/aws-setup/zms-setup/build/bin/aws_init.sh by editing the below lines: export ZMS_DATA_BUCKET_NAME=\"<The name of your zms data bucket>\" export ZMS_AUDIT_LOG_BUCKET_NAME=\"<The name of your zms audit data bucket>\" export DOMAIN_ADMINS=\"<zms-admin-name>\" export RDS_MASTER=\"<zms-rds-database-cluster-endpoint>\" When running the server very first time, ZMS Server automatically creates the required domains and sets the running user as the system administrator. The system administrators are the only ones authorized to create top level domains in Athenz. Before running the server very first time, you can configure the set of system administrators who are authorized to create top level domains in Athenz. Set DOMAIN_ADMINS to unix user id that you want to add as Athenz system administrator. The password for this user is uploaded to ZMS Data S3 Bucket created above with name admin_pass . Create a file containing password for ZMS Domain Admin Upload the file to bucket with name admin_pass The other variables are for truststore & keystore setup. We recommend to use the defaults but if you change then update the corresponding values in athenz.properties file discussed later.","title":"Edit aws_init.sh"},{"location":"aws_zms_setup/#edit-zmsproperties-file","text":"The following properties need to be edited in zms.properties file located at athenz/aws-setup/zms-setup/build/conf/zms.properties","title":"Edit zms.properties file"},{"location":"aws_zms_setup/#database-access","text":"Modify the following settings if RDS username & RDS password filename (stored on S3) are different from defaults suggested above. athenz.zms.object_store_factory_class=com.yahoo.athenz.zms.store.impl.JDBCObjectStoreFactory athenz.zms.jdbc_user=athenz-zms athenz.zms.jdbc_password=db_user_data","title":"Database Access"},{"location":"aws_zms_setup/#user-authentication","text":"For a user to authenticate himself/herself in ZMS, the server must have the appropriate authentication authority implementation configured. By default, ZMS enables the following two authorities: Unix User Authority - using pam login profile to authenticate users Principal Authority - validating Principal Tokens that are issued when users authenticate using their unix login password. This is set using the following properties athenz.zms.authority_classes=com.yahoo.athenz.auth.impl.PrincipalAuthority,com.yahoo.athenz.auth.impl.UserAuthority The server also provides other authorities - e.g. Kerberos, TLS Certificate, that are not enabled by default. To add your own authentication authority modify the: athenz.zms.authority_classes=com.yahoo.athenz.auth.impl.PrincipalAuthority,com.yahoo.athenz.auth.impl.UserAuthority line in zms.properties file and include comma separated list of authority implementation classes to support.","title":"User Authentication"},{"location":"aws_zms_setup/#domain-admins","text":"Modify the below setting and set it to unix user you passed as domain admin in aws_init_file in above steps. athenz.zms.domain_admin=user.zms-admin","title":"Domain Admins"},{"location":"aws_zms_setup/#edit-athenzproperties-file","text":"The following properties need to be edited in athenz.properties file located at athenz/aws-setup/zms-setup/build/conf/athenz.properties","title":"Edit athenz.properties file"},{"location":"aws_zms_setup/#truststore-and-keystore-settings","text":"If you modified the truststore and keystore paths and password in the aws_init.sh file then change the below settings in athenz.properties file accordingly: athenz.ssl_key_store=/opt/zms/conf/zms_keystore.pkcs12 //path to the keystore file that contains the server's certificate athenz.ssl_key_store_type=PKCS12 //specifies the type for the keystore specified in the athenz.ssl_key_store_password=service_x509_store_pwd //S3 bucket key name for Password for the keystore specified in the athenz.ssl_key_store property athenz.ssl_trust_store=/opt/zms/conf/zms_truststore.jks //path to the trust store file that contains CA certificates trusted by this Jetty instance athenz.ssl_trust_store_type=JKS //specifies the type for the truststore specified athenz.ssl_trust_store_password=service_x509_store_pwd //password for the truststore","title":"Truststore and Keystore Settings"},{"location":"aws_zms_setup/#packer","text":"","title":"Packer"},{"location":"aws_zms_setup/#packer-vpc-setup","text":"Setup packer vpc by using the cloudformation template and update packer.json file accordingly. { \"subnet_id\":\"<packer_public_subnet_id>\", \"vpc_id\": \"<vpc_id>\", \"aws_region\": \"<aws-region where you created the resources>\", \"aws_ami_name\": \"zms-aws-cd-image\", \"aws_access_key\": \"{{env `AWS_ACCESS_KEY_ID`}}\", \"aws_secret_key\": \"{{env `AWS_SECRET_ACCESS_KEY`}}\", \"aws_session_token\": \"{{env `AWS_SESSION_TOKEN`}}\", \"ssh_keypair_name\":\"<EC2_SSH_Key_Name>\", \"ssh_private_key_file\":\"<PATH_TO_SSH_KEYPAIR>\", \"source_ami\": \"ami-02c71d7a\" }","title":"Packer VPC Setup"},{"location":"aws_zms_setup/#build-zms-image","text":"Build the image with packer using the following command: cd /aws-setup/zms-setup packer build packer/aws/packer.json","title":"Build ZMS image"},{"location":"aws_zms_setup/#deploy-zms","text":"Run cloudformation template to bring up the zms-instances in 2 availability zones. The imageID parameter should be set to the image created in previous step. The ZMS Server is now up and running.","title":"Deploy ZMS"},{"location":"aws_zts_setup/","text":"Setup ZTS on AWS \u00b6 IAM role setup VPC setup RDS Setup Create Aurora Mysql cluster Schema setup S3 bucket for zts data Generate and upload service private key and Id Upload server X.509 cert and key Upload RDS CA Certs Upload truststore password Upload ZTS DB User Password Upload ZMS CA Certs Upload ZTS and ZMS Public keys Upload Self Cert Signer Key Update the policy for S3 bucket for Audit logs Update ZMS DATA BUCKET Register ZTS Service Configure Variables and Properties aws_init.sh Edit the properties file Database Access Athenz CA X.509 Certificate Issuing Truststore and Keystore Settings Packer Packer VPC setup Build ZTS Image Deploy ZTS IAM Role Setup \u00b6 Create an EC2 profile role for ZTS using cloudformation template . This template creates a role named athenz.zts-service VPC Setup \u00b6 Setup VPC using the cloudformation template and giving the following mandatory parameters: Route53HostedZoneName Route53RecordName S3AccessLogBucketName (Created during ZMS Setup) Environment The other parameters are set by default. Change them as per your requirements. NOTE - Modifying the other defaults might require subsequent changes. Following resources will be created after executing the template: 1. 2 availability zones 1. Public & Private subnets for zts in each availability zone 1. Public & Private subnets for cert signer in each availability zone 1. 4 NAT gateways and elastic IPs 1. NACL's for the subnets 1. Internet gateways for all public subnets 1. Route tables for all subnets 1. Elastic load balancer 1. Route 53 DNS entry 1. ZTS Server & ELB security groups RDS Setup \u00b6 Create Aurora MySQL cluster \u00b6 Setup an Aurora MySQL cluster using cloudformation template by giving the following mandatory parameters: Route53HostedZoneName Route53RecordName DatabaseUsername DatabasePassword Environment The other parameters are set by default. Change them as per your requirements. Schema Setup \u00b6 Create an instance in your private subnet and ssh login into it. After logging in, install the mysql client and use the following command to connect to the cluster using Database Root Credentials: mysql -h <RDS_CLUSTER_ENDPOINT> -P 3306 -u <DB_USER> -p Copy the zts_server.sql file from the Athenz Git repository onto this host and create the database using the following command mysql -h <RDS_CLUSTER_ENDPOINT> -P 3306 -u <DB_USER> -p < zts_server.sql Create a user with full privileges on zts database created above. For e.g. If your ZTS Server will be running on zts1.athenz.com and user to be created is athenz-zts having password athenz-zts : CREATE USER 'athenz-zts'@'zts1.athenz.com' IDENTIFIED BY 'athenz-zts'; GRANT ALL PRIVILEGES ON zts_store TO 'athenz-zts'@'zts1.athenz.com'; FLUSH PRIVILEGES; Create S3 Bucket to Store ZTS Data \u00b6 Create a S3 bucket for storing ZTS certificates, keys and other configuration data with appropriate policy as follows: { \"Version\": \"2012-10-17\", \"Statement\": [ { \"Sid\": \"\", \"Effect\": \"Allow\", \"Principal\": { \"AWS\": \"arn:aws:iam::<aws_account_id>:role/athenz.zts-service\" }, \"Action\": \"s3:GetObject\", \"Resource\": \"arn:aws:s3::: <bucket-name> /*\" } ] } Also enable Default Encryption for your bucket. NOTE - athenz.zts-service is the EC2 role created using IAM template above Generate and Upload Service Private Key and Id \u00b6 Generate a unique private key that ZTS Server will use to sign any Tokens it issues: openssl genrsa -out service_private_key 2048 openssl rsa -in service_private_key -pubout > zts_service_x509_key_public Upload the service private key with name service_private_key onto the s3 bucket. Upload the service private key id with name service_private_key_id onto the s3 bucket. This file just contains the id of private key. It is not mandatory as the id defaults to 0 if not specified Upload Server X.509 Cert and Key \u00b6 NOTE - While it is still possible to generate and use a self-signed X.509 certificate for ZTS Servers, it is recommended to purchase one for your production server from a well known certificate authority. Having such a certificate installed on your ZTS Servers will no longer require to distribute the server's CA certificate to other hosts (e.g. Hosts running ZPU). Follow the instructions provided by the Certificate Authority that you're going to purchase your certificate from, to generate your private key and Certificate Request (CSR). Submit your CSR to your CA to generate a x.509 certificate for your ZMS server. If you are using self signed certs then run the following commands: openssl genrsa -des3 -out zts_ca_key 4096 (Create ZTS CA Key) openssl req -x509 -new -nodes -key zts_ca_key -sha256 -days 1024 -out service_x509_ca_certs (Generate CA Cert) openssl genrsa -out service_x509_key 2048 (Generate your private key) openssl req -new -key service_x509_key -out service_x509_csr (Generate your CSR) openssl x509 -req -in service_x509_csr -CA service_x509_ca_certs -CAkey zts_ca_key -CAcreateserial -out service_x509_cert -days 730 -sha256 (Generate your Certificate) Verify your certs openssl x509 -in service_x509_ca_certs -text -noout openssl x509 -in service_x509_cert -text -noout Once you have received your X509 certificate and key: - Upload the certificate with on s3 bucket with name service_x509_cert - Upload the private key with name service_x509_key - Upload the Root CA cert with name service_x509_ca_certs Upload RDS CA Certs \u00b6 Upload the RDS CA Certs with key service_rds_ca_certs For details on AWS RDS Certs, Please refer RDS SSL Certificates in AWS Upload truststore password \u00b6 Upload password you want to use for truststore with name service_x509_store_pwd Upload ZTS DB User Password \u00b6 Create a file containing only the password for ZTS Database user( athenz-zts ) created above during RDS schema setup Upload the file to bucket with name db_user_data Upload ZMS CA Certs \u00b6 Upload ZMS CA Cert with key zms_service_x509_ca_certs . They will be added to ZTS truststore so that ZTS can communicate securely with ZMS Upload ZTS and ZMS Public keys \u00b6 Upload ZTS public key with name zts_service_x509_key_public.pem Upload ZMS public key with name zms_service_x509_key_public.pem They are required to generate athenz.conf file at /opt/zts/conf to include the ZTS and ZMS Server URL and the registered public keys that the athenz client libraries and utilities will use to establish connections and validate any data signed by the ZTS and ZMS Server. Upload Self Cert Signer Key \u00b6 You can use SelfCertSigner or have your implementation of Cert Signer. Refer Certificate Signer for full details how to implement your cert signer. If you are using self cert signer then Generate a private key and upload it to s3 bucket with name self_cert_signer_key Update the policy for S3 bucket for Audit logs \u00b6 Update the bucket policy for S3 bucket created for audit logs during zms setup to allow athenz.zts-service role to read and write to it. { \"Version\": \"2012-10-17\", \"Statement\": [ { \"Sid\": \"\", \"Effect\": \"Allow\", \"Principal\": { \"AWS\": [ \"arn:aws:iam::<aws_account_id>:role/athenz.zms-service\" \"arn:aws:iam::<aws_account_id>:role/athenz.zts-service\" ] }, ... ] } Update ZMS Data Bucket \u00b6 Upload zts service public key to ZMS Data Bucket with key zts_service_x509_key_public.pem Register ZTS Service \u00b6 In order for ZTS to access ZMS domain data, it must identify itself as a registered service in ZMS. Use zms-cli utility to register a new service in sys.auth domain. If ZMS Servers are running with a X509 certificate from a well know certificate authority (not a self-signed one) we don't need to reference the CA cert like we are doing below for self signed certs. Login into your zms-server instance as domain admin you created during zms setup and run the below commands: - Download ZMS CA Certs(If using self signed certs) aws s3 cp s3://<zms_bucket_name>/zms_service_x509_ca_certs /tmp/zms_service_x509_ca_certs - Download ZTS public key aws s3 cp s3://<zms_bucket_name>/zts_service_x509_key_public.pem /tmp/zts_service_x509_key_public.pem - Register Service using zms-cli /opt/zts/bin/zms-cli -c /tmp/service_x509_ca_certs -z <zms_url> -d sys.auth add-service zts 0 /tmp/zts_service_x509_key_public.pem NOTE - Append /zms/v1 to your url in the command above For e.g. if your zms server is running at https://zms.athenz.com:4443 then pass https://zms.athenz.com:4443/zms/v1 . Configure Variables and Properties \u00b6 Edit aws_init.sh \u00b6 Update the bucket names in athenz/aws-setup/zts-setup/build/bin/aws_init.sh by editing the below lines: export ZTS_DATA_BUCKET_NAME=\"<The name of your zts data bucket>\" export ZTS_AUDIT_LOG_BUCKET_NAME=\"<The name of your zms audit data bucket>\" export ZTS_URL=\"<zts_url>\" export ZMS_URL=\"\"<zms_url>\" export RDS_MASTER=\"<zts-rds-databasecluster-endpoint>\" The other variables are for trust store & key store setup. We recommend to use the defaults but if you change then update the corresponding values in athenz.properties file discussed later. Edit the properties file \u00b6 Database Access \u00b6 Modify the following settings in zts.properties file located at athenz/aws-setup/zts-setup/build/conf/zts.properties if RDS username & RDS password filename (stored on S3) are different from defaults suggested above. athenz.zts.cert_record_store_factory_class=com.yahoo.athenz.zts.cert.impl.JDBCCertRecordStoreFactory athenz.zts.cert_jdbc_user=athenz-zts athenz.zts.cert_jdbc_password=db_user_data Athenz CA X.509 Certificate Issuing \u00b6 For authenticating services using X509 certificates, ZTS Servers expect the configured cert signer factory class names in its athenz.zts.cert_signer_factory_class system property. Self Cert Signer com.yahoo.athenz.zts.cert.impl.SelfCertSignerFactory is a sample implementation of cert Signer we have for development environment. You can use SelfCertSigner or have your implementation of Cert Signer. If you are using self cert signer make the below changes: The self cert signer key you uploaded in above steps has to be downloaded on the box. The default is to download it to /opt/zts/conf/self_cert_signer_key . If you using the defaults, uncomment the below lines in initialize_zts.sh # echo \"Downloading self cert signer key\" # aws s3 cp s3://$bucket_name/self_cert_signer_key /opt/zts/conf/self_cert_signer_key Edit the below properties in zts.properties file accordingly: # athenz.zts.self_signer_private_key_fname=/opt/zts/conf/self_cert_signer_key # athenz.zts.self_signer_private_key_password= # athenz.zts.self_signer_cert_dn=C=US,ST=CA,L=Sunnyvale,O=Oath,OU=Athenz,CN=zts.aws.oath.cloud Truststore and Keystore Settings \u00b6 If you modified the truststore and keystore paths and password in the aws_init.sh file then change the below settings in athenz.properties file located at athenz/aws-setup/zts-setup/build/conf/athenz.properties : athenz.ssl_key_store=/opt/zts/conf/zts_keystore.pkcs12 //path to the keystore file that contains the server's certificate athenz.ssl_key_store_type=PKCS12 //specifies the type for the keystore specified in the athenz.ssl_key_store_password=service_x509_store_pwd //S3 bucket key name for Password for the keystore specified in the athenz.ssl_key_store property athenz.ssl_trust_store=/opt/zts/conf/zts_truststore.jks //path to the trust store file that contains CA certificates trusted by this Jetty instance athenz.ssl_trust_store_type=JKS //specifies the type for the truststore specified athenz.ssl_trust_store_password=service_x509_store_pwd //password for the truststore Update the following in zts.properties file: athenz.zts.ssl_key_store=/opt/zts/conf/zts_keystore.pkcs12 //path to the keystore file that contains the server's certificate athenz.zts.ssl_key_store_type=PKCS12 //specifies the type for the keystore specified in the athenz.zts.ssl_key_store_password=service_x509_store_pwd //S3 bucket key name for Password for the keystore specified in the athenz.ssl_key_store property athenz.zts.ssl_trust_store=/opt/zts/conf/zts_truststore.jks //path to the trust store file that contains CA certificates trusted by this Jetty instance athenz.zts.ssl_trust_store_type=JKS //specifies the type for the truststore specified athenz.zts.ssl_trust_store_password=service_x509_store_pwd //password for the truststore Packer \u00b6 Packer VPC Setup \u00b6 Packer VPC was set during zms setup, update packer.json accordingly: { \"subnet_id\":\"<packer_public_subnet_id>\", \"vpc_id\": \"<vpc_id>\", \"aws_region\": \"<aws-region where you created the resources>\", \"aws_ami_name\": \"zts-aws-cd-image\", \"aws_access_key\": \"{{env `AWS_ACCESS_KEY_ID`}}\", \"aws_secret_key\": \"{{env `AWS_SECRET_ACCESS_KEY`}}\", \"aws_session_token\": \"{{env `AWS_SESSION_TOKEN`}}\", \"ssh_keypair_name\":\"<EC2_SSH_Key_Name>\", \"ssh_private_key_file\":\"<PATH_TO_SSH_KEYPAIR>\", \"source_ami\": \"ami-02c71d7a\" } Build ZTS image \u00b6 Build the image with packer using the following command cd /aws-setup/zts-setup packer build packer/aws/packer.json Deploy ZTS \u00b6 Run cloudformation template to bring up the zts-instances in 2 availability zones. The imageID parameter should be set to the image created in above step. The ZTS Server is now up and running.","title":"ZTS Server"},{"location":"aws_zts_setup/#setup-zts-on-aws","text":"IAM role setup VPC setup RDS Setup Create Aurora Mysql cluster Schema setup S3 bucket for zts data Generate and upload service private key and Id Upload server X.509 cert and key Upload RDS CA Certs Upload truststore password Upload ZTS DB User Password Upload ZMS CA Certs Upload ZTS and ZMS Public keys Upload Self Cert Signer Key Update the policy for S3 bucket for Audit logs Update ZMS DATA BUCKET Register ZTS Service Configure Variables and Properties aws_init.sh Edit the properties file Database Access Athenz CA X.509 Certificate Issuing Truststore and Keystore Settings Packer Packer VPC setup Build ZTS Image Deploy ZTS","title":"Setup ZTS on AWS"},{"location":"aws_zts_setup/#iam-role-setup","text":"Create an EC2 profile role for ZTS using cloudformation template . This template creates a role named athenz.zts-service","title":"IAM Role Setup"},{"location":"aws_zts_setup/#vpc-setup","text":"Setup VPC using the cloudformation template and giving the following mandatory parameters: Route53HostedZoneName Route53RecordName S3AccessLogBucketName (Created during ZMS Setup) Environment The other parameters are set by default. Change them as per your requirements. NOTE - Modifying the other defaults might require subsequent changes. Following resources will be created after executing the template: 1. 2 availability zones 1. Public & Private subnets for zts in each availability zone 1. Public & Private subnets for cert signer in each availability zone 1. 4 NAT gateways and elastic IPs 1. NACL's for the subnets 1. Internet gateways for all public subnets 1. Route tables for all subnets 1. Elastic load balancer 1. Route 53 DNS entry 1. ZTS Server & ELB security groups","title":"VPC Setup"},{"location":"aws_zts_setup/#rds-setup","text":"","title":"RDS Setup"},{"location":"aws_zts_setup/#create-aurora-mysql-cluster","text":"Setup an Aurora MySQL cluster using cloudformation template by giving the following mandatory parameters: Route53HostedZoneName Route53RecordName DatabaseUsername DatabasePassword Environment The other parameters are set by default. Change them as per your requirements.","title":"Create Aurora MySQL cluster"},{"location":"aws_zts_setup/#schema-setup","text":"Create an instance in your private subnet and ssh login into it. After logging in, install the mysql client and use the following command to connect to the cluster using Database Root Credentials: mysql -h <RDS_CLUSTER_ENDPOINT> -P 3306 -u <DB_USER> -p Copy the zts_server.sql file from the Athenz Git repository onto this host and create the database using the following command mysql -h <RDS_CLUSTER_ENDPOINT> -P 3306 -u <DB_USER> -p < zts_server.sql Create a user with full privileges on zts database created above. For e.g. If your ZTS Server will be running on zts1.athenz.com and user to be created is athenz-zts having password athenz-zts : CREATE USER 'athenz-zts'@'zts1.athenz.com' IDENTIFIED BY 'athenz-zts'; GRANT ALL PRIVILEGES ON zts_store TO 'athenz-zts'@'zts1.athenz.com'; FLUSH PRIVILEGES;","title":"Schema Setup"},{"location":"aws_zts_setup/#create-s3-bucket-to-store-zts-data","text":"Create a S3 bucket for storing ZTS certificates, keys and other configuration data with appropriate policy as follows: { \"Version\": \"2012-10-17\", \"Statement\": [ { \"Sid\": \"\", \"Effect\": \"Allow\", \"Principal\": { \"AWS\": \"arn:aws:iam::<aws_account_id>:role/athenz.zts-service\" }, \"Action\": \"s3:GetObject\", \"Resource\": \"arn:aws:s3::: <bucket-name> /*\" } ] } Also enable Default Encryption for your bucket. NOTE - athenz.zts-service is the EC2 role created using IAM template above","title":"Create S3 Bucket to Store ZTS Data"},{"location":"aws_zts_setup/#generate-and-upload-service-private-key-and-id","text":"Generate a unique private key that ZTS Server will use to sign any Tokens it issues: openssl genrsa -out service_private_key 2048 openssl rsa -in service_private_key -pubout > zts_service_x509_key_public Upload the service private key with name service_private_key onto the s3 bucket. Upload the service private key id with name service_private_key_id onto the s3 bucket. This file just contains the id of private key. It is not mandatory as the id defaults to 0 if not specified","title":"Generate and Upload Service Private Key and Id"},{"location":"aws_zts_setup/#upload-server-x509-cert-and-key","text":"NOTE - While it is still possible to generate and use a self-signed X.509 certificate for ZTS Servers, it is recommended to purchase one for your production server from a well known certificate authority. Having such a certificate installed on your ZTS Servers will no longer require to distribute the server's CA certificate to other hosts (e.g. Hosts running ZPU). Follow the instructions provided by the Certificate Authority that you're going to purchase your certificate from, to generate your private key and Certificate Request (CSR). Submit your CSR to your CA to generate a x.509 certificate for your ZMS server. If you are using self signed certs then run the following commands: openssl genrsa -des3 -out zts_ca_key 4096 (Create ZTS CA Key) openssl req -x509 -new -nodes -key zts_ca_key -sha256 -days 1024 -out service_x509_ca_certs (Generate CA Cert) openssl genrsa -out service_x509_key 2048 (Generate your private key) openssl req -new -key service_x509_key -out service_x509_csr (Generate your CSR) openssl x509 -req -in service_x509_csr -CA service_x509_ca_certs -CAkey zts_ca_key -CAcreateserial -out service_x509_cert -days 730 -sha256 (Generate your Certificate) Verify your certs openssl x509 -in service_x509_ca_certs -text -noout openssl x509 -in service_x509_cert -text -noout Once you have received your X509 certificate and key: - Upload the certificate with on s3 bucket with name service_x509_cert - Upload the private key with name service_x509_key - Upload the Root CA cert with name service_x509_ca_certs","title":"Upload Server X.509 Cert and Key"},{"location":"aws_zts_setup/#upload-rds-ca-certs","text":"Upload the RDS CA Certs with key service_rds_ca_certs For details on AWS RDS Certs, Please refer RDS SSL Certificates in AWS","title":"Upload RDS CA Certs"},{"location":"aws_zts_setup/#upload-truststore-password","text":"Upload password you want to use for truststore with name service_x509_store_pwd","title":"Upload truststore password"},{"location":"aws_zts_setup/#upload-zts-db-user-password","text":"Create a file containing only the password for ZTS Database user( athenz-zts ) created above during RDS schema setup Upload the file to bucket with name db_user_data","title":"Upload ZTS DB User Password"},{"location":"aws_zts_setup/#upload-zms-ca-certs","text":"Upload ZMS CA Cert with key zms_service_x509_ca_certs . They will be added to ZTS truststore so that ZTS can communicate securely with ZMS","title":"Upload ZMS CA Certs"},{"location":"aws_zts_setup/#upload-zts-and-zms-public-keys","text":"Upload ZTS public key with name zts_service_x509_key_public.pem Upload ZMS public key with name zms_service_x509_key_public.pem They are required to generate athenz.conf file at /opt/zts/conf to include the ZTS and ZMS Server URL and the registered public keys that the athenz client libraries and utilities will use to establish connections and validate any data signed by the ZTS and ZMS Server.","title":"Upload ZTS and ZMS Public keys"},{"location":"aws_zts_setup/#upload-self-cert-signer-key","text":"You can use SelfCertSigner or have your implementation of Cert Signer. Refer Certificate Signer for full details how to implement your cert signer. If you are using self cert signer then Generate a private key and upload it to s3 bucket with name self_cert_signer_key","title":"Upload Self Cert Signer Key"},{"location":"aws_zts_setup/#update-the-policy-for-s3-bucket-for-audit-logs","text":"Update the bucket policy for S3 bucket created for audit logs during zms setup to allow athenz.zts-service role to read and write to it. { \"Version\": \"2012-10-17\", \"Statement\": [ { \"Sid\": \"\", \"Effect\": \"Allow\", \"Principal\": { \"AWS\": [ \"arn:aws:iam::<aws_account_id>:role/athenz.zms-service\" \"arn:aws:iam::<aws_account_id>:role/athenz.zts-service\" ] }, ... ] }","title":"Update the  policy for S3 bucket for Audit logs"},{"location":"aws_zts_setup/#update-zms-data-bucket","text":"Upload zts service public key to ZMS Data Bucket with key zts_service_x509_key_public.pem","title":"Update ZMS Data Bucket"},{"location":"aws_zts_setup/#register-zts-service","text":"In order for ZTS to access ZMS domain data, it must identify itself as a registered service in ZMS. Use zms-cli utility to register a new service in sys.auth domain. If ZMS Servers are running with a X509 certificate from a well know certificate authority (not a self-signed one) we don't need to reference the CA cert like we are doing below for self signed certs. Login into your zms-server instance as domain admin you created during zms setup and run the below commands: - Download ZMS CA Certs(If using self signed certs) aws s3 cp s3://<zms_bucket_name>/zms_service_x509_ca_certs /tmp/zms_service_x509_ca_certs - Download ZTS public key aws s3 cp s3://<zms_bucket_name>/zts_service_x509_key_public.pem /tmp/zts_service_x509_key_public.pem - Register Service using zms-cli /opt/zts/bin/zms-cli -c /tmp/service_x509_ca_certs -z <zms_url> -d sys.auth add-service zts 0 /tmp/zts_service_x509_key_public.pem NOTE - Append /zms/v1 to your url in the command above For e.g. if your zms server is running at https://zms.athenz.com:4443 then pass https://zms.athenz.com:4443/zms/v1 .","title":"Register ZTS Service"},{"location":"aws_zts_setup/#configure-variables-and-properties","text":"","title":"Configure Variables and Properties"},{"location":"aws_zts_setup/#edit-aws_initsh","text":"Update the bucket names in athenz/aws-setup/zts-setup/build/bin/aws_init.sh by editing the below lines: export ZTS_DATA_BUCKET_NAME=\"<The name of your zts data bucket>\" export ZTS_AUDIT_LOG_BUCKET_NAME=\"<The name of your zms audit data bucket>\" export ZTS_URL=\"<zts_url>\" export ZMS_URL=\"\"<zms_url>\" export RDS_MASTER=\"<zts-rds-databasecluster-endpoint>\" The other variables are for trust store & key store setup. We recommend to use the defaults but if you change then update the corresponding values in athenz.properties file discussed later.","title":"Edit aws_init.sh"},{"location":"aws_zts_setup/#edit-the-properties-file","text":"","title":"Edit the properties file"},{"location":"aws_zts_setup/#database-access","text":"Modify the following settings in zts.properties file located at athenz/aws-setup/zts-setup/build/conf/zts.properties if RDS username & RDS password filename (stored on S3) are different from defaults suggested above. athenz.zts.cert_record_store_factory_class=com.yahoo.athenz.zts.cert.impl.JDBCCertRecordStoreFactory athenz.zts.cert_jdbc_user=athenz-zts athenz.zts.cert_jdbc_password=db_user_data","title":"Database Access"},{"location":"aws_zts_setup/#athenz-ca-x509-certificate-issuing","text":"For authenticating services using X509 certificates, ZTS Servers expect the configured cert signer factory class names in its athenz.zts.cert_signer_factory_class system property. Self Cert Signer com.yahoo.athenz.zts.cert.impl.SelfCertSignerFactory is a sample implementation of cert Signer we have for development environment. You can use SelfCertSigner or have your implementation of Cert Signer. If you are using self cert signer make the below changes: The self cert signer key you uploaded in above steps has to be downloaded on the box. The default is to download it to /opt/zts/conf/self_cert_signer_key . If you using the defaults, uncomment the below lines in initialize_zts.sh # echo \"Downloading self cert signer key\" # aws s3 cp s3://$bucket_name/self_cert_signer_key /opt/zts/conf/self_cert_signer_key Edit the below properties in zts.properties file accordingly: # athenz.zts.self_signer_private_key_fname=/opt/zts/conf/self_cert_signer_key # athenz.zts.self_signer_private_key_password= # athenz.zts.self_signer_cert_dn=C=US,ST=CA,L=Sunnyvale,O=Oath,OU=Athenz,CN=zts.aws.oath.cloud","title":"Athenz CA X.509 Certificate Issuing"},{"location":"aws_zts_setup/#truststore-and-keystore-settings","text":"If you modified the truststore and keystore paths and password in the aws_init.sh file then change the below settings in athenz.properties file located at athenz/aws-setup/zts-setup/build/conf/athenz.properties : athenz.ssl_key_store=/opt/zts/conf/zts_keystore.pkcs12 //path to the keystore file that contains the server's certificate athenz.ssl_key_store_type=PKCS12 //specifies the type for the keystore specified in the athenz.ssl_key_store_password=service_x509_store_pwd //S3 bucket key name for Password for the keystore specified in the athenz.ssl_key_store property athenz.ssl_trust_store=/opt/zts/conf/zts_truststore.jks //path to the trust store file that contains CA certificates trusted by this Jetty instance athenz.ssl_trust_store_type=JKS //specifies the type for the truststore specified athenz.ssl_trust_store_password=service_x509_store_pwd //password for the truststore Update the following in zts.properties file: athenz.zts.ssl_key_store=/opt/zts/conf/zts_keystore.pkcs12 //path to the keystore file that contains the server's certificate athenz.zts.ssl_key_store_type=PKCS12 //specifies the type for the keystore specified in the athenz.zts.ssl_key_store_password=service_x509_store_pwd //S3 bucket key name for Password for the keystore specified in the athenz.ssl_key_store property athenz.zts.ssl_trust_store=/opt/zts/conf/zts_truststore.jks //path to the trust store file that contains CA certificates trusted by this Jetty instance athenz.zts.ssl_trust_store_type=JKS //specifies the type for the truststore specified athenz.zts.ssl_trust_store_password=service_x509_store_pwd //password for the truststore","title":"Truststore and Keystore Settings"},{"location":"aws_zts_setup/#packer","text":"","title":"Packer"},{"location":"aws_zts_setup/#packer-vpc-setup","text":"Packer VPC was set during zms setup, update packer.json accordingly: { \"subnet_id\":\"<packer_public_subnet_id>\", \"vpc_id\": \"<vpc_id>\", \"aws_region\": \"<aws-region where you created the resources>\", \"aws_ami_name\": \"zts-aws-cd-image\", \"aws_access_key\": \"{{env `AWS_ACCESS_KEY_ID`}}\", \"aws_secret_key\": \"{{env `AWS_SECRET_ACCESS_KEY`}}\", \"aws_session_token\": \"{{env `AWS_SESSION_TOKEN`}}\", \"ssh_keypair_name\":\"<EC2_SSH_Key_Name>\", \"ssh_private_key_file\":\"<PATH_TO_SSH_KEYPAIR>\", \"source_ami\": \"ami-02c71d7a\" }","title":"Packer VPC Setup"},{"location":"aws_zts_setup/#build-zts-image","text":"Build the image with packer using the following command cd /aws-setup/zts-setup packer build packer/aws/packer.json","title":"Build ZTS image"},{"location":"aws_zts_setup/#deploy-zts","text":"Run cloudformation template to bring up the zts-instances in 2 availability zones. The imageID parameter should be set to the image created in above step. The ZTS Server is now up and running.","title":"Deploy ZTS"},{"location":"capabilities/","text":"Athenz Capabilities \u00b6 OAuth2 Access Token Support \u00b6 Athenz supports the OAuth2 standard by enabling the generation of Access Tokens. Access tokens represent an authoritative statement that a given principal may assume some number of roles in a domain for a limited period. They are signed to prevent tampering. For more information, please refer to Obtaining OAuth2 Access Tokens Notifications \u00b6 Athenz can be configured to send Email Notifications. These notifications can remind users that there are tasks that require their attention such as approving a member's request to join a role, warn them on a certificate that is close to expiration, and even alert them on Athenz health when needed. To enable notifications, refer to Email Notifications Templates \u00b6 Templates are a collection of predefined roles, policies, and services that can be applied to a domain. For more information, please refer to Athenz Templates Audit features \u00b6 Athenz maintains a history of all the changes that were executed in a domain by their respective administrators. The audit log can be used whenever the administrator wants to find out who made a specific change. The query can be filtered for a specific role in a given period. AWS service identity certificate support \u00b6 The term service within Athenz is more generic than a traditional service. A service identity could represent a command, job, daemon, workflow, as well as both a client and a server. EC2 instances in AWS are no exception. They too can be bootstrapped to Athenz which allows them to access other Athenz enabled services while providing services for identities with valid authorization. For more information, please refer to Athenz Service Identity X.509 Certificate for AWS EC2 instances AWS temp credentials support \u00b6 This feature allows any service to obtain temporary session credentials for a role defined in AWS IAM to carry out operations against AWS Services. For more information, please refer to AWS Temp Credentials","title":"Athenz Capabilities"},{"location":"capabilities/#athenz-capabilities","text":"","title":"Athenz Capabilities"},{"location":"capabilities/#oauth2-access-token-support","text":"Athenz supports the OAuth2 standard by enabling the generation of Access Tokens. Access tokens represent an authoritative statement that a given principal may assume some number of roles in a domain for a limited period. They are signed to prevent tampering. For more information, please refer to Obtaining OAuth2 Access Tokens","title":"OAuth2 Access Token Support"},{"location":"capabilities/#notifications","text":"Athenz can be configured to send Email Notifications. These notifications can remind users that there are tasks that require their attention such as approving a member's request to join a role, warn them on a certificate that is close to expiration, and even alert them on Athenz health when needed. To enable notifications, refer to Email Notifications","title":"Notifications"},{"location":"capabilities/#templates","text":"Templates are a collection of predefined roles, policies, and services that can be applied to a domain. For more information, please refer to Athenz Templates","title":"Templates"},{"location":"capabilities/#audit-features","text":"Athenz maintains a history of all the changes that were executed in a domain by their respective administrators. The audit log can be used whenever the administrator wants to find out who made a specific change. The query can be filtered for a specific role in a given period.","title":"Audit features"},{"location":"capabilities/#aws-service-identity-certificate-support","text":"The term service within Athenz is more generic than a traditional service. A service identity could represent a command, job, daemon, workflow, as well as both a client and a server. EC2 instances in AWS are no exception. They too can be bootstrapped to Athenz which allows them to access other Athenz enabled services while providing services for identities with valid authorization. For more information, please refer to Athenz Service Identity X.509 Certificate for AWS EC2 instances","title":"AWS service identity certificate support"},{"location":"capabilities/#aws-temp-credentials-support","text":"This feature allows any service to obtain temporary session credentials for a role defined in AWS IAM to carry out operations against AWS Services. For more information, please refer to AWS Temp Credentials","title":"AWS temp credentials support"},{"location":"cent_authz_flow/","text":"In this section, we're going to examine the centralized authorization flow. Subsystems \u00b6 Before we go into the details of the authorization flow, it's important to understand the subsystems involved. The authorization (AuthZ) system shown in the figure below consists of several logical subsystems, which we will elaborate on in the following section. ZMS (AuthZ Management System) \u00b6 ZMS is where domains, roles, and policies are defined. This is Athenz's centralized authorization system and is likely part of a larger management system. In addition to allowing CRUD operations on the basic entities, ZMS provides an API to replicate the entities, per domain, to ZTS. It also can directly support the access check, both for internal management system checks, as well as a simple centralized deployment. ZMS is the source of truth for domains, roles, and policies for centralized authorization. ZMS supports a centralized call to check if a principal has access to a resource. Because ZMS supports service identities, ZMS can authenticate services. For centralized authorization, ZMS may be the only Athenz subsystem that you need to interact with. SIA (Service Identity Agent) \u00b6 SIA is required for authenticating existing unmanaged services. Any service that launches other services should integrate SIA (or an equivalent system). To confirm a service's identity, SIA communicates with ZTS. Centralized Access Control \u00b6 A traditional centralized mechanism works as expected for services that are not dealing with the decentralized authorization: the server with resources can simply ask the ZMS directly about access, passing its credentials (X.509 Cert) and resource/action information for a given principal to get a simple boolean answer. In this model, the Athenz Management Service is the only component that needs to be deployed and managed within your environment. This does not scale well enough for data-plane access, since a central service must be consulted, but requires no local installation of other components and related storage and synchronization logic, so it is suitable for human interaction and control-plane provisioning uses where the number of requests processed by the server is small and the latency for authorization checks is not important. Principals \u00b6 In Athenz, actors that can assume a role are called principals. Principals can be users or services, and users can be those looking for resources from a service or use the ZMS management console. The user or service must be configured with Athenz CA certificates and require mutual client authentication to accept and validate the service's X.509 certificate. Once validated, it can extract the CN field from the certificate would be the service's identity. Finally, just like the user case, it which would perform an identical check with ZMS to confirm access passing the action, resource and service name to ZMS.","title":"Centralized Authorization Flow"},{"location":"cent_authz_flow/#subsystems","text":"Before we go into the details of the authorization flow, it's important to understand the subsystems involved. The authorization (AuthZ) system shown in the figure below consists of several logical subsystems, which we will elaborate on in the following section.","title":"Subsystems"},{"location":"cent_authz_flow/#zms-authz-management-system","text":"ZMS is where domains, roles, and policies are defined. This is Athenz's centralized authorization system and is likely part of a larger management system. In addition to allowing CRUD operations on the basic entities, ZMS provides an API to replicate the entities, per domain, to ZTS. It also can directly support the access check, both for internal management system checks, as well as a simple centralized deployment. ZMS is the source of truth for domains, roles, and policies for centralized authorization. ZMS supports a centralized call to check if a principal has access to a resource. Because ZMS supports service identities, ZMS can authenticate services. For centralized authorization, ZMS may be the only Athenz subsystem that you need to interact with.","title":"ZMS (AuthZ Management System)"},{"location":"cent_authz_flow/#sia-service-identity-agent","text":"SIA is required for authenticating existing unmanaged services. Any service that launches other services should integrate SIA (or an equivalent system). To confirm a service's identity, SIA communicates with ZTS.","title":"SIA (Service Identity Agent)"},{"location":"cent_authz_flow/#centralized-access-control","text":"A traditional centralized mechanism works as expected for services that are not dealing with the decentralized authorization: the server with resources can simply ask the ZMS directly about access, passing its credentials (X.509 Cert) and resource/action information for a given principal to get a simple boolean answer. In this model, the Athenz Management Service is the only component that needs to be deployed and managed within your environment. This does not scale well enough for data-plane access, since a central service must be consulted, but requires no local installation of other components and related storage and synchronization logic, so it is suitable for human interaction and control-plane provisioning uses where the number of requests processed by the server is small and the latency for authorization checks is not important.","title":"Centralized Access Control"},{"location":"cent_authz_flow/#principals","text":"In Athenz, actors that can assume a role are called principals. Principals can be users or services, and users can be those looking for resources from a service or use the ZMS management console. The user or service must be configured with Athenz CA certificates and require mutual client authentication to accept and validate the service's X.509 certificate. Once validated, it can extract the CN field from the certificate would be the service's identity. Finally, just like the user case, it which would perform an identical check with ZMS to confirm access passing the action, resource and service name to ZMS.","title":"Principals"},{"location":"cert_signer/","text":"Certificate Signer \u00b6 Cert Signer Interfaces Configuration Provided Implementations Self Cert Signer HTTP Cert Signer Athenz supports service authentication with X.509 certificates. The services receive X509 certificates from ZTS which requires a cert signer implementation to sign and issue X509 certificates for Athenz Services. This feature, commonly referred as Copper Argos, is described in the following section . Cert Signer Interfaces \u00b6 For ZTS servers to issue X509 certificates, the following two interfaces must be implemented: CertSignerFactory . The job of the CertSignerFactory class is to implement a single create() method which returns an instance of CertSigner class implementation. CertSigner . This class implements six methods listed below: generateX509Certificate(): This method generates a signed X509 Certificate based on the given request. It takes three parameters csr (Certificate request) , requested key usage keyUsage (null for both server and client, otherwise specified usage type: server or client) and expiryTime which specifies requested certificate expiration time in minutes and returns a X509 Certificate in PEM format getCACertificate(): This method is to retrieve the CA certificate in PEM format that will be returned along with the x509 certificate back to the client. generateSSHCertificate(): This method is to generate a SSH Certificate based on the given request. getSSHCertificate(): This method is to retrieve the SSH Signer certificate for the given type. getMaxCertExpiryTimeMins(): This method is to retrieve the certificate max expiry time supported by the given signer. close(): This method is for closing the certSigner signer object and release all allocated resources During server startup, ZTS servers will load the configured cert signer factory class and invoke the create method. Then it will use the CertSigner object returned to issue X509 certificates to requesting services. Configuration \u00b6 ZTS Servers expect the configured cert signer factory class name in its athenz.zts.cert_signer_factory_class system property. For example, -Dathenz.zts.cert_signer_factory_class=com.yahoo.athenz.zts.cert.impl.HttpCertSignerFactory If you're installing and running Athenz services using the binary packages provided, you can configure the cert signer factory class in the conf/zts_server/zts.properties file for ZTS server: athenz.zts.cert_signer_factory_class=com.yahoo.athenz.zts.cert.impl.HttpCertSignerFactory Provided Implementations \u00b6 Here is the list of Athenz provided certificate signer implementations with a brief description of each one. Self Cert Signer \u00b6 Class: com.yahoo.athenz.zts.cert.impl.SelfCertSignerFactory This factory class creates and returns an object of SelfCertSigner class com.yahoo.athenz.zts.cert.impl.SelfCertSignerFactory The private key file name, private key password and the DN for self signer can be configured by using the following system properties: Key File: athenz.zts.self_signer_private_key_fname Key password: athenz.zts.self_signer_private_key_password DN: athenz.zts.self_signer_cert_dn The key file must be a PEM encoded either RSA or EC private key. Http Cert Signer \u00b6 Class: com.yahoo.athenz.zts.cert.impl.HttpCertSignerFactory This factory class creates and returns a object of HttpCertSigner class com.yahoo.athenz.zts.cert.impl.SelfCertSignerFactory This signer assumes you have a certificate singing daemon that implements POST/GET REST /x509 and /ssh endpoints to sign and return x.509 certificates. The base uri of signer service and other settings can be configured by using the following system properties: Base Uri of Cert Signer Service: athenz.zts.certsign_base_uri Connect Timeout: athenz.zts.certsign_connect_timeout This setting specifies in seconds the connect timeout. We are setting it to 10. Request Timeout: athenz.zts.certsign_request_timeout This setting specifies in seconds the request timeout. We are setting it to 5. Retry count: athenz.zts.certsign_retry_count This setting specifies the number of times the request should be retried if it's not completed with the requested timeout value. We are setting it to 3.","title":"Certificate Signer"},{"location":"cert_signer/#certificate-signer","text":"Cert Signer Interfaces Configuration Provided Implementations Self Cert Signer HTTP Cert Signer Athenz supports service authentication with X.509 certificates. The services receive X509 certificates from ZTS which requires a cert signer implementation to sign and issue X509 certificates for Athenz Services. This feature, commonly referred as Copper Argos, is described in the following section .","title":"Certificate Signer"},{"location":"cert_signer/#cert-signer-interfaces","text":"For ZTS servers to issue X509 certificates, the following two interfaces must be implemented: CertSignerFactory . The job of the CertSignerFactory class is to implement a single create() method which returns an instance of CertSigner class implementation. CertSigner . This class implements six methods listed below: generateX509Certificate(): This method generates a signed X509 Certificate based on the given request. It takes three parameters csr (Certificate request) , requested key usage keyUsage (null for both server and client, otherwise specified usage type: server or client) and expiryTime which specifies requested certificate expiration time in minutes and returns a X509 Certificate in PEM format getCACertificate(): This method is to retrieve the CA certificate in PEM format that will be returned along with the x509 certificate back to the client. generateSSHCertificate(): This method is to generate a SSH Certificate based on the given request. getSSHCertificate(): This method is to retrieve the SSH Signer certificate for the given type. getMaxCertExpiryTimeMins(): This method is to retrieve the certificate max expiry time supported by the given signer. close(): This method is for closing the certSigner signer object and release all allocated resources During server startup, ZTS servers will load the configured cert signer factory class and invoke the create method. Then it will use the CertSigner object returned to issue X509 certificates to requesting services.","title":"Cert Signer Interfaces"},{"location":"cert_signer/#configuration","text":"ZTS Servers expect the configured cert signer factory class name in its athenz.zts.cert_signer_factory_class system property. For example, -Dathenz.zts.cert_signer_factory_class=com.yahoo.athenz.zts.cert.impl.HttpCertSignerFactory If you're installing and running Athenz services using the binary packages provided, you can configure the cert signer factory class in the conf/zts_server/zts.properties file for ZTS server: athenz.zts.cert_signer_factory_class=com.yahoo.athenz.zts.cert.impl.HttpCertSignerFactory","title":"Configuration"},{"location":"cert_signer/#provided-implementations","text":"Here is the list of Athenz provided certificate signer implementations with a brief description of each one.","title":"Provided Implementations"},{"location":"cert_signer/#self-cert-signer","text":"Class: com.yahoo.athenz.zts.cert.impl.SelfCertSignerFactory This factory class creates and returns an object of SelfCertSigner class com.yahoo.athenz.zts.cert.impl.SelfCertSignerFactory The private key file name, private key password and the DN for self signer can be configured by using the following system properties: Key File: athenz.zts.self_signer_private_key_fname Key password: athenz.zts.self_signer_private_key_password DN: athenz.zts.self_signer_cert_dn The key file must be a PEM encoded either RSA or EC private key.","title":"Self Cert Signer"},{"location":"cert_signer/#http-cert-signer","text":"Class: com.yahoo.athenz.zts.cert.impl.HttpCertSignerFactory This factory class creates and returns a object of HttpCertSigner class com.yahoo.athenz.zts.cert.impl.SelfCertSignerFactory This signer assumes you have a certificate singing daemon that implements POST/GET REST /x509 and /ssh endpoints to sign and return x.509 certificates. The base uri of signer service and other settings can be configured by using the following system properties: Base Uri of Cert Signer Service: athenz.zts.certsign_base_uri Connect Timeout: athenz.zts.certsign_connect_timeout This setting specifies in seconds the connect timeout. We are setting it to 10. Request Timeout: athenz.zts.certsign_request_timeout This setting specifies in seconds the request timeout. We are setting it to 5. Retry count: athenz.zts.certsign_retry_count This setting specifies the number of times the request should be retried if it's not completed with the requested timeout value. We are setting it to 3.","title":"Http Cert Signer"},{"location":"client_side_x509_credentials/","text":"In order to contact Athenz Services (ZMS/ZTS) or other Athenz Enabled services, your client needs to establish a HTTPS connection using its Athenz issued x.509 certificate. This section contains some examples how to utilize Athenz x.509 certificates for service authentication Table of Contents \u00b6 Java ZMS Client ZTS Client HTTPSUrlConnection Client Java \u00b6 In the following set of examples we're going to assume that the service has already obtained its x.509 certificate from Athenz. ZMS Client \u00b6 We're going to use our ZMS Java client to communicate with ZMS running in AWS to carry out a centralized access check to see if principal user.john has read access to sports:nhl-scores resource. First we need to update our Java project pom.xml file to indicate our dependency on the ZMS Java Client and Certificate Refresh Helper libraries <dependencies> <dependency> <groupId>com.yahoo.athenz</groupId> <artifactId>athenz-zms-java-client</artifactId> <version>VERSION-NUMBER</version> </dependency> <dependency> <groupId>com.yahoo.athenz</groupId> <artifactId>athenz-cert-refresher</artifactId> <version>VERSION-NUMBER</version> </dependency> </dependencies> Next, let's assume the Athenz identity for the service is sports.api and SIA running on this host has already generated the private key for the service and retrieved the X.509 certificate from ZTS Server: / var / lib / sia / keys / sports . api . key . pem / var / lib / sia / certs / sports . api . cert . pem The ZMS server is running with a public X.509 certificate so we're going to use the standard jdk truststore for our connection which has a default password of changeit . import javax.net.ssl.SSLContext ; import com.oath.auth.KeyRefresher ; import com.oath.auth.Utils ; final String zmsUrl = \"https://zms-address/zms/v1\" ; final String keyPath = \"/var/lib/sia/keys/sports.api.key.pem\" ; final String certPath = \"/var/lib/sia/certs/sports.api.cert.pem\" ; final String trustStorePath = javaHome + \"/jre/lib/security/cacerts\" ; final String trustStorePassword = \"changeit\" ; try { // Create our SSL Context object based on our private key and // certificate and jdk truststore KeyRefresher keyRefresher = Utils . generateKeyRefresher ( trustStorePath , trustStorePassword , certPath , keyPath ); // Default refresh period is every hour. keyRefresher . startup (); // Can be adjusted to use other values in milliseconds. However, // only one keyRefresher.startup call must be present. // keyRefresher.startup(900000); SSLContext sslContext = Utils . buildSSLContext ( keyRefresher . getKeyManagerProxy (), keyRefresher . getTrustManagerProxy ()); // create our zms client and execute request try ( ZMSClient zmsClient = new ZMSClient ( zmsUrl , sslContext )) { try { Access access = zmsClient . getAccess ( \"read\" , \"sports:nhl-scores\" , null , \"user.john\" ); System . out . println ( \"Access: \" + access . getGranted ()); } catch ( ZMSClientException ex ) { LOGGER . error ( \"Unable to carry out access check: {}\" , ex . getMessage ()); return ; } } } catch ( Exception ex ) { LOGGER . error ( \"Unable to process request\" , ex ); return ; } ZTS Client \u00b6 We're going to use our ZTS Java client to communicate with ZTS Server running in AWS to retrieve the public key for the weather.api service with key id weather.api.key . First we need to update our Java project pom.xml file to indicate our dependency on the ZTS Java Client and Certificate Refresh Helper libraries <dependencies> <dependency> <groupId>com.yahoo.athenz</groupId> <artifactId>athenz-zts-java-client</artifactId> <version>VERSION-NUMBER</version> </dependency> <dependency> <groupId>com.yahoo.athenz</groupId> <artifactId>athenz-cert-refresher</artifactId> <version>VERSION-NUMBER</version> </dependency> </dependencies> Next, let's assume the Athenz identity for the service is sports.api and SIA running on this host has already generated the private key for the service and retrieved the X.509 certificate from ZTS Server: / var / lib / sia / keys / sports . api . key . pem / var / lib / sia / certs / sports . api . cert . pem The ZTS server is running with a public X.509 certificate so we're going to use the standard jdk truststore for our connection which has a default password of changeit . import javax.net.ssl.SSLContext ; import com.oath.auth.KeyRefresher ; import com.oath.auth.Utils ; final String ztsUrl = \"https://zts-address/zts/v1\" ; final String keyPath = \"/var/lib/sia/keys/sports.api.key.pem\" ; final String certPath = \"/var/lib/sia/certs/sports.api.cert.pem\" ; final String trustStorePath = javaHome + \"/jre/lib/security/cacerts\" ; final String trustStorePassword = \"changeit\" ; try { // Create our SSL Context object based on our private key and // certificate and jdk truststore KeyRefresher keyRefresher = Utils . generateKeyRefresher ( trustStorePath , trustStorePassword , certPath , keyPath ); // Default refresh period is every hour. keyRefresher . startup (); // Can be adjusted to use other values in milliseconds. //keyRefresher.startup(900000); SSLContext sslContext = Utils . buildSSLContext ( keyRefresher . getKeyManagerProxy (), keyRefresher . getTrustManagerProxy ()); // create our zts client and execute request try ( ZTSClient ztsClient = new ZTSClient ( ztsUrl , sslContext )) { try { PublicKeyEntry publicKey = ztsClient . getPublicKeyEntry ( \"weather\" , \"api\" , \"weather.api.key\" ); System . out . println ( \"PublicKey: \" + publicKey . getKey ()); } catch ( ZTSClientException ex ) { LOGGER . error ( \"Unable to retrieve public key: {}\" , ex . getMessage ()); return ; } } } catch ( Exception ex ) { LOGGER . error ( \"Unable to process request\" , ex ); return ; } ** Important ** During the shutdown of the application, ZTSClient.cancelPrefetch() must be called to stop the timer thread that automatically fetches and refreshes any cached tokens in the ZTS Client. Apache HTTPClient \u00b6 This example demonstrates how to correctly set up Apache HTTPClient for mutual TLS with persistent connections and connection pooling, with automatic certificate refreshing. import com.oath.auth.KeyRefresher ; import com.oath.auth.Utils ; import org.apache.http.HttpResponse ; import org.apache.http.client.methods.HttpGet ; import org.apache.http.impl.client.CloseableHttpClient ; import org.apache.http.impl.client.HttpClients ; import org.apache.http.impl.client.NoopUserTokenHandler ; import org.apache.http.util.EntityUtils ; import java.io.IOException ; import java.net.URI ; import javax.net.ssl.SSLContext ; public class Example { private final KeyRefresher keyRefresher ; private final CloseableHttpClient httpClient ; // These parameters normally point to files generated by SIA on managed hosts public Example ( String trustStorePath , String trustStorePassword , String certPath , String keyPath ) throws Exception { // Create a key refresher to automatically reload key/cert when updated by SIA this . keyRefresher = Utils . generateKeyRefresher ( trustStorePath , trustStorePassword , certPath , keyPath ); keyRefresher . startup (); // Create TLS context // Note that this may create a TLS 1.3 context when supported SSLContext sslContext = Utils . buildSSLContext ( keyRefresher . getKeyManagerProxy (), keyRefresher . getTrustManagerProxy ()); // Create the actual HTTP client this . httpClient = HttpClients . custom () // Use the context that has our keys and trusted CAs . setSSLContext ( sslContext ) // Enable connection pooling - when mutual TLS used this gets disabled by default! . setUserTokenHandler ( NoopUserTokenHandler . INSTANCE ) // You can set more options here as desired, for example number of connections to use . build (); } public void callSomeService ( URI uri ) { HttpResponse response = null ; try { HttpGet request = new HttpGet ( uri ); response = httpClient . execute ( request ); // Do something with the response System . err . println ( \"Got response: \" + response . getStatusLine (). getStatusCode ()); } catch ( IOException e ) { // Handle connection level errors here e . printStackTrace (); } finally { // Ensure the entire request entity is consumed to release the connection for reuse // Note that calling CloseableHttpResponse.close() will make the connection ineligible // for reuse so it must be avoided if ( response != null ) { EntityUtils . consumeQuietly ( response . getEntity ()); } } } } HTTPSUrlConnection Client \u00b6 Note: This method does not support connection pooling and is only included as a demonstration, production code should use fully featured HTTP client. We're going to use a HTTPSUrlConnection client to communicate with an HTTPS Server running to retrieve some data for a given url. First we need to update our Java project pom.xml file to indicate our dependency on the Certificate Refresh Helper library. <dependencies> <dependency> <groupId>com.yahoo.athenz</groupId> <artifactId>athenz-cert-refresher</artifactId> <version>VERSION-NUMBER</version> </dependency> </dependencies> Next, let's assume the Athenz identity for the service is sports.api and SIA running on this host has already generated the private key for the service and retrieved the X.509 certificate from ZTS Server: / var / lib / sia / keys / sports . api . key . pem / var / lib / sia / certs / sports . api . cert . pem The HTTPS server is running with an Athenz issued certificate so our truststore must include the Athenz CA certificates. For the following example, the truststore containing the Athenz CA certificates will be located at /home/example/athenz_certificate_bundle.jks with a default password of changeit . import javax.net.ssl.SSLContext ; import com.oath.auth.KeyRefresher ; import com.oath.auth.Utils ; final String keyPath = \"/var/lib/sia/keys/sports.api.key.pem\" ; final String certPath = \"/var/lib/sia/certs/sports.api.cert.pem\" ; final String trustStorePath = \"/home/example/athenz_certificate_bundle.jks\" ; final String trustStorePassword = \"changeit\" ; try { KeyRefresher keyRefresher = Utils . generateKeyRefresher ( trustStorePath , trustStorePassword , certPath , keyPath ); // Default refresh period is every hour. keyRefresher . startup (); // Can be adjusted to use other values in milliseconds. //keyRefresher.startup(900000); SSLContext sslContext = Utils . buildSSLContext ( keyRefresher . getKeyManagerProxy (), keyRefresher . getTrustManagerProxy ()); HttpsURLConnection . setDefaultSSLSocketFactory ( sslContext . getSocketFactory ()); HttpsURLConnection con = ( HttpsURLConnection ) new URL ( url ). openConnection (); con . setReadTimeout ( 15000 ); con . setDoOutput ( true ); con . connect (); try ( BufferedReader br = new BufferedReader ( new InputStreamReader ( con . getInputStream ()))) { StringBuilder sb = new StringBuilder (); String line ; while (( line = br . readLine ()) != null ) { sb . append ( line ); } System . out . println ( \"Data output: \" + sb . toString ()); } } catch ( Exception ex ) { LOGGER . error ( \"Unable to process request\" , ex ); return ; }","title":"Client Side Service Identity Authentication"},{"location":"client_side_x509_credentials/#table-of-contents","text":"Java ZMS Client ZTS Client HTTPSUrlConnection Client","title":"Table of Contents"},{"location":"client_side_x509_credentials/#java","text":"In the following set of examples we're going to assume that the service has already obtained its x.509 certificate from Athenz.","title":"Java"},{"location":"client_side_x509_credentials/#zms-client","text":"We're going to use our ZMS Java client to communicate with ZMS running in AWS to carry out a centralized access check to see if principal user.john has read access to sports:nhl-scores resource. First we need to update our Java project pom.xml file to indicate our dependency on the ZMS Java Client and Certificate Refresh Helper libraries <dependencies> <dependency> <groupId>com.yahoo.athenz</groupId> <artifactId>athenz-zms-java-client</artifactId> <version>VERSION-NUMBER</version> </dependency> <dependency> <groupId>com.yahoo.athenz</groupId> <artifactId>athenz-cert-refresher</artifactId> <version>VERSION-NUMBER</version> </dependency> </dependencies> Next, let's assume the Athenz identity for the service is sports.api and SIA running on this host has already generated the private key for the service and retrieved the X.509 certificate from ZTS Server: / var / lib / sia / keys / sports . api . key . pem / var / lib / sia / certs / sports . api . cert . pem The ZMS server is running with a public X.509 certificate so we're going to use the standard jdk truststore for our connection which has a default password of changeit . import javax.net.ssl.SSLContext ; import com.oath.auth.KeyRefresher ; import com.oath.auth.Utils ; final String zmsUrl = \"https://zms-address/zms/v1\" ; final String keyPath = \"/var/lib/sia/keys/sports.api.key.pem\" ; final String certPath = \"/var/lib/sia/certs/sports.api.cert.pem\" ; final String trustStorePath = javaHome + \"/jre/lib/security/cacerts\" ; final String trustStorePassword = \"changeit\" ; try { // Create our SSL Context object based on our private key and // certificate and jdk truststore KeyRefresher keyRefresher = Utils . generateKeyRefresher ( trustStorePath , trustStorePassword , certPath , keyPath ); // Default refresh period is every hour. keyRefresher . startup (); // Can be adjusted to use other values in milliseconds. However, // only one keyRefresher.startup call must be present. // keyRefresher.startup(900000); SSLContext sslContext = Utils . buildSSLContext ( keyRefresher . getKeyManagerProxy (), keyRefresher . getTrustManagerProxy ()); // create our zms client and execute request try ( ZMSClient zmsClient = new ZMSClient ( zmsUrl , sslContext )) { try { Access access = zmsClient . getAccess ( \"read\" , \"sports:nhl-scores\" , null , \"user.john\" ); System . out . println ( \"Access: \" + access . getGranted ()); } catch ( ZMSClientException ex ) { LOGGER . error ( \"Unable to carry out access check: {}\" , ex . getMessage ()); return ; } } } catch ( Exception ex ) { LOGGER . error ( \"Unable to process request\" , ex ); return ; }","title":"ZMS Client"},{"location":"client_side_x509_credentials/#zts-client","text":"We're going to use our ZTS Java client to communicate with ZTS Server running in AWS to retrieve the public key for the weather.api service with key id weather.api.key . First we need to update our Java project pom.xml file to indicate our dependency on the ZTS Java Client and Certificate Refresh Helper libraries <dependencies> <dependency> <groupId>com.yahoo.athenz</groupId> <artifactId>athenz-zts-java-client</artifactId> <version>VERSION-NUMBER</version> </dependency> <dependency> <groupId>com.yahoo.athenz</groupId> <artifactId>athenz-cert-refresher</artifactId> <version>VERSION-NUMBER</version> </dependency> </dependencies> Next, let's assume the Athenz identity for the service is sports.api and SIA running on this host has already generated the private key for the service and retrieved the X.509 certificate from ZTS Server: / var / lib / sia / keys / sports . api . key . pem / var / lib / sia / certs / sports . api . cert . pem The ZTS server is running with a public X.509 certificate so we're going to use the standard jdk truststore for our connection which has a default password of changeit . import javax.net.ssl.SSLContext ; import com.oath.auth.KeyRefresher ; import com.oath.auth.Utils ; final String ztsUrl = \"https://zts-address/zts/v1\" ; final String keyPath = \"/var/lib/sia/keys/sports.api.key.pem\" ; final String certPath = \"/var/lib/sia/certs/sports.api.cert.pem\" ; final String trustStorePath = javaHome + \"/jre/lib/security/cacerts\" ; final String trustStorePassword = \"changeit\" ; try { // Create our SSL Context object based on our private key and // certificate and jdk truststore KeyRefresher keyRefresher = Utils . generateKeyRefresher ( trustStorePath , trustStorePassword , certPath , keyPath ); // Default refresh period is every hour. keyRefresher . startup (); // Can be adjusted to use other values in milliseconds. //keyRefresher.startup(900000); SSLContext sslContext = Utils . buildSSLContext ( keyRefresher . getKeyManagerProxy (), keyRefresher . getTrustManagerProxy ()); // create our zts client and execute request try ( ZTSClient ztsClient = new ZTSClient ( ztsUrl , sslContext )) { try { PublicKeyEntry publicKey = ztsClient . getPublicKeyEntry ( \"weather\" , \"api\" , \"weather.api.key\" ); System . out . println ( \"PublicKey: \" + publicKey . getKey ()); } catch ( ZTSClientException ex ) { LOGGER . error ( \"Unable to retrieve public key: {}\" , ex . getMessage ()); return ; } } } catch ( Exception ex ) { LOGGER . error ( \"Unable to process request\" , ex ); return ; } ** Important ** During the shutdown of the application, ZTSClient.cancelPrefetch() must be called to stop the timer thread that automatically fetches and refreshes any cached tokens in the ZTS Client.","title":"ZTS Client"},{"location":"client_side_x509_credentials/#apache-httpclient","text":"This example demonstrates how to correctly set up Apache HTTPClient for mutual TLS with persistent connections and connection pooling, with automatic certificate refreshing. import com.oath.auth.KeyRefresher ; import com.oath.auth.Utils ; import org.apache.http.HttpResponse ; import org.apache.http.client.methods.HttpGet ; import org.apache.http.impl.client.CloseableHttpClient ; import org.apache.http.impl.client.HttpClients ; import org.apache.http.impl.client.NoopUserTokenHandler ; import org.apache.http.util.EntityUtils ; import java.io.IOException ; import java.net.URI ; import javax.net.ssl.SSLContext ; public class Example { private final KeyRefresher keyRefresher ; private final CloseableHttpClient httpClient ; // These parameters normally point to files generated by SIA on managed hosts public Example ( String trustStorePath , String trustStorePassword , String certPath , String keyPath ) throws Exception { // Create a key refresher to automatically reload key/cert when updated by SIA this . keyRefresher = Utils . generateKeyRefresher ( trustStorePath , trustStorePassword , certPath , keyPath ); keyRefresher . startup (); // Create TLS context // Note that this may create a TLS 1.3 context when supported SSLContext sslContext = Utils . buildSSLContext ( keyRefresher . getKeyManagerProxy (), keyRefresher . getTrustManagerProxy ()); // Create the actual HTTP client this . httpClient = HttpClients . custom () // Use the context that has our keys and trusted CAs . setSSLContext ( sslContext ) // Enable connection pooling - when mutual TLS used this gets disabled by default! . setUserTokenHandler ( NoopUserTokenHandler . INSTANCE ) // You can set more options here as desired, for example number of connections to use . build (); } public void callSomeService ( URI uri ) { HttpResponse response = null ; try { HttpGet request = new HttpGet ( uri ); response = httpClient . execute ( request ); // Do something with the response System . err . println ( \"Got response: \" + response . getStatusLine (). getStatusCode ()); } catch ( IOException e ) { // Handle connection level errors here e . printStackTrace (); } finally { // Ensure the entire request entity is consumed to release the connection for reuse // Note that calling CloseableHttpResponse.close() will make the connection ineligible // for reuse so it must be avoided if ( response != null ) { EntityUtils . consumeQuietly ( response . getEntity ()); } } } }","title":"Apache HTTPClient"},{"location":"client_side_x509_credentials/#httpsurlconnection-client","text":"Note: This method does not support connection pooling and is only included as a demonstration, production code should use fully featured HTTP client. We're going to use a HTTPSUrlConnection client to communicate with an HTTPS Server running to retrieve some data for a given url. First we need to update our Java project pom.xml file to indicate our dependency on the Certificate Refresh Helper library. <dependencies> <dependency> <groupId>com.yahoo.athenz</groupId> <artifactId>athenz-cert-refresher</artifactId> <version>VERSION-NUMBER</version> </dependency> </dependencies> Next, let's assume the Athenz identity for the service is sports.api and SIA running on this host has already generated the private key for the service and retrieved the X.509 certificate from ZTS Server: / var / lib / sia / keys / sports . api . key . pem / var / lib / sia / certs / sports . api . cert . pem The HTTPS server is running with an Athenz issued certificate so our truststore must include the Athenz CA certificates. For the following example, the truststore containing the Athenz CA certificates will be located at /home/example/athenz_certificate_bundle.jks with a default password of changeit . import javax.net.ssl.SSLContext ; import com.oath.auth.KeyRefresher ; import com.oath.auth.Utils ; final String keyPath = \"/var/lib/sia/keys/sports.api.key.pem\" ; final String certPath = \"/var/lib/sia/certs/sports.api.cert.pem\" ; final String trustStorePath = \"/home/example/athenz_certificate_bundle.jks\" ; final String trustStorePassword = \"changeit\" ; try { KeyRefresher keyRefresher = Utils . generateKeyRefresher ( trustStorePath , trustStorePassword , certPath , keyPath ); // Default refresh period is every hour. keyRefresher . startup (); // Can be adjusted to use other values in milliseconds. //keyRefresher.startup(900000); SSLContext sslContext = Utils . buildSSLContext ( keyRefresher . getKeyManagerProxy (), keyRefresher . getTrustManagerProxy ()); HttpsURLConnection . setDefaultSSLSocketFactory ( sslContext . getSocketFactory ()); HttpsURLConnection con = ( HttpsURLConnection ) new URL ( url ). openConnection (); con . setReadTimeout ( 15000 ); con . setDoOutput ( true ); con . connect (); try ( BufferedReader br = new BufferedReader ( new InputStreamReader ( con . getInputStream ()))) { StringBuilder sb = new StringBuilder (); String line ; while (( line = br . readLine ()) != null ) { sb . append ( line ); } System . out . println ( \"Data output: \" + sb . toString ()); } } catch ( Exception ex ) { LOGGER . error ( \"Unable to process request\" , ex ); return ; }","title":"HTTPSUrlConnection Client"},{"location":"code_of_conduct/","text":"Verizon Media Open Source Code of Conduct \u00b6 Summary \u00b6 This Code of Conduct is our way to encourage good behavior and discourage bad behavior in our open source projects. We invite participation from many people to bring different perspectives to our projects. We will do our part to foster a welcoming and professional environment free of harassment. We expect participants to communicate professionally and thoughtfully during their involvement with this project. Participants may lose their good standing by engaging in misconduct. For example: insulting, threatening, or conveying unwelcome sexual content. We ask participants who observe conduct issues to report the incident directly to the project's Response Team at opensource-conduct@verizonmedia.com . Verizon Media will assign a respondent to address the issue. We may remove harassers from this project. This code does not replace the terms of service or acceptable use policies of the websites used to support this project. We acknowledge that participants may be subject to additional conduct terms based on their employment which may govern their online expressions. Details \u00b6 This Code of Conduct makes our expectations of participants in this community explicit. * We forbid harassment and abusive speech within this community. * We request participants to report misconduct to the project\u2019s Response Team. * We urge participants to refrain from using discussion forums to play out a fight. Expected Behaviors \u00b6 We expect participants in this community to conduct themselves professionally. Since our primary mode of communication is text on an online forum (e.g. issues, pull requests, comments, emails, or chats) devoid of vocal tone, gestures, or other context that is often vital to understanding, it is important that participants are attentive to their interaction style. Assume positive intent. We ask community members to assume positive intent on the part of other people\u2019s communications. We may disagree on details, but we expect all suggestions to be supportive of the community goals. Respect participants. We expect occasional disagreements. Open Source projects are learning experiences. Ask, explore, challenge, and then respectfully state if you agree or disagree. If your idea is rejected, be more persuasive not bitter. Welcoming to new members. New members bring new perspectives. Some ask questions that have been addressed before. Kindly point to existing discussions. Everyone is new to every project once. Be kind to beginners. Beginners use open source projects to get experience. They might not be talented coders yet, and projects should not accept poor quality code. But we were all beginners once, and we need to engage kindly. Consider your impact on others. Your work will be used by others, and you depend on the work of others. We expect community members to be considerate and establish a balance their self-interest with communal interest. Use words carefully. We may not understand intent when you say something ironic. Often, people will misinterpret sarcasm in online communications. We ask community members to communicate plainly. Leave with class. When you wish to resign from participating in this project for any reason, you are free to fork the code and create a competitive project. Open Source explicitly allows this. Your exit should not be dramatic or bitter. Unacceptable Behaviors \u00b6 Participants remain in good standing when they do not engage in misconduct or harassment (some examples follow). We do not list all forms of harassment, nor imply some forms of harassment are not worthy of action. Any participant who feels harassed or observes harassment, should report the incident to the Response Team. * Don't be a bigot. Calling out project members by their identity or background in a negative or insulting manner. This includes, but is not limited to, slurs or insinuations related to protected or suspect classes e.g. race, color, citizenship, national origin, political belief, religion, sexual orientation, gender identity and expression, age, size, culture, ethnicity, genetic features, language, profession, national minority status, mental or physical ability. * Don't insult. Insulting remarks about a person\u2019s lifestyle practices. * Don't dox. Revealing private information about other participants without explicit permission. * Don't intimidate. Threats of violence or intimidation of any project member. * Don't creep. Unwanted sexual attention or content unsuited for the subject of this project. * Don't inflame. We ask that victim of harassment not address their grievances in the public forum, as this often intensifies the problem. Report it, and let us address it off-line. * Don't disrupt. Sustained disruptions in a discussion. Reporting Issues \u00b6 If you experience or witness misconduct, or have any other concerns about the conduct of members of this project, please report it by contacting our Response Team at opensource-conduct@verizonmedia.com who will handle your report with discretion. Your report should include: * Your preferred contact information. We cannot process anonymous reports. * Names (real or usernames) of those involved in the incident. * Your account of what occurred, and if the incident is ongoing. Please provide links to or transcripts of the publicly available records (e.g. a mailing list archive or a public IRC logger), so that we can review it. * Any additional information that may be helpful to achieve resolution. After filing a report, a representative will contact you directly to review the incident and ask additional questions. If a member of the Verizon Media Response Team is named in an incident report, that member will be recused from handling your incident. If the complaint originates from a member of the Response Team, it will be addressed by a different member of the Response Team. We will consider reports to be confidential for the purpose of protecting victims of abuse. Scope \u00b6 Verizon Media will assign a Response Team member with admin rights on the project and legal rights on the project copyright. The Response Team is empowered to restrict some privileges to the project as needed. Since this project is governed by an open source license, any participant may fork the code under the terms of the project license. The Response Team\u2019s goal is to preserve the project if possible, and will restrict or remove participation from those who disrupt the project. This code does not replace the terms of service or acceptable use policies that are provided by the websites used to support this community. Nor does this code apply to communications or actions that take place outside of the context of this community. Many participants in this project are also subject to codes of conduct based on their employment. This code is a social-contract that informs participants of our social expectations. It is not a terms of service or legal contract. License and Acknowledgment. \u00b6 This text is shared under the CC-BY-4.0 license . This code is based on a study conducted by the TODO Group of many codes used in the open source community. If you have feedback about this code, contact our Response Team at the address listed above.","title":"Verizon Media Open Source Code of Conduct"},{"location":"code_of_conduct/#verizon-media-open-source-code-of-conduct","text":"","title":"Verizon Media Open Source Code of Conduct"},{"location":"code_of_conduct/#summary","text":"This Code of Conduct is our way to encourage good behavior and discourage bad behavior in our open source projects. We invite participation from many people to bring different perspectives to our projects. We will do our part to foster a welcoming and professional environment free of harassment. We expect participants to communicate professionally and thoughtfully during their involvement with this project. Participants may lose their good standing by engaging in misconduct. For example: insulting, threatening, or conveying unwelcome sexual content. We ask participants who observe conduct issues to report the incident directly to the project's Response Team at opensource-conduct@verizonmedia.com . Verizon Media will assign a respondent to address the issue. We may remove harassers from this project. This code does not replace the terms of service or acceptable use policies of the websites used to support this project. We acknowledge that participants may be subject to additional conduct terms based on their employment which may govern their online expressions.","title":"Summary"},{"location":"code_of_conduct/#details","text":"This Code of Conduct makes our expectations of participants in this community explicit. * We forbid harassment and abusive speech within this community. * We request participants to report misconduct to the project\u2019s Response Team. * We urge participants to refrain from using discussion forums to play out a fight.","title":"Details"},{"location":"code_of_conduct/#expected-behaviors","text":"We expect participants in this community to conduct themselves professionally. Since our primary mode of communication is text on an online forum (e.g. issues, pull requests, comments, emails, or chats) devoid of vocal tone, gestures, or other context that is often vital to understanding, it is important that participants are attentive to their interaction style. Assume positive intent. We ask community members to assume positive intent on the part of other people\u2019s communications. We may disagree on details, but we expect all suggestions to be supportive of the community goals. Respect participants. We expect occasional disagreements. Open Source projects are learning experiences. Ask, explore, challenge, and then respectfully state if you agree or disagree. If your idea is rejected, be more persuasive not bitter. Welcoming to new members. New members bring new perspectives. Some ask questions that have been addressed before. Kindly point to existing discussions. Everyone is new to every project once. Be kind to beginners. Beginners use open source projects to get experience. They might not be talented coders yet, and projects should not accept poor quality code. But we were all beginners once, and we need to engage kindly. Consider your impact on others. Your work will be used by others, and you depend on the work of others. We expect community members to be considerate and establish a balance their self-interest with communal interest. Use words carefully. We may not understand intent when you say something ironic. Often, people will misinterpret sarcasm in online communications. We ask community members to communicate plainly. Leave with class. When you wish to resign from participating in this project for any reason, you are free to fork the code and create a competitive project. Open Source explicitly allows this. Your exit should not be dramatic or bitter.","title":"Expected Behaviors"},{"location":"code_of_conduct/#unacceptable-behaviors","text":"Participants remain in good standing when they do not engage in misconduct or harassment (some examples follow). We do not list all forms of harassment, nor imply some forms of harassment are not worthy of action. Any participant who feels harassed or observes harassment, should report the incident to the Response Team. * Don't be a bigot. Calling out project members by their identity or background in a negative or insulting manner. This includes, but is not limited to, slurs or insinuations related to protected or suspect classes e.g. race, color, citizenship, national origin, political belief, religion, sexual orientation, gender identity and expression, age, size, culture, ethnicity, genetic features, language, profession, national minority status, mental or physical ability. * Don't insult. Insulting remarks about a person\u2019s lifestyle practices. * Don't dox. Revealing private information about other participants without explicit permission. * Don't intimidate. Threats of violence or intimidation of any project member. * Don't creep. Unwanted sexual attention or content unsuited for the subject of this project. * Don't inflame. We ask that victim of harassment not address their grievances in the public forum, as this often intensifies the problem. Report it, and let us address it off-line. * Don't disrupt. Sustained disruptions in a discussion.","title":"Unacceptable Behaviors"},{"location":"code_of_conduct/#reporting-issues","text":"If you experience or witness misconduct, or have any other concerns about the conduct of members of this project, please report it by contacting our Response Team at opensource-conduct@verizonmedia.com who will handle your report with discretion. Your report should include: * Your preferred contact information. We cannot process anonymous reports. * Names (real or usernames) of those involved in the incident. * Your account of what occurred, and if the incident is ongoing. Please provide links to or transcripts of the publicly available records (e.g. a mailing list archive or a public IRC logger), so that we can review it. * Any additional information that may be helpful to achieve resolution. After filing a report, a representative will contact you directly to review the incident and ask additional questions. If a member of the Verizon Media Response Team is named in an incident report, that member will be recused from handling your incident. If the complaint originates from a member of the Response Team, it will be addressed by a different member of the Response Team. We will consider reports to be confidential for the purpose of protecting victims of abuse.","title":"Reporting Issues"},{"location":"code_of_conduct/#scope","text":"Verizon Media will assign a Response Team member with admin rights on the project and legal rights on the project copyright. The Response Team is empowered to restrict some privileges to the project as needed. Since this project is governed by an open source license, any participant may fork the code under the terms of the project license. The Response Team\u2019s goal is to preserve the project if possible, and will restrict or remove participation from those who disrupt the project. This code does not replace the terms of service or acceptable use policies that are provided by the websites used to support this community. Nor does this code apply to communications or actions that take place outside of the context of this community. Many participants in this project are also subject to codes of conduct based on their employment. This code is a social-contract that informs participants of our social expectations. It is not a terms of service or legal contract.","title":"Scope"},{"location":"code_of_conduct/#license-and-acknowledgment","text":"This text is shared under the CC-BY-4.0 license . This code is based on a study conducted by the TODO Group of many codes used in the open source community. If you have feedback about this code, contact our Response Team at the address listed above.","title":"License and Acknowledgment."},{"location":"contributing/","text":"How to contribute \u00b6 First, thanks for taking the time to contribute to our project! There are many ways you can help out. Questions \u00b6 If you have a question that needs an answer, create an issue , and label it as a question. Issues for bugs or feature requests \u00b6 If you encounter any bugs in the code, or want to request a new feature or enhancement, please create an issue to report it. Kindly add a label to indicate what type of issue it is. Contribute Code \u00b6 We welcome your pull requests for bug fixes. To implement something new, please create an issue first so we can discuss it together. Creating a Pull Request Please follow best practices for creating git commits. When your code is ready to be submitted, submit a pull request to begin the code review process. We only seek to accept code that you are authorized to contribute to the project. We have added a pull request template on our projects so that your contributions are made with the following confirmation: I confirm that this contribution is made under the terms of the license found in the root directory of this repository's source tree and that I have the authority necessary to make this contribution on behalf of its copyright owner. Code of Conduct \u00b6 We encourage inclusive and professional interactions on our project. We welcome everyone to open an issue, improve the documentation, report bug or submit a pull request. By participating in this project, you agree to abide by the Verizon Media Code of Conduct . If you feel there is a conduct issue related to this project, please raise it per the Code of Conduct process and we will address it.","title":"How to contribute"},{"location":"contributing/#how-to-contribute","text":"First, thanks for taking the time to contribute to our project! There are many ways you can help out.","title":"How to contribute"},{"location":"contributing/#questions","text":"If you have a question that needs an answer, create an issue , and label it as a question.","title":"Questions"},{"location":"contributing/#issues-for-bugs-or-feature-requests","text":"If you encounter any bugs in the code, or want to request a new feature or enhancement, please create an issue to report it. Kindly add a label to indicate what type of issue it is.","title":"Issues for bugs or feature requests"},{"location":"contributing/#contribute-code","text":"We welcome your pull requests for bug fixes. To implement something new, please create an issue first so we can discuss it together. Creating a Pull Request Please follow best practices for creating git commits. When your code is ready to be submitted, submit a pull request to begin the code review process. We only seek to accept code that you are authorized to contribute to the project. We have added a pull request template on our projects so that your contributions are made with the following confirmation: I confirm that this contribution is made under the terms of the license found in the root directory of this repository's source tree and that I have the authority necessary to make this contribution on behalf of its copyright owner.","title":"Contribute Code"},{"location":"contributing/#code-of-conduct","text":"We encourage inclusive and professional interactions on our project. We welcome everyone to open an issue, improve the documentation, report bug or submit a pull request. By participating in this project, you agree to abide by the Verizon Media Code of Conduct . If you feel there is a conduct issue related to this project, please raise it per the Code of Conduct process and we will address it.","title":"Code of Conduct"},{"location":"copper_argos/","text":"Copper Argos: Athenz Service Identity X.509 Certificates \u00b6 Introduction Copper Argos Provider Service Registration Instance Register Request Instance Refresh Request Conclusion Introduction \u00b6 Rather than having a service administrator generate a key pair and register in Athenz, a new solution called Copper Argos was designed and implemented that would allow the service to be identified by its X.509 certificate issued by Athenz: * Athenz would integrate with a Certificate Signer Daemon that would store its private key in HSM (e.g. AWS CloudHSM) * A Service Identity Agent (SIA) running on an instance would generate a key pair on the instance itself, generate a CSR and send along with its authentication details to ZTS Server to request a certificate for the service. * Once the request is authorized and validated, ZTS would contact Certificate Signer Daemon to mint a certificate for the instance. It would be valid for 30 days and the SIA running on the instance will be responsible to refresh the certificate daily. * The service running on host can use the generated private key and the X.509 certificate it received from ZTS to identify itself to other services running within the organization. Copper Argos \u00b6 Copper Argos is Athenz generalized model for service providers to launch other service identities in an authorized way through a callback-based verification model. The high level requirements for Copper Argos are as follows: 1. Once authorized as a service launcher in Athenz, the Provider will launch the Service by providing it with a signed identity document. 2. SIA installed on the instance during bootstrap process or available as part of the base image that the service is deployed on will create a public/private key pair, generate a certificate request (CSR) and submit the identity document along with its CSR to Athenz ZTS Service. 3. Athenz ZTS Service would carry out 2 authorization checks: a. It verifies that the Provider is authorized to launch services. This prohibits any service act like a provider and attempt to launch other services. b. It verifies that the Service being launched has authorized the Provider as its launcher. This prohibits any authorized Provider to launch any other service without explicit authorization from the tenant service administrator. 4. Athenz ZTS contacts the Provider to validate the signed instance identity document. 5. Once verified, ZTS contacts Certificate Signer Daemon to generate a X.509 Certificate valid for 30 days for the given CSR and returns to instance. 6. SIA is responsible for contacting ZTS daily to refresh the service X.509 certificate. The next several section describe the for Copper Argos requirements in more detail. Provider Service Registration \u00b6 An important part of issuing X.509 certificates is trusting the Provider. The Provider must retrieve a TLS certificate for its own service from Athenz and use that as its Server Certificate. When ZTS contacts Provider Service to validate an instance document, it will require TLS authentication and verify that the certificate the service used for establish secure communication was issued for the expected provider service by ZTS itself. As part of its registration, the provider will also specify a unique registered dns suffix that would be combined with the service identity name and included as a dnsName attribute value in the X.509 certificate. For example, if an instance deployed is going to have an Athenz identity of sports.api and the Provider\u2019s dns suffix is sports.athenz.cloud, then the dnsName attribute in the generated X.509 certificate would be api.sports.sports.athenz.cloud. The official format for the dnsName attribute is . . . Instance Register Request \u00b6 Before a tenant service can be launched by a specific provider and issued a TLS certificate for, the tenant domain administrator must authorize a specific provider service to launch its services. The provider is expected to configure separate launcher services for each data center and/or region it supports. This allows the tenant the flexibility to authorize the provider to launch its service in specific data center/region (e.g. grant launch action to provider sys.auth.aws.us-west-2) or in all supported data centers/regions (e.g. grant launch action to provider sys.auth.aws.*). ZTS does not have knowledge of each provider\u2019s signed instance document details - what\u2019s included, what is the format or what crypto algorithm was used to sign the document. Although each provider is strongly recommended to represent their instance documents as signed Json Web Tokens, ZTS treats it as an opaque string and relies on the registered provider service callback verifier to validate the document. ZTS does impose specific requirements on the X.509 CSR generated by SIA: * The Subject CN in the CSR must be the Athenz service identity name (e.g. sports.api - api service in sports domain) * The CSR must include a SAN dnsName attribute with the format: . . . The provider-dnsname-suffix must be provided by the provider service to the SIA agent. * The provider must specify a unique identifier for the instance within the provider\u2019s namespace (this could be combination of multiple strings - e.g. instance-id.pod-id.cluster-id) and this information must be included in the CSR as another SAN dnsName attribute with the format: \u201c .instanceid.athenz. \u201d. The ZTS server will use this information along with the issued TLS Certificate Serial number to revoke specific instances if they\u2019re compromised (more details are provided in the Instance Refresh Request section below). Instance Refresh Request \u00b6 During instance refresh request, ZTS Server carries out additional checks in addition to contacting provider service for verification of the instance. It will first verify that the connection is using the previous TLS certificate issued for the service and provider and the service authorization policies are still in place. In case a host is compromised and the attacker obtains the private key and ZTS issued X.509 certificate corresponding to that key, Athenz has additional checks in place to prevent the attacker to continuously refresh the certificate. A requirement of Copper Argos is that the CSR that the SIA generates must include a unique id that the provider has assigned to that instance in the X509 v3 SAN Extension dnsName field. Since each certificate is uniquely identified by its Serial Number (defined as BigInteger - e.g. Serial Number: 7e:14:6f:a2:33:b4:49:84:cb:f1:1f:c5:9d:a8:38:cb) generated by Athenz CA, Athenz ZTS can use that information along with instance id to maintain list of all issued certificates for instances with their serial numbers, detect compromised certificate refresh requests and revoke specific hosts from the refresh requests. When processing refresh requests, Athenz ZTS Server: * Validates that the instance id in the CSR matches to the instance id of the certificate that was used for authentication. * Retrieve the Instance ID record from the Certificate Database. This database is updated when the initial and refresh certificates are issued. * The current serial number of the certificate must match to the certificate serial number registered in the instance ID record. The server keeps track of last 2 (current and previous) serial numbers thus allowing a single retry operation in case the client failed to update its local filesystem after receiving refreshed certificates. * So if both the instance and the attacker start using the same instance id for refreshing certificates, Athenz ZTS will detect a mismatch between serial numbers assigned and used in those refresh requests, thus will revoke the instance from refreshing its certificates. Conclusion \u00b6 Copper Argos provides a secure and generic way for service providers to launch other authorized services with Athenz issued service identity X.509 certificates.","title":"Service Identity X.509 Certificates - Copper Argos"},{"location":"copper_argos/#copper-argos-athenz-service-identity-x509-certificates","text":"Introduction Copper Argos Provider Service Registration Instance Register Request Instance Refresh Request Conclusion","title":"Copper Argos: Athenz Service Identity X.509 Certificates"},{"location":"copper_argos/#introduction","text":"Rather than having a service administrator generate a key pair and register in Athenz, a new solution called Copper Argos was designed and implemented that would allow the service to be identified by its X.509 certificate issued by Athenz: * Athenz would integrate with a Certificate Signer Daemon that would store its private key in HSM (e.g. AWS CloudHSM) * A Service Identity Agent (SIA) running on an instance would generate a key pair on the instance itself, generate a CSR and send along with its authentication details to ZTS Server to request a certificate for the service. * Once the request is authorized and validated, ZTS would contact Certificate Signer Daemon to mint a certificate for the instance. It would be valid for 30 days and the SIA running on the instance will be responsible to refresh the certificate daily. * The service running on host can use the generated private key and the X.509 certificate it received from ZTS to identify itself to other services running within the organization.","title":"Introduction"},{"location":"copper_argos/#copper-argos","text":"Copper Argos is Athenz generalized model for service providers to launch other service identities in an authorized way through a callback-based verification model. The high level requirements for Copper Argos are as follows: 1. Once authorized as a service launcher in Athenz, the Provider will launch the Service by providing it with a signed identity document. 2. SIA installed on the instance during bootstrap process or available as part of the base image that the service is deployed on will create a public/private key pair, generate a certificate request (CSR) and submit the identity document along with its CSR to Athenz ZTS Service. 3. Athenz ZTS Service would carry out 2 authorization checks: a. It verifies that the Provider is authorized to launch services. This prohibits any service act like a provider and attempt to launch other services. b. It verifies that the Service being launched has authorized the Provider as its launcher. This prohibits any authorized Provider to launch any other service without explicit authorization from the tenant service administrator. 4. Athenz ZTS contacts the Provider to validate the signed instance identity document. 5. Once verified, ZTS contacts Certificate Signer Daemon to generate a X.509 Certificate valid for 30 days for the given CSR and returns to instance. 6. SIA is responsible for contacting ZTS daily to refresh the service X.509 certificate. The next several section describe the for Copper Argos requirements in more detail.","title":"Copper Argos"},{"location":"copper_argos/#provider-service-registration","text":"An important part of issuing X.509 certificates is trusting the Provider. The Provider must retrieve a TLS certificate for its own service from Athenz and use that as its Server Certificate. When ZTS contacts Provider Service to validate an instance document, it will require TLS authentication and verify that the certificate the service used for establish secure communication was issued for the expected provider service by ZTS itself. As part of its registration, the provider will also specify a unique registered dns suffix that would be combined with the service identity name and included as a dnsName attribute value in the X.509 certificate. For example, if an instance deployed is going to have an Athenz identity of sports.api and the Provider\u2019s dns suffix is sports.athenz.cloud, then the dnsName attribute in the generated X.509 certificate would be api.sports.sports.athenz.cloud. The official format for the dnsName attribute is . . .","title":"Provider Service Registration"},{"location":"copper_argos/#instance-register-request","text":"Before a tenant service can be launched by a specific provider and issued a TLS certificate for, the tenant domain administrator must authorize a specific provider service to launch its services. The provider is expected to configure separate launcher services for each data center and/or region it supports. This allows the tenant the flexibility to authorize the provider to launch its service in specific data center/region (e.g. grant launch action to provider sys.auth.aws.us-west-2) or in all supported data centers/regions (e.g. grant launch action to provider sys.auth.aws.*). ZTS does not have knowledge of each provider\u2019s signed instance document details - what\u2019s included, what is the format or what crypto algorithm was used to sign the document. Although each provider is strongly recommended to represent their instance documents as signed Json Web Tokens, ZTS treats it as an opaque string and relies on the registered provider service callback verifier to validate the document. ZTS does impose specific requirements on the X.509 CSR generated by SIA: * The Subject CN in the CSR must be the Athenz service identity name (e.g. sports.api - api service in sports domain) * The CSR must include a SAN dnsName attribute with the format: . . . The provider-dnsname-suffix must be provided by the provider service to the SIA agent. * The provider must specify a unique identifier for the instance within the provider\u2019s namespace (this could be combination of multiple strings - e.g. instance-id.pod-id.cluster-id) and this information must be included in the CSR as another SAN dnsName attribute with the format: \u201c .instanceid.athenz. \u201d. The ZTS server will use this information along with the issued TLS Certificate Serial number to revoke specific instances if they\u2019re compromised (more details are provided in the Instance Refresh Request section below).","title":"Instance Register Request"},{"location":"copper_argos/#instance-refresh-request","text":"During instance refresh request, ZTS Server carries out additional checks in addition to contacting provider service for verification of the instance. It will first verify that the connection is using the previous TLS certificate issued for the service and provider and the service authorization policies are still in place. In case a host is compromised and the attacker obtains the private key and ZTS issued X.509 certificate corresponding to that key, Athenz has additional checks in place to prevent the attacker to continuously refresh the certificate. A requirement of Copper Argos is that the CSR that the SIA generates must include a unique id that the provider has assigned to that instance in the X509 v3 SAN Extension dnsName field. Since each certificate is uniquely identified by its Serial Number (defined as BigInteger - e.g. Serial Number: 7e:14:6f:a2:33:b4:49:84:cb:f1:1f:c5:9d:a8:38:cb) generated by Athenz CA, Athenz ZTS can use that information along with instance id to maintain list of all issued certificates for instances with their serial numbers, detect compromised certificate refresh requests and revoke specific hosts from the refresh requests. When processing refresh requests, Athenz ZTS Server: * Validates that the instance id in the CSR matches to the instance id of the certificate that was used for authentication. * Retrieve the Instance ID record from the Certificate Database. This database is updated when the initial and refresh certificates are issued. * The current serial number of the certificate must match to the certificate serial number registered in the instance ID record. The server keeps track of last 2 (current and previous) serial numbers thus allowing a single retry operation in case the client failed to update its local filesystem after receiving refreshed certificates. * So if both the instance and the attacker start using the same instance id for refreshing certificates, Athenz ZTS will detect a mismatch between serial numbers assigned and used in those refresh requests, thus will revoke the instance from refreshing its certificates.","title":"Instance Refresh Request"},{"location":"copper_argos/#conclusion","text":"Copper Argos provides a secure and generic way for service providers to launch other authorized services with Athenz issued service identity X.509 certificates.","title":"Conclusion"},{"location":"copper_argos_dev/","text":"Copper Argos: Athenz Service Identity X.509 Certificates Development \u00b6 What is Copper Argos Provider Service Registration Tenant Service Launch Authorization Instance Register Request Instance Refresh Request Instance Revocation Request Athenz RDL Instance Register Request Instance Identity Response Instance Refresh Request Instance Revoke Request Instance Provider RDL Authorization Policies System Providers Provider Authorized DNS Suffix Service Authorized Providers Sample Implementation and Setup Tasks Athenz System Setup Provider Service Implementation and Registration Athenz Authorized Provider Registration Tenant Service Registration Provider Client Implementation What is Copper Argos \u00b6 Copper Argos extends Athenz with generalized model for service providers to launch other identities in an authorized way through a callback-based verification model. With this model each provider is responsible for their instance document verification service instead of embedding that logic inside ZTS. Provider Service Registration \u00b6 Each provider is a registered service identity object in Athenz. As such, the provider domain administrator will create the service identity object in their domain and provide the following attributes using zms-cil utility or the REST API. (Athenz UI does not expose optional service attributes since they\u2019re not commonly used). * Provider Endpoint - A REST API endpoint that implements Provider RDL and ZTS will contact to validate the instance document (ServiceIdentity already has the providerEndpoint attribute) Domain administrator will then need to follow up with the Athenz Team to authorize Provider Service as an Instance Launcher Service in Athenz. The Provider will also specify the DNS suffix that will be used by its tenants. There will be a policy in sys.auth domain that grants launch action to instance resource to the providers role. Once approved, the Athenz System admin will add the provider service identity to the providers role in the sys.auth domain either using zms-cli or Athenz UI. There will be policy granting access to the specified Provider SAN dnsName attribute suffix to the list service provider. Requirements for Provider Service: * It must retrieve a TLS certificate for its service from Athenz and use that as its Service Certificate. * When ZTS Contacts Provider Service to validate an instance document, it will require TLS authentication and verify that the certificate the service used for authentication was issued for the expected provider service by ZTS itself. * ZTS issues TLS certificates valid for 30 days only, so the Provider Service Admin must have the capability to periodically refresh its certificate by requesting a new one from ZTS Server (e.g. daily) and dynamically update its service to use the refreshed certificates. Tenant Service Launch Authorization \u00b6 Before a tenant service can be launched by a specific provider and issued a TLS certificate for, the tenant domain administrator must authorize a specific provider service to launch its services. This will require that a role and policy to be created in the tenant\u2019s domain. For example, if weather.api service wants to authorize athenz.aws provider to launch its services, it will need to create the following policy and role in their domain: * Policy: grant launch to aws-provider on weather:service.api * Role: aws-provider role member: athenz.aws.us-west-2 The change can be carried out with using zms-cli or Athenz UI. Instance Register Request \u00b6 Once the service admin creates the appropriate role and policy in its domain authorizing the provider service to bootstrap its instance, it can submit the launch request to the provider service. The steps of the bootstrap process pertaining Athenz integration would include: As part of the launch request, the admin will specify the Athenz domain and service that should be assigned to the instance. The provider service will generate an instance identity document, sign it with its private key and securely transfer this document along with its signature onto to the bootstrapped host. As part of the bootstrap process or possible as part of the image, the Service Identity Agent (SIA) will also be installed on the host. SIA will generate a public/private key pair on the host, generate a CSR using the newly generated private key. The CSR requirements are as follows: The Subject CN in the CSR must be the Athenz service identity name (e.g. weather.api - api service in weather domain) The CSR must include a SAN dnsName attribute with the format: <service-with-domain>.<provider-dnsname-suffix> . The provider-dnsname-suffix must match the value registered for the provider service. The <service-with-domain> part is left up to to the provider to define what format they want to use (e.g. <service>.<domain> or <service>.<domain-with-dashes> ). ZTS server will pass these hostnames to the provider as entries in the attribute field for validation. The provider must specify a unique identifier for the instance within the provider\u2019s namespace (this could be combination of multiple strings - e.g. instance-id.pod-id.cluster-id) and this information must be included in the CSR as another SAN dnsName attribute with the format: <provider-unique-instance-id>.instanceid.athenz.<provider-dnsname-suffix> . The ZTS server will use this information along with the issued TLS Certificate Serial number to revoke specific instances if they\u2019re compromised. SIA will generate an InstanceRegisterInformation object that will include attestation data (this would include the instance identity document, its signature and other attributes that will be necessary for the provider to validate and confirm the instance register request from ZTS) received from the provider and submit the post request to ZTS Server. ZTS Server will carry out the following authorization and verification checks before contacting provider service: The provider service in the info object has been authorized in Athenz to launch services (policy exists in sys.auth domain). Service specified in the info object (domain.service) has authorized provider service in the info object to launch itself (policy exists in the service\u2019s own domain). The provider service is registered in Athenz, has a providerEndpoint (verified as internal ip address) and providerDnsNameSuffix attributes defined. The cn in the CSR matches to the specific domain and service names. The CSR must include only 2 dnsName attributes with the expected format: <service-with-domain>.<provider-dnsname-suffix> <provider-unique-instance-id>.instanceid.athenz.<provider-dnsname-suffix> ZTS Server will contact Provider service at its configured endpoint and verify that the TLS certificate used for authentication by the provider service matches to the service name and was issued by ZTS server itself. ZTS Server will generate an InstanceConfirmation object and submit the post request to the Provider Service. In the InstanceConfirmation object, ZTS server will include the following entries in the optional attributes map: sanDNS: comma separated list of dnsNames attributes in the CSR - there will only be 2 as defined in 6(e) above sanIP - comma separated list of IP addresses in the CSR if any were specified clientIP - the IP address of the client cloudAccount - domain\u2019s account id if one is configured The Provider Service will be responsible for: Validating Signature Validating the instance id Validating the bootup time is within acceptable time period (e..g 5 mins) Validating hostnames included in the CSR Validating IP addresses (if available) included in the CSR Once ZTS service receives a successful response from the Provider Service, it will submit the CSR to Certsignd to generate a X.509 Certificate ZTS Server will retrieve the Serial number from the Certificate and register the certificate along with instanceid and provider service name in its certificate database. This will be used to monitor refresh certificate operations and, in case of a compromise, revoke specific instances from the capability to refresh their own certificates. Instance Refresh Request \u00b6 During instance refresh request, ZTS Server again contacts provider service for verification of the instance. This is necessary in case the credentials have been compromised and the original instance is no longer running and will allow the provider to verify that the instance is indeed still running. ZTS will also verify that the connection is using the previous TLS certificate issued for the service and provider and the authorization policies are still in place. The steps would include: SIA will generate a public/private key pair on the host, generate a CSR using the newly generated private key. The CSR requirements are as follows: The Subject CN in the CSR must be the Athenz service identity name (e.g. weather.api - api service in weather domain) The CSR must include a SAN dnsName attribute with the format: <service-with-domain>.<provider-dnsname-suffix> that was used in the original register request. The provider must specify a unique identifier for the instance within the provider namespace (this could be combination of multiple strings - e.g. instance-id.pod-id.cluster-id) and this information must be included in the CSR as another SAN dnsName attribute with the format: <provider-unique-instance-id>.instanceid.athenz.<provider-dnsname-suffix> . The ZTS server will use this information along with the issued TLS Certificate Serial number to revoke specific instances if they\u2019re compromised. SIA will generate an InstanceRefreshInformation object including attestation data and submit the post request to ZTS Server. It will be required to use the TLS certificate that was issued to that instance previously by ZTS Server. ZTS Server will carry out the following authorization and verification checks before contacting provider service: The provider service in the info object has been authorized in Athenz to launch services (policy exists in sys.auth domain). Service specified in the info object (domain.service) has authorized provider service in the info object to launch itself (policy exists in the service\u2019s own domain). The cn in the CSR matches to the specific domain and service names. The TLS certificate SIA used to contact ZTS server must be for the same service. The TLS certificate SIA used to contact ZTS server must have the same provider and the 2 dnsName attributes as the CSR. ZTS Server will extract the instanceid from CSR and verify that the instance has not been revoked and the serial number matches to the registered entry in the certificate database. ZTS Server will contact Provider service at its configured endpoint and verify that the TLS certificate used for authentication by the provider service matches to the service name and was issued by ZTS server itself. ZTS Server will generate an InstanceConfirmation object and submit the post request to the Provider Service. In the InstanceConfirmation object, ZTS server will include the attestation data presented by instance. The Provider Service will be responsible for: Validating attestation data Validating hostnames included in the CSR Validating IP addresses (if available) included in the CSR Once ZTS service receives a successful response from the Provider Service, it will submit the CSR to Certsignd to generate a X.509 Certificate ZTS Server will retrieve the Serial number from the new Certificate and update the certificate database with the new serial number. Instance Revocation Request \u00b6 If necessary, the domain administrators must be able to revoke specific instances from having the capability to refresh their certificate. The steps would be: Domain Admin will issue a HTTP DELETE /instance/\u2026 request to ZTS Server. ZTS Server will authorize the request and update the serial number for the requested instance id in the certificate database to -1. This operation will revoke the instance from refreshing its certificates. Athenz RDL \u00b6 Instance Register Request \u00b6 InstanceRegisterInformation is the information a provider-hosted booting instance must provide to Athenz to authenticate: type InstanceRegisterInformation Struct { ServiceName provider; //the provider service name (i.e. \"aws.us-west-2\") DomainName domain; //the domain of the instance SimpleName service; //the service this instance is supposed to run String attestationData;//signed identity document containing attributes //like IP address, instance-id, account#, signature, etc String csr; //the Certificate Signing Request for the expected //X.509 certificate in the response String ssh (optional); //if present, return an SSH host certificate. //Format is JSON. Bool token (optional); // if true, return a service token signed by //ZTS for this service } resource InstanceIdentity POST \"/instance\" { InstanceRegisterInformation info; String location (header=\"Location\", out); //return location for subsequent operations expected CREATED; exceptions { ResourceError BAD_REQUEST; ResourceError FORBIDDEN; ResourceError UNAUTHORIZED; ResourceError INTERNAL_SERVER_ERROR; } } Instance Identity Response \u00b6 InstanceIdentity is returned on successful attestation. includes the certifictates, tokens, and any additional provider-specific derived attributes. type InstanceIdentity Struct { ServiceName provider; //the provider service name (i.e. \"aws.us-west-2\") ServiceName name; //name of the identity, fully qualified, e.g weather.api PathElement instanceId; //unique instance id within provider\u2019s namespace String x509Certificate (optional); //an X.509 certificate usable for //both client and server in TLS connections String x509CertificateSigner (optional); //the CA certificate chain to //verify all generated X.509 certs String sshCertificate (optional); //the SSH certificate, signed by //the CA (user or host) String sshCertificateSigner (optional); //the SSH CA's public key //for the sshCertificate (user or host) SignedToken serviceToken (optional); //service token instead of TLS certificate Map<String,String> attributes (optional); //other config-like attributes //determined at boot time } Instance Refresh Request \u00b6 InstanceRefreshInformation is the information a provider-hosted booting instance must provide to Athenz to refresh the TLS certificate it was issued initially. The request must be done using the previously issued client TLS certificate. type InstanceRefreshInformation Struct { String attestationData (optional); //identity attestation data including //document with its signature containing attributes like IP //address, instance-id, account#, etc. String csr (optional); //the Certificate Signing Request for the expected //X.509 certificate in the response String ssh (optional); //if present, return an SSH host certificate. //Format is JSON. Bool token (optional); // if true, return a service token signed by //ZTS for this service } resource InstanceIdentity POST \"/instance/{provider}/{domain}/{service}/{instanceId}\" { ServiceName provider; //the provider service name (i.e. \"aws.us-west-2\") DomainName domain; //the domain of the instance SimpleName service; //the service this instance is supposed to run PathElement instanceId; //the instance id that\u2019s unique within this provider InstanceRefreshInformation info; //the refresh request authenticate; //only TLS Certificate authentication is allowed expected OK; exceptions { ResourceError BAD_REQUEST; ResourceError FORBIDDEN; ResourceError NOT_FOUND; ResourceError UNAUTHORIZED; ResourceError INTERNAL_SERVER_ERROR; } } Instance Revoke Request \u00b6 resource InstanceIdentity DELETE \"/instance/{provider}/{domain}/{service}/{instanceId}\" { ServiceName provider; //the provider service name (i.e. \"aws.us-west-2\") DomainName domain; //the domain of the instance SimpleName service; //the service this instance is supposed to run PathElement instanceId; //the instance id that\u2019s unique within this provider authorize(\u201cdelete\u201d, {domain}:instance.{instanceId}; expected NO_CONTENT; exceptions { ResourceError BAD_REQUEST; ResourceError FORBIDDEN; ResourceError NOT_FOUND; ResourceError UNAUTHORIZED; ResourceError INTERNAL_SERVER_ERROR; } } Instance Provider RDL \u00b6 This is the RDL that any provider that is authorized to create instances through Athenz must implement. This interface must be available over HTTPS only. type InstanceConfirmation Struct { ServiceName provider; //the provider service name DomainName domain; //the domain of the instance SimpleName service; //the service this instance is supposed to run String attestationData; //signed identity document containing attributes //like IP address, instance-id, account#, signature, etc. Map<String,String> attributes (optional); //additional non-signed attributes that assist //in attestation. I.e. \"instanceId\u201d, keyId\", \"accessKey\", etc } Confirm instance identity information and return appropriate response to ZTS Server. On return from the confirmation, the resulting InstanceConfirmation may have additional useful attributes added, for example attributes taken from the identity document like \"account\" number or a canonical value like \"network\" that gets identified differently with different providers. resource InstanceConfirmation POST \"/instance\" { InstanceConfirmation confirmation; authenticate; expected OK; exceptions { ResourceError BAD_REQUEST; ResourceError FORBIDDEN; ResourceError UNAUTHORIZED; } } resource InstanceConfirmation POST \"/refresh\" (name=PostRefreshConfirmation) { InstanceConfirmation confirmation; Authenticate; expected OK; exceptions { ResourceError BAD_REQUEST; ResourceError FORBIDDEN; ResourceError UNAUTHORIZED; } } Authorization Policies \u00b6 System Providers \u00b6 Athenz will maintain list of authorized provider services in sys.auth domain. If necessary, we can configure specific policies to grant additional users access over the roles/policies used to configure the list of provider. Domain: sys.auth Role: providers Members: <provider-name(s)> (e.g. openstack.cluster1) Policy: providers Assertion: grant launch to providers on sys.auth:instance Provider Authorized DNS Suffix \u00b6 When generating a CSR to request a TLS certificate for a service, the sia agent must know what DNS Suffix is the provider authorized to use so it can include the dnsName attribute in the CSR in the expected form (e.g. <service>.<domain-with-dashes>.<provider-dns-suffix> ). ZTS must validate that the provider is authorized to launch a service with that DNS suffix. For now, this information will be authorized against a policy in special sys.auth domain. Domain: sys.auth Role: provider.<provider-name> (e.g. provider.openstack.cluster1) Members: <provider-name(s)> (e.g. openstack.cluster1) Policy: provider.<provider-name> Assertion: grant launch to provider.<provider-name> on sys.auth:dns.<provider-suffix> Service Authorized Providers \u00b6 Each service will have a role/policy in their own domain that they control whether or not authorize specific providers to launch their services. For example, service weather.api wants to authorize AWS services to launch its services: Domain: weather.api Role: api_providers Members: athenz.aws Policy: api_providers Assertion: grant launch to \u201capi_providers\u201d on \u201cweather:service.api\u201d Sample Implementation and Setup Tasks \u00b6 Athenz System Setup \u00b6 Create the provider\u2019s role: $ zms-cli -d sys.auth add-group-role providers Create the provider\u2019s policy: $ zms-cli -d sys.auth add-policy providers grant launch to providers on instance Provider Service Implementation and Registration \u00b6 Implement provider service that implements Instance Provider RDL. Register the provider service in Athenz in the provider\u2019s domain. For example, we\u2019ll be registering a provider service called openstack.cluster1. Generate private/public key pair for the service. $ openssl genrsa -out service_private.key 2048 $ openssl rsa -in service_private.key -pubout > service_public.key Create the service identity in Athenz with public key id: v0 $ zms-cli -d openstack add-service cluster1 v0 ./service_public.key Determine the https endpoint for your service that ZTS will contact to verify instance information. For example, https://provider-cluster1.openstack.athenz.com:4443/hostsigner/v1 and set the endpoint for the service: $ zms-cli -d openstack set-service-endpoint cluster1 https://provider-cluster1.openstack.athenz.com:4443/hostsigner/v1 Obtain a TLS certificate from ZTS Server for the service to run with. If your service is Jetty based, then the private key and certificate must be added to a keystore using the openssl utility. The certificate is valid for 30 days, so you must setup a cron job that periodically retrieves an updated certificates and your service is refreshed to use to the new certificate. $ zts-svccert -domain openstack -service cluster1 -private-key ./service_private.key -key-version v0 -zts https://<zts-hostname>:4443/zts/v1 -dns-domain athenz.com Determine the dns suffix for your provider service and submit a request to the Athenz system administrators to register the provider service with its dns suffix as an authorized provider service in Athenz Athenz Authorized Provider Registration \u00b6 Verify the dns suffix requested for the provider and, if valid, register the service in Athenz Add the service to the providers role: $ zms-cli -d sys.auth add-member providers openstack.cluster1 Register the dns suffix for the provider service. For example, cluster1.ostk.athenz.cloud $ zms-cli -d sys.auth add-group-role provider.openstack.providers openstack.cluster1 $ zms-cli -d sys.auth add-policy provider.openstack.providers grant launch to provider.openstack.providers on dns.cluster1.ostk.athenz.cloud Tenant Service Registration \u00b6 Authorize provider service to launch its instances. For example, weater domain wants to authorize its service api to be launched by openstack.cluster1 provider. $ zms-cli -d weather add-group-role openstack_providers openstack.cluster1 $ zms-cli -d weather add-policy openstack_providers grant launch to openstack_providers on weather:service.api Provider Client Implementation \u00b6 Provider must implement a client that will communicate with ZTS and execute Instance Register and Instance Refresh requests. When bootstrapping the the tenant instance, the Provider service must pass to the client the following details: the provider service name (e.g. openstack.cluster1) its dns suffix (e.g. cluster1.ostk.athenz.cloud) signed instance identity document The client will generate a CSR based on the details it received from its provider service, include the CSR in the InstanceRegisterInformation object and post it to ZTS. The client will be responsible for storing the certificate used from ZTS on the local host and use it for its subsequent requests to ZTS to refresh the certificate.","title":"Service Identity X.509 Certificate Support Requirements - Copper Argos"},{"location":"copper_argos_dev/#copper-argos-athenz-service-identity-x509-certificates-development","text":"What is Copper Argos Provider Service Registration Tenant Service Launch Authorization Instance Register Request Instance Refresh Request Instance Revocation Request Athenz RDL Instance Register Request Instance Identity Response Instance Refresh Request Instance Revoke Request Instance Provider RDL Authorization Policies System Providers Provider Authorized DNS Suffix Service Authorized Providers Sample Implementation and Setup Tasks Athenz System Setup Provider Service Implementation and Registration Athenz Authorized Provider Registration Tenant Service Registration Provider Client Implementation","title":"Copper Argos: Athenz Service Identity X.509 Certificates Development"},{"location":"copper_argos_dev/#what-is-copper-argos","text":"Copper Argos extends Athenz with generalized model for service providers to launch other identities in an authorized way through a callback-based verification model. With this model each provider is responsible for their instance document verification service instead of embedding that logic inside ZTS.","title":"What is Copper Argos"},{"location":"copper_argos_dev/#provider-service-registration","text":"Each provider is a registered service identity object in Athenz. As such, the provider domain administrator will create the service identity object in their domain and provide the following attributes using zms-cil utility or the REST API. (Athenz UI does not expose optional service attributes since they\u2019re not commonly used). * Provider Endpoint - A REST API endpoint that implements Provider RDL and ZTS will contact to validate the instance document (ServiceIdentity already has the providerEndpoint attribute) Domain administrator will then need to follow up with the Athenz Team to authorize Provider Service as an Instance Launcher Service in Athenz. The Provider will also specify the DNS suffix that will be used by its tenants. There will be a policy in sys.auth domain that grants launch action to instance resource to the providers role. Once approved, the Athenz System admin will add the provider service identity to the providers role in the sys.auth domain either using zms-cli or Athenz UI. There will be policy granting access to the specified Provider SAN dnsName attribute suffix to the list service provider. Requirements for Provider Service: * It must retrieve a TLS certificate for its service from Athenz and use that as its Service Certificate. * When ZTS Contacts Provider Service to validate an instance document, it will require TLS authentication and verify that the certificate the service used for authentication was issued for the expected provider service by ZTS itself. * ZTS issues TLS certificates valid for 30 days only, so the Provider Service Admin must have the capability to periodically refresh its certificate by requesting a new one from ZTS Server (e.g. daily) and dynamically update its service to use the refreshed certificates.","title":"Provider Service Registration"},{"location":"copper_argos_dev/#tenant-service-launch-authorization","text":"Before a tenant service can be launched by a specific provider and issued a TLS certificate for, the tenant domain administrator must authorize a specific provider service to launch its services. This will require that a role and policy to be created in the tenant\u2019s domain. For example, if weather.api service wants to authorize athenz.aws provider to launch its services, it will need to create the following policy and role in their domain: * Policy: grant launch to aws-provider on weather:service.api * Role: aws-provider role member: athenz.aws.us-west-2 The change can be carried out with using zms-cli or Athenz UI.","title":"Tenant Service Launch Authorization"},{"location":"copper_argos_dev/#instance-register-request","text":"Once the service admin creates the appropriate role and policy in its domain authorizing the provider service to bootstrap its instance, it can submit the launch request to the provider service. The steps of the bootstrap process pertaining Athenz integration would include: As part of the launch request, the admin will specify the Athenz domain and service that should be assigned to the instance. The provider service will generate an instance identity document, sign it with its private key and securely transfer this document along with its signature onto to the bootstrapped host. As part of the bootstrap process or possible as part of the image, the Service Identity Agent (SIA) will also be installed on the host. SIA will generate a public/private key pair on the host, generate a CSR using the newly generated private key. The CSR requirements are as follows: The Subject CN in the CSR must be the Athenz service identity name (e.g. weather.api - api service in weather domain) The CSR must include a SAN dnsName attribute with the format: <service-with-domain>.<provider-dnsname-suffix> . The provider-dnsname-suffix must match the value registered for the provider service. The <service-with-domain> part is left up to to the provider to define what format they want to use (e.g. <service>.<domain> or <service>.<domain-with-dashes> ). ZTS server will pass these hostnames to the provider as entries in the attribute field for validation. The provider must specify a unique identifier for the instance within the provider\u2019s namespace (this could be combination of multiple strings - e.g. instance-id.pod-id.cluster-id) and this information must be included in the CSR as another SAN dnsName attribute with the format: <provider-unique-instance-id>.instanceid.athenz.<provider-dnsname-suffix> . The ZTS server will use this information along with the issued TLS Certificate Serial number to revoke specific instances if they\u2019re compromised. SIA will generate an InstanceRegisterInformation object that will include attestation data (this would include the instance identity document, its signature and other attributes that will be necessary for the provider to validate and confirm the instance register request from ZTS) received from the provider and submit the post request to ZTS Server. ZTS Server will carry out the following authorization and verification checks before contacting provider service: The provider service in the info object has been authorized in Athenz to launch services (policy exists in sys.auth domain). Service specified in the info object (domain.service) has authorized provider service in the info object to launch itself (policy exists in the service\u2019s own domain). The provider service is registered in Athenz, has a providerEndpoint (verified as internal ip address) and providerDnsNameSuffix attributes defined. The cn in the CSR matches to the specific domain and service names. The CSR must include only 2 dnsName attributes with the expected format: <service-with-domain>.<provider-dnsname-suffix> <provider-unique-instance-id>.instanceid.athenz.<provider-dnsname-suffix> ZTS Server will contact Provider service at its configured endpoint and verify that the TLS certificate used for authentication by the provider service matches to the service name and was issued by ZTS server itself. ZTS Server will generate an InstanceConfirmation object and submit the post request to the Provider Service. In the InstanceConfirmation object, ZTS server will include the following entries in the optional attributes map: sanDNS: comma separated list of dnsNames attributes in the CSR - there will only be 2 as defined in 6(e) above sanIP - comma separated list of IP addresses in the CSR if any were specified clientIP - the IP address of the client cloudAccount - domain\u2019s account id if one is configured The Provider Service will be responsible for: Validating Signature Validating the instance id Validating the bootup time is within acceptable time period (e..g 5 mins) Validating hostnames included in the CSR Validating IP addresses (if available) included in the CSR Once ZTS service receives a successful response from the Provider Service, it will submit the CSR to Certsignd to generate a X.509 Certificate ZTS Server will retrieve the Serial number from the Certificate and register the certificate along with instanceid and provider service name in its certificate database. This will be used to monitor refresh certificate operations and, in case of a compromise, revoke specific instances from the capability to refresh their own certificates.","title":"Instance Register Request"},{"location":"copper_argos_dev/#instance-refresh-request","text":"During instance refresh request, ZTS Server again contacts provider service for verification of the instance. This is necessary in case the credentials have been compromised and the original instance is no longer running and will allow the provider to verify that the instance is indeed still running. ZTS will also verify that the connection is using the previous TLS certificate issued for the service and provider and the authorization policies are still in place. The steps would include: SIA will generate a public/private key pair on the host, generate a CSR using the newly generated private key. The CSR requirements are as follows: The Subject CN in the CSR must be the Athenz service identity name (e.g. weather.api - api service in weather domain) The CSR must include a SAN dnsName attribute with the format: <service-with-domain>.<provider-dnsname-suffix> that was used in the original register request. The provider must specify a unique identifier for the instance within the provider namespace (this could be combination of multiple strings - e.g. instance-id.pod-id.cluster-id) and this information must be included in the CSR as another SAN dnsName attribute with the format: <provider-unique-instance-id>.instanceid.athenz.<provider-dnsname-suffix> . The ZTS server will use this information along with the issued TLS Certificate Serial number to revoke specific instances if they\u2019re compromised. SIA will generate an InstanceRefreshInformation object including attestation data and submit the post request to ZTS Server. It will be required to use the TLS certificate that was issued to that instance previously by ZTS Server. ZTS Server will carry out the following authorization and verification checks before contacting provider service: The provider service in the info object has been authorized in Athenz to launch services (policy exists in sys.auth domain). Service specified in the info object (domain.service) has authorized provider service in the info object to launch itself (policy exists in the service\u2019s own domain). The cn in the CSR matches to the specific domain and service names. The TLS certificate SIA used to contact ZTS server must be for the same service. The TLS certificate SIA used to contact ZTS server must have the same provider and the 2 dnsName attributes as the CSR. ZTS Server will extract the instanceid from CSR and verify that the instance has not been revoked and the serial number matches to the registered entry in the certificate database. ZTS Server will contact Provider service at its configured endpoint and verify that the TLS certificate used for authentication by the provider service matches to the service name and was issued by ZTS server itself. ZTS Server will generate an InstanceConfirmation object and submit the post request to the Provider Service. In the InstanceConfirmation object, ZTS server will include the attestation data presented by instance. The Provider Service will be responsible for: Validating attestation data Validating hostnames included in the CSR Validating IP addresses (if available) included in the CSR Once ZTS service receives a successful response from the Provider Service, it will submit the CSR to Certsignd to generate a X.509 Certificate ZTS Server will retrieve the Serial number from the new Certificate and update the certificate database with the new serial number.","title":"Instance Refresh Request"},{"location":"copper_argos_dev/#instance-revocation-request","text":"If necessary, the domain administrators must be able to revoke specific instances from having the capability to refresh their certificate. The steps would be: Domain Admin will issue a HTTP DELETE /instance/\u2026 request to ZTS Server. ZTS Server will authorize the request and update the serial number for the requested instance id in the certificate database to -1. This operation will revoke the instance from refreshing its certificates.","title":"Instance Revocation Request"},{"location":"copper_argos_dev/#athenz-rdl","text":"","title":"Athenz RDL"},{"location":"copper_argos_dev/#instance-register-request_1","text":"InstanceRegisterInformation is the information a provider-hosted booting instance must provide to Athenz to authenticate: type InstanceRegisterInformation Struct { ServiceName provider; //the provider service name (i.e. \"aws.us-west-2\") DomainName domain; //the domain of the instance SimpleName service; //the service this instance is supposed to run String attestationData;//signed identity document containing attributes //like IP address, instance-id, account#, signature, etc String csr; //the Certificate Signing Request for the expected //X.509 certificate in the response String ssh (optional); //if present, return an SSH host certificate. //Format is JSON. Bool token (optional); // if true, return a service token signed by //ZTS for this service } resource InstanceIdentity POST \"/instance\" { InstanceRegisterInformation info; String location (header=\"Location\", out); //return location for subsequent operations expected CREATED; exceptions { ResourceError BAD_REQUEST; ResourceError FORBIDDEN; ResourceError UNAUTHORIZED; ResourceError INTERNAL_SERVER_ERROR; } }","title":"Instance Register Request"},{"location":"copper_argos_dev/#instance-identity-response","text":"InstanceIdentity is returned on successful attestation. includes the certifictates, tokens, and any additional provider-specific derived attributes. type InstanceIdentity Struct { ServiceName provider; //the provider service name (i.e. \"aws.us-west-2\") ServiceName name; //name of the identity, fully qualified, e.g weather.api PathElement instanceId; //unique instance id within provider\u2019s namespace String x509Certificate (optional); //an X.509 certificate usable for //both client and server in TLS connections String x509CertificateSigner (optional); //the CA certificate chain to //verify all generated X.509 certs String sshCertificate (optional); //the SSH certificate, signed by //the CA (user or host) String sshCertificateSigner (optional); //the SSH CA's public key //for the sshCertificate (user or host) SignedToken serviceToken (optional); //service token instead of TLS certificate Map<String,String> attributes (optional); //other config-like attributes //determined at boot time }","title":"Instance Identity Response"},{"location":"copper_argos_dev/#instance-refresh-request_1","text":"InstanceRefreshInformation is the information a provider-hosted booting instance must provide to Athenz to refresh the TLS certificate it was issued initially. The request must be done using the previously issued client TLS certificate. type InstanceRefreshInformation Struct { String attestationData (optional); //identity attestation data including //document with its signature containing attributes like IP //address, instance-id, account#, etc. String csr (optional); //the Certificate Signing Request for the expected //X.509 certificate in the response String ssh (optional); //if present, return an SSH host certificate. //Format is JSON. Bool token (optional); // if true, return a service token signed by //ZTS for this service } resource InstanceIdentity POST \"/instance/{provider}/{domain}/{service}/{instanceId}\" { ServiceName provider; //the provider service name (i.e. \"aws.us-west-2\") DomainName domain; //the domain of the instance SimpleName service; //the service this instance is supposed to run PathElement instanceId; //the instance id that\u2019s unique within this provider InstanceRefreshInformation info; //the refresh request authenticate; //only TLS Certificate authentication is allowed expected OK; exceptions { ResourceError BAD_REQUEST; ResourceError FORBIDDEN; ResourceError NOT_FOUND; ResourceError UNAUTHORIZED; ResourceError INTERNAL_SERVER_ERROR; } }","title":"Instance Refresh Request"},{"location":"copper_argos_dev/#instance-revoke-request","text":"resource InstanceIdentity DELETE \"/instance/{provider}/{domain}/{service}/{instanceId}\" { ServiceName provider; //the provider service name (i.e. \"aws.us-west-2\") DomainName domain; //the domain of the instance SimpleName service; //the service this instance is supposed to run PathElement instanceId; //the instance id that\u2019s unique within this provider authorize(\u201cdelete\u201d, {domain}:instance.{instanceId}; expected NO_CONTENT; exceptions { ResourceError BAD_REQUEST; ResourceError FORBIDDEN; ResourceError NOT_FOUND; ResourceError UNAUTHORIZED; ResourceError INTERNAL_SERVER_ERROR; } }","title":"Instance Revoke Request"},{"location":"copper_argos_dev/#instance-provider-rdl","text":"This is the RDL that any provider that is authorized to create instances through Athenz must implement. This interface must be available over HTTPS only. type InstanceConfirmation Struct { ServiceName provider; //the provider service name DomainName domain; //the domain of the instance SimpleName service; //the service this instance is supposed to run String attestationData; //signed identity document containing attributes //like IP address, instance-id, account#, signature, etc. Map<String,String> attributes (optional); //additional non-signed attributes that assist //in attestation. I.e. \"instanceId\u201d, keyId\", \"accessKey\", etc } Confirm instance identity information and return appropriate response to ZTS Server. On return from the confirmation, the resulting InstanceConfirmation may have additional useful attributes added, for example attributes taken from the identity document like \"account\" number or a canonical value like \"network\" that gets identified differently with different providers. resource InstanceConfirmation POST \"/instance\" { InstanceConfirmation confirmation; authenticate; expected OK; exceptions { ResourceError BAD_REQUEST; ResourceError FORBIDDEN; ResourceError UNAUTHORIZED; } } resource InstanceConfirmation POST \"/refresh\" (name=PostRefreshConfirmation) { InstanceConfirmation confirmation; Authenticate; expected OK; exceptions { ResourceError BAD_REQUEST; ResourceError FORBIDDEN; ResourceError UNAUTHORIZED; } }","title":"Instance Provider RDL"},{"location":"copper_argos_dev/#authorization-policies","text":"","title":"Authorization Policies"},{"location":"copper_argos_dev/#system-providers","text":"Athenz will maintain list of authorized provider services in sys.auth domain. If necessary, we can configure specific policies to grant additional users access over the roles/policies used to configure the list of provider. Domain: sys.auth Role: providers Members: <provider-name(s)> (e.g. openstack.cluster1) Policy: providers Assertion: grant launch to providers on sys.auth:instance","title":"System Providers"},{"location":"copper_argos_dev/#provider-authorized-dns-suffix","text":"When generating a CSR to request a TLS certificate for a service, the sia agent must know what DNS Suffix is the provider authorized to use so it can include the dnsName attribute in the CSR in the expected form (e.g. <service>.<domain-with-dashes>.<provider-dns-suffix> ). ZTS must validate that the provider is authorized to launch a service with that DNS suffix. For now, this information will be authorized against a policy in special sys.auth domain. Domain: sys.auth Role: provider.<provider-name> (e.g. provider.openstack.cluster1) Members: <provider-name(s)> (e.g. openstack.cluster1) Policy: provider.<provider-name> Assertion: grant launch to provider.<provider-name> on sys.auth:dns.<provider-suffix>","title":"Provider Authorized DNS Suffix"},{"location":"copper_argos_dev/#service-authorized-providers","text":"Each service will have a role/policy in their own domain that they control whether or not authorize specific providers to launch their services. For example, service weather.api wants to authorize AWS services to launch its services: Domain: weather.api Role: api_providers Members: athenz.aws Policy: api_providers Assertion: grant launch to \u201capi_providers\u201d on \u201cweather:service.api\u201d","title":"Service Authorized Providers"},{"location":"copper_argos_dev/#sample-implementation-and-setup-tasks","text":"","title":"Sample Implementation and Setup Tasks"},{"location":"copper_argos_dev/#athenz-system-setup","text":"Create the provider\u2019s role: $ zms-cli -d sys.auth add-group-role providers Create the provider\u2019s policy: $ zms-cli -d sys.auth add-policy providers grant launch to providers on instance","title":"Athenz System Setup"},{"location":"copper_argos_dev/#provider-service-implementation-and-registration","text":"Implement provider service that implements Instance Provider RDL. Register the provider service in Athenz in the provider\u2019s domain. For example, we\u2019ll be registering a provider service called openstack.cluster1. Generate private/public key pair for the service. $ openssl genrsa -out service_private.key 2048 $ openssl rsa -in service_private.key -pubout > service_public.key Create the service identity in Athenz with public key id: v0 $ zms-cli -d openstack add-service cluster1 v0 ./service_public.key Determine the https endpoint for your service that ZTS will contact to verify instance information. For example, https://provider-cluster1.openstack.athenz.com:4443/hostsigner/v1 and set the endpoint for the service: $ zms-cli -d openstack set-service-endpoint cluster1 https://provider-cluster1.openstack.athenz.com:4443/hostsigner/v1 Obtain a TLS certificate from ZTS Server for the service to run with. If your service is Jetty based, then the private key and certificate must be added to a keystore using the openssl utility. The certificate is valid for 30 days, so you must setup a cron job that periodically retrieves an updated certificates and your service is refreshed to use to the new certificate. $ zts-svccert -domain openstack -service cluster1 -private-key ./service_private.key -key-version v0 -zts https://<zts-hostname>:4443/zts/v1 -dns-domain athenz.com Determine the dns suffix for your provider service and submit a request to the Athenz system administrators to register the provider service with its dns suffix as an authorized provider service in Athenz","title":"Provider Service Implementation and Registration"},{"location":"copper_argos_dev/#athenz-authorized-provider-registration","text":"Verify the dns suffix requested for the provider and, if valid, register the service in Athenz Add the service to the providers role: $ zms-cli -d sys.auth add-member providers openstack.cluster1 Register the dns suffix for the provider service. For example, cluster1.ostk.athenz.cloud $ zms-cli -d sys.auth add-group-role provider.openstack.providers openstack.cluster1 $ zms-cli -d sys.auth add-policy provider.openstack.providers grant launch to provider.openstack.providers on dns.cluster1.ostk.athenz.cloud","title":"Athenz Authorized Provider Registration"},{"location":"copper_argos_dev/#tenant-service-registration","text":"Authorize provider service to launch its instances. For example, weater domain wants to authorize its service api to be launched by openstack.cluster1 provider. $ zms-cli -d weather add-group-role openstack_providers openstack.cluster1 $ zms-cli -d weather add-policy openstack_providers grant launch to openstack_providers on weather:service.api","title":"Tenant Service Registration"},{"location":"copper_argos_dev/#provider-client-implementation","text":"Provider must implement a client that will communicate with ZTS and execute Instance Register and Instance Refresh requests. When bootstrapping the the tenant instance, the Provider service must pass to the client the following details: the provider service name (e.g. openstack.cluster1) its dns suffix (e.g. cluster1.ostk.athenz.cloud) signed instance identity document The client will generate a CSR based on the details it received from its provider service, include the CSR in the InstanceRegisterInformation object and post it to ZTS. The client will be responsible for storing the certificate used from ZTS on the local host and use it for its subsequent requests to ZTS to refresh the certificate.","title":"Provider Client Implementation"},{"location":"data_model/","text":"Architecture - Data Model \u00b6 Concepts Data Model Terminology Domains Resources Policies Roles Principals Users Services Groups Tokens Principal Token - NToken Access Tokens Having a firm grasp on some fundamental concepts will help you understand the Athenz architecture, the flow for both centralized and decentralized authorization, and how to set up role-based authorization. Concepts \u00b6 Role based Access Control (RBAC) system Symbolic names are used to identify the entities involved in authorization, so humans can read and understand the assertions Namespaces are strictly partitioned into Domains, which imply an ownership and control aspect to the names Enforcement can be factored such that it can be done in a distributed way, making possible data-plane checks that do not go off-box Administrative tasks can be delegated to created subdomains to avoid reliance on central \"super user\" administrative roles. Multi-tenancy relationships across domains can also take advantage of delegated administration Cryptographic signatures are used to ensure the fidelity of assertions and their lifecycle attributes Policy orientation, as opposed to Resource orientation, allows few assertions (in policies) to affect a potentially large number of resources, and allows more flexible scoping via wildcarding over groups of resources. In Athenz, the authorization management server converts all incoming data to lowercase before any processing - this applies to all data types within Athenz (e.g. domain names, role names, policy names, resource group values, etc). Data Model \u00b6 Terminology \u00b6 Domain - a partition/namespace/account of control and isolation Role - an entity that takes action on resources, when assumed by a principal Resource - an entity to take action on, referred to by unique name Policy - a set of assertions that govern usage of resources Assertion - a quadruple of <effect, role, action, resource> Principal - an authenticated user or service that assumes one or more roles User - a user identity that is authenticated by a particular authority Service - An identity that exposes reusable resources, authenticated by an Athenz-aware container, reachable via an explicit endpoint. Provider - a type of service that participates in the multi-tenant provisioning protocol. Tenant - a Domain that is provisioned to access some Resources in a Provider Group - A group is a collection of user and service principals Control Plane - operations done to provision or otherwise setup a system, outside its normal operation. Data Plane - operations done in the normal usage of a system, after it is set up. These operations are usually highly performance sensitive. There are numerous domains, and domains can themselves \u201ccontain\u201d subdomains, from a creation/deletion perspective. However, all domains and subdomains, regardless of their administrative relationships, are independent and share no state. Relationships between them (i.e. quotas, billing roll ups, etc) must be explicitly introduced if desired. Roles, Policies and their Assertions, and Services are all defined in a Domain. Domains \u00b6 Domains are namespaces, strictly partitioned, providing a context for authoritative statements to be made about entities it contains. Only system administrators can create and destroy top-level domains. Each domain is assigned users in an administrative role. Those admins can, in turn, create and delete subdomains, that is, domains that start with the parent domain as a prefix, using a '.' as a domain delimiter. For example, \"media\" is a top-level domain, and \"media.news\" is a subdomain of it. It is important to note that the only relation between these two domains involves creation and destruction of the domains -- the two domains share no state by default, and there is no inheritance or other relation between them other than that implied by their names. This allows all domains (whether top-level or subdomains) to be completely partitioned from each other, and the ownership of the entities defined within a domain is clear. A domain is a place to group your resources and entities. All resources are partitioned across some set of domains Domains are given a symbolic name, so humans can easily understand a reference to them The domain name is used as a namespace for resource names Domains are similar the concept of an account, and provides a \u201cwalled garden\u201d in which to operate Resources \u00b6 Resources aren't explicitly modeled in Athenz, they are referred to by name. A resource is something that is \"owned\" and controlled in a specific domain. Concrete example: a machine Abstract example: a security policy Identified by a canonical name, so humans can comprehend references to it When referring to resources for authorization, a global naming system needs to be introduced to handle names in namespaces. A Resource Name is defined as follows: {Domain}:{Entity} The Domain is the namespace mentioned above, and the Entity is an entity path (delimited by periods) within that namespace. The two are often used together to form a short resource name. For example, if the media.news property provisions a table in a db service, the resource name for the table may look like this: media.news:storage.db.table Policies \u00b6 To implement access control, we have policies in our domain that govern the use of our resources. A policy is a set of assertions (rules) about granting or denying an operation/action on a resource. For example, the assertion [grant, update, dev, storage.db.table] would grant the update operation/action to all the members in the dev role on the storage.db.table resource. Note that the assertion fields are declared as general strings, as they may contain \"globbing\" style wildcards, for example \"media.news:role.*\", which would apply to any entity that matched the pattern. Roles \u00b6 A role can be thought of as a group, anyone in the group can assume the role that takes a particular action. Every policy assertion describes what can be done by a role. A role can also delegate the determination of membership to another trusted domain. For example, a netops role managed outside a property domain. This is how we can model tenant relations between a provider domain and tenant domains. Because roles are defined in domains, they can be partitioned by domain, unlike users, which are global. This allows the distributed operation to be more easily scaled. Principals \u00b6 The actors in Athenz that can assume a role are called principals. These principals are authenticated and can be users (for example, authenticated by their Unix or Kerberos credentials). Principals can also be services that are authenticated by a service management system. Athenz currently provides service identity and authentication support. In either case, the identity is expressed as a resource name, and the proof of that identity is provided as an X509 certificate. Users \u00b6 Users are actually defined in some external authority, e.g. Unix or Kerberos system. A special domain is reserved for the purpose of namespacing users, the name of that domain is user , so some example users are: user.john user.doe The credentials that the external system requires are exchanged for X509 certificates before operating on any data. Services \u00b6 The concept of a Service Identity is introduced as the identity of independent agents of execution. Services are defined as a subdomain of the managing domain, which provides a simple way of naming them. For example: media.news.msbe sports.storage The relationship of a service identity and its parent domain essentially means that the parent domain is an authority for the service itself, from a management perspective. A Service Identity may be used as a principal when specifying Roles, just like a User. Athenz provides support for registering such a Service Identity, in a domain, along with its public key that can be used to later verify an NToken that is presented by the service. Groups \u00b6 To simplify principal management, the users and services can be included in Groups. Then, the Group can be added as a principal to any role within Athenz thus granting the members of that group access to the configured resources. For example, if you need to add your development team members to multiple roles in your domain, you can create a group called dev-team , add those users into that group and then include the group as a member in the corresponding roles. When you need to remove or add a member, then you only need to modify the membership of your dev-team group. The groups cannot contain other groups. Tokens \u00b6 Athenz authorization system utilizes 2 types of tokens: Principal Tokens (NTokens) and Access Tokens. Principal Token (NToken) \u00b6 The Principal token can be thought of an identity token because it identifies either a user or a service. Users submit their credentials to ZMS, which validates those credentials and generates, signs and returns principal tokens. A service generates its principal token using the service's private key. The principal token can then be used to access role tokens. A principal token is serialized as a string with following attributes: version (v) - the version of the token - U1 for user tokens and S1 for service tokens domain (d) - the domain of principal. For users this will always be \"user\" name (n) - the name of the principal host (h) - the FQDN of the host that issued this token salt (a) - a salt time (t) - the time the token was issued expires (e) - the time the token expires keyId (k) - the key identifier of the private key that was used to sign this token ip (i) - the IP address where the request to get this token was initiated from authorized-services (b) - the list of services authorized to use this user token signature (s) - the signature of the other items The single letter in parentheses is the key in the serialized string, where semicolons separate key value pairs, and the key and value are separated by an equals sign. For example: v=U1;d=user;n=joe;h=host.athenz.org;a=bb4e;t=1442255237;e=1442258837;k=0;i=10.72.42.32;s=Jw8SvYGYrk Note that requests that include a principal token should be protected to keep the token from being intercepted and reused (for the lifetime of the token). It is strongly recommended to always use HTTPS for such requests. Access Tokens \u00b6 Athenz supports the OAuth2 standard by enabling the generation of Access Tokens. Access tokens represent an authoritative statement that a given principal may assume some number of roles in a domain for a limited period. They are signed to prevent tampering. Using Access Tokens instead of directly asking for an access check with a principal identity, reduces the chance of providing identity details to a compromised service. This mechanism also allows a service to make a completely local access check against the cached policies used by the policy engine.","title":"Data Model"},{"location":"data_model/#architecture-data-model","text":"Concepts Data Model Terminology Domains Resources Policies Roles Principals Users Services Groups Tokens Principal Token - NToken Access Tokens Having a firm grasp on some fundamental concepts will help you understand the Athenz architecture, the flow for both centralized and decentralized authorization, and how to set up role-based authorization.","title":"Architecture - Data Model"},{"location":"data_model/#concepts","text":"Role based Access Control (RBAC) system Symbolic names are used to identify the entities involved in authorization, so humans can read and understand the assertions Namespaces are strictly partitioned into Domains, which imply an ownership and control aspect to the names Enforcement can be factored such that it can be done in a distributed way, making possible data-plane checks that do not go off-box Administrative tasks can be delegated to created subdomains to avoid reliance on central \"super user\" administrative roles. Multi-tenancy relationships across domains can also take advantage of delegated administration Cryptographic signatures are used to ensure the fidelity of assertions and their lifecycle attributes Policy orientation, as opposed to Resource orientation, allows few assertions (in policies) to affect a potentially large number of resources, and allows more flexible scoping via wildcarding over groups of resources. In Athenz, the authorization management server converts all incoming data to lowercase before any processing - this applies to all data types within Athenz (e.g. domain names, role names, policy names, resource group values, etc).","title":"Concepts"},{"location":"data_model/#data-model","text":"","title":"Data Model"},{"location":"data_model/#terminology","text":"Domain - a partition/namespace/account of control and isolation Role - an entity that takes action on resources, when assumed by a principal Resource - an entity to take action on, referred to by unique name Policy - a set of assertions that govern usage of resources Assertion - a quadruple of <effect, role, action, resource> Principal - an authenticated user or service that assumes one or more roles User - a user identity that is authenticated by a particular authority Service - An identity that exposes reusable resources, authenticated by an Athenz-aware container, reachable via an explicit endpoint. Provider - a type of service that participates in the multi-tenant provisioning protocol. Tenant - a Domain that is provisioned to access some Resources in a Provider Group - A group is a collection of user and service principals Control Plane - operations done to provision or otherwise setup a system, outside its normal operation. Data Plane - operations done in the normal usage of a system, after it is set up. These operations are usually highly performance sensitive. There are numerous domains, and domains can themselves \u201ccontain\u201d subdomains, from a creation/deletion perspective. However, all domains and subdomains, regardless of their administrative relationships, are independent and share no state. Relationships between them (i.e. quotas, billing roll ups, etc) must be explicitly introduced if desired. Roles, Policies and their Assertions, and Services are all defined in a Domain.","title":"Terminology"},{"location":"data_model/#domains","text":"Domains are namespaces, strictly partitioned, providing a context for authoritative statements to be made about entities it contains. Only system administrators can create and destroy top-level domains. Each domain is assigned users in an administrative role. Those admins can, in turn, create and delete subdomains, that is, domains that start with the parent domain as a prefix, using a '.' as a domain delimiter. For example, \"media\" is a top-level domain, and \"media.news\" is a subdomain of it. It is important to note that the only relation between these two domains involves creation and destruction of the domains -- the two domains share no state by default, and there is no inheritance or other relation between them other than that implied by their names. This allows all domains (whether top-level or subdomains) to be completely partitioned from each other, and the ownership of the entities defined within a domain is clear. A domain is a place to group your resources and entities. All resources are partitioned across some set of domains Domains are given a symbolic name, so humans can easily understand a reference to them The domain name is used as a namespace for resource names Domains are similar the concept of an account, and provides a \u201cwalled garden\u201d in which to operate","title":"Domains"},{"location":"data_model/#resources","text":"Resources aren't explicitly modeled in Athenz, they are referred to by name. A resource is something that is \"owned\" and controlled in a specific domain. Concrete example: a machine Abstract example: a security policy Identified by a canonical name, so humans can comprehend references to it When referring to resources for authorization, a global naming system needs to be introduced to handle names in namespaces. A Resource Name is defined as follows: {Domain}:{Entity} The Domain is the namespace mentioned above, and the Entity is an entity path (delimited by periods) within that namespace. The two are often used together to form a short resource name. For example, if the media.news property provisions a table in a db service, the resource name for the table may look like this: media.news:storage.db.table","title":"Resources"},{"location":"data_model/#policies","text":"To implement access control, we have policies in our domain that govern the use of our resources. A policy is a set of assertions (rules) about granting or denying an operation/action on a resource. For example, the assertion [grant, update, dev, storage.db.table] would grant the update operation/action to all the members in the dev role on the storage.db.table resource. Note that the assertion fields are declared as general strings, as they may contain \"globbing\" style wildcards, for example \"media.news:role.*\", which would apply to any entity that matched the pattern.","title":"Policies"},{"location":"data_model/#roles","text":"A role can be thought of as a group, anyone in the group can assume the role that takes a particular action. Every policy assertion describes what can be done by a role. A role can also delegate the determination of membership to another trusted domain. For example, a netops role managed outside a property domain. This is how we can model tenant relations between a provider domain and tenant domains. Because roles are defined in domains, they can be partitioned by domain, unlike users, which are global. This allows the distributed operation to be more easily scaled.","title":"Roles"},{"location":"data_model/#principals","text":"The actors in Athenz that can assume a role are called principals. These principals are authenticated and can be users (for example, authenticated by their Unix or Kerberos credentials). Principals can also be services that are authenticated by a service management system. Athenz currently provides service identity and authentication support. In either case, the identity is expressed as a resource name, and the proof of that identity is provided as an X509 certificate.","title":"Principals"},{"location":"data_model/#users","text":"Users are actually defined in some external authority, e.g. Unix or Kerberos system. A special domain is reserved for the purpose of namespacing users, the name of that domain is user , so some example users are: user.john user.doe The credentials that the external system requires are exchanged for X509 certificates before operating on any data.","title":"Users"},{"location":"data_model/#services","text":"The concept of a Service Identity is introduced as the identity of independent agents of execution. Services are defined as a subdomain of the managing domain, which provides a simple way of naming them. For example: media.news.msbe sports.storage The relationship of a service identity and its parent domain essentially means that the parent domain is an authority for the service itself, from a management perspective. A Service Identity may be used as a principal when specifying Roles, just like a User. Athenz provides support for registering such a Service Identity, in a domain, along with its public key that can be used to later verify an NToken that is presented by the service.","title":"Services"},{"location":"data_model/#groups","text":"To simplify principal management, the users and services can be included in Groups. Then, the Group can be added as a principal to any role within Athenz thus granting the members of that group access to the configured resources. For example, if you need to add your development team members to multiple roles in your domain, you can create a group called dev-team , add those users into that group and then include the group as a member in the corresponding roles. When you need to remove or add a member, then you only need to modify the membership of your dev-team group. The groups cannot contain other groups.","title":"Groups"},{"location":"data_model/#tokens","text":"Athenz authorization system utilizes 2 types of tokens: Principal Tokens (NTokens) and Access Tokens.","title":"Tokens"},{"location":"data_model/#principal-token-ntoken","text":"The Principal token can be thought of an identity token because it identifies either a user or a service. Users submit their credentials to ZMS, which validates those credentials and generates, signs and returns principal tokens. A service generates its principal token using the service's private key. The principal token can then be used to access role tokens. A principal token is serialized as a string with following attributes: version (v) - the version of the token - U1 for user tokens and S1 for service tokens domain (d) - the domain of principal. For users this will always be \"user\" name (n) - the name of the principal host (h) - the FQDN of the host that issued this token salt (a) - a salt time (t) - the time the token was issued expires (e) - the time the token expires keyId (k) - the key identifier of the private key that was used to sign this token ip (i) - the IP address where the request to get this token was initiated from authorized-services (b) - the list of services authorized to use this user token signature (s) - the signature of the other items The single letter in parentheses is the key in the serialized string, where semicolons separate key value pairs, and the key and value are separated by an equals sign. For example: v=U1;d=user;n=joe;h=host.athenz.org;a=bb4e;t=1442255237;e=1442258837;k=0;i=10.72.42.32;s=Jw8SvYGYrk Note that requests that include a principal token should be protected to keep the token from being intercepted and reused (for the lifetime of the token). It is strongly recommended to always use HTTPS for such requests.","title":"Principal Token (NToken)"},{"location":"data_model/#access-tokens","text":"Athenz supports the OAuth2 standard by enabling the generation of Access Tokens. Access tokens represent an authoritative statement that a given principal may assume some number of roles in a domain for a limited period. They are signed to prevent tampering. Using Access Tokens instead of directly asking for an access check with a principal identity, reduces the chance of providing identity details to a compromised service. This mechanism also allows a service to make a completely local access check against the cached policies used by the policy engine.","title":"Access Tokens"},{"location":"decent_authz_flow/","text":"In this section, we're going to examine the decentralized authorization flow. Subsystems \u00b6 Before we go into the details of the authorization flow, it's important to understand the subsystems. ZMS (AuthZ Management System) \u00b6 ZMS is where domains, roles, and policies are defined. This is Athenz's centralized authorization system and is likely part of a larger management system. In addition to allowing CRUD operations on the basic entities, ZMS provides an API to replicate the entities, per domain, to ZTS. It also can directly support the access check, both for internal management system checks, as well as a simple centralized deployment. ZMS is the source of truth for domains, roles, and policies for centralized authorization. ZMS supports a centralized call to check if a principal has access to a resource. Because ZMS supports service identities, ZMS can authenticate services. SIA (Service Identity Agent) \u00b6 SIA is required for authenticating existing services. Any service should integrate SIA (or an equivalent system). To confirm a service's identity, SIA communicates with ZTS. ZTS (AuthZ Token System) \u00b6 ZTS, the authentication token service, is only needed to support decentralized or data plane functionality. In many ways, ZTS is like a local replica of ZMS's data to check a principal's authentication and confirm membership in roles within a domain. The authentication is in the form of a signed Access Token that can be presented to any decentralized service that wants to authorize access efficiently. If needed, multiple ZTS instances will be distributed to different data centers as needed to scale for issuing tokens. ZPE (AuthZ Policy Engine) \u00b6 Like ZTS, ZPE, the authorization policy engine is only needed to support the decentralized authorization. ZPE is the subsystem of Athenz that evaluates policies for a set of roles to yield an allowed or a denied response. ZPE is a library that your service calls and only refers to a local policy cache for your services domain (a small amount of data). ZPU (AuthZ PolicyEngine Updater) \u00b6 Like ZTS and ZPE, ZPU is only needed to support the decentralized authorization. The policy updater is the utility that retrieves from ZTS the policy files for provisioned domains on a host, which ZPE uses to evaluate access requests. Decentralized Access Control \u00b6 A more interesting scenario introduces the local policy engine (ZPE), and a few supporting changes. Rather than directly asking for an access check with a principal identity, the identity is instead used to get an Access Token, and that is presented to the target service until it expires. This mechanism allows a service to make a completely local access check against ZPE, given an Access Token and locally cached policies. Specifically, as shown in the diagram below, the client service/user uses its identity x.509 certificate along with its private key that it got from local SIA (1) to get an authorization token (Access Token) from ZTS (2), and then presents the access token to a target service to access its resources (3). That service can make use of a local ZPE to validate the role assertions in the access token, and then correlate them to the asynchronously updated Policies for the domain involved. The ZPE can make the decision locally, without going off box. It has no knowledge about specific users, only roles, and because roles and policies are always in the domain, the amount of data to distribute to the machine is small. The model works exactly the same when using X.509 certificates instead of tokens. The service would use its identity X.509 certificate to request a X.509 Role Certificate from ZTS and then would make the call to the target service using the X.509 Role Certificate. The target service would first validate the X.509 Certificate and call ZPE to extract the role certificate to carry out the authorization check.","title":"Decentralized Authorization Flow"},{"location":"decent_authz_flow/#subsystems","text":"Before we go into the details of the authorization flow, it's important to understand the subsystems.","title":"Subsystems"},{"location":"decent_authz_flow/#zms-authz-management-system","text":"ZMS is where domains, roles, and policies are defined. This is Athenz's centralized authorization system and is likely part of a larger management system. In addition to allowing CRUD operations on the basic entities, ZMS provides an API to replicate the entities, per domain, to ZTS. It also can directly support the access check, both for internal management system checks, as well as a simple centralized deployment. ZMS is the source of truth for domains, roles, and policies for centralized authorization. ZMS supports a centralized call to check if a principal has access to a resource. Because ZMS supports service identities, ZMS can authenticate services.","title":"ZMS (AuthZ Management System)"},{"location":"decent_authz_flow/#sia-service-identity-agent","text":"SIA is required for authenticating existing services. Any service should integrate SIA (or an equivalent system). To confirm a service's identity, SIA communicates with ZTS.","title":"SIA (Service Identity Agent)"},{"location":"decent_authz_flow/#zts-authz-token-system","text":"ZTS, the authentication token service, is only needed to support decentralized or data plane functionality. In many ways, ZTS is like a local replica of ZMS's data to check a principal's authentication and confirm membership in roles within a domain. The authentication is in the form of a signed Access Token that can be presented to any decentralized service that wants to authorize access efficiently. If needed, multiple ZTS instances will be distributed to different data centers as needed to scale for issuing tokens.","title":"ZTS (AuthZ Token System)"},{"location":"decent_authz_flow/#zpe-authz-policy-engine","text":"Like ZTS, ZPE, the authorization policy engine is only needed to support the decentralized authorization. ZPE is the subsystem of Athenz that evaluates policies for a set of roles to yield an allowed or a denied response. ZPE is a library that your service calls and only refers to a local policy cache for your services domain (a small amount of data).","title":"ZPE (AuthZ Policy Engine)"},{"location":"decent_authz_flow/#zpu-authz-policyengine-updater","text":"Like ZTS and ZPE, ZPU is only needed to support the decentralized authorization. The policy updater is the utility that retrieves from ZTS the policy files for provisioned domains on a host, which ZPE uses to evaluate access requests.","title":"ZPU (AuthZ PolicyEngine Updater)"},{"location":"decent_authz_flow/#decentralized-access-control","text":"A more interesting scenario introduces the local policy engine (ZPE), and a few supporting changes. Rather than directly asking for an access check with a principal identity, the identity is instead used to get an Access Token, and that is presented to the target service until it expires. This mechanism allows a service to make a completely local access check against ZPE, given an Access Token and locally cached policies. Specifically, as shown in the diagram below, the client service/user uses its identity x.509 certificate along with its private key that it got from local SIA (1) to get an authorization token (Access Token) from ZTS (2), and then presents the access token to a target service to access its resources (3). That service can make use of a local ZPE to validate the role assertions in the access token, and then correlate them to the asynchronously updated Policies for the domain involved. The ZPE can make the decision locally, without going off box. It has no knowledge about specific users, only roles, and because roles and policies are always in the domain, the amount of data to distribute to the machine is small. The model works exactly the same when using X.509 certificates instead of tokens. The service would use its identity X.509 certificate to request a X.509 Role Certificate from ZTS and then would make the call to the target service using the X.509 Role Certificate. The target service would first validate the X.509 Certificate and call ZPE to extract the role certificate to carry out the authorization check.","title":"Decentralized Access Control"},{"location":"dev_environment/","text":"Development Environment \u00b6 Development Tools Java Platform JDK 8 Maven Git Client Go Node JS Build Steps Development Tools \u00b6 If you would like to build your own copy of Athenz rather than using the pre-built binary packages, then here is the list of development tools you need to have installed on your system. Java Platform JDK 8 \u00b6 To build Athenz components, you must have Java Platform JDK 8 installed on your machine. The main authorization services - ZMS and ZTS, are written in Java and using embedded Jetty. Oracle Java Platform JDK 8 Athenz has been developed and tested with Oracle Java Platform JDK 8. However, it should compile and run without any issues with OpenJDK 8 as well. Maven \u00b6 Download and install Apache Maven . Git Client \u00b6 If you don't have git client installed on your host, you can download one from Git website . 2.x version of the git client is required. Go \u00b6 Install go by following the directions at Getting Started - The Go Programming Language . Node JS \u00b6 Install node by following the directions at Node.js JavaScript Runtime Verify that you have the required minimum version of node and nodemon binaries installed on your system and are included in your runtime path: $ node --version v6.9.4 $ npm install -g nodemon $ nodemon --version 1 .11.0 Build Steps \u00b6 To build Athenz components, change to the top level directory where Athenz code has been checked out and execute: $ git clone https://github.com/AthenZ/athenz.git $ cd athenz $ mvn clean install The release packages will be created automatically in the assembly subdirectory.","title":"Development Environment"},{"location":"dev_environment/#development-environment","text":"Development Tools Java Platform JDK 8 Maven Git Client Go Node JS Build Steps","title":"Development Environment"},{"location":"dev_environment/#development-tools","text":"If you would like to build your own copy of Athenz rather than using the pre-built binary packages, then here is the list of development tools you need to have installed on your system.","title":"Development Tools"},{"location":"dev_environment/#java-platform-jdk-8","text":"To build Athenz components, you must have Java Platform JDK 8 installed on your machine. The main authorization services - ZMS and ZTS, are written in Java and using embedded Jetty. Oracle Java Platform JDK 8 Athenz has been developed and tested with Oracle Java Platform JDK 8. However, it should compile and run without any issues with OpenJDK 8 as well.","title":"Java Platform JDK 8"},{"location":"dev_environment/#maven","text":"Download and install Apache Maven .","title":"Maven"},{"location":"dev_environment/#git-client","text":"If you don't have git client installed on your host, you can download one from Git website . 2.x version of the git client is required.","title":"Git Client"},{"location":"dev_environment/#go","text":"Install go by following the directions at Getting Started - The Go Programming Language .","title":"Go"},{"location":"dev_environment/#node-js","text":"Install node by following the directions at Node.js JavaScript Runtime Verify that you have the required minimum version of node and nodemon binaries installed on your system and are included in your runtime path: $ node --version v6.9.4 $ npm install -g nodemon $ nodemon --version 1 .11.0","title":"Node JS"},{"location":"dev_environment/#build-steps","text":"To build Athenz components, change to the top level directory where Athenz code has been checked out and execute: $ git clone https://github.com/AthenZ/athenz.git $ cd athenz $ mvn clean install The release packages will be created automatically in the assembly subdirectory.","title":"Build Steps"},{"location":"email_notifications/","text":"Athenz can send email notifications for events such as a role member with access that about to expire. Athenz supports Amazon Simple Email Service (Amazon SES) out of the box. This requires Athenz to be deployed on AWS. Users may use other Email Providers by following the steps to Enable Notifications using other Providers Enable Email Notifications using Amazon Simple Email Service (Amazon SES) \u00b6 Enable Email Notifications for ZMS server by editing the zms.properties file: # Notification: Factory class using AWS SES implementation to send out email notifications athenz.zms.notification_service_factory_class=com.yahoo.athenz.common.server.notification.impl.NotificationServiceFactoryImpl # Notification: Email domain from athenz.notification_email_domain_from=from.domain.com # Notification: Email from athenz.notification_email_from=sender.name # Notification: Email domain to athenz.notification_email_domain_to=to.domain.com # Notification: Workflow url for approvers to click from within email body to take action on the notification athenz.notification_workflow_url=https://your.athenz.ui/athenz/workflow # Notification: Athenz UI Link included in Expiry Reminder Emails athenz.notification_athenz_ui_url=https://your.athenz.ui/athenz Enable Notifications using other Providers \u00b6 To use other providers, create a Jar file on the Athenz classpath with implementations for the following Interface: com.yahoo.athenz.common.server.notification.NotificationServiceFactory - A factory that creates a Notification Service based on a Notifications Provider. You may use the existing com.yahoo.athenz.common.server.notification.impl.EmailNotificationService and inject a new provider or implement a compleley new Notifications Provider that will notify users by means other than email. If you do plan on sending email notifications, implement the following interface: com.yahoo.athenz.common.server.notification.EmailProvider For example, to enable Email Notifications with your provider, you may implement com.yahoo.athenz.common.server.notification.NotificationServiceFactory like so: package your.packge ; import com.yahoo.athenz.common.server.notification.impl.EmailNotificationService ; public class YourNotificationServiceFactory implements NotificationServiceFactory { @Override public NotificationService create () { return new EmailNotificationService ( new YourEmailProvider ()); } } Once the jar is ready, change the value of athenz.zms.notification_service_factory_class in the zms.properties file to your factory class: athenz.zms.notification_service_factory_class=your.packge.YourNotificationServiceFactory We can also send notifications to more than one service by specifying all service factories. For example, if we would like notifications to be sent via your.packge.YourNotificationServiceFactory and their.packge.TheirNotificationServiceFactory , specify both values in the property using , as a delimiter: athenz.zms.notification_service_factory_class=your.packge.YourNotificationServiceFactory, their.packge.TheirNotificationServiceFactory","title":"Email Notifications"},{"location":"email_notifications/#enable-email-notifications-using-amazon-simple-email-service-amazon-ses","text":"Enable Email Notifications for ZMS server by editing the zms.properties file: # Notification: Factory class using AWS SES implementation to send out email notifications athenz.zms.notification_service_factory_class=com.yahoo.athenz.common.server.notification.impl.NotificationServiceFactoryImpl # Notification: Email domain from athenz.notification_email_domain_from=from.domain.com # Notification: Email from athenz.notification_email_from=sender.name # Notification: Email domain to athenz.notification_email_domain_to=to.domain.com # Notification: Workflow url for approvers to click from within email body to take action on the notification athenz.notification_workflow_url=https://your.athenz.ui/athenz/workflow # Notification: Athenz UI Link included in Expiry Reminder Emails athenz.notification_athenz_ui_url=https://your.athenz.ui/athenz","title":"Enable Email Notifications using Amazon Simple Email Service (Amazon SES)"},{"location":"email_notifications/#enable-notifications-using-other-providers","text":"To use other providers, create a Jar file on the Athenz classpath with implementations for the following Interface: com.yahoo.athenz.common.server.notification.NotificationServiceFactory - A factory that creates a Notification Service based on a Notifications Provider. You may use the existing com.yahoo.athenz.common.server.notification.impl.EmailNotificationService and inject a new provider or implement a compleley new Notifications Provider that will notify users by means other than email. If you do plan on sending email notifications, implement the following interface: com.yahoo.athenz.common.server.notification.EmailProvider For example, to enable Email Notifications with your provider, you may implement com.yahoo.athenz.common.server.notification.NotificationServiceFactory like so: package your.packge ; import com.yahoo.athenz.common.server.notification.impl.EmailNotificationService ; public class YourNotificationServiceFactory implements NotificationServiceFactory { @Override public NotificationService create () { return new EmailNotificationService ( new YourEmailProvider ()); } } Once the jar is ready, change the value of athenz.zms.notification_service_factory_class in the zms.properties file to your factory class: athenz.zms.notification_service_factory_class=your.packge.YourNotificationServiceFactory We can also send notifications to more than one service by specifying all service factories. For example, if we would like notifications to be sent via your.packge.YourNotificationServiceFactory and their.packge.TheirNotificationServiceFactory , specify both values in the property using , as a delimiter: athenz.zms.notification_service_factory_class=your.packge.YourNotificationServiceFactory, their.packge.TheirNotificationServiceFactory","title":"Enable Notifications using other Providers"},{"location":"events_monitoring/","text":"Athenz can be monitored by capturing events using an Event monitoring service. Athenz Events \u00b6 The following events can be sent by Athenz API HTTP Requests - Name of API method, status and duration Certificate Requests Email Reminders and Notifications Enable ZMS Event Monitoring in Prometheus \u00b6 Enable ZMS Event Monitoring in Prometheus for ZMS server by performing the following steps: Build the athenz_metrics_prometheus Java project located in contributions/metric/prometheus Place it in the ZMS Server classpath Edit the zms.properties file: # Specifies the factory class that implements the Metrics interface # used by the ZMS Server to report stats athenz.zms.metric_factory_class=com.yahoo.athenz.common.metrics.impl.prometheus.PrometheusMetricFactory Enable ZTS Event Monitoring in Prometheus \u00b6 Enable ZTS Event Monitoring in Prometheus for ZTS server by performing the following steps: Build the athenz_metrics_prometheus Java project located in contributions/metric/prometheus Place it in the ZTS Server classpath Edit the zts.properties file: # Specifies the factory class that implements the Metrics interface # used by the ZTS Server to report stats athenz.zts.metric_factory_class=com.yahoo.athenz.common.metrics.impl.prometheus.PrometheusMetricFactory Enable Email Notifications Monitoring \u00b6 You may also choose to enable Email Notifications and record the notifications sent in an Event Monitoring Service. The Event Monitoring Service may be the same one used to record other Athenz Events or can be a dedicated service that captures Notification Events only. To enable Notification Events for Prometheus, perform the following steps: Enable Email Notifications by following the steps in Email Notifications Edit the athenz.zms.notification_service_factory_class property to also include the MetricNotificationServiceFactory class. For example, if the NotificationServiceFactory used is com.yahoo.athenz.common.server.notification.impl.NotificationServiceFactoryImpl (the default AWS Email Notification Service Factory), then the property should be: athenz.zms.notification_service_factory_class=com.yahoo.athenz.common.server.notification.impl.NotificationServiceFactoryImpl, com.yahoo.athenz.common.server.notification.impl.MetricNotificationServiceFactory Build the athenz_metrics_prometheus Java project located in contributions/metric/prometheus Place it in the ZMS / ZTS Server classpath Edit the zts.properties file for ZTS and zms.properties file to ZMS: # Specifies the factory class that implements the Metrics interface # used to record Notification Events athenz.notification.metric_factory_class=com.yahoo.athenz.common.metrics.impl.prometheus.PrometheusMetricFactory Enable Event Monitoring using other Event Monitoring Services \u00b6 To use Monitoring Services other than Prometheus, create a Jar file on the Athenz classpath with implementations for the following Interface: com.yahoo.athenz.common.metrics.MetricFactory - A factory that creates a Notification Service based on a Notifications Provider.","title":"Events Monitoring"},{"location":"events_monitoring/#athenz-events","text":"The following events can be sent by Athenz API HTTP Requests - Name of API method, status and duration Certificate Requests Email Reminders and Notifications","title":"Athenz Events"},{"location":"events_monitoring/#enable-zms-event-monitoring-in-prometheus","text":"Enable ZMS Event Monitoring in Prometheus for ZMS server by performing the following steps: Build the athenz_metrics_prometheus Java project located in contributions/metric/prometheus Place it in the ZMS Server classpath Edit the zms.properties file: # Specifies the factory class that implements the Metrics interface # used by the ZMS Server to report stats athenz.zms.metric_factory_class=com.yahoo.athenz.common.metrics.impl.prometheus.PrometheusMetricFactory","title":"Enable ZMS Event Monitoring in Prometheus"},{"location":"events_monitoring/#enable-zts-event-monitoring-in-prometheus","text":"Enable ZTS Event Monitoring in Prometheus for ZTS server by performing the following steps: Build the athenz_metrics_prometheus Java project located in contributions/metric/prometheus Place it in the ZTS Server classpath Edit the zts.properties file: # Specifies the factory class that implements the Metrics interface # used by the ZTS Server to report stats athenz.zts.metric_factory_class=com.yahoo.athenz.common.metrics.impl.prometheus.PrometheusMetricFactory","title":"Enable ZTS Event Monitoring in Prometheus"},{"location":"events_monitoring/#enable-email-notifications-monitoring","text":"You may also choose to enable Email Notifications and record the notifications sent in an Event Monitoring Service. The Event Monitoring Service may be the same one used to record other Athenz Events or can be a dedicated service that captures Notification Events only. To enable Notification Events for Prometheus, perform the following steps: Enable Email Notifications by following the steps in Email Notifications Edit the athenz.zms.notification_service_factory_class property to also include the MetricNotificationServiceFactory class. For example, if the NotificationServiceFactory used is com.yahoo.athenz.common.server.notification.impl.NotificationServiceFactoryImpl (the default AWS Email Notification Service Factory), then the property should be: athenz.zms.notification_service_factory_class=com.yahoo.athenz.common.server.notification.impl.NotificationServiceFactoryImpl, com.yahoo.athenz.common.server.notification.impl.MetricNotificationServiceFactory Build the athenz_metrics_prometheus Java project located in contributions/metric/prometheus Place it in the ZMS / ZTS Server classpath Edit the zts.properties file for ZTS and zms.properties file to ZMS: # Specifies the factory class that implements the Metrics interface # used to record Notification Events athenz.notification.metric_factory_class=com.yahoo.athenz.common.metrics.impl.prometheus.PrometheusMetricFactory","title":"Enable Email Notifications Monitoring"},{"location":"events_monitoring/#enable-event-monitoring-using-other-event-monitoring-services","text":"To use Monitoring Services other than Prometheus, create a Jar file on the Athenz classpath with implementations for the following Interface: com.yahoo.athenz.common.metrics.MetricFactory - A factory that creates a Notification Service based on a Notifications Provider.","title":"Enable Event Monitoring using other Event Monitoring Services"},{"location":"example_go_centralized_access/","text":"Go Client/Server Example - Centralized Access Control \u00b6 Required Components Service Definition Resource Definition Athenz Management Setup Code Changes Client Changes Client Import Dependency Update Obtaining NTokens Build Go zms_svctoken Client Utility Server Changes Server Project Dependency Update Authorization Checks Build Server Deploying Example Servlet Test Cases Invalid Access Without ServiceToken Movie Editor Access TvShow Editor Access Site Editor Access Other Test Cases In the centralized access control model, the service as a principal requests its NToken from SIA Provider and then presents it to the target service which would perform an identical check with ZMS to confirm access. The required steps to setup the environment for provider and tenant services to support centralized access control are as follows: System administrator creates the provider and tenant domains. Tenant Domain administrator generates a public/private key pair and registers a service in its domain. Provider Domain administrator creates a role and policy that grants access to the given role with configured action and resource. Provider Domain administrator adds the Tenant Service to the role to grant access. Tenant Domain administrator installs the private key on the host that will be running the client/tenant service. Required Components \u00b6 To support centralized access control in your applications, you only need to install and configure the Athenz ZMS server along with the Athenz UI. Please follow these guides to make sure you have both of those components up and running in your environment: ZMS Server UI Server To build the client and server components of this example, you need to download and install Go and Git client if you don't already have these available on your box: The Go Programming Language Git client Make sure your GOPATH variable is set and the PATH variable includes the $(GOPATH)/bin to run the utilities. Service Definition \u00b6 Let's first define our service that needs to be Athenz protected. We have a simple recommendation service that returns either a movie or tv show for the caller. It has two endpoints: GET /rec/v1/movie GET /rec/v1/tvshow So in this first release we just want to protect access to these endpoints. The traffic is very low - we only expect a couple of requests an hour so we have decided to use Athenz' centralized authorization model. Resource Definition \u00b6 Defining resources and actions the principals are authorized to execute is one of the most important tasks in the authorization process. Based on our endpoints, it's expected that we'll have 2 general resources: movie tvshow The resources are referenced in their own domain namespace. So those are valid if your domain is specifically created to support this recommendation service only. But's lets assume we might add rental support later, so we need to make sure the policies are based on service specific resources. So we'll define our resources as: rec.movie rec.tvshow Support action for these resources would be read . We can extend our authorization policies later on if we need to introduce other actions - such as write or list as we add more functionality into our service. Athenz Management Setup \u00b6 Once we have defined what our resources and actions are, we can create their respective client and server (also commonly referred as tenant and provider) roles and policies in Athenz. Go to Athenz UI and login with your account which should have system administrator access. Follow the instructions in the following guide to setup the required access control: Access Control Setup Code Changes \u00b6 Both the client and server implementors need to make changes in their respective code bases to support centralized authorization checks. The client needs to make sure to submit its service identity as part of its request, while the service needs to carry out the authorization check based on that service identity to determine if it request should be processed or not. Client Changes \u00b6 While we'll use the curl client to make the http calls to our example service, we provide a sample client code that utilizes our zmssvctoken go library to generate service identity tokens. The full client source code is available from: https://github.com/AthenZ/athenz/blob/master/utils/zms-svctoken/zms-svctoken.go Client Import Dependency Update \u00b6 First you need to update your go client to import the zms service token library. import ( \"github.com/AthenZ/athenz/libs/go/zmssvctoken\" ) Obtaining NTokens \u00b6 The domain administrator must have already generated a public/private key pair for the service and registered public key in Athenz. The private key must be available on the host where the client will be running. // load private key bytes , err := ioutil . ReadFile ( privateKeyFile ) if err != nil { log . Fatalln ( err ) } // get token builder instance builder , err := zmssvctoken . NewTokenBuilder ( domain , service , bytes , keyVersion ) if err != nil { log . Fatalln ( err ) } // set optional attributes builder . SetExpiration ( 60 * time . Minute ) tok := builder . Token () // get a token for use ntoken , err := tok . Value () Once we have our ntoken value, the http client before contacting the provider service needs to add it as the value for the Athenz-Principal-Auth header: req , err := http . NewRequest ( \"GET\" , \"http://recommend-host/rec/v1/movie\" , nil ) // ... req . Header . Add ( \"Athenz-Principal-Auth\" , ntoken ) Build Go zms_svctoken Client Utility \u00b6 To download, compile and install zms_svctoken utility, execute the following command: $ go get github.com/AthenZ/athenz/utils/zms-svctoken/... Server Changes \u00b6 The full server source code is available from: https://github.com/AthenZ/athenz/tree/master/examples/go/centralized-use-case/server Server Import Dependency Update \u00b6 First you need to update your go client to import the zms client library. import ( \"github.com/AthenZ/athenz/clients/go/zms\" ) Authorization Checks \u00b6 Before any authorization calls, we're going to check to make sure our request contains the Athenz principal token: const authHeader = \"Athenz-Principal-Auth\" func movieHandler ( w http . ResponseWriter , r * http . Request ) { // first let's verify that we have an ntoken if r . Header [ authHeader ] == nil { http . Error ( w , \"403 - Missing NToken\" , 403 ) return } ... } } Next, the most important part is to determine the resource and action based on the given http request. Since we have a separate handler for each endpoint: http . HandleFunc ( \"/rec/v1/movie\" , movieHandler ) http . HandleFunc ( \"/rec/v1/tvshow\" , tvshowHandler ) each function knows exactly what the resource and the action is. Finally, we are going to contact ZMS for the authorization check. func movieHandler ( w http . ResponseWriter , r * http . Request ) { ... // let's generate our resource value which is the // <provider domain>:<entity value> resource := providerDomain + \":rec.movie\" // let's check with ZMS if the principal is authorized if ! authorizeRequest ( r . Header [ authHeader ][ 0 ], resource , \"read\" ) { http . Error ( w , \"403 - Unauthorized access\" , 403 ) return } io . WriteString ( w , \"Name: Slap Shot; Director: George Roy Hill\\n\" ) } func authorizeRequest ( ntoken , resource , action string ) bool { // for our test example we're just going to skip // validating self-signed certificates tr := http . Transport {} config := & tls . Config {} config . InsecureSkipVerify = true tr . TLSClientConfig = config zmsClient := zms . ZMSClient { URL : zmsUrl , Transport : & tr , } zmsClient . AddCredentials ( authHeader , ntoken ) access , err := zmsClient . GetAccess ( zms . ActionName ( action ), zms . ResourceName ( resource ), \"\" , \"\" ) if err != nil { fmt . Println ( \"Unable to verify access: %v\" , err ) return false } return access . Granted } Build Server \u00b6 Checkout and build the server component: $ go get github.com/AthenZ/athenz/examples/go/centralized-use-case/server Deploying Example Server \u00b6 To run the Go server, you just need to specify the ZMS Server url. The server listens on port 8080: $ recommend -zms https://<zms-server>:4443/zms/v1 Test Cases \u00b6 Run the following test cases to verify authorization access for specific services. We're running our go server on the local box so we're using localhost as the hostname. The zms_svctoken utility should already be built and installed on your host. cd to the directory that includes the private keys for the test services we created in the section Athenz Management Setup above. Invalid Access Without ServiceToken \u00b6 For this test case we'll just use the curl client directly: $ curl http://localhost:8080/rec/v1/movie 403 - Missing NToken Movie Editor Access \u00b6 Movie service can successfully access /rec/v1/movie endpoint. So let's first generate an NToken for this service and then contact our server: $ export NTOKEN = ` zms_svctoken -domain editors -service movie -private-key movie_private.pem -key-version v0 ` $ curl -H \"Athenz-Principal-Auth: $NTOKEN \" http://localhost:8080/rec/v1/movie Name: Slap Shot ; Director: George Roy Hill Movie service does not have access to /rec/v1/tvshow endpoint: $ export NTOKEN = ` zms_svctoken -domain editors -service movie -private-key movie_private.pem -key-version v0 ` $ curl -H \"Athenz-Principal-Auth: $NTOKEN \" http://localhost:8080/rec/v1/tvshow 403 - Unauthorized access TvShow Editor Access \u00b6 TvShow service can successfully access /rec/v1/tvshow endpoint. So let's first generate an NToken for this service and then contact our server: $ export NTOKEN = ` zms_svctoken -domain editors -service tvshow -private-key tvshow_private.pem -key-version v0 ` $ curl -H \"Athenz-Principal-Auth: $NTOKEN \" http://localhost:8080/rec/v1/tvshow Name: Middle ; Channel: ABC TvShow service does not have access to /rec/v1/movie endpoint: $ export NTOKEN = ` zms_svctoken -domain editors -service tvshow -private-key tvshow_private.pem -key-version v0 ` $ curl -H \"Athenz-Principal-Auth: $NTOKEN \" http://localhost:8080/rec/v1/movie 403 - Unauthorized access Site Editor Access \u00b6 Site service has access to both /rec/v1/tvshow and /rec/v1/movie endpoints: $ export NTOKEN = ` zms_svctoken -domain editors -service site -private-key site_private.pem -key-version v0 ` $ curl -H \"Athenz-Principal-Auth: $NTOKEN \" http://localhost:8080/rec/v1/movie Name: Slap Shot ; Director: George Roy Hill $ curl -H \"Athenz-Principal-Auth: $NTOKEN \" http://localhost:8080/rec/v1/tvshow Name: Middle ; Channel: ABC Other Test Cases \u00b6 Now you can modify the movie_editos, tvshow_editors, and site_editors roles in the recommend domain to add and remove the defined services and then run the corresponding test cases to verify your access change.","title":"Go Client/Server Example"},{"location":"example_go_centralized_access/#go-clientserver-example-centralized-access-control","text":"Required Components Service Definition Resource Definition Athenz Management Setup Code Changes Client Changes Client Import Dependency Update Obtaining NTokens Build Go zms_svctoken Client Utility Server Changes Server Project Dependency Update Authorization Checks Build Server Deploying Example Servlet Test Cases Invalid Access Without ServiceToken Movie Editor Access TvShow Editor Access Site Editor Access Other Test Cases In the centralized access control model, the service as a principal requests its NToken from SIA Provider and then presents it to the target service which would perform an identical check with ZMS to confirm access. The required steps to setup the environment for provider and tenant services to support centralized access control are as follows: System administrator creates the provider and tenant domains. Tenant Domain administrator generates a public/private key pair and registers a service in its domain. Provider Domain administrator creates a role and policy that grants access to the given role with configured action and resource. Provider Domain administrator adds the Tenant Service to the role to grant access. Tenant Domain administrator installs the private key on the host that will be running the client/tenant service.","title":"Go Client/Server Example - Centralized Access Control"},{"location":"example_go_centralized_access/#required-components","text":"To support centralized access control in your applications, you only need to install and configure the Athenz ZMS server along with the Athenz UI. Please follow these guides to make sure you have both of those components up and running in your environment: ZMS Server UI Server To build the client and server components of this example, you need to download and install Go and Git client if you don't already have these available on your box: The Go Programming Language Git client Make sure your GOPATH variable is set and the PATH variable includes the $(GOPATH)/bin to run the utilities.","title":"Required Components"},{"location":"example_go_centralized_access/#service-definition","text":"Let's first define our service that needs to be Athenz protected. We have a simple recommendation service that returns either a movie or tv show for the caller. It has two endpoints: GET /rec/v1/movie GET /rec/v1/tvshow So in this first release we just want to protect access to these endpoints. The traffic is very low - we only expect a couple of requests an hour so we have decided to use Athenz' centralized authorization model.","title":"Service Definition"},{"location":"example_go_centralized_access/#resource-definition","text":"Defining resources and actions the principals are authorized to execute is one of the most important tasks in the authorization process. Based on our endpoints, it's expected that we'll have 2 general resources: movie tvshow The resources are referenced in their own domain namespace. So those are valid if your domain is specifically created to support this recommendation service only. But's lets assume we might add rental support later, so we need to make sure the policies are based on service specific resources. So we'll define our resources as: rec.movie rec.tvshow Support action for these resources would be read . We can extend our authorization policies later on if we need to introduce other actions - such as write or list as we add more functionality into our service.","title":"Resource Definition"},{"location":"example_go_centralized_access/#athenz-management-setup","text":"Once we have defined what our resources and actions are, we can create their respective client and server (also commonly referred as tenant and provider) roles and policies in Athenz. Go to Athenz UI and login with your account which should have system administrator access. Follow the instructions in the following guide to setup the required access control: Access Control Setup","title":"Athenz Management Setup"},{"location":"example_go_centralized_access/#code-changes","text":"Both the client and server implementors need to make changes in their respective code bases to support centralized authorization checks. The client needs to make sure to submit its service identity as part of its request, while the service needs to carry out the authorization check based on that service identity to determine if it request should be processed or not.","title":"Code Changes"},{"location":"example_go_centralized_access/#client-changes","text":"While we'll use the curl client to make the http calls to our example service, we provide a sample client code that utilizes our zmssvctoken go library to generate service identity tokens. The full client source code is available from: https://github.com/AthenZ/athenz/blob/master/utils/zms-svctoken/zms-svctoken.go","title":"Client Changes"},{"location":"example_go_centralized_access/#client-import-dependency-update","text":"First you need to update your go client to import the zms service token library. import ( \"github.com/AthenZ/athenz/libs/go/zmssvctoken\" )","title":"Client Import Dependency Update"},{"location":"example_go_centralized_access/#obtaining-ntokens","text":"The domain administrator must have already generated a public/private key pair for the service and registered public key in Athenz. The private key must be available on the host where the client will be running. // load private key bytes , err := ioutil . ReadFile ( privateKeyFile ) if err != nil { log . Fatalln ( err ) } // get token builder instance builder , err := zmssvctoken . NewTokenBuilder ( domain , service , bytes , keyVersion ) if err != nil { log . Fatalln ( err ) } // set optional attributes builder . SetExpiration ( 60 * time . Minute ) tok := builder . Token () // get a token for use ntoken , err := tok . Value () Once we have our ntoken value, the http client before contacting the provider service needs to add it as the value for the Athenz-Principal-Auth header: req , err := http . NewRequest ( \"GET\" , \"http://recommend-host/rec/v1/movie\" , nil ) // ... req . Header . Add ( \"Athenz-Principal-Auth\" , ntoken )","title":"Obtaining NTokens"},{"location":"example_go_centralized_access/#build-go-zms_svctoken-client-utility","text":"To download, compile and install zms_svctoken utility, execute the following command: $ go get github.com/AthenZ/athenz/utils/zms-svctoken/...","title":"Build Go zms_svctoken Client Utility"},{"location":"example_go_centralized_access/#server-changes","text":"The full server source code is available from: https://github.com/AthenZ/athenz/tree/master/examples/go/centralized-use-case/server","title":"Server Changes"},{"location":"example_go_centralized_access/#server-import-dependency-update","text":"First you need to update your go client to import the zms client library. import ( \"github.com/AthenZ/athenz/clients/go/zms\" )","title":"Server Import Dependency Update"},{"location":"example_go_centralized_access/#authorization-checks","text":"Before any authorization calls, we're going to check to make sure our request contains the Athenz principal token: const authHeader = \"Athenz-Principal-Auth\" func movieHandler ( w http . ResponseWriter , r * http . Request ) { // first let's verify that we have an ntoken if r . Header [ authHeader ] == nil { http . Error ( w , \"403 - Missing NToken\" , 403 ) return } ... } } Next, the most important part is to determine the resource and action based on the given http request. Since we have a separate handler for each endpoint: http . HandleFunc ( \"/rec/v1/movie\" , movieHandler ) http . HandleFunc ( \"/rec/v1/tvshow\" , tvshowHandler ) each function knows exactly what the resource and the action is. Finally, we are going to contact ZMS for the authorization check. func movieHandler ( w http . ResponseWriter , r * http . Request ) { ... // let's generate our resource value which is the // <provider domain>:<entity value> resource := providerDomain + \":rec.movie\" // let's check with ZMS if the principal is authorized if ! authorizeRequest ( r . Header [ authHeader ][ 0 ], resource , \"read\" ) { http . Error ( w , \"403 - Unauthorized access\" , 403 ) return } io . WriteString ( w , \"Name: Slap Shot; Director: George Roy Hill\\n\" ) } func authorizeRequest ( ntoken , resource , action string ) bool { // for our test example we're just going to skip // validating self-signed certificates tr := http . Transport {} config := & tls . Config {} config . InsecureSkipVerify = true tr . TLSClientConfig = config zmsClient := zms . ZMSClient { URL : zmsUrl , Transport : & tr , } zmsClient . AddCredentials ( authHeader , ntoken ) access , err := zmsClient . GetAccess ( zms . ActionName ( action ), zms . ResourceName ( resource ), \"\" , \"\" ) if err != nil { fmt . Println ( \"Unable to verify access: %v\" , err ) return false } return access . Granted }","title":"Authorization Checks"},{"location":"example_go_centralized_access/#build-server","text":"Checkout and build the server component: $ go get github.com/AthenZ/athenz/examples/go/centralized-use-case/server","title":"Build Server"},{"location":"example_go_centralized_access/#deploying-example-server","text":"To run the Go server, you just need to specify the ZMS Server url. The server listens on port 8080: $ recommend -zms https://<zms-server>:4443/zms/v1","title":"Deploying Example Server"},{"location":"example_go_centralized_access/#test-cases","text":"Run the following test cases to verify authorization access for specific services. We're running our go server on the local box so we're using localhost as the hostname. The zms_svctoken utility should already be built and installed on your host. cd to the directory that includes the private keys for the test services we created in the section Athenz Management Setup above.","title":"Test Cases"},{"location":"example_go_centralized_access/#invalid-access-without-servicetoken","text":"For this test case we'll just use the curl client directly: $ curl http://localhost:8080/rec/v1/movie 403 - Missing NToken","title":"Invalid Access Without ServiceToken"},{"location":"example_go_centralized_access/#movie-editor-access","text":"Movie service can successfully access /rec/v1/movie endpoint. So let's first generate an NToken for this service and then contact our server: $ export NTOKEN = ` zms_svctoken -domain editors -service movie -private-key movie_private.pem -key-version v0 ` $ curl -H \"Athenz-Principal-Auth: $NTOKEN \" http://localhost:8080/rec/v1/movie Name: Slap Shot ; Director: George Roy Hill Movie service does not have access to /rec/v1/tvshow endpoint: $ export NTOKEN = ` zms_svctoken -domain editors -service movie -private-key movie_private.pem -key-version v0 ` $ curl -H \"Athenz-Principal-Auth: $NTOKEN \" http://localhost:8080/rec/v1/tvshow 403 - Unauthorized access","title":"Movie Editor Access"},{"location":"example_go_centralized_access/#tvshow-editor-access","text":"TvShow service can successfully access /rec/v1/tvshow endpoint. So let's first generate an NToken for this service and then contact our server: $ export NTOKEN = ` zms_svctoken -domain editors -service tvshow -private-key tvshow_private.pem -key-version v0 ` $ curl -H \"Athenz-Principal-Auth: $NTOKEN \" http://localhost:8080/rec/v1/tvshow Name: Middle ; Channel: ABC TvShow service does not have access to /rec/v1/movie endpoint: $ export NTOKEN = ` zms_svctoken -domain editors -service tvshow -private-key tvshow_private.pem -key-version v0 ` $ curl -H \"Athenz-Principal-Auth: $NTOKEN \" http://localhost:8080/rec/v1/movie 403 - Unauthorized access","title":"TvShow Editor Access"},{"location":"example_go_centralized_access/#site-editor-access","text":"Site service has access to both /rec/v1/tvshow and /rec/v1/movie endpoints: $ export NTOKEN = ` zms_svctoken -domain editors -service site -private-key site_private.pem -key-version v0 ` $ curl -H \"Athenz-Principal-Auth: $NTOKEN \" http://localhost:8080/rec/v1/movie Name: Slap Shot ; Director: George Roy Hill $ curl -H \"Athenz-Principal-Auth: $NTOKEN \" http://localhost:8080/rec/v1/tvshow Name: Middle ; Channel: ABC","title":"Site Editor Access"},{"location":"example_go_centralized_access/#other-test-cases","text":"Now you can modify the movie_editos, tvshow_editors, and site_editors roles in the recommend domain to add and remove the defined services and then run the corresponding test cases to verify your access change.","title":"Other Test Cases"},{"location":"example_java_centralized_access/","text":"Java Client/Servlet Example - Centralized Access Control \u00b6 Required Components Service Definition Resource Definition Athenz Management Setup Code Changes Getting an SSL Context to be used in Http Clients Client Project Dependency Update Build Http Client Utility Servlet Changes Servlet Project Dependency Update Enable TLS Client Certificate Authentication Authorization Checks Build Servlet Deploying Example Servlet Test Cases Invalid Access Without ServiceToken Movie Editor Access TvShow Editor Access Site Editor Access Other Test Cases In the centralized access control model, the service as a principal requests an X509 certificate from SIA Provider and then presents it to the target service which would perform an identical check with ZMS to confirm access. The required steps to setup the environment for provider and tenant services to support centralized access control are as follows: System administrator creates the provider and tenant domains. Tenant Domain administrator generates a public/private key pair and registers a service in its domain. Provider Domain administrator creates a role and policy that grants access to the given role with configured action and resource. Provider Domain administrator adds the Tenant Service to the role to grant access. Tenant Domain administrator installs the private key on the host that will be running the client/tenant service. Required Components \u00b6 To support centralized access control in your applications, you only need to install and configure the Athenz ZMS server along with the Athenz UI. Please follow these guides to make sure you have both of those components up and running in your environment: ZMS Server UI Server To build the client and servlet components of this example, you need to download and install Oracle JDK 8, Apache Maven and Git client if you don't already have these available on your box: Oracle Java Platform JDK 8 Apache Maven Git client Service Definition \u00b6 Let's first define our service that needs to be Athenz protected. We have a simple recommendation service that returns either a movie or tv show for the caller. It has two endpoints: GET /rec/v1/movie GET /rec/v1/tvshow So in this first release we just want to protect access to these endpoints. The traffic is very low - we only expect a couple of requests an hour so we have decided to use Athenz' centralized authorization model. Resource Definition \u00b6 Defining resources and actions the principals are authorized to execute is one of the most important tasks in the authorization process. Based on our endpoints, it's expected that we'll have 2 general resources: movie tvshow The resources are referenced in their own domain namespace. So those are valid if your domain is specifically created to support this recommendation service only. But's lets assume we might add rental support later, so we need to make sure the policies are based on service specific resources. So we'll define our resources as: rec.movie rec.tvshow Support action for these resources would be read . We can extend our authorization policies later on if we need to introduce other actions - such as write or list as we add more functionality into our service. Athenz Management Setup \u00b6 Once we have defined what our resources and actions are, we can create their respective client and server (also commonly referred as tenant and provider) roles and policies in Athenz. Go to Athenz UI and login with your account which should have system administrator access. Follow the instructions in the following guide to setup the required access control: Access Control Setup Obtaining X509 Certificate \u00b6 The service should obtain an X509 certificate that will be used for authentication with Athenz. Follow the steps in the Authentication section to receive a certificate depending on the environment: Athenz Service Identity X.509 Certificate for AWS EC2 instances Athenz Service Identity X.509 Certificate for AWS ECS containers Athenz Service Identity X.509 Certificate for AWS Fargate tasks Athenz Service Identity X.509 Certificate for AWS EKS pods Athenz Service Identity X.509 Certificate for AWS Lambda functions Code Changes \u00b6 Both the client and servlet implementors need to make changes in their respective code bases to support centralized authorization checks. The client needs to make sure to submit its service certificate as part of its request, while the servlet needs to carry out the authorization check based on that service identity to determine if it request should be processed or not. Getting an SSL Context to be used in Http Clients \u00b6 The full client source code is available from: https://github.com/AthenZ/athenz/tree/master/libs/java/cert_refresher/examples/tls-support/src/main/java/com/yahoo/athenz/example/http/tls/client/HttpTLSClient.java Client Project Dependency Update \u00b6 First you need to update your Java project pom.xml file to indicate the dependency on the Athenz Cert Refresher Library. Checkout the Bintray Athenz Cert Refresher Package to make sure you're using the latest release version: <dependency> <groupId>com.yahoo.athenz</groupId> <artifactId>athenz-cert-refresher</artifactId> <version>VERSION-NUMBER</version> </dependency> <repositories> <repository> <id>bintray-yahoo-maven</id> <name>bintray</name> <url>https://yahoo.bintray.com/maven</url> </repository> </repositories> Build Http Client Utility \u00b6 Checkout and build the client component: $ git clone https://github.com/AthenZ/athenz.git $ cd libs/java/cert_refresher/examples/tls-support/src/main/java/com/yahoo/athenz/example/http/tls/client/ $ mvn clean package Verify that the client is built successfully: $ java -cp target/example-http-tls-java-client-1.0.jar HttpExampleClient Missing required options: k, c, t, p, u usage: http-example-client -k,--keyid <arg> key identifier -c,--cert <arg> certficate path -t,--trustStorePath <arg> CA TrustStore path -p,--trustStorePassword <arg> CA TrustStore password -u,--url <arg> request url Servlet Changes \u00b6 The full servlet source code is available from: https://github.com/AthenZ/athenz/tree/master/examples/java/centralized-use-case/servlet Servlet Project Dependency Update \u00b6 First you need to update your Java project pom.xml file to indicate the dependency on the Athenz ZMS Java Client Library and the Athenz Cert Refresher Libarry. Checkout Bintray ZMS Client Package Page and Bintray Athenz Cert Refresher Package to make sure you're using the latest release version: <dependency> <groupId>com.yahoo.athenz</groupId> <artifactId>athenz-zms-java-client</artifactId> <version>VERSION-NUMBER</version> </dependency> <dependency> <groupId>com.yahoo.athenz</groupId> <artifactId>athenz-cert-refresher</artifactId> <version>VERSION-NUMBER</version> </dependency> <repositories> <repository> <id>bintray-yahoo-maven</id> <name>bintray</name> <url>https://yahoo.bintray.com/maven</url> </repository> </repositories> Enable TLS Client Certificate Authentication \u00b6 To enable TLS Client Certificate Authentication, follow the steps in Server Side Service Identity Authentication Authorization Checks \u00b6 Before any authorization calls, we're going to check to make sure our request contains the Athenz X509 certificate: static final String ATHENZ_HEADER = \"Athenz-Principal-Auth\" ; protected void doGet ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { // retrieve and verify that our request contains an Athenz // service authentication certificate X509Certificate [] certs = ( X509Certificate [] ) request . getAttribute ( JAVAX_CERT_ATTR ); // Assuming only one certificate sent in the request if ( certs == null || certs [ 0 ] == null ) { response . sendError ( 403 , \"Forbidden - No Athenz X509 certificate provided in request\" ); return ; } ... } Next, the most important part is to determine the resource and action based on the given http request. protected void doGet ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { ... switch ( reqUri ) { case \"/movie\" : responseText = \"Name: Slap Shot; Director: George Roy Hill\" ; athenzResource = \"rec.movie\" ; athenzAction = \"read\" ; break ; case \"/tvshow\" : responseText = \"Name: Middle; Channel: ABC\" ; athenzResource = \"rec.tvshow\" ; athenzAction = \"read\" ; break ; default : response . sendError ( 404 , \"Unknown endpoint\" ); return ; } ... } Once we have those two values determined, then all that is left is to contact ZMS for the authorization check. protected void doGet ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { ... // carry out the authorization check with the expected resource // and action values String principalName = x509cert . getSubjectX500Principal (). getName (); Access access = zmsClient . getAccess ( athenzAction , athenzResource , null , principalName ); boolean authorized = access . getGranted (); if ( ! authorized ) { response . sendError ( 403 , \"Forbidden - Athenz Authorization Rejected\" ); return ; } ... } Build Servlet \u00b6 Checkout and build the servlet component: $ git clone https://github.com/AthenZ/athenz.git $ cd examples/java/centralized-use-case/servlet/ $ mvn clean package Deploying Example Servlet \u00b6 Download and install latest Jetty 9.3.x container Copy the athenz-control.war from the servlet/target directory to the Jetty distribution's webapps directory Configure ZMS Server's URL in the expected environment variable: export ZMS_SERVER_URL = https://<zms-server-hostname>:4443/zms/v1 Configure Valid Issuers file path in the expected environment variable: export ATHENZ_ISSUERS_FILEPATH = <Path to valid issuers file> Configure environment variables for our web app cert, key and truststore: export REC_SERVLET_ATHENZ_KEY_PATH = <Path to key> export REC_SERVLET_ATHENZ_CERT_PATH = <Path to cert> export REC_SERVLET_ATHENZ_TRUSTSTORE_PATH = <Path to truststore> export REC_SERVLET_ATHENZ_TRUSTSTORE_PASSWORD = <truststore password> If the ZMS Server is running with a self-signed certificate, we need to generate a truststore for the java http client to use when communicating with the ZMS Server. From your ZMS Server installation, copy the zms_cert.pem file from the athenz-zms-X.Y/var/zms_server/certs directory to the jetty's etc subdirectory and execute the following commands: $ keytool -importcert -noprompt -alias zms -keystore zms_truststore.jks -file zms_cert.pem -storepass athenz $ export JAVA_OPTIONS = -Djavax.net.ssl.trustStore = <full-path-to-jetty-basedir>/etc/zms_truststore.jks Start the Jetty server by running the following command from Jetty's distribution base directory: bin/jetty.sh start Test Cases \u00b6 Run the following test cases to verify authorization access for specific services. We're running jetty server on the local box so we're using localhost as the hostname. Copy the example-http-tls-java-client-1.0.jar file from the client/target directory to the directory that includes the private keys for the test services we created in the section Athenz Management Setup above. Invalid Access Without Cert \u00b6 For this test case we'll just use the curl client directly: $ curl http://localhost:8080/athenz-control/rec/v1/movie <html> ... <title>Error 403 Forbidden - No Athenz X509 certificate provided in request</title> ... </html> Movie Editor Access \u00b6 Movie service can successfully access /rec/v1/movie endpoint: $ java -cp ./example-http-tls-java-client-1.0.jar HttpTLSClient -d editors -s movie -p ./movie_private.pem -k v0 -u http://localhost:8080/athenz-control/rec/v1/movie Successful response: Name: Slap Shot ; Director: George Roy Hill Movie service does not have access to /rec/v1/tvshow endpoint: $ java -cp ./example-http-tls-java-client-1.0.jar HttpTLSClient -d editors -s movie -p ./movie_private.pem -k v0 -u http://localhost:8080/athenz-control/rec/v1/tvshow Request was forbidden - not authorized TvShow Editor Access \u00b6 TvShow service can successfully access /rec/v1/tvshow endpoint: $ java -cp ./example-http-tls-java-client-1.0.jar HttpTLSClient -d editors -s tvshow -p ./tvshow_private.pem -k v0 -u http://localhost:8080/athenz-control/rec/v1/tvshow Successful response: Name: Middle ; Channel: ABC TvShow service does not have access to /rec/v1/movie endpoint: $ java -cp ./example-http-tls-java-client-1.0.jar HttpTLSClient -d editors -s tvshow -p ./tvshow_private.pem -k v0 -u http://localhost:8080/athenz-control/rec/v1/movie Request was forbidden - not authorized Site Editor Access \u00b6 Site service has access to both /rec/v1/tvshow and /rec/v1/movie endpoints: $ java -cp ./example-http-tls-java-client-1.0.jar HttpTLSClient -d editors -s site -p ./site_private.pem -k v0 -u http://localhost:8080/athenz-control/rec/v1/movie Successful response: Name: Slap Shot ; Director: George Roy Hill $ java -cp ./example-http-tls-java-client-1.0.jar HttpTLSClient -d editors -s site -p ./site_private.pem -k v0 -u http://localhost:8080/athenz-control/rec/v1/tvshow Successful response: Name: Middle ; Channel: ABC Other Test Cases \u00b6 Now you can modify the movie_editos, tvshow_editors, and site_editors roles in the recommend domain to add and remove the defined services and then run the corresponding test cases to verify your access change.","title":"Java Client/Servlet Centralized Example"},{"location":"example_java_centralized_access/#java-clientservlet-example-centralized-access-control","text":"Required Components Service Definition Resource Definition Athenz Management Setup Code Changes Getting an SSL Context to be used in Http Clients Client Project Dependency Update Build Http Client Utility Servlet Changes Servlet Project Dependency Update Enable TLS Client Certificate Authentication Authorization Checks Build Servlet Deploying Example Servlet Test Cases Invalid Access Without ServiceToken Movie Editor Access TvShow Editor Access Site Editor Access Other Test Cases In the centralized access control model, the service as a principal requests an X509 certificate from SIA Provider and then presents it to the target service which would perform an identical check with ZMS to confirm access. The required steps to setup the environment for provider and tenant services to support centralized access control are as follows: System administrator creates the provider and tenant domains. Tenant Domain administrator generates a public/private key pair and registers a service in its domain. Provider Domain administrator creates a role and policy that grants access to the given role with configured action and resource. Provider Domain administrator adds the Tenant Service to the role to grant access. Tenant Domain administrator installs the private key on the host that will be running the client/tenant service.","title":"Java Client/Servlet Example - Centralized Access Control"},{"location":"example_java_centralized_access/#required-components","text":"To support centralized access control in your applications, you only need to install and configure the Athenz ZMS server along with the Athenz UI. Please follow these guides to make sure you have both of those components up and running in your environment: ZMS Server UI Server To build the client and servlet components of this example, you need to download and install Oracle JDK 8, Apache Maven and Git client if you don't already have these available on your box: Oracle Java Platform JDK 8 Apache Maven Git client","title":"Required Components"},{"location":"example_java_centralized_access/#service-definition","text":"Let's first define our service that needs to be Athenz protected. We have a simple recommendation service that returns either a movie or tv show for the caller. It has two endpoints: GET /rec/v1/movie GET /rec/v1/tvshow So in this first release we just want to protect access to these endpoints. The traffic is very low - we only expect a couple of requests an hour so we have decided to use Athenz' centralized authorization model.","title":"Service Definition"},{"location":"example_java_centralized_access/#resource-definition","text":"Defining resources and actions the principals are authorized to execute is one of the most important tasks in the authorization process. Based on our endpoints, it's expected that we'll have 2 general resources: movie tvshow The resources are referenced in their own domain namespace. So those are valid if your domain is specifically created to support this recommendation service only. But's lets assume we might add rental support later, so we need to make sure the policies are based on service specific resources. So we'll define our resources as: rec.movie rec.tvshow Support action for these resources would be read . We can extend our authorization policies later on if we need to introduce other actions - such as write or list as we add more functionality into our service.","title":"Resource Definition"},{"location":"example_java_centralized_access/#athenz-management-setup","text":"Once we have defined what our resources and actions are, we can create their respective client and server (also commonly referred as tenant and provider) roles and policies in Athenz. Go to Athenz UI and login with your account which should have system administrator access. Follow the instructions in the following guide to setup the required access control: Access Control Setup","title":"Athenz Management Setup"},{"location":"example_java_centralized_access/#obtaining-x509-certificate","text":"The service should obtain an X509 certificate that will be used for authentication with Athenz. Follow the steps in the Authentication section to receive a certificate depending on the environment: Athenz Service Identity X.509 Certificate for AWS EC2 instances Athenz Service Identity X.509 Certificate for AWS ECS containers Athenz Service Identity X.509 Certificate for AWS Fargate tasks Athenz Service Identity X.509 Certificate for AWS EKS pods Athenz Service Identity X.509 Certificate for AWS Lambda functions","title":"Obtaining X509 Certificate"},{"location":"example_java_centralized_access/#code-changes","text":"Both the client and servlet implementors need to make changes in their respective code bases to support centralized authorization checks. The client needs to make sure to submit its service certificate as part of its request, while the servlet needs to carry out the authorization check based on that service identity to determine if it request should be processed or not.","title":"Code Changes"},{"location":"example_java_centralized_access/#getting-an-ssl-context-to-be-used-in-http-clients","text":"The full client source code is available from: https://github.com/AthenZ/athenz/tree/master/libs/java/cert_refresher/examples/tls-support/src/main/java/com/yahoo/athenz/example/http/tls/client/HttpTLSClient.java","title":"Getting an SSL Context to be used in Http Clients"},{"location":"example_java_centralized_access/#client-project-dependency-update","text":"First you need to update your Java project pom.xml file to indicate the dependency on the Athenz Cert Refresher Library. Checkout the Bintray Athenz Cert Refresher Package to make sure you're using the latest release version: <dependency> <groupId>com.yahoo.athenz</groupId> <artifactId>athenz-cert-refresher</artifactId> <version>VERSION-NUMBER</version> </dependency> <repositories> <repository> <id>bintray-yahoo-maven</id> <name>bintray</name> <url>https://yahoo.bintray.com/maven</url> </repository> </repositories>","title":"Client Project Dependency Update"},{"location":"example_java_centralized_access/#build-http-client-utility","text":"Checkout and build the client component: $ git clone https://github.com/AthenZ/athenz.git $ cd libs/java/cert_refresher/examples/tls-support/src/main/java/com/yahoo/athenz/example/http/tls/client/ $ mvn clean package Verify that the client is built successfully: $ java -cp target/example-http-tls-java-client-1.0.jar HttpExampleClient Missing required options: k, c, t, p, u usage: http-example-client -k,--keyid <arg> key identifier -c,--cert <arg> certficate path -t,--trustStorePath <arg> CA TrustStore path -p,--trustStorePassword <arg> CA TrustStore password -u,--url <arg> request url","title":"Build Http Client Utility"},{"location":"example_java_centralized_access/#servlet-changes","text":"The full servlet source code is available from: https://github.com/AthenZ/athenz/tree/master/examples/java/centralized-use-case/servlet","title":"Servlet Changes"},{"location":"example_java_centralized_access/#servlet-project-dependency-update","text":"First you need to update your Java project pom.xml file to indicate the dependency on the Athenz ZMS Java Client Library and the Athenz Cert Refresher Libarry. Checkout Bintray ZMS Client Package Page and Bintray Athenz Cert Refresher Package to make sure you're using the latest release version: <dependency> <groupId>com.yahoo.athenz</groupId> <artifactId>athenz-zms-java-client</artifactId> <version>VERSION-NUMBER</version> </dependency> <dependency> <groupId>com.yahoo.athenz</groupId> <artifactId>athenz-cert-refresher</artifactId> <version>VERSION-NUMBER</version> </dependency> <repositories> <repository> <id>bintray-yahoo-maven</id> <name>bintray</name> <url>https://yahoo.bintray.com/maven</url> </repository> </repositories>","title":"Servlet Project Dependency Update"},{"location":"example_java_centralized_access/#enable-tls-client-certificate-authentication","text":"To enable TLS Client Certificate Authentication, follow the steps in Server Side Service Identity Authentication","title":"Enable TLS Client Certificate Authentication"},{"location":"example_java_centralized_access/#authorization-checks","text":"Before any authorization calls, we're going to check to make sure our request contains the Athenz X509 certificate: static final String ATHENZ_HEADER = \"Athenz-Principal-Auth\" ; protected void doGet ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { // retrieve and verify that our request contains an Athenz // service authentication certificate X509Certificate [] certs = ( X509Certificate [] ) request . getAttribute ( JAVAX_CERT_ATTR ); // Assuming only one certificate sent in the request if ( certs == null || certs [ 0 ] == null ) { response . sendError ( 403 , \"Forbidden - No Athenz X509 certificate provided in request\" ); return ; } ... } Next, the most important part is to determine the resource and action based on the given http request. protected void doGet ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { ... switch ( reqUri ) { case \"/movie\" : responseText = \"Name: Slap Shot; Director: George Roy Hill\" ; athenzResource = \"rec.movie\" ; athenzAction = \"read\" ; break ; case \"/tvshow\" : responseText = \"Name: Middle; Channel: ABC\" ; athenzResource = \"rec.tvshow\" ; athenzAction = \"read\" ; break ; default : response . sendError ( 404 , \"Unknown endpoint\" ); return ; } ... } Once we have those two values determined, then all that is left is to contact ZMS for the authorization check. protected void doGet ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { ... // carry out the authorization check with the expected resource // and action values String principalName = x509cert . getSubjectX500Principal (). getName (); Access access = zmsClient . getAccess ( athenzAction , athenzResource , null , principalName ); boolean authorized = access . getGranted (); if ( ! authorized ) { response . sendError ( 403 , \"Forbidden - Athenz Authorization Rejected\" ); return ; } ... }","title":"Authorization Checks"},{"location":"example_java_centralized_access/#build-servlet","text":"Checkout and build the servlet component: $ git clone https://github.com/AthenZ/athenz.git $ cd examples/java/centralized-use-case/servlet/ $ mvn clean package","title":"Build Servlet"},{"location":"example_java_centralized_access/#deploying-example-servlet","text":"Download and install latest Jetty 9.3.x container Copy the athenz-control.war from the servlet/target directory to the Jetty distribution's webapps directory Configure ZMS Server's URL in the expected environment variable: export ZMS_SERVER_URL = https://<zms-server-hostname>:4443/zms/v1 Configure Valid Issuers file path in the expected environment variable: export ATHENZ_ISSUERS_FILEPATH = <Path to valid issuers file> Configure environment variables for our web app cert, key and truststore: export REC_SERVLET_ATHENZ_KEY_PATH = <Path to key> export REC_SERVLET_ATHENZ_CERT_PATH = <Path to cert> export REC_SERVLET_ATHENZ_TRUSTSTORE_PATH = <Path to truststore> export REC_SERVLET_ATHENZ_TRUSTSTORE_PASSWORD = <truststore password> If the ZMS Server is running with a self-signed certificate, we need to generate a truststore for the java http client to use when communicating with the ZMS Server. From your ZMS Server installation, copy the zms_cert.pem file from the athenz-zms-X.Y/var/zms_server/certs directory to the jetty's etc subdirectory and execute the following commands: $ keytool -importcert -noprompt -alias zms -keystore zms_truststore.jks -file zms_cert.pem -storepass athenz $ export JAVA_OPTIONS = -Djavax.net.ssl.trustStore = <full-path-to-jetty-basedir>/etc/zms_truststore.jks Start the Jetty server by running the following command from Jetty's distribution base directory: bin/jetty.sh start","title":"Deploying Example Servlet"},{"location":"example_java_centralized_access/#test-cases","text":"Run the following test cases to verify authorization access for specific services. We're running jetty server on the local box so we're using localhost as the hostname. Copy the example-http-tls-java-client-1.0.jar file from the client/target directory to the directory that includes the private keys for the test services we created in the section Athenz Management Setup above.","title":"Test Cases"},{"location":"example_java_centralized_access/#invalid-access-without-cert","text":"For this test case we'll just use the curl client directly: $ curl http://localhost:8080/athenz-control/rec/v1/movie <html> ... <title>Error 403 Forbidden - No Athenz X509 certificate provided in request</title> ... </html>","title":"Invalid Access Without Cert"},{"location":"example_java_centralized_access/#movie-editor-access","text":"Movie service can successfully access /rec/v1/movie endpoint: $ java -cp ./example-http-tls-java-client-1.0.jar HttpTLSClient -d editors -s movie -p ./movie_private.pem -k v0 -u http://localhost:8080/athenz-control/rec/v1/movie Successful response: Name: Slap Shot ; Director: George Roy Hill Movie service does not have access to /rec/v1/tvshow endpoint: $ java -cp ./example-http-tls-java-client-1.0.jar HttpTLSClient -d editors -s movie -p ./movie_private.pem -k v0 -u http://localhost:8080/athenz-control/rec/v1/tvshow Request was forbidden - not authorized","title":"Movie Editor Access"},{"location":"example_java_centralized_access/#tvshow-editor-access","text":"TvShow service can successfully access /rec/v1/tvshow endpoint: $ java -cp ./example-http-tls-java-client-1.0.jar HttpTLSClient -d editors -s tvshow -p ./tvshow_private.pem -k v0 -u http://localhost:8080/athenz-control/rec/v1/tvshow Successful response: Name: Middle ; Channel: ABC TvShow service does not have access to /rec/v1/movie endpoint: $ java -cp ./example-http-tls-java-client-1.0.jar HttpTLSClient -d editors -s tvshow -p ./tvshow_private.pem -k v0 -u http://localhost:8080/athenz-control/rec/v1/movie Request was forbidden - not authorized","title":"TvShow Editor Access"},{"location":"example_java_centralized_access/#site-editor-access","text":"Site service has access to both /rec/v1/tvshow and /rec/v1/movie endpoints: $ java -cp ./example-http-tls-java-client-1.0.jar HttpTLSClient -d editors -s site -p ./site_private.pem -k v0 -u http://localhost:8080/athenz-control/rec/v1/movie Successful response: Name: Slap Shot ; Director: George Roy Hill $ java -cp ./example-http-tls-java-client-1.0.jar HttpTLSClient -d editors -s site -p ./site_private.pem -k v0 -u http://localhost:8080/athenz-control/rec/v1/tvshow Successful response: Name: Middle ; Channel: ABC","title":"Site Editor Access"},{"location":"example_java_centralized_access/#other-test-cases","text":"Now you can modify the movie_editos, tvshow_editors, and site_editors roles in the recommend domain to add and remove the defined services and then run the corresponding test cases to verify your access change.","title":"Other Test Cases"},{"location":"example_java_decentralized_access/","text":"Java Client/Servlet Example - Decentralized Access Control \u00b6 Required Components Service Definition Resource Definition Athenz Management Setup Client (Tenant) Domain Movie Editors TvShow Editors Site Editors Service View Server (Provider) Domain Authorization Roles and Policies Movie Access TvShow Access Full Access Code Changes Client Changes Client Project Dependency Update Obtaining Access Tokens from ZTS Server Build Http Client Utility Servlet Changes Servlet Project Dependency Update Authorization Checks Build Servlet Deploying Example Servlet Test Cases Invalid Access Without RoleToken Movie Editor Access TvShow Editor Access Site Editor Access Other Test Cases In the decentralized access control model, the client service/user uses its identity x.509 certificate along with its private key that it got from local SIA (1) to get an authorization token (Access Token) from ZTS (2), and then presents the access token to a target service to access its resources (3). The required steps to setup the environment for provider and tenant services to support decentralized access control are as follows: System administrator creates the provider and tenant domains. Tenant Domain administrator generates a public/private key pair and registers a service in its domain. Provider Domain administrator creates a role and policy that grants access to the given role with configured action and resource. Provider Domain administrator adds the Tenant Service to the role to grant access. Provider Domain administrator installs Athenz Policy Engine Updater (ZPU) on the hosts that will be running the provider service. ZPU must be configured with the provider domain name and setup to run as a cron job to periodically download the latest policy files for the server/provider domain. Tenant Domain administrator installs the private key on the host that will be running the client/tenant service. Required Components \u00b6 To support centralized access control in your applications, you only need to install and configure all Athenz components: ZMS and ZTS servers along with the Athenz UI. ZPE Policy updater needs to be install on the target service host. Please follow these guides to make sure you have all of these components up and running in your environment: ZMS Server ZTS Server UI Server On the provider service's host only install ZPU: ZPU Utility To build the client and servlet components of this example, you need to download and install Oracle JDK 8, Apache Maven and Git client if you don't already have these available on your box: Oracle Java Platform JDK 8 Apache Maven Git client Service Definition \u00b6 Let's first define our service that needs to be Athenz protected. We have a simple recommendation service that returns either a movie or tv show for the caller. It has two endpoints: GET /rec/v1/movie GET /rec/v1/tvshow So in this first release we just want to protect access to these endpoints. We're going to get large number of requests per second so contacting ZMS server for centralized authorization checks is not an option. Instead, we have decided to use Athenz' decentralized authorization model. Resource Definition \u00b6 Defining resources and actions the principals are authorized to execute is one of the most important tasks in the authorization process. Based on our endpoints, it's expected that we'll have 2 general resources: movie tvshow The resources are referenced in their own domain namespace. So those are valid if your domain is specifically created to support this recommendation service only. But's lets assume we might add rental support later, so we need to make sure the policies are based on service specific resources. So we'll define our resources as: rec.movie rec.tvshow Support action for these resources would be read . We can extend our authorization policies later on if we need to introduce other actions - such as write or list as we add more functionality into our service. Athenz Management Setup \u00b6 Once we have defined what our resources and actions are, we can create their respective client and server (also commonly referred as tenant and provider) roles and policies in Athenz. Go to Athenz UI and login with your account which should have system administrator access. Follow the instructions in the following guide to setup the required access control: Access Control Setup Code Changes \u00b6 Both the client and servlet implementors need to make changes in their respective code bases to support decentralized authorization checks. The client needs to make sure to retrieve its Access Token from ZTS Service and submit that as part of its request, while the servlet needs to carry out the authorization check based on that Access Token to determine if it request should be processed or not. Client Changes \u00b6 The full client source code is available from: https://github.com/AthenZ/athenz/tree/master/examples/java/decentralized-use-case/client Client Project Dependency Update \u00b6 First you need to update your Java project pom.xml file to indicate the dependency on the Athenz auth_core and zts java client libraries. Checkout the Bintray Athenz Cert Refresher Package and Bintray ZTS Java Client Package pages to make sure you're using the latest release version: <dependency> <groupId>com.yahoo.athenz</groupId> <artifactId>athenz-cert-refresher</artifactId> <version>VERSION-NUMBER</version> </dependency> <dependency> <groupId>com.yahoo.athenz</groupId> <artifactId>athenz-zts-java-client</artifactId> <version>VERSION-NUMBER</version> </dependency> <repositories> <repository> <id>bintray-yahoo-maven</id> <name>bintray</name> <url>https://yahoo.bintray.com/maven</url> </repository> </repositories> Obtaining Access Tokens from ZTS Server \u00b6 The service should obtain an X509 certificate that will be used for authentication with Athenz. Follow the steps in the Authentication section to receive a certificate depending on the environment: Athenz Service Identity X.509 Certificate for AWS EC2 instances Athenz Service Identity X.509 Certificate for AWS ECS containers Athenz Service Identity X.509 Certificate for AWS Fargate tasks Athenz Service Identity X.509 Certificate for AWS EKS pods Athenz Service Identity X.509 Certificate for AWS Lambda functions Then, we need to contact ZTS Server to retrieve an access token for the given service identity (provided by the ServiceIdentityProvider) accessing a target service domain: // the fields used in the following snippet of code // ztsUrl -> ZTS Server Url // domainName -> 'recommend' // serviceName -> 'movie', 'tvshow' or 'site' // providerRole -> 'movie_editors, tvshow_editors, full_access' KeyRefresher keyRefresher = Utils . generateKeyRefresher ( trustStorePath , trustStorePassword , certPath , keyPath ); keyRefresher . startup (); SSLContext sslContext = Utils . buildSSLContext ( keyRefresher . getKeyManagerProxy (), keyRefresher . getTrustManagerProxy ()); HttpsURLConnection . setDefaultSSLSocketFactory ( sslContext . getSocketFactory ()); ZTSClient ztsClient = new ZTSClient ( ztsUrl , sslContext ); List < String > roles = new ArrayList <> (); roles . add ( providerRole ); // Can be several of roles. Our example only use one AccessTokenResponse accessTokenResponse = ztsClient . getAccessToken ( domainName , roles , serviceName , 0 , true ); String accessToken = accessTokenResponse == null ? null : accessTokenResponse . getToken_type () + \" \" + accessTokenResponse . getAccess_token (); Once we have our Access Token, we can use it in the Authorization header. // set our Athenz credentials. The ZTSClient provides the header // name that we must use for authorization token while the access // token itself provides the token string. con . setRequestProperty ( ZTSClient . getHeader (), accessToken ); Build Http Client Utility \u00b6 Checkout and build the client component: $ git clone https://github.com/AthenZ/athenz.git $ cd examples/java/decentralized-use-case/client/ $ mvn clean package Verify that the client is built successfully: $ java -cp target/example-java-client-access-token-1.0.jar com.yahoo.athenz.example.accesstoken.HttpExampleClient Missing required options: k, c, t, p, d, pr, s, u, z usage: http-example-client -k,--keyid <arg> key identifier -c,--cert <arg> certficate path -t,--trustStorePath <arg> CA TrustStore path -p,--trustStorePassword <arg> CA TrustStore password -d,--domain <arg> domain name -pr,--provider-role <arg> Provider role name -s,--service <arg> service name -u,--url <arg> request url -z,--ztsurl <arg> ZTS Server url Servlet Changes \u00b6 The full servlet source code is available from: https://github.com/AthenZ/athenz/tree/master/examples/java/decentralized-use-case/servlet Servlet Project Dependency Update \u00b6 First you need to update your Java project pom.xml file to indicate the dependency on the Athenz ZPE Java Client Library. Checkout the Bintray ZPE Client Package Page to make sure you're using the latest release version: <dependency> <groupId>com.yahoo.athenz</groupId> <artifactId>athenz-zpe-java-client</artifactId> <version>VERSION-NUMBER</version> </dependency> <repositories> <repository> <id>bintray-yahoo-maven</id> <name>bintray</name> <url>https://yahoo.bintray.com/maven</url> </repository> </repositories> Authorization Checks \u00b6 First, we need to make sure the servlet initialization time, Athenz ZPE Client library is initialized so it can process and load any domain policy documents retrieved by ZPE Policy Updater. public void init () throws ServletException { // initialize Athenz ZPE client which will load // all policy files into memory AuthZpeClient . init (); } Before any authorization calls, we're going to check to make sure our request contains the Athenz role token: static final String ATHENZ_HEADER = \"Athenz-Role-Auth\" ; protected void doGet ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { // retrieve and verify that our request contains an Athenz // access token String accessToken = request . getHeader ( ATHENZ_HEADER ); if ( accessToken == null ) { response . sendError ( 403 , \"Forbidden - No Athenz accessToken provided in request\" ); return ; } ... } Next, the most important part is to determine the resource and action based on the given http request. protected void doGet ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { ... switch ( reqUri ) { case \"/movie\" : responseText = \"Name: Slap Shot; Director: George Roy Hill\" ; athenzResource = \"rec.movie\" ; athenzAction = \"read\" ; break ; case \"/tvshow\" : responseText = \"Name: Middle; Channel: ABC\" ; athenzResource = \"rec.tvshow\" ; athenzAction = \"read\" ; break ; default : response . sendError ( 404 , \"Unknown endpoint\" ); return ; } ... } Once we have those two values determined, then all that is left is to use ZPE client library for the authorization check. protected void doGet ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { ... // carry out the authorization check with the expected resource // and action values AccessCheckStatus status = AuthZpeClient . allowAccess ( accessToken , athenzResource , athenzAction ); if ( status != AccessCheckStatus . ALLOW ) { response . sendError ( 403 , \"Forbidden - Athenz Authorization Rejected\" ); return ; } ... } Build Servlet \u00b6 Checkout and build the servlet component: $ git clone https://github.com/AthenZ/athenz.git $ cd examples/java/decentralized-use-case/servlet/ $ mvn clean package Deploying Example Servlet \u00b6 Download and install latest Jetty 9.3.x container Copy the athenz-data.war from the servlet/target directory to the Jetty distribution's webapps directory Configure ZPU to download the policy documents for domain recommend . $ vi <zpu-install-directory>/conf/zpe_policy_updater/zpu.conf In the json file, edit the value for the domains field to be set to recommend . Run the zpu utility to retrieve the policy documents from ZTS. $ <zpu-directory>/bin/zpu_run.sh $ ls -lat <zpe-directory>/var/zpe/recommend.pol Configure ZPE library to look for the policy file and the athenz.conf files in the expected directory: $ export JAVA_OPTIONS = \"-Dathenz.zpe.policy_dir=<zpu-directory>/var/zpe -Dathenz.athenz_conf=<zpu-directory>/conf/zpe_policy_updater/athenz.conf\" Start the Jetty server by running the following command from Jetty's distribution base directory: bin/jetty.sh start Test Cases \u00b6 Run the following test cases to verify authorization access for specific services. We're running jetty server on the local box so we're using localhost as the hostname. Copy the example-java-client-access-token-1.0.jar file from the client/target directory to the directory that includes the private keys for the test services we created in the section Athenz Management Setup above. If the ZTS Server is running with a self-signed certificate, we need to generate a truststore for the java http client to use when communicating with the ZTS Server. From your ZTS Server installation, copy the zts_cert.pem file from the athenz-zts-X.Y/var/zts_server/certs directory into the same directory where the client access token utility is saved (previous step) and execute the following commands: $ keytool -importcert -noprompt -alias zts -keystore zts_truststore.jks -file zts_cert.pem -storepass athenz Invalid Access Without accessToken \u00b6 For this test case we'll just use the curl client directly: $ curl http://localhost:8080/athenz-data/rec/v1/movie <html> ... <title>Error 403 Forbidden - No Athenz accessToken provided in request</title> ... </html> Movie Editor Access \u00b6 Movie service can successfully access /rec/v1/movie endpoint: $ java -Djavax.net.ssl.trustStore = ./zts_truststore.jks -cp ./example-java-client-access-token-1.0.jar com.yahoo.athenz.example.accesstoken.HttpExampleClient -t ./zts_truststore.jks -p athenz -s movie -p ./movie_private.pem -d recommend -pr movie_editors -z https://<zts-server>:8443/zts/v1 -u http://localhost:8080/athenz-data/rec/v1/movie Successful response: Name: Slap Shot ; Director: George Roy Hill Movie service does not have access to /rec/v1/tvshow endpoint: $ java -Djavax.net.ssl.trustStore = ./zts_truststore.jks -cp ./example-java-client-access-token-1.0.jar com.yahoo.athenz.example.accesstoken.HttpExampleClient -t ./zts_truststore.jks -p athenz -s movie -p ./movie_private.pem -d recommend -pr movie_editors -z https://<zts-server>:8443/zts/v1 -u http://localhost:8080/athenz-data/rec/v1/tvshow Request was forbidden - not authorized TvShow Editor Access \u00b6 TvShow service can successfully access /rec/v1/tvshow endpoint: $ java -Djavax.net.ssl.trustStore = ./zts_truststore.jks -cp ./example-java-client-access-token-1.0.jar com.yahoo.athenz.example.accesstoken.HttpExampleClient -t ./zts_truststore.jks -p athenz -s tvshow -p ./tvshow_private.pem -d recommend -pr tvshow_editors -z https://<zts-server>:8443/zts/v1 -u http://localhost:8080/athenz-data/rec/v1/tvshow Successful response: Name: Middle ; Channel: ABC TvShow service does not have access to /rec/v1/movie endpoint: $ java -Djavax.net.ssl.trustStore = ./zts_truststore.jks -cp ./example-java-client-access-token-1.0.jar com.yahoo.athenz.example.accesstoken.HttpExampleClient -t ./zts_truststore.jks -p athenz -s tvshow -p ./tvshow_private.pem -d recommend -pr tvshow_editors -z https://<zts-server>:8443/zts/v1 -u http://localhost:8080/athenz-data/rec/v1/movie Request was forbidden - not authorized Site Editor Access \u00b6 Site service has access to both /rec/v1/tvshow and /rec/v1/movie endpoints: $ java -Djavax.net.ssl.trustStore = ./zts_truststore.jks -cp ./example-java-client-access-token-1.0.jar com.yahoo.athenz.example.accesstoken.HttpExampleClient -t ./zts_truststore.jks -p athenz -s site -p ./site_private.pem -d recommend -pr full_access -z https://<zts-server>:8443/zts/v1 -u http://localhost:8080/athenz-data/rec/v1/movie Successful response: Name: Slap Shot ; Director: George Roy Hill $ java -Djavax.net.ssl.trustStore = ./zts_truststore.jks -cp ./example-java-client-access-token-1.0.jar com.yahoo.athenz.example.accesstoken.HttpExampleClient -t ./zts_truststore.jks -p athenz -s site -p ./site_private.pem -k v0 -d recommend -pr full_access -z https://<zts-server>:8443/zts/v1 -u http://localhost:8080/athenz-data/rec/v1/tvshow Successful response: Name: Middle ; Channel: ABC Other Test Cases \u00b6 Now you can modify the movie_editos, tvshow_editors, and site_editors roles in the recommend domain to add and remove the defined services. After you make the changes, it will take about a minute for the updates to propagate from ZMS to the ZTS Server. Then you need to run the zpu_run.sh command again to fetch the updated policy files for the domain onto your host. Then you can run the corresponding test cases to verify your access change.","title":"Java Client/Servlet Decentralized Example"},{"location":"example_java_decentralized_access/#java-clientservlet-example-decentralized-access-control","text":"Required Components Service Definition Resource Definition Athenz Management Setup Client (Tenant) Domain Movie Editors TvShow Editors Site Editors Service View Server (Provider) Domain Authorization Roles and Policies Movie Access TvShow Access Full Access Code Changes Client Changes Client Project Dependency Update Obtaining Access Tokens from ZTS Server Build Http Client Utility Servlet Changes Servlet Project Dependency Update Authorization Checks Build Servlet Deploying Example Servlet Test Cases Invalid Access Without RoleToken Movie Editor Access TvShow Editor Access Site Editor Access Other Test Cases In the decentralized access control model, the client service/user uses its identity x.509 certificate along with its private key that it got from local SIA (1) to get an authorization token (Access Token) from ZTS (2), and then presents the access token to a target service to access its resources (3). The required steps to setup the environment for provider and tenant services to support decentralized access control are as follows: System administrator creates the provider and tenant domains. Tenant Domain administrator generates a public/private key pair and registers a service in its domain. Provider Domain administrator creates a role and policy that grants access to the given role with configured action and resource. Provider Domain administrator adds the Tenant Service to the role to grant access. Provider Domain administrator installs Athenz Policy Engine Updater (ZPU) on the hosts that will be running the provider service. ZPU must be configured with the provider domain name and setup to run as a cron job to periodically download the latest policy files for the server/provider domain. Tenant Domain administrator installs the private key on the host that will be running the client/tenant service.","title":"Java Client/Servlet Example - Decentralized Access Control"},{"location":"example_java_decentralized_access/#required-components","text":"To support centralized access control in your applications, you only need to install and configure all Athenz components: ZMS and ZTS servers along with the Athenz UI. ZPE Policy updater needs to be install on the target service host. Please follow these guides to make sure you have all of these components up and running in your environment: ZMS Server ZTS Server UI Server On the provider service's host only install ZPU: ZPU Utility To build the client and servlet components of this example, you need to download and install Oracle JDK 8, Apache Maven and Git client if you don't already have these available on your box: Oracle Java Platform JDK 8 Apache Maven Git client","title":"Required Components"},{"location":"example_java_decentralized_access/#service-definition","text":"Let's first define our service that needs to be Athenz protected. We have a simple recommendation service that returns either a movie or tv show for the caller. It has two endpoints: GET /rec/v1/movie GET /rec/v1/tvshow So in this first release we just want to protect access to these endpoints. We're going to get large number of requests per second so contacting ZMS server for centralized authorization checks is not an option. Instead, we have decided to use Athenz' decentralized authorization model.","title":"Service Definition"},{"location":"example_java_decentralized_access/#resource-definition","text":"Defining resources and actions the principals are authorized to execute is one of the most important tasks in the authorization process. Based on our endpoints, it's expected that we'll have 2 general resources: movie tvshow The resources are referenced in their own domain namespace. So those are valid if your domain is specifically created to support this recommendation service only. But's lets assume we might add rental support later, so we need to make sure the policies are based on service specific resources. So we'll define our resources as: rec.movie rec.tvshow Support action for these resources would be read . We can extend our authorization policies later on if we need to introduce other actions - such as write or list as we add more functionality into our service.","title":"Resource Definition"},{"location":"example_java_decentralized_access/#athenz-management-setup","text":"Once we have defined what our resources and actions are, we can create their respective client and server (also commonly referred as tenant and provider) roles and policies in Athenz. Go to Athenz UI and login with your account which should have system administrator access. Follow the instructions in the following guide to setup the required access control: Access Control Setup","title":"Athenz Management Setup"},{"location":"example_java_decentralized_access/#code-changes","text":"Both the client and servlet implementors need to make changes in their respective code bases to support decentralized authorization checks. The client needs to make sure to retrieve its Access Token from ZTS Service and submit that as part of its request, while the servlet needs to carry out the authorization check based on that Access Token to determine if it request should be processed or not.","title":"Code Changes"},{"location":"example_java_decentralized_access/#client-changes","text":"The full client source code is available from: https://github.com/AthenZ/athenz/tree/master/examples/java/decentralized-use-case/client","title":"Client Changes"},{"location":"example_java_decentralized_access/#client-project-dependency-update","text":"First you need to update your Java project pom.xml file to indicate the dependency on the Athenz auth_core and zts java client libraries. Checkout the Bintray Athenz Cert Refresher Package and Bintray ZTS Java Client Package pages to make sure you're using the latest release version: <dependency> <groupId>com.yahoo.athenz</groupId> <artifactId>athenz-cert-refresher</artifactId> <version>VERSION-NUMBER</version> </dependency> <dependency> <groupId>com.yahoo.athenz</groupId> <artifactId>athenz-zts-java-client</artifactId> <version>VERSION-NUMBER</version> </dependency> <repositories> <repository> <id>bintray-yahoo-maven</id> <name>bintray</name> <url>https://yahoo.bintray.com/maven</url> </repository> </repositories>","title":"Client Project Dependency Update"},{"location":"example_java_decentralized_access/#obtaining-access-tokens-from-zts-server","text":"The service should obtain an X509 certificate that will be used for authentication with Athenz. Follow the steps in the Authentication section to receive a certificate depending on the environment: Athenz Service Identity X.509 Certificate for AWS EC2 instances Athenz Service Identity X.509 Certificate for AWS ECS containers Athenz Service Identity X.509 Certificate for AWS Fargate tasks Athenz Service Identity X.509 Certificate for AWS EKS pods Athenz Service Identity X.509 Certificate for AWS Lambda functions Then, we need to contact ZTS Server to retrieve an access token for the given service identity (provided by the ServiceIdentityProvider) accessing a target service domain: // the fields used in the following snippet of code // ztsUrl -> ZTS Server Url // domainName -> 'recommend' // serviceName -> 'movie', 'tvshow' or 'site' // providerRole -> 'movie_editors, tvshow_editors, full_access' KeyRefresher keyRefresher = Utils . generateKeyRefresher ( trustStorePath , trustStorePassword , certPath , keyPath ); keyRefresher . startup (); SSLContext sslContext = Utils . buildSSLContext ( keyRefresher . getKeyManagerProxy (), keyRefresher . getTrustManagerProxy ()); HttpsURLConnection . setDefaultSSLSocketFactory ( sslContext . getSocketFactory ()); ZTSClient ztsClient = new ZTSClient ( ztsUrl , sslContext ); List < String > roles = new ArrayList <> (); roles . add ( providerRole ); // Can be several of roles. Our example only use one AccessTokenResponse accessTokenResponse = ztsClient . getAccessToken ( domainName , roles , serviceName , 0 , true ); String accessToken = accessTokenResponse == null ? null : accessTokenResponse . getToken_type () + \" \" + accessTokenResponse . getAccess_token (); Once we have our Access Token, we can use it in the Authorization header. // set our Athenz credentials. The ZTSClient provides the header // name that we must use for authorization token while the access // token itself provides the token string. con . setRequestProperty ( ZTSClient . getHeader (), accessToken );","title":"Obtaining Access Tokens from ZTS Server"},{"location":"example_java_decentralized_access/#build-http-client-utility","text":"Checkout and build the client component: $ git clone https://github.com/AthenZ/athenz.git $ cd examples/java/decentralized-use-case/client/ $ mvn clean package Verify that the client is built successfully: $ java -cp target/example-java-client-access-token-1.0.jar com.yahoo.athenz.example.accesstoken.HttpExampleClient Missing required options: k, c, t, p, d, pr, s, u, z usage: http-example-client -k,--keyid <arg> key identifier -c,--cert <arg> certficate path -t,--trustStorePath <arg> CA TrustStore path -p,--trustStorePassword <arg> CA TrustStore password -d,--domain <arg> domain name -pr,--provider-role <arg> Provider role name -s,--service <arg> service name -u,--url <arg> request url -z,--ztsurl <arg> ZTS Server url","title":"Build Http Client Utility"},{"location":"example_java_decentralized_access/#servlet-changes","text":"The full servlet source code is available from: https://github.com/AthenZ/athenz/tree/master/examples/java/decentralized-use-case/servlet","title":"Servlet Changes"},{"location":"example_java_decentralized_access/#servlet-project-dependency-update","text":"First you need to update your Java project pom.xml file to indicate the dependency on the Athenz ZPE Java Client Library. Checkout the Bintray ZPE Client Package Page to make sure you're using the latest release version: <dependency> <groupId>com.yahoo.athenz</groupId> <artifactId>athenz-zpe-java-client</artifactId> <version>VERSION-NUMBER</version> </dependency> <repositories> <repository> <id>bintray-yahoo-maven</id> <name>bintray</name> <url>https://yahoo.bintray.com/maven</url> </repository> </repositories>","title":"Servlet Project Dependency Update"},{"location":"example_java_decentralized_access/#authorization-checks","text":"First, we need to make sure the servlet initialization time, Athenz ZPE Client library is initialized so it can process and load any domain policy documents retrieved by ZPE Policy Updater. public void init () throws ServletException { // initialize Athenz ZPE client which will load // all policy files into memory AuthZpeClient . init (); } Before any authorization calls, we're going to check to make sure our request contains the Athenz role token: static final String ATHENZ_HEADER = \"Athenz-Role-Auth\" ; protected void doGet ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { // retrieve and verify that our request contains an Athenz // access token String accessToken = request . getHeader ( ATHENZ_HEADER ); if ( accessToken == null ) { response . sendError ( 403 , \"Forbidden - No Athenz accessToken provided in request\" ); return ; } ... } Next, the most important part is to determine the resource and action based on the given http request. protected void doGet ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { ... switch ( reqUri ) { case \"/movie\" : responseText = \"Name: Slap Shot; Director: George Roy Hill\" ; athenzResource = \"rec.movie\" ; athenzAction = \"read\" ; break ; case \"/tvshow\" : responseText = \"Name: Middle; Channel: ABC\" ; athenzResource = \"rec.tvshow\" ; athenzAction = \"read\" ; break ; default : response . sendError ( 404 , \"Unknown endpoint\" ); return ; } ... } Once we have those two values determined, then all that is left is to use ZPE client library for the authorization check. protected void doGet ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { ... // carry out the authorization check with the expected resource // and action values AccessCheckStatus status = AuthZpeClient . allowAccess ( accessToken , athenzResource , athenzAction ); if ( status != AccessCheckStatus . ALLOW ) { response . sendError ( 403 , \"Forbidden - Athenz Authorization Rejected\" ); return ; } ... }","title":"Authorization Checks"},{"location":"example_java_decentralized_access/#build-servlet","text":"Checkout and build the servlet component: $ git clone https://github.com/AthenZ/athenz.git $ cd examples/java/decentralized-use-case/servlet/ $ mvn clean package","title":"Build Servlet"},{"location":"example_java_decentralized_access/#deploying-example-servlet","text":"Download and install latest Jetty 9.3.x container Copy the athenz-data.war from the servlet/target directory to the Jetty distribution's webapps directory Configure ZPU to download the policy documents for domain recommend . $ vi <zpu-install-directory>/conf/zpe_policy_updater/zpu.conf In the json file, edit the value for the domains field to be set to recommend . Run the zpu utility to retrieve the policy documents from ZTS. $ <zpu-directory>/bin/zpu_run.sh $ ls -lat <zpe-directory>/var/zpe/recommend.pol Configure ZPE library to look for the policy file and the athenz.conf files in the expected directory: $ export JAVA_OPTIONS = \"-Dathenz.zpe.policy_dir=<zpu-directory>/var/zpe -Dathenz.athenz_conf=<zpu-directory>/conf/zpe_policy_updater/athenz.conf\" Start the Jetty server by running the following command from Jetty's distribution base directory: bin/jetty.sh start","title":"Deploying Example Servlet"},{"location":"example_java_decentralized_access/#test-cases","text":"Run the following test cases to verify authorization access for specific services. We're running jetty server on the local box so we're using localhost as the hostname. Copy the example-java-client-access-token-1.0.jar file from the client/target directory to the directory that includes the private keys for the test services we created in the section Athenz Management Setup above. If the ZTS Server is running with a self-signed certificate, we need to generate a truststore for the java http client to use when communicating with the ZTS Server. From your ZTS Server installation, copy the zts_cert.pem file from the athenz-zts-X.Y/var/zts_server/certs directory into the same directory where the client access token utility is saved (previous step) and execute the following commands: $ keytool -importcert -noprompt -alias zts -keystore zts_truststore.jks -file zts_cert.pem -storepass athenz","title":"Test Cases"},{"location":"example_java_decentralized_access/#invalid-access-without-accesstoken","text":"For this test case we'll just use the curl client directly: $ curl http://localhost:8080/athenz-data/rec/v1/movie <html> ... <title>Error 403 Forbidden - No Athenz accessToken provided in request</title> ... </html>","title":"Invalid Access Without accessToken"},{"location":"example_java_decentralized_access/#movie-editor-access","text":"Movie service can successfully access /rec/v1/movie endpoint: $ java -Djavax.net.ssl.trustStore = ./zts_truststore.jks -cp ./example-java-client-access-token-1.0.jar com.yahoo.athenz.example.accesstoken.HttpExampleClient -t ./zts_truststore.jks -p athenz -s movie -p ./movie_private.pem -d recommend -pr movie_editors -z https://<zts-server>:8443/zts/v1 -u http://localhost:8080/athenz-data/rec/v1/movie Successful response: Name: Slap Shot ; Director: George Roy Hill Movie service does not have access to /rec/v1/tvshow endpoint: $ java -Djavax.net.ssl.trustStore = ./zts_truststore.jks -cp ./example-java-client-access-token-1.0.jar com.yahoo.athenz.example.accesstoken.HttpExampleClient -t ./zts_truststore.jks -p athenz -s movie -p ./movie_private.pem -d recommend -pr movie_editors -z https://<zts-server>:8443/zts/v1 -u http://localhost:8080/athenz-data/rec/v1/tvshow Request was forbidden - not authorized","title":"Movie Editor Access"},{"location":"example_java_decentralized_access/#tvshow-editor-access","text":"TvShow service can successfully access /rec/v1/tvshow endpoint: $ java -Djavax.net.ssl.trustStore = ./zts_truststore.jks -cp ./example-java-client-access-token-1.0.jar com.yahoo.athenz.example.accesstoken.HttpExampleClient -t ./zts_truststore.jks -p athenz -s tvshow -p ./tvshow_private.pem -d recommend -pr tvshow_editors -z https://<zts-server>:8443/zts/v1 -u http://localhost:8080/athenz-data/rec/v1/tvshow Successful response: Name: Middle ; Channel: ABC TvShow service does not have access to /rec/v1/movie endpoint: $ java -Djavax.net.ssl.trustStore = ./zts_truststore.jks -cp ./example-java-client-access-token-1.0.jar com.yahoo.athenz.example.accesstoken.HttpExampleClient -t ./zts_truststore.jks -p athenz -s tvshow -p ./tvshow_private.pem -d recommend -pr tvshow_editors -z https://<zts-server>:8443/zts/v1 -u http://localhost:8080/athenz-data/rec/v1/movie Request was forbidden - not authorized","title":"TvShow Editor Access"},{"location":"example_java_decentralized_access/#site-editor-access","text":"Site service has access to both /rec/v1/tvshow and /rec/v1/movie endpoints: $ java -Djavax.net.ssl.trustStore = ./zts_truststore.jks -cp ./example-java-client-access-token-1.0.jar com.yahoo.athenz.example.accesstoken.HttpExampleClient -t ./zts_truststore.jks -p athenz -s site -p ./site_private.pem -d recommend -pr full_access -z https://<zts-server>:8443/zts/v1 -u http://localhost:8080/athenz-data/rec/v1/movie Successful response: Name: Slap Shot ; Director: George Roy Hill $ java -Djavax.net.ssl.trustStore = ./zts_truststore.jks -cp ./example-java-client-access-token-1.0.jar com.yahoo.athenz.example.accesstoken.HttpExampleClient -t ./zts_truststore.jks -p athenz -s site -p ./site_private.pem -k v0 -d recommend -pr full_access -z https://<zts-server>:8443/zts/v1 -u http://localhost:8080/athenz-data/rec/v1/tvshow Successful response: Name: Middle ; Channel: ABC","title":"Site Editor Access"},{"location":"example_java_decentralized_access/#other-test-cases","text":"Now you can modify the movie_editos, tvshow_editors, and site_editors roles in the recommend domain to add and remove the defined services. After you make the changes, it will take about a minute for the updates to propagate from ZMS to the ZTS Server. Then you need to run the zpu_run.sh command again to fetch the updated policy files for the domain onto your host. Then you can run the corresponding test cases to verify your access change.","title":"Other Test Cases"},{"location":"example_service_athenz_setup/","text":"Example Service Access Control Setup \u00b6 Client (Tenant) Domain Movie Editors TvShow Editors Site Editors Service View Server (Provider) Domain Authorization Roles and Policies Movie Access TvShow Access Full Access We've decided that our resources for the service will be defined in Athenz as: rec.movie rec.tvshow and the only supported action for now would be read . Now we can create their respective client and server (also commonly referred as tenant and provider) roles and policies in Athenz. Go to Athenz UI and login with your account which should have system administrator access. Client (Tenant) Domain \u00b6 The client services will be defined in the editors domain so let's create that domain and services. Click on the Create a domain link in top left corner to add the domain: Movie Editors \u00b6 Each service is identified by its private/public key pair. The movie service will be authorized to access the /rec/v1/movie endpoint from our recommendation service. So we need to first generate the key pair (at the end we're going to display the contents of the public key since we'll be using that when creating the service in the UI): $ openssl genrsa -out movie_private.pem 2048 $ openssl rsa -in movie_private.pem -pubout > movie_public.pem $ cat movie_public.pem Now we need to register the movie service in the editors domain. After you login, click on the editors domain in the left hand tree pane, then choose the Services tab. Click on the Add Service button. In the Key Value field when creating a service, enter the contents of the movie_public.pem file. For the Public Key Id field we'll use v0 . Each service can be identified my multiple key pairs. For example, if you have services running in different geographical data centers, each data center instance can have its own unique public/private key pair. It also allows the service administrator to establish a key rotation policy - e.g. generate a new key pair every 6 months and assign a new key identifier: v0, v1, etc. TvShow Editors \u00b6 The tvshow service will be authorized to access the /rec/v1/tvshow endpoint from our recommendation service. So again, we need to first generate the key pair (at the end we're going to display the contents of the public key since we'll be using that when creating the service in the UI): $ openssl genrsa -out tvshow_private.pem 2048 $ openssl rsa -in tvshow_private.pem -pubout > tvshow_public.pem $ cat tvshow_public.pem Now we need to register the tvshow service in the editors domain. After you login, click on the editors domain in the left hand tree pane, then choose the Services tab. Click on the Add Service button. In the Key Value field when creating a service, enter the contents of the tvshow_public.pem file. For the Public Key Id field we'll use v0 . See the Movie Editors section for additional details on this field. Site Editors \u00b6 The site service will be authorized to access both /rec/v1/movie and /rec/v1/tvshow endpoints from our recommendation service. So we need to first generate the key pair (at the end we're going to display the contents of the public key since we'll be using that when creating the service in the UI): $ openssl genrsa -out site_private.pem 2048 $ openssl rsa -in site_private.pem -pubout > site_public.pem $ cat site_public.pem Finally, we need to register the site service in the editors domain. After you login, click on the editors domain in the left hand tree pane, then choose the Services tab.Click on the Add Service button. In the Key Value field when creating a service, enter the contents of the site_public.pem file. For the Public Key Id field we'll use v0 . See the Movie Editors section for additional details on this field. Service View \u00b6 Once all three services are successfully registered, you should have the following Services view for the editors domains: Server (Provider) Domain \u00b6 The recommendation service will be run by recommend property. So let's first create this domain in Athenz. Click on the Create a domain link in top left corner to add the domain: Authorization Roles and Policies \u00b6 Typically since we have two resources and only one action supported in this use case, we'll be creating 2 roles that will be providing access control. In this model, if we want one service to have access to both services, we'll need to add that principal to both roles. A slightly different approach would be to create yet another role that provides full access to all recommendation endpoints. Movie Access \u00b6 First we need to create the role that includes principals authorized to access the movie resource. In our example, we'll call this role as movie_editors and include editors.movie service as a member of this role. After you login, click on the recommend domain in the left hand tree pane, then choose the Roles tab. Click on the Add Role button: Now we need to give access to this role with action read to resource rec.movie . Choose the Policies tab and click on the Add Policy button: TvShow Access \u00b6 Now we need to create the role that includes principals authorized to access the tvshow resource. In our example, we'll call this role as tvshow_editors and include editors.tvshow service as a member of this role. After you login, click on the recommend domain in the left hand tree pane, then choose the Roles tab. Click on the Add Role button: Now we need to give access to this role with action read to resource rec.tvshow . Choose the Policies tab and click on the Add Policy button: Full Access \u00b6 Finally, we need to create the role that includes principals authorized to have full access to any resource in our recommendation service. In our example, we'll call this role as full_access and include editors.site service as a member of this role. After you login, click on the recommend domain in the left hand tree pane, then choose the Roles tab. Click on the Add Role button: Now we need to give access to this role with action * to resource rec.* . Since Athenz support glob style wildcards, having * indicates it will match all actions - e.g. read , write , etc. And having the resource as rec.* indicates that it will match rec.movie , rec.tvshow and any other resource that we create with the prefix rec. . Choose the Policies tab and click on the Add Policy button:","title":"Example Service Access Control Setup"},{"location":"example_service_athenz_setup/#example-service-access-control-setup","text":"Client (Tenant) Domain Movie Editors TvShow Editors Site Editors Service View Server (Provider) Domain Authorization Roles and Policies Movie Access TvShow Access Full Access We've decided that our resources for the service will be defined in Athenz as: rec.movie rec.tvshow and the only supported action for now would be read . Now we can create their respective client and server (also commonly referred as tenant and provider) roles and policies in Athenz. Go to Athenz UI and login with your account which should have system administrator access.","title":"Example Service Access Control Setup"},{"location":"example_service_athenz_setup/#client-tenant-domain","text":"The client services will be defined in the editors domain so let's create that domain and services. Click on the Create a domain link in top left corner to add the domain:","title":"Client (Tenant) Domain"},{"location":"example_service_athenz_setup/#movie-editors","text":"Each service is identified by its private/public key pair. The movie service will be authorized to access the /rec/v1/movie endpoint from our recommendation service. So we need to first generate the key pair (at the end we're going to display the contents of the public key since we'll be using that when creating the service in the UI): $ openssl genrsa -out movie_private.pem 2048 $ openssl rsa -in movie_private.pem -pubout > movie_public.pem $ cat movie_public.pem Now we need to register the movie service in the editors domain. After you login, click on the editors domain in the left hand tree pane, then choose the Services tab. Click on the Add Service button. In the Key Value field when creating a service, enter the contents of the movie_public.pem file. For the Public Key Id field we'll use v0 . Each service can be identified my multiple key pairs. For example, if you have services running in different geographical data centers, each data center instance can have its own unique public/private key pair. It also allows the service administrator to establish a key rotation policy - e.g. generate a new key pair every 6 months and assign a new key identifier: v0, v1, etc.","title":"Movie Editors"},{"location":"example_service_athenz_setup/#tvshow-editors","text":"The tvshow service will be authorized to access the /rec/v1/tvshow endpoint from our recommendation service. So again, we need to first generate the key pair (at the end we're going to display the contents of the public key since we'll be using that when creating the service in the UI): $ openssl genrsa -out tvshow_private.pem 2048 $ openssl rsa -in tvshow_private.pem -pubout > tvshow_public.pem $ cat tvshow_public.pem Now we need to register the tvshow service in the editors domain. After you login, click on the editors domain in the left hand tree pane, then choose the Services tab. Click on the Add Service button. In the Key Value field when creating a service, enter the contents of the tvshow_public.pem file. For the Public Key Id field we'll use v0 . See the Movie Editors section for additional details on this field.","title":"TvShow Editors"},{"location":"example_service_athenz_setup/#site-editors","text":"The site service will be authorized to access both /rec/v1/movie and /rec/v1/tvshow endpoints from our recommendation service. So we need to first generate the key pair (at the end we're going to display the contents of the public key since we'll be using that when creating the service in the UI): $ openssl genrsa -out site_private.pem 2048 $ openssl rsa -in site_private.pem -pubout > site_public.pem $ cat site_public.pem Finally, we need to register the site service in the editors domain. After you login, click on the editors domain in the left hand tree pane, then choose the Services tab.Click on the Add Service button. In the Key Value field when creating a service, enter the contents of the site_public.pem file. For the Public Key Id field we'll use v0 . See the Movie Editors section for additional details on this field.","title":"Site Editors"},{"location":"example_service_athenz_setup/#service-view","text":"Once all three services are successfully registered, you should have the following Services view for the editors domains:","title":"Service View"},{"location":"example_service_athenz_setup/#server-provider-domain","text":"The recommendation service will be run by recommend property. So let's first create this domain in Athenz. Click on the Create a domain link in top left corner to add the domain:","title":"Server (Provider) Domain"},{"location":"example_service_athenz_setup/#authorization-roles-and-policies","text":"Typically since we have two resources and only one action supported in this use case, we'll be creating 2 roles that will be providing access control. In this model, if we want one service to have access to both services, we'll need to add that principal to both roles. A slightly different approach would be to create yet another role that provides full access to all recommendation endpoints.","title":"Authorization Roles and Policies"},{"location":"example_service_athenz_setup/#movie-access","text":"First we need to create the role that includes principals authorized to access the movie resource. In our example, we'll call this role as movie_editors and include editors.movie service as a member of this role. After you login, click on the recommend domain in the left hand tree pane, then choose the Roles tab. Click on the Add Role button: Now we need to give access to this role with action read to resource rec.movie . Choose the Policies tab and click on the Add Policy button:","title":"Movie Access"},{"location":"example_service_athenz_setup/#tvshow-access","text":"Now we need to create the role that includes principals authorized to access the tvshow resource. In our example, we'll call this role as tvshow_editors and include editors.tvshow service as a member of this role. After you login, click on the recommend domain in the left hand tree pane, then choose the Roles tab. Click on the Add Role button: Now we need to give access to this role with action read to resource rec.tvshow . Choose the Policies tab and click on the Add Policy button:","title":"TvShow Access"},{"location":"example_service_athenz_setup/#full-access","text":"Finally, we need to create the role that includes principals authorized to have full access to any resource in our recommendation service. In our example, we'll call this role as full_access and include editors.site service as a member of this role. After you login, click on the recommend domain in the left hand tree pane, then choose the Roles tab. Click on the Add Role button: Now we need to give access to this role with action * to resource rec.* . Since Athenz support glob style wildcards, having * indicates it will match all actions - e.g. read , write , etc. And having the resource as rec.* indicates that it will match rec.movie , rec.tvshow and any other resource that we create with the prefix rec. . Choose the Policies tab and click on the Add Policy button:","title":"Full Access"},{"location":"how_to_sample_identity_from_local_athenz/","text":"Overview \u00b6 In this guide, you will be able to create a service in Athenz and obtain a service identity in the form of X.509 certificate from Athenz. Prerequisites \u00b6 Athenz running locally on docker Steps \u00b6 As part of local set up, an example domain by the name \"athenz\" is created and \"athenz-admin\" user is added as a domain administrator of that domain. Please refer to concepts to understand more about domains. To see the workflow of obtaining a service identity certificate from Athenz, please use following steps - Download latest Athenz Utils & add it in the current shell PATH variable latestVer = $( curl -Ls -o /dev/null -w % { url_effective } https://bintray.com/yahoo/maven/athenz-utils/_latestVersion \\# files | cut -d '/' -f 7 ) athenzUtilsLocation = $( mktemp -d ) curl -Ls https://bintray.com/yahoo/maven/download_file?file_path = com%2Fyahoo%2Fathenz%2Fathenz-utils%2F $latestVer %2Fathenz-utils- $latestVer -bin.tar.gz -o $athenzUtilsLocation /athenz-utils- $latestVer .tar.gz tar -xf $athenzUtilsLocation /athenz-utils- $latestVer .tar.gz -C $athenzUtilsLocation export PATH = $athenzUtilsLocation /athenz-utils- $latestVer /bin/ ` uname ` : $PATH Create a public private key pair, register the new service and its public key in Athenz Management Service. Athenz Management Service (ZMS) is running inside a docker container exposed over local port 4443. mkdir -p docker/sample/example-service openssl genrsa -out docker/sample/example-service/athenz.example-service.key.pem 4096 2 > /dev/null openssl rsa -pubout -in docker/sample/example-service/athenz.example-service.key.pem -out docker/sample/example-service/athenz.example-service.pub.pem zms-cli -z https://127.0.0.1:4443/zms/v1 -cert docker/sample/domain-admin/team_admin_cert.pem -key docker/sample/domain-admin/team_admin_key.pem \\ -d athenz add-service example-service v0 docker/sample/example-service/athenz.example-service.pub.pem Now to obtain a service identity certificate, first domain admin needs to authorize a provider. Athenz uses a generalized model for service providers to launch other service identities in an authorized way through a callback-based verification model. For more details please refer to copper argos In this case we will be using Athenz Token Service itself as a provider. In production, it can be any provider like Kubernetes, Openstack, AWS EC2 etc. Domain administrators have a full control over which provider they can authorize to launch their domains' services. Run following command to authorize Athenz Token Service to issue identity certificates for the service created previously zms-cli -z https://127.0.0.1:4443/zms/v1 -cert docker/sample/domain-admin/team_admin_cert.pem -key docker/sample/domain-admin/team_admin_key.pem \\ -d athenz set-domain-template zts_instance_launch_provider service = example-service Wait for few seconds for Athenz Token Service to receive the launch authorization changes from Management Service. Athenz Token Service (ZTS) is running inside a docker container exposed over local port 8443. Use zts-svccert utility to obtain the service identity certificate from Athenz. Athenz also provides agents which can do this for you automatically. zts-svccert -domain athenz -service example-service \\ -private-key docker/sample/example-service/athenz.example-service.key.pem -key-version v0 -zts https://127.0.0.1:8443/zts/v1 \\ -dns-domain zts.athenz.cloud -cert-file docker/sample/example-service/athenz.example-service.cert.pem \\ -cacert docker/sample/CAs/athenz_ca.pem -provider sys.auth.zts -instance instance123 Verify the Common Name ( CN ) in the certificate openssl x509 -in docker/sample/example-service/athenz.example-service.cert.pem -noout -subject","title":"Quick Guide to obtain identity cert using local docker"},{"location":"how_to_sample_identity_from_local_athenz/#overview","text":"In this guide, you will be able to create a service in Athenz and obtain a service identity in the form of X.509 certificate from Athenz.","title":"Overview"},{"location":"how_to_sample_identity_from_local_athenz/#prerequisites","text":"Athenz running locally on docker","title":"Prerequisites"},{"location":"how_to_sample_identity_from_local_athenz/#steps","text":"As part of local set up, an example domain by the name \"athenz\" is created and \"athenz-admin\" user is added as a domain administrator of that domain. Please refer to concepts to understand more about domains. To see the workflow of obtaining a service identity certificate from Athenz, please use following steps - Download latest Athenz Utils & add it in the current shell PATH variable latestVer = $( curl -Ls -o /dev/null -w % { url_effective } https://bintray.com/yahoo/maven/athenz-utils/_latestVersion \\# files | cut -d '/' -f 7 ) athenzUtilsLocation = $( mktemp -d ) curl -Ls https://bintray.com/yahoo/maven/download_file?file_path = com%2Fyahoo%2Fathenz%2Fathenz-utils%2F $latestVer %2Fathenz-utils- $latestVer -bin.tar.gz -o $athenzUtilsLocation /athenz-utils- $latestVer .tar.gz tar -xf $athenzUtilsLocation /athenz-utils- $latestVer .tar.gz -C $athenzUtilsLocation export PATH = $athenzUtilsLocation /athenz-utils- $latestVer /bin/ ` uname ` : $PATH Create a public private key pair, register the new service and its public key in Athenz Management Service. Athenz Management Service (ZMS) is running inside a docker container exposed over local port 4443. mkdir -p docker/sample/example-service openssl genrsa -out docker/sample/example-service/athenz.example-service.key.pem 4096 2 > /dev/null openssl rsa -pubout -in docker/sample/example-service/athenz.example-service.key.pem -out docker/sample/example-service/athenz.example-service.pub.pem zms-cli -z https://127.0.0.1:4443/zms/v1 -cert docker/sample/domain-admin/team_admin_cert.pem -key docker/sample/domain-admin/team_admin_key.pem \\ -d athenz add-service example-service v0 docker/sample/example-service/athenz.example-service.pub.pem Now to obtain a service identity certificate, first domain admin needs to authorize a provider. Athenz uses a generalized model for service providers to launch other service identities in an authorized way through a callback-based verification model. For more details please refer to copper argos In this case we will be using Athenz Token Service itself as a provider. In production, it can be any provider like Kubernetes, Openstack, AWS EC2 etc. Domain administrators have a full control over which provider they can authorize to launch their domains' services. Run following command to authorize Athenz Token Service to issue identity certificates for the service created previously zms-cli -z https://127.0.0.1:4443/zms/v1 -cert docker/sample/domain-admin/team_admin_cert.pem -key docker/sample/domain-admin/team_admin_key.pem \\ -d athenz set-domain-template zts_instance_launch_provider service = example-service Wait for few seconds for Athenz Token Service to receive the launch authorization changes from Management Service. Athenz Token Service (ZTS) is running inside a docker container exposed over local port 8443. Use zts-svccert utility to obtain the service identity certificate from Athenz. Athenz also provides agents which can do this for you automatically. zts-svccert -domain athenz -service example-service \\ -private-key docker/sample/example-service/athenz.example-service.key.pem -key-version v0 -zts https://127.0.0.1:8443/zts/v1 \\ -dns-domain zts.athenz.cloud -cert-file docker/sample/example-service/athenz.example-service.cert.pem \\ -cacert docker/sample/CAs/athenz_ca.pem -provider sys.auth.zts -instance instance123 Verify the Common Name ( CN ) in the certificate openssl x509 -in docker/sample/example-service/athenz.example-service.cert.pem -noout -subject","title":"Steps"},{"location":"local_athenz_on_docker/","text":"Overview \u00b6 In this introduction to Athenz, you will be able to run Athenz on your workstation. Prerequisites \u00b6 Docker Steps \u00b6 Checkout Athenz from Github git clone https://github.com/AthenZ/athenz.git cd to checked out directory and run following command: cd athenz && ./start-local-athenz.sh This script will - download Athenz components docker images from DockerHub generate self-signed certificates to be used by Athenz components configure Athenz with meaningful defaults suitable for local environment ( for production set up, please refer to \"Production set up\" section of docs.) start local containers corresponding to Athenz components (ZMS, ZMS DB, ZTS, ZTS DB, UI) Note If you are using MacOS, then the script prints out a command at the end, which you can execute to add the generated self-signed certificate to your login keychain so that you can access Athenz UI in the browser without certificate warning. If you don't want to do that, please follow appropriate instructions for your workstation and / or browser so that you can access Athenz UI in the browser. Access the UI at https://localhost . For your convenience local set up uses a TestUserAuthority which accepts any username and password as far as it's a same string. To look at a pre-created \"athenz\" domain during start up, login with \"athenz-admin\" as username and password.","title":"Using Athenz on local docker"},{"location":"local_athenz_on_docker/#overview","text":"In this introduction to Athenz, you will be able to run Athenz on your workstation.","title":"Overview"},{"location":"local_athenz_on_docker/#prerequisites","text":"Docker","title":"Prerequisites"},{"location":"local_athenz_on_docker/#steps","text":"Checkout Athenz from Github git clone https://github.com/AthenZ/athenz.git cd to checked out directory and run following command: cd athenz && ./start-local-athenz.sh This script will - download Athenz components docker images from DockerHub generate self-signed certificates to be used by Athenz components configure Athenz with meaningful defaults suitable for local environment ( for production set up, please refer to \"Production set up\" section of docs.) start local containers corresponding to Athenz components (ZMS, ZMS DB, ZTS, ZTS DB, UI) Note If you are using MacOS, then the script prints out a command at the end, which you can execute to add the generated self-signed certificate to your login keychain so that you can access Athenz UI in the browser without certificate warning. If you don't want to do that, please follow appropriate instructions for your workstation and / or browser so that you can access Athenz UI in the browser. Access the UI at https://localhost . For your convenience local set up uses a TestUserAuthority which accepts any username and password as far as it's a same string. To look at a pre-created \"athenz\" domain during start up, login with \"athenz-admin\" as username and password.","title":"Steps"},{"location":"member_expiration/","text":"When adding principals to a role, the domain administrator can specify an optional expiry date for the principal. Athenz also provides the capability to automatically assign an expiry date for any principal for a configured role or all roles if the expiry day is configured at the domain level. There are separate limits for user and service principals. The administrator may decide to configure a limit only for user members but not for service principals to avoid any possible service outages when they fail to review and extend service principals' memberships. Athenz can send email notifications to all principals and the domain administrators when access is about to expire. See the Email Notifications section to enable notifications. Role Level Expiry Support \u00b6 The domain administrator may specify a maximum expiry day setting for a specific role: zms-cli -d <domain-name> set-role-member-expiry-days <role-name> <user-member-expiry-days> zms-cli -d <domain-name> set-role-service-expiry-days <role-name> <service-member-expiry-days> If the domain administrator has specified a user max expiry days of 30 to db_reader_access role, then all user members will automatically have an expiration value of 30 days from the current time. If the domain administrator has specified a value longer than 30 days or no expiry, then it will be reduced to 30 days from the current time. However, if the domain administrator specified expiration of fewer than 30 days (e.g. 7 days), then it will be honored and not extended to 30 days. If the domain administrator specifies a shorter limit on an already configured role, for example reducing from 30 to 15 days, then the server will iterate through all members and reduce the expiration to 15 days from the current time based on the configured limit (either user or service principals depending on the setting being changed). Again, if the current expiry is already less than 15 days, the expiration value will not be changed. However, if the domain administrator extends the configuration setting from 30 to 60 days, then no changes will be made to existing users - they will not be automatically extended. All new members will be enforced with a 60 day expiry period, but old members will continue to have their original 30-day expiration values until those values are extended. If the domain administrator specifies an expiration at both role and domain levels, then the role level always overrides the domain setting for the role - regardless if it's shorter or longer than the domain configured value. You can look at the currently configured value for a specific role using zms-cli -d <domain-name> show-role <role-name> command. Domain Level Expiry Support \u00b6 The domain administrator may specify maximum expiry day setting for the full domain: zms-cli -d <domain-name> set-domain-member-expiry-days <user-member-expiry-days> zms-cli -d <domain-name> set-domain-service-expiry-days <service-member-expiry-days> If the domain administrator has specified a max expiry days of 90 to sports domain, then all members in all roles in that domain will automatically have an expiration value of 30 days from the current time. Check the section above to understand how the server automatically assigns an expiration date to all role members. You can look at the currently configured value for a specific domain using zms-cli -d <domain-name> show-domain command. ** Important ** When setting an expiry days at a domain level, the limit is also imposed on all domain administrators in the admin role. Thus, the domain administrator must be careful to extend their expiry days before they lose access to the domain. Email Notifications \u00b6 Athenz automatically monitors all role members and notifies both principals and domain administrators when access to a role is about to expire and can send email notifications. There are 2 types of email notifications you might get. The email notifications are sent when the expiry is 1, 7, 14, 21, and 28 days away. Role Member Expiration \u00b6 The principal (if human) or the principal's domain administrators (if service) will get a notification when the principal's access in a role is about to expiry. The email notification will include the domain and role name that the principal is a member of. The principal must contact the administrators of that role/domain to request their access to be extended. Domain Administrator Notification \u00b6 The domain administrators will receive a single email notification listing all the members that are about to expire in their domain. It is their responsibility to access their domain in Athenz UI and extend those member's expiration, if necessary.","title":"Role Member Auto Expiry and Notification Support"},{"location":"member_expiration/#role-level-expiry-support","text":"The domain administrator may specify a maximum expiry day setting for a specific role: zms-cli -d <domain-name> set-role-member-expiry-days <role-name> <user-member-expiry-days> zms-cli -d <domain-name> set-role-service-expiry-days <role-name> <service-member-expiry-days> If the domain administrator has specified a user max expiry days of 30 to db_reader_access role, then all user members will automatically have an expiration value of 30 days from the current time. If the domain administrator has specified a value longer than 30 days or no expiry, then it will be reduced to 30 days from the current time. However, if the domain administrator specified expiration of fewer than 30 days (e.g. 7 days), then it will be honored and not extended to 30 days. If the domain administrator specifies a shorter limit on an already configured role, for example reducing from 30 to 15 days, then the server will iterate through all members and reduce the expiration to 15 days from the current time based on the configured limit (either user or service principals depending on the setting being changed). Again, if the current expiry is already less than 15 days, the expiration value will not be changed. However, if the domain administrator extends the configuration setting from 30 to 60 days, then no changes will be made to existing users - they will not be automatically extended. All new members will be enforced with a 60 day expiry period, but old members will continue to have their original 30-day expiration values until those values are extended. If the domain administrator specifies an expiration at both role and domain levels, then the role level always overrides the domain setting for the role - regardless if it's shorter or longer than the domain configured value. You can look at the currently configured value for a specific role using zms-cli -d <domain-name> show-role <role-name> command.","title":"Role Level Expiry Support"},{"location":"member_expiration/#domain-level-expiry-support","text":"The domain administrator may specify maximum expiry day setting for the full domain: zms-cli -d <domain-name> set-domain-member-expiry-days <user-member-expiry-days> zms-cli -d <domain-name> set-domain-service-expiry-days <service-member-expiry-days> If the domain administrator has specified a max expiry days of 90 to sports domain, then all members in all roles in that domain will automatically have an expiration value of 30 days from the current time. Check the section above to understand how the server automatically assigns an expiration date to all role members. You can look at the currently configured value for a specific domain using zms-cli -d <domain-name> show-domain command. ** Important ** When setting an expiry days at a domain level, the limit is also imposed on all domain administrators in the admin role. Thus, the domain administrator must be careful to extend their expiry days before they lose access to the domain.","title":"Domain Level Expiry Support"},{"location":"member_expiration/#email-notifications","text":"Athenz automatically monitors all role members and notifies both principals and domain administrators when access to a role is about to expire and can send email notifications. There are 2 types of email notifications you might get. The email notifications are sent when the expiry is 1, 7, 14, 21, and 28 days away.","title":"Email Notifications"},{"location":"member_expiration/#role-member-expiration","text":"The principal (if human) or the principal's domain administrators (if service) will get a notification when the principal's access in a role is about to expiry. The email notification will include the domain and role name that the principal is a member of. The principal must contact the administrators of that role/domain to request their access to be extended.","title":"Role Member Expiration"},{"location":"member_expiration/#domain-administrator-notification","text":"The domain administrators will receive a single email notification listing all the members that are about to expire in their domain. It is their responsibility to access their domain in Athenz UI and extend those member's expiration, if necessary.","title":"Domain Administrator Notification"},{"location":"member_soft_expiration/","text":"When adding principals to a role, the domain administrator can specify an optional reminder date (aka soft expiry) to review the principal. Athenz also provides the capability to automatically assign a reminder review date for any principal for a configured role. There are separate limits for user and service principals. The administrator may decide to configure a limit only for user members but not for service principals. Athenz can send email notifications to all principals and the domain administrators when the review date is approaching. See the Email Notifications section to enable notifications. Role Level Review Reminder Support \u00b6 The domain administrator may specify a maximum review day setting for a specific role: zms-cli -d <domain-name> set-role-member-review-days <role-name> <user-member-review-days> zms-cli -d <domain-name> set-role-service-review-days <role-name> <service-member-review-days> If the domain administrator has specified a user max review days of 30 to db_reader_access role, then all user members will automatically have a review value of 30 days from the current time. If the domain administrator has specified a value longer than 30 days or no review date, then it will be reduced to 30 days from the current time. However, if the domain administrator specified a review date of fewer than 30 days (e.g. 7 days), then it will be honored and not extended to 30 days. If the domain administrator specifies a shorter limit on an already configured role, for example reducing from 30 to 15 days, then the server will iterate through all members and reduce the review to 15 days from the current time based on the configured limit (either user or service principals depending on the setting being changed). Again, if the current review date is already less than 15 days, the review value will not be changed. However, if the domain administrator extends the configuration setting from 30 to 60 days, then no changes will be made to existing users - they will not be automatically extended. All new members will be enforced with a 60 day review period, but old members will continue to have their original 30-day review values until those values are extended. You can look at the currently configured value for a specific role using zms-cli -d <domain-name> show-role <role-name> command. Email Notifications \u00b6 Athenz automatically monitors all role members and notifies both principals and domain administrators when role membership review is approaching and can send email notifications. There are 2 types of email notifications you might get. The email notifications are sent when the review is 1, 7, 14, 21, and 28 days away. Role Member Review \u00b6 The principal (if human) or the principal's domain administrators (if service) will get a notification when the principal's role membership review date is approaching. The email notification will include the domain and role name that the principal is a member of. The principal must contact the administrators of that role/domain to request their access to be extended. Domain Administrator Notification \u00b6 The domain administrators will receive a single email notification listing all the members with approaching review dates in their domain. It is their responsibility to access their domain in Athenz UI and extend those member's review, if necessary. Role Members with Overdue Review \u00b6 The domain administrator or the paranoids team may review the list of members with overdue review dates: zms-cli overdue-review <domain-name>","title":"Role Member Review Reminder Support"},{"location":"member_soft_expiration/#role-level-review-reminder-support","text":"The domain administrator may specify a maximum review day setting for a specific role: zms-cli -d <domain-name> set-role-member-review-days <role-name> <user-member-review-days> zms-cli -d <domain-name> set-role-service-review-days <role-name> <service-member-review-days> If the domain administrator has specified a user max review days of 30 to db_reader_access role, then all user members will automatically have a review value of 30 days from the current time. If the domain administrator has specified a value longer than 30 days or no review date, then it will be reduced to 30 days from the current time. However, if the domain administrator specified a review date of fewer than 30 days (e.g. 7 days), then it will be honored and not extended to 30 days. If the domain administrator specifies a shorter limit on an already configured role, for example reducing from 30 to 15 days, then the server will iterate through all members and reduce the review to 15 days from the current time based on the configured limit (either user or service principals depending on the setting being changed). Again, if the current review date is already less than 15 days, the review value will not be changed. However, if the domain administrator extends the configuration setting from 30 to 60 days, then no changes will be made to existing users - they will not be automatically extended. All new members will be enforced with a 60 day review period, but old members will continue to have their original 30-day review values until those values are extended. You can look at the currently configured value for a specific role using zms-cli -d <domain-name> show-role <role-name> command.","title":"Role Level Review Reminder Support"},{"location":"member_soft_expiration/#email-notifications","text":"Athenz automatically monitors all role members and notifies both principals and domain administrators when role membership review is approaching and can send email notifications. There are 2 types of email notifications you might get. The email notifications are sent when the review is 1, 7, 14, 21, and 28 days away.","title":"Email Notifications"},{"location":"member_soft_expiration/#role-member-review","text":"The principal (if human) or the principal's domain administrators (if service) will get a notification when the principal's role membership review date is approaching. The email notification will include the domain and role name that the principal is a member of. The principal must contact the administrators of that role/domain to request their access to be extended.","title":"Role Member Review"},{"location":"member_soft_expiration/#domain-administrator-notification","text":"The domain administrators will receive a single email notification listing all the members with approaching review dates in their domain. It is their responsibility to access their domain in Athenz UI and extend those member's review, if necessary.","title":"Domain Administrator Notification"},{"location":"member_soft_expiration/#role-members-with-overdue-review","text":"The domain administrator or the paranoids team may review the list of members with overdue review dates: zms-cli overdue-review <domain-name>","title":"Role Members with Overdue Review"},{"location":"principal_authentication/","text":"Principal Authentication \u00b6 Authority Work Configuration Provided Authorities Unix User Authority Principal Authority Kerberos Authority Certificate Authority Role Authority LDAP Authority For a principal (either user or service) to authenticate himself/herself in Athenz, the server must have the appropriate authentication authority implementation configured. Athenz has implementation of several authorities that support variety of authentication methods. The system administrator may decide to configure and use one of the provided authorities or implement a completely new one to satisfy their requirements. Authority Work \u00b6 The job of the Authority is authenticate a specific request and, if valid, generate and return an object representing the authenticated Principal. The Authority interface is defined in the following file: Authority The system administrator can configure a list of authorities for supporting principal authentication. During startup, the server will call the initialize() method for all configured authorities. If the authority requires access to any of the service public keys registered within Athenz, then it needs to implement the AuthorityKeyStore interface as well and provide an implementation of the setKeyStore() method. The server implements the KeyStore interface and will automatically call the setKeyStore() method to pass its implementation to the authority. AuthorityKeyStore When processing a request the server goes through the list of authorities in their configured order and processes until it receives a successful principal object. As soon as a successful response is received from the authenticate method, the server will stop processing other authorities in the list and continue with the authorization check. If no authority returns an authenticated principal, the server returns 401 Unauthenticated response to the calling client. The Authority defines if the authentication details are based on a header or certificate: getCredSource() . If the returned value is HEADER then the Athenz server will retrieve the header, identified by the value returned by the getHeader() method, that the authority is looking for and if a value is present, it will call the authenticate() method to see if the request contains valid credentials or not. The returned principal object contains the Authority object that was used for authentication. This allows the Athenz servers, if necessary, to decide if further checks and/or restrictions are necessary. Configuration \u00b6 Both ZMS and ZTS Servers expect to find the list of authority classes in their respective system properties: ZMS: athenz.zms.authority_classes ZTS: athenz.zts.authority_classes The value of the property must be a comma separated (no spaces) list of authority class names. For example, -Dathenz.zms.authority_classes=com.yahoo.athenz.auth.impl.PrincipalAuthority,com.yahoo.athenz.auth.impl.UserAuthority If you're installing and running Athenz services using the binary packages provided, you can configure the list of authorities in the conf/zms_server/zms.properties or conf/zts_server/zts.properties files for ZMS and ZTS servers respectively: athenz.zms.authority_classes=com.yahoo.athenz.auth.impl.PrincipalAuthority,com.yahoo.athenz.auth.impl.UserAuthority athenz.zts.authority_classes=com.yahoo.athenz.auth.impl.PrincipalAuthority,com.yahoo.athenz.auth.impl.UserAuthority Provided Authorities \u00b6 Here is the list of Athenz provided authorities with brief description of each one. Unix User Authority \u00b6 Class: com.yahoo.athenz.auth.impl.UserAuthority This authority uses the Unix pam login profile to authenticate users. The user that the ZMS process runs as must have read access to the /etc/shadow file. There are two options available: Run the process as root using sudo. This is only recommended for a local development installation. Create a special Unix group that has read access to the /etc/shadow file and set the user that the ZMS process will be running as a member of that group. User Authority is typically not allowed to carry out any authorized operation. It is required that the user first must obtain an X509 certificate for his/her identity and use that certificate to carry out the authorized request. Principal Authority \u00b6 Class: com.yahoo.athenz.auth.impl.PrincipalAuthority This authority uses Athenz generated NTokens. It accepts NTokens, parses to extract the signature and the private key details that were used to sign this token: domain, service, and key id. Then it requests the corresponding public key and verifies the signature. Principal Authority is one of primary authorities in Athenz. It is used to validate NTokens that were issued by ZTS and service tokens generated by SIA Providers. By default, when authenticating an NToken, the authority validates that the IP address in the NToken matches to the IP address of the request. This provides extra security that changes to domain data are not carried out by NTokens that possible have been stolen. Kerberos Authority \u00b6 Class: com.yahoo.athenz.auth.impl.KerberosAuthority This authority supports environments with Kerberos servers. This authority expects to find the Kerberos Ticket in the Authorization header. There are several system properties that must be set for proper initialization of this authority: athenz.auth.kerberos.service_principal - Kerberos service principal athenz.auth.kerberos.keytab_location - Kerberos keytab location athenz.auth.kerberos.jaas_cfg_section - JAAS configuration section. If using a jaas.conf file then that path is specified by the system property java.security.auth.login.config For full details check out the implementation of the Kerberos Authority: Kerberos Authority Certificate Authority \u00b6 Class: com.yahoo.athenz.auth.impl.CertificateAuthority The certificate authority expects that the server has been configured with a truststore that only includes the CA cert that it tasked with issuing principal certificates. The Authority only looks at the CommonName component of the certificate and expects it to include the service name in the {domain}.{service} format. For example: Certificate Subject DN: c=US;o=Some Athenz Company;cn=sports.fantasy The authenticated principal in this case is service fantasy in domain sports . LDAP Authority \u00b6 Class: com.yahoo.athenz.auth.impl.LDAPAuthority Lightweight Directory Access Protocol (LDAP) authority uses the bind operation to authenticate users. The authentication mechanism used is simple where plain text username and passwords are used. The hostname , port number and base DN property of the LDAP server needs to be provided. An example of base dn is: LDAP Server Base DN: dc=example,dc=com","title":"Principal Authentication"},{"location":"principal_authentication/#principal-authentication","text":"Authority Work Configuration Provided Authorities Unix User Authority Principal Authority Kerberos Authority Certificate Authority Role Authority LDAP Authority For a principal (either user or service) to authenticate himself/herself in Athenz, the server must have the appropriate authentication authority implementation configured. Athenz has implementation of several authorities that support variety of authentication methods. The system administrator may decide to configure and use one of the provided authorities or implement a completely new one to satisfy their requirements.","title":"Principal Authentication"},{"location":"principal_authentication/#authority-work","text":"The job of the Authority is authenticate a specific request and, if valid, generate and return an object representing the authenticated Principal. The Authority interface is defined in the following file: Authority The system administrator can configure a list of authorities for supporting principal authentication. During startup, the server will call the initialize() method for all configured authorities. If the authority requires access to any of the service public keys registered within Athenz, then it needs to implement the AuthorityKeyStore interface as well and provide an implementation of the setKeyStore() method. The server implements the KeyStore interface and will automatically call the setKeyStore() method to pass its implementation to the authority. AuthorityKeyStore When processing a request the server goes through the list of authorities in their configured order and processes until it receives a successful principal object. As soon as a successful response is received from the authenticate method, the server will stop processing other authorities in the list and continue with the authorization check. If no authority returns an authenticated principal, the server returns 401 Unauthenticated response to the calling client. The Authority defines if the authentication details are based on a header or certificate: getCredSource() . If the returned value is HEADER then the Athenz server will retrieve the header, identified by the value returned by the getHeader() method, that the authority is looking for and if a value is present, it will call the authenticate() method to see if the request contains valid credentials or not. The returned principal object contains the Authority object that was used for authentication. This allows the Athenz servers, if necessary, to decide if further checks and/or restrictions are necessary.","title":"Authority Work"},{"location":"principal_authentication/#configuration","text":"Both ZMS and ZTS Servers expect to find the list of authority classes in their respective system properties: ZMS: athenz.zms.authority_classes ZTS: athenz.zts.authority_classes The value of the property must be a comma separated (no spaces) list of authority class names. For example, -Dathenz.zms.authority_classes=com.yahoo.athenz.auth.impl.PrincipalAuthority,com.yahoo.athenz.auth.impl.UserAuthority If you're installing and running Athenz services using the binary packages provided, you can configure the list of authorities in the conf/zms_server/zms.properties or conf/zts_server/zts.properties files for ZMS and ZTS servers respectively: athenz.zms.authority_classes=com.yahoo.athenz.auth.impl.PrincipalAuthority,com.yahoo.athenz.auth.impl.UserAuthority athenz.zts.authority_classes=com.yahoo.athenz.auth.impl.PrincipalAuthority,com.yahoo.athenz.auth.impl.UserAuthority","title":"Configuration"},{"location":"principal_authentication/#provided-authorities","text":"Here is the list of Athenz provided authorities with brief description of each one.","title":"Provided Authorities"},{"location":"principal_authentication/#unix-user-authority","text":"Class: com.yahoo.athenz.auth.impl.UserAuthority This authority uses the Unix pam login profile to authenticate users. The user that the ZMS process runs as must have read access to the /etc/shadow file. There are two options available: Run the process as root using sudo. This is only recommended for a local development installation. Create a special Unix group that has read access to the /etc/shadow file and set the user that the ZMS process will be running as a member of that group. User Authority is typically not allowed to carry out any authorized operation. It is required that the user first must obtain an X509 certificate for his/her identity and use that certificate to carry out the authorized request.","title":"Unix User Authority"},{"location":"principal_authentication/#principal-authority","text":"Class: com.yahoo.athenz.auth.impl.PrincipalAuthority This authority uses Athenz generated NTokens. It accepts NTokens, parses to extract the signature and the private key details that were used to sign this token: domain, service, and key id. Then it requests the corresponding public key and verifies the signature. Principal Authority is one of primary authorities in Athenz. It is used to validate NTokens that were issued by ZTS and service tokens generated by SIA Providers. By default, when authenticating an NToken, the authority validates that the IP address in the NToken matches to the IP address of the request. This provides extra security that changes to domain data are not carried out by NTokens that possible have been stolen.","title":"Principal Authority"},{"location":"principal_authentication/#kerberos-authority","text":"Class: com.yahoo.athenz.auth.impl.KerberosAuthority This authority supports environments with Kerberos servers. This authority expects to find the Kerberos Ticket in the Authorization header. There are several system properties that must be set for proper initialization of this authority: athenz.auth.kerberos.service_principal - Kerberos service principal athenz.auth.kerberos.keytab_location - Kerberos keytab location athenz.auth.kerberos.jaas_cfg_section - JAAS configuration section. If using a jaas.conf file then that path is specified by the system property java.security.auth.login.config For full details check out the implementation of the Kerberos Authority: Kerberos Authority","title":"Kerberos Authority"},{"location":"principal_authentication/#certificate-authority","text":"Class: com.yahoo.athenz.auth.impl.CertificateAuthority The certificate authority expects that the server has been configured with a truststore that only includes the CA cert that it tasked with issuing principal certificates. The Authority only looks at the CommonName component of the certificate and expects it to include the service name in the {domain}.{service} format. For example: Certificate Subject DN: c=US;o=Some Athenz Company;cn=sports.fantasy The authenticated principal in this case is service fantasy in domain sports .","title":"Certificate Authority"},{"location":"principal_authentication/#ldap-authority","text":"Class: com.yahoo.athenz.auth.impl.LDAPAuthority Lightweight Directory Access Protocol (LDAP) authority uses the bind operation to authenticate users. The authentication mechanism used is simple where plain text username and passwords are used. The hostname , port number and base DN property of the LDAP server needs to be provided. An example of base dn is: LDAP Server Base DN: dc=example,dc=com","title":"LDAP Authority"},{"location":"principal_groups/","text":"To simplify management of principals in roles, the users and services can be included in Groups. Then, the Group can be added as a principal to any role within Athenz thus granting the members of that group access to the configured resources. For example, if you need to add your development team members to multiple roles in your domain, you can create a group called dev-team , add those users into that group and then include the group as a member in the corresponding roles. When you need to remove or add a member, then you only need to modify the membership of your dev-team group. The groups cannot contain other groups. Resource URI \u00b6 The groups are identified in Athenz with the following resource uri: <domain>:group.<group-name> Group Management \u00b6 The group name can only include alpha numeric characters including - and _. Currently, groups can only be provisioned with zms-cli command line utility: zms-cli -d <domain-name> add-group <group-name> <member> [<member> ...] Once provisioned, they can be added to any role as a regular member. For example, if I need to create a group called dev-team in my sports domain and add it to my readers role in fantasy domain, I would execute the following zms-cli commands: zms-cli -d sports add-group dev-team user.hga user.pgote zms-cli -d fantasy add-member readers sports:group.dev-team Similar to roles api, groups can be managed by adding and removing members: zms-cli -d <domain-name> add-group-member <group-name> <member> [<member> ...] zms-cli -d <domain-name> delete-group-member <group-name> <member> [<member> ...] To enforce the least privilege access principle, there are several restrictions placed on groups: You cannot use wildcards * when adding members to a group. The ZMS Server will verify that all users and services are valid before they can be added to a group. Groups are not allowed to be added to admin groups. We strongly recommend limiting the number of users who are identified as domain administrators. Groups cannot include other groups (no inheritance). However, a role can include multiple groups as a member, and those groups could be from different domains. Groups cannot be references in policies. They can only be added as members of a role. Groups cannot be deleted if they're referenced in other roles. The domain administrator must first remove the group as a member (the role might be in a different domain) before deleting it. Groups do not support temporary members. If you need to give temporary access to a specific principal, that principal with expiration must be added to the role directly. Governance / Audit Support \u00b6 Similar to roles, groups support multiple features to satisfy auditing and governance requirements: Audit Enabled Mode \u00b6 If the domain is marked as audit enabled, then specific groups within that domain can also be set in audit enabled mode thus requiring an explicit approval process for any member addition to that group. zms-cli -d <domain-name> set-group-audit-enabled <group-name> true Unlike a regular group, when any one of the domain administrators adds a user in an audit enabled group, it will be added in pending/inactive state until it is approved by one of the organization approvers configured for the domain. Review Enabled Mode \u00b6 The domain administrator can also mark a group as review enabled thus requiring two domain administrator approvals before a principal is added to a group. zms-cli -d <domain-name> set-group-review-enabled <group-name> true Self Service Mode \u00b6 The users can only add themselves to any self-served groups. Their access is not active until one of the domain administrators approves the request. zms-cli -d <domain-name> set-group-self-serve <group-name> true","title":"Principal Groups"},{"location":"principal_groups/#resource-uri","text":"The groups are identified in Athenz with the following resource uri: <domain>:group.<group-name>","title":"Resource URI"},{"location":"principal_groups/#group-management","text":"The group name can only include alpha numeric characters including - and _. Currently, groups can only be provisioned with zms-cli command line utility: zms-cli -d <domain-name> add-group <group-name> <member> [<member> ...] Once provisioned, they can be added to any role as a regular member. For example, if I need to create a group called dev-team in my sports domain and add it to my readers role in fantasy domain, I would execute the following zms-cli commands: zms-cli -d sports add-group dev-team user.hga user.pgote zms-cli -d fantasy add-member readers sports:group.dev-team Similar to roles api, groups can be managed by adding and removing members: zms-cli -d <domain-name> add-group-member <group-name> <member> [<member> ...] zms-cli -d <domain-name> delete-group-member <group-name> <member> [<member> ...] To enforce the least privilege access principle, there are several restrictions placed on groups: You cannot use wildcards * when adding members to a group. The ZMS Server will verify that all users and services are valid before they can be added to a group. Groups are not allowed to be added to admin groups. We strongly recommend limiting the number of users who are identified as domain administrators. Groups cannot include other groups (no inheritance). However, a role can include multiple groups as a member, and those groups could be from different domains. Groups cannot be references in policies. They can only be added as members of a role. Groups cannot be deleted if they're referenced in other roles. The domain administrator must first remove the group as a member (the role might be in a different domain) before deleting it. Groups do not support temporary members. If you need to give temporary access to a specific principal, that principal with expiration must be added to the role directly.","title":"Group Management"},{"location":"principal_groups/#governance-audit-support","text":"Similar to roles, groups support multiple features to satisfy auditing and governance requirements:","title":"Governance / Audit Support"},{"location":"principal_groups/#audit-enabled-mode","text":"If the domain is marked as audit enabled, then specific groups within that domain can also be set in audit enabled mode thus requiring an explicit approval process for any member addition to that group. zms-cli -d <domain-name> set-group-audit-enabled <group-name> true Unlike a regular group, when any one of the domain administrators adds a user in an audit enabled group, it will be added in pending/inactive state until it is approved by one of the organization approvers configured for the domain.","title":"Audit Enabled Mode"},{"location":"principal_groups/#review-enabled-mode","text":"The domain administrator can also mark a group as review enabled thus requiring two domain administrator approvals before a principal is added to a group. zms-cli -d <domain-name> set-group-review-enabled <group-name> true","title":"Review Enabled Mode"},{"location":"principal_groups/#self-service-mode","text":"The users can only add themselves to any self-served groups. Their access is not active until one of the domain administrators approves the request. zms-cli -d <domain-name> set-group-self-serve <group-name> true","title":"Self Service Mode"},{"location":"private_key_store/","text":"Private Key Store \u00b6 Private Key Store Interfaces Configuration Provided Implementation File Based Private Key Store Athenz servers (both ZMS and ZTS) require a unique private key to sign their respective tokens. There are 2 distinct operations that require the use of signatures: X509 Certificates / Access Token signatures Policy Document signatures The private key could be unique per host (if you have multiple ZMS and/or ZTS servers in your production environment) or per data center location. By default the server ships with a file based private key store which expects to find the private key in PEM format in the configured file. The system administrator may decide to configure and use this implementation or otherwise implement a completely new one to satisfy their requirements (e.g. the private keys are to be stored in some external system rather than a file). Private Key Store Interfaces \u00b6 To provide ZMS/ZTS servers with private keys, the following two interfaces must be implemented: PrivateKeyStoreFactory The job of the PrivateKeyStoreFactory class is to implement a single create() method which returns an instance of PrivateKeyStore class implementation. PrivateKeyStore The job of the PrivateKeyStore class is to return a private key for a given host in a PEM format. The hostname is passed as the first argument to the getPrivateKey() method. Each private key in Athenz is identified by a unique key identifier. This allows each service to have multiple active private/public key pairs to support per host keys with key rotation capability. The getPrivateKey() method is passed a StringBuilder object that the implementation must update and return the corresponding key identifier for the public key returned from this method. During server startup, Athenz servers will load the configured private key store factory class and invoke the create method. Then it will use the PrivateKeyStore object returned to retrieve the private key for the host. If the private key store does not return a PrivateKey (returns null), then the server will continue to run. This is necessary since it's possible that an environment may choose to run only ZMS Servers for centralized authorization thus no need to sign and distribute policy documents and only supports TLS certificates for principal authentication. Configuration \u00b6 Both ZMS and ZTS Servers expect to find the configured private key store factory class names in their respective system properties: ZMS: athenz.zms.private_key_store_factory_class ZTS: athenz.zts.private_key_store_factory_class For example, -Dathenz.zms.private_key_store_factory_class=com.yahoo.athenz.zms.pkey.file.FilePrivateKeyStoreFactory If you're installing and running Athenz services using the binary packages provided, you can configure the private key store factory class in the conf/zms_server/zms.properties or conf/zts_server/zts.properties files for ZMS and ZTS servers respectively: athenz.zms.private_key_store_factory_class=com.yahoo.athenz.auth.impl.FilePrivateKeyStoreFactory athenz.zts.private_key_store_factory_class=com.yahoo.athenz.auth.impl.FilePrivateKeyStoreFactory Provided Implementation \u00b6 Here is the list of Athenz provided private key store implementations with brief description of each one. File Based Private Key Store \u00b6 Class: com.yahoo.athenz.auth.impl.FilePrivateKeyStoreFactory This factory class creates and returns a single private key regardless of the hostname passed to the getPrivateKey() method. The private key file and its corresponding id can be configured by using the following system properties: Key File: athenz.auth.private_key_store.private_key Key-Id: athenz.auth.private_key_store.private_key_id The key file must be a PEM encoded either RSA or EC private key.","title":"Private Key Store"},{"location":"private_key_store/#private-key-store","text":"Private Key Store Interfaces Configuration Provided Implementation File Based Private Key Store Athenz servers (both ZMS and ZTS) require a unique private key to sign their respective tokens. There are 2 distinct operations that require the use of signatures: X509 Certificates / Access Token signatures Policy Document signatures The private key could be unique per host (if you have multiple ZMS and/or ZTS servers in your production environment) or per data center location. By default the server ships with a file based private key store which expects to find the private key in PEM format in the configured file. The system administrator may decide to configure and use this implementation or otherwise implement a completely new one to satisfy their requirements (e.g. the private keys are to be stored in some external system rather than a file).","title":"Private Key Store"},{"location":"private_key_store/#private-key-store-interfaces","text":"To provide ZMS/ZTS servers with private keys, the following two interfaces must be implemented: PrivateKeyStoreFactory The job of the PrivateKeyStoreFactory class is to implement a single create() method which returns an instance of PrivateKeyStore class implementation. PrivateKeyStore The job of the PrivateKeyStore class is to return a private key for a given host in a PEM format. The hostname is passed as the first argument to the getPrivateKey() method. Each private key in Athenz is identified by a unique key identifier. This allows each service to have multiple active private/public key pairs to support per host keys with key rotation capability. The getPrivateKey() method is passed a StringBuilder object that the implementation must update and return the corresponding key identifier for the public key returned from this method. During server startup, Athenz servers will load the configured private key store factory class and invoke the create method. Then it will use the PrivateKeyStore object returned to retrieve the private key for the host. If the private key store does not return a PrivateKey (returns null), then the server will continue to run. This is necessary since it's possible that an environment may choose to run only ZMS Servers for centralized authorization thus no need to sign and distribute policy documents and only supports TLS certificates for principal authentication.","title":"Private Key Store Interfaces"},{"location":"private_key_store/#configuration","text":"Both ZMS and ZTS Servers expect to find the configured private key store factory class names in their respective system properties: ZMS: athenz.zms.private_key_store_factory_class ZTS: athenz.zts.private_key_store_factory_class For example, -Dathenz.zms.private_key_store_factory_class=com.yahoo.athenz.zms.pkey.file.FilePrivateKeyStoreFactory If you're installing and running Athenz services using the binary packages provided, you can configure the private key store factory class in the conf/zms_server/zms.properties or conf/zts_server/zts.properties files for ZMS and ZTS servers respectively: athenz.zms.private_key_store_factory_class=com.yahoo.athenz.auth.impl.FilePrivateKeyStoreFactory athenz.zts.private_key_store_factory_class=com.yahoo.athenz.auth.impl.FilePrivateKeyStoreFactory","title":"Configuration"},{"location":"private_key_store/#provided-implementation","text":"Here is the list of Athenz provided private key store implementations with brief description of each one.","title":"Provided Implementation"},{"location":"private_key_store/#file-based-private-key-store","text":"Class: com.yahoo.athenz.auth.impl.FilePrivateKeyStoreFactory This factory class creates and returns a single private key regardless of the hostname passed to the getPrivateKey() method. The private key file and its corresponding id can be configured by using the following system properties: Key File: athenz.auth.private_key_store.private_key Key-Id: athenz.auth.private_key_store.private_key_id The key file must be a PEM encoded either RSA or EC private key.","title":"File Based Private Key Store"},{"location":"reg_service_guide/","text":"Once a domain has been registered in Athenz, the administrator will register service identities that are specified in domain roles and policy assertions. The latter can reference those roles having access to specified resources. Athenz supports service authentication with two types of credentials: X.509 Certificates (preferred approach) Instructions Public/Private Key Pairs Before you can register the service identity, you'll need to generate keys. In this section we'll cover how to create the keys and register the service identity. Key Generation \u00b6 The registration process requires the domain administrator to generate a private/public RSA key pair (must be at least 2048 bit) for the service. The following are the keys and the services that use those keys: private key - The SIA server/utility uses the private key to generate a ServiceToken identifying the service. public key - ZMS/ZTS then use the public key to validate the ServiceToken generated by SIA. The openssl command-line utility is used to generate the key pair: $ umask 077 $ openssl genrsa -out service_private.key 2048 $ openssl rsa -in service_private.key -pubout > service_public.key If using the zms-cli client utility to register the service identity, the public key file must have an extension of .pem or .key. Private Keys \u00b6 The private key file must be installed on all hosts where the service will be running. The reason the use of X.509 Certificates is the preferred approach is because to securely install the private key on all hosts presents a challenge. Each key pair has a key identifier that will be included in the generated ServiceTokens as the value of the k component. If the service\u2019s private key has been compromised or the service has a policy to periodically rotate the keys, the service administrator will generate a new key pair, remove the public key with the old identifier, and register a new public key with a different key identifier. Typically, a service would start with \"0\" as its first identifier and increment when required. Key Rotation \u00b6 If the service\u2019s private key has been compromised or the service has a policy to periodically rotate the keys, the service administrator will generate a new key pair, remove the public key with identifier 0 and register a new public key with a different key identifier. As mentioned above, the key identifier is included in generated Service Tokens as the value of the k component. See the instructions below how to add and delete public keys for a service. Service Identity Registration \u00b6 To register a new service identity, select your domain in Athenz UI and choose the Services tab. Select Add Service link on the left side of the screen underneath the Roles/Services/Policies tabs. Enter the Service name, and optional description, the public key ID, and the actual public key contents in pem format: Add new public key \u00b6 Once the services view is displayed, Select the Public Keys icon on the same line as the service to see all the registered public key. Once that view is open, click on the Add Key link on the right hand side. Enter the Key Id and the Key Value which must be a PEM encoded public key. Click Submit to complete your update. Delete an existing public key \u00b6 Once the services view is displayed, Select the Public Keys icon on the same line as the service to see all the registered public key. Once that view is open, click on the Delete trash can icon on the right hand side of the public key.","title":"Registering ZMS Service Identity"},{"location":"reg_service_guide/#key-generation","text":"The registration process requires the domain administrator to generate a private/public RSA key pair (must be at least 2048 bit) for the service. The following are the keys and the services that use those keys: private key - The SIA server/utility uses the private key to generate a ServiceToken identifying the service. public key - ZMS/ZTS then use the public key to validate the ServiceToken generated by SIA. The openssl command-line utility is used to generate the key pair: $ umask 077 $ openssl genrsa -out service_private.key 2048 $ openssl rsa -in service_private.key -pubout > service_public.key If using the zms-cli client utility to register the service identity, the public key file must have an extension of .pem or .key.","title":"Key Generation"},{"location":"reg_service_guide/#private-keys","text":"The private key file must be installed on all hosts where the service will be running. The reason the use of X.509 Certificates is the preferred approach is because to securely install the private key on all hosts presents a challenge. Each key pair has a key identifier that will be included in the generated ServiceTokens as the value of the k component. If the service\u2019s private key has been compromised or the service has a policy to periodically rotate the keys, the service administrator will generate a new key pair, remove the public key with the old identifier, and register a new public key with a different key identifier. Typically, a service would start with \"0\" as its first identifier and increment when required.","title":"Private Keys"},{"location":"reg_service_guide/#key-rotation","text":"If the service\u2019s private key has been compromised or the service has a policy to periodically rotate the keys, the service administrator will generate a new key pair, remove the public key with identifier 0 and register a new public key with a different key identifier. As mentioned above, the key identifier is included in generated Service Tokens as the value of the k component. See the instructions below how to add and delete public keys for a service.","title":"Key Rotation"},{"location":"reg_service_guide/#service-identity-registration","text":"To register a new service identity, select your domain in Athenz UI and choose the Services tab. Select Add Service link on the left side of the screen underneath the Roles/Services/Policies tabs. Enter the Service name, and optional description, the public key ID, and the actual public key contents in pem format:","title":"Service Identity Registration"},{"location":"reg_service_guide/#add-new-public-key","text":"Once the services view is displayed, Select the Public Keys icon on the same line as the service to see all the registered public key. Once that view is open, click on the Add Key link on the right hand side. Enter the Key Id and the Key Value which must be a PEM encoded public key. Click Submit to complete your update.","title":"Add new public key"},{"location":"reg_service_guide/#delete-an-existing-public-key","text":"Once the services view is displayed, Select the Public Keys icon on the same line as the service to see all the registered public key. Once that view is open, click on the Delete trash can icon on the right hand side of the public key.","title":"Delete an existing public key"},{"location":"review_enabled_roles/","text":"Athenz now supports configuring roles in domains as review-enabled thus requiring two domain administrator approvals before a principal is added to a role. Role Setup \u00b6 To designate a role as review-enabled, the domain administrator may use either Athenz UI or zms-cli utility. To use Athenz UI, the domain administrator will login to their domain role view and choose the Review Enabled slider for the appropriate role. For example, in the following case, the db_reader_access role is configured as review-served. zms-cli -d <domain-name> set-role-review-enabled <role-name> true The show-role command will display the review attribute if it's enabled for a role: $ zms-cli -d home.johndoe set-role-review-enabled read-access true [domain home.johndoe role read-access review-enabled attribute successfully updated] $ zms-cli -d home.johndoe show-role read-access role: - name: read-access review_enabled: true members: - user.janedoe Adding Users to Review Enabled Roles \u00b6 Unlike a regular role, when any one of the domain administrators adds a user in a review enabled role, it will be added in pending/inactive state until it is approved by one of the other domain administrators. For example, in this use case, the domain administrator would like to add user.bob principal to the db_reader_access role which is configured as review enabled. When the domain administrator adds the principal id to the role, it will be added in the Pending Approval column. It will be in pending state until one of the other domain administrators reviews and either approves or rejects the request. Domain Administrator Approval \u00b6 Once the pending request is processed, all domain administrators will receive an email notification stating that user.pgote would like to be added to the db_reader_access role and they need to either approve or reject the request. The email will include a link to the Athenz UI workflow page which can also be accessed by clicking on the notifications icon in the Athenz UI toolbar: Once in the approval view page, the domain administrator may either approve or reject the request. The domain administrator will need to provide a justification in the Audit Reference field and optionally specify an expiration date (even if the user didn't request one). Once approved, the principal will become an active/approved member of the role. If rejected, the principal's name will be removed from the Pending Approval column. ** Important ** The domain administrator that submitted the original request is not authorized to approve his/her own request. It must be approved by another domain administrator. This requires that the domain must have at least 2 administrators. Deleting Users from Review Enabled Roles \u00b6 Additional domain administrator approver workflow only applies to adding users in review enabled roles. The domain administrators have the authorization to remove any principal from a review enabled role without further approval process.","title":"Review Enabled Roles"},{"location":"review_enabled_roles/#role-setup","text":"To designate a role as review-enabled, the domain administrator may use either Athenz UI or zms-cli utility. To use Athenz UI, the domain administrator will login to their domain role view and choose the Review Enabled slider for the appropriate role. For example, in the following case, the db_reader_access role is configured as review-served. zms-cli -d <domain-name> set-role-review-enabled <role-name> true The show-role command will display the review attribute if it's enabled for a role: $ zms-cli -d home.johndoe set-role-review-enabled read-access true [domain home.johndoe role read-access review-enabled attribute successfully updated] $ zms-cli -d home.johndoe show-role read-access role: - name: read-access review_enabled: true members: - user.janedoe","title":"Role Setup"},{"location":"review_enabled_roles/#adding-users-to-review-enabled-roles","text":"Unlike a regular role, when any one of the domain administrators adds a user in a review enabled role, it will be added in pending/inactive state until it is approved by one of the other domain administrators. For example, in this use case, the domain administrator would like to add user.bob principal to the db_reader_access role which is configured as review enabled. When the domain administrator adds the principal id to the role, it will be added in the Pending Approval column. It will be in pending state until one of the other domain administrators reviews and either approves or rejects the request.","title":"Adding Users to Review Enabled Roles"},{"location":"review_enabled_roles/#domain-administrator-approval","text":"Once the pending request is processed, all domain administrators will receive an email notification stating that user.pgote would like to be added to the db_reader_access role and they need to either approve or reject the request. The email will include a link to the Athenz UI workflow page which can also be accessed by clicking on the notifications icon in the Athenz UI toolbar: Once in the approval view page, the domain administrator may either approve or reject the request. The domain administrator will need to provide a justification in the Audit Reference field and optionally specify an expiration date (even if the user didn't request one). Once approved, the principal will become an active/approved member of the role. If rejected, the principal's name will be removed from the Pending Approval column. ** Important ** The domain administrator that submitted the original request is not authorized to approve his/her own request. It must be approved by another domain administrator. This requires that the domain must have at least 2 administrators.","title":"Domain Administrator Approval"},{"location":"review_enabled_roles/#deleting-users-from-review-enabled-roles","text":"Additional domain administrator approver workflow only applies to adding users in review enabled roles. The domain administrators have the authorization to remove any principal from a review enabled role without further approval process.","title":"Deleting Users from Review Enabled Roles"},{"location":"role_cert_expiration/","text":"By default, Athenz ZTS server allows principals to request role certificates with a maximum expiry of 30 days. However, the domain administrator has the capability to specify a maximum expiry limit for a given role or the full domain. This allows the domain administrators to control access to specific roles (or domains) such that the principals do not request role certificates that are valid for up-to 30 days but instead are valid only for the configured number of minutes. Role Level Certificate Expiry Support \u00b6 The domain administrator may specify maximum role certificate expiry setting in minutes for a specific role: zms-cli -d <domain-name> set-role-cert-expiry-mins <role-name> <max-expiry-mins> If the domain administrator has specified a max role certificate expiry mins of 120 to db.writers role, then ZTS will only issue a role certificate with a maximum expiry of 120 mins even if the principal is requesting a longer one. If the principal is requesting a role certificate with a smaller expiry that 120 mins, for example 60 mins, then it will be honored and the role certificate will be issued for 60 mins. If the role does not have a max certificate expiry setting configured, then ZTS will lookup to see if there is a max role certificate expiry setting specified for the domain and use that if it's smaller than the requested certificate expiry value. If the domain administrator specifies a role certificate expiry at both role and domain levels, then the role level always overrides the domain setting for the role - regardless if it's shorter or longer than the domain configured value. You can look at the currently configured value for a specific role using zms-cli -d <domain-name> show-role <role-name> command. To reset the configured limit back to its default behavior, set the limit to 0: zms-cli -d <domain-name> set-role-cert-expiry-mins <role-name> 0 Domain Level Role Certificate Expiry Support \u00b6 The domain administrator may specify maximum role certificate expiry setting in minutes for the full domain: zms-cli -d <domain-name> set-domain-role-cert-expiry-mins <max-expiry-mins> If the domain administrator has specified a max role certificate expiry mins of 360 to sales domain, then ZTS will only issue role certificates with a maximum expiry of 360 mins even if the principal is requesting a longer one. The exception to this rule is if the domain administrator has also specified a value for the role. If the domain administrator specifies a role certificate expiry at both role and domain levels, then the role level always overrides the domain setting for the role - regardless if it's shorter or longer than the domain configured value. If the principal is requesting a role certificate with a smaller expiry that 360 mins configured for the domain, for example 120 mins, and there are no per-role certificate expiry settings configured, then it will be honored and the role certificate will be issued for 120 mins. You can look at the currently configured value for a specific domain using zms-cli -d <domain-name> show-domain command. To reset the configured limit back to its default behavior, set the limit to 0: zms-cli -d <domain-name> set-domain-role-cert-expiry-mins 0","title":"Role Certificate Limit Expiry Support"},{"location":"role_cert_expiration/#role-level-certificate-expiry-support","text":"The domain administrator may specify maximum role certificate expiry setting in minutes for a specific role: zms-cli -d <domain-name> set-role-cert-expiry-mins <role-name> <max-expiry-mins> If the domain administrator has specified a max role certificate expiry mins of 120 to db.writers role, then ZTS will only issue a role certificate with a maximum expiry of 120 mins even if the principal is requesting a longer one. If the principal is requesting a role certificate with a smaller expiry that 120 mins, for example 60 mins, then it will be honored and the role certificate will be issued for 60 mins. If the role does not have a max certificate expiry setting configured, then ZTS will lookup to see if there is a max role certificate expiry setting specified for the domain and use that if it's smaller than the requested certificate expiry value. If the domain administrator specifies a role certificate expiry at both role and domain levels, then the role level always overrides the domain setting for the role - regardless if it's shorter or longer than the domain configured value. You can look at the currently configured value for a specific role using zms-cli -d <domain-name> show-role <role-name> command. To reset the configured limit back to its default behavior, set the limit to 0: zms-cli -d <domain-name> set-role-cert-expiry-mins <role-name> 0","title":"Role Level Certificate Expiry Support"},{"location":"role_cert_expiration/#domain-level-role-certificate-expiry-support","text":"The domain administrator may specify maximum role certificate expiry setting in minutes for the full domain: zms-cli -d <domain-name> set-domain-role-cert-expiry-mins <max-expiry-mins> If the domain administrator has specified a max role certificate expiry mins of 360 to sales domain, then ZTS will only issue role certificates with a maximum expiry of 360 mins even if the principal is requesting a longer one. The exception to this rule is if the domain administrator has also specified a value for the role. If the domain administrator specifies a role certificate expiry at both role and domain levels, then the role level always overrides the domain setting for the role - regardless if it's shorter or longer than the domain configured value. If the principal is requesting a role certificate with a smaller expiry that 360 mins configured for the domain, for example 120 mins, and there are no per-role certificate expiry settings configured, then it will be honored and the role certificate will be issued for 120 mins. You can look at the currently configured value for a specific domain using zms-cli -d <domain-name> show-domain command. To reset the configured limit back to its default behavior, set the limit to 0: zms-cli -d <domain-name> set-domain-role-cert-expiry-mins 0","title":"Domain Level Role Certificate Expiry Support"},{"location":"role_delegation/","text":"Athenz supports two types of roles that an administrator can create in their domains: regular and delegated. The regular role just includes list of principals that may assume that role. The delegated type specifies the trusted domain who has assumed the management of the members for that role. The delegation scenario involves two domains: The \"provider-domain\" is the domain of the service, where the policies and rules are declared, The \"tenant-domain\" (a.k.a. \"trusted-domain\") is the domain in which principals are assigned to the role. The delegation requires agreement from both domains: The provider-domain administrator specifies a role as \"delegated\" to a specific tenant-domain. The tenant-domain administrator creates a rule to assume that role and maps it to one if its local regular roles for principal membership. Definition of required roles and rules \u00b6 The keywords PROVIDER_DOMAIN , TENANT_DOMAIN , PROVIDER_ROLE and TENANT_ROLE are place-holders for the actual id's. Steps for establishing a delegated role: In the provider-domain: Create the role PROVIDER_ROLE as \"delegated\" to the domain TENANT_DOMAIN . Create various rules for PROVIDER_ROLE as usual. In the tenant-domain: Create role TENANT_ROLE Create this rule: Allow Action= assume_role Role= TENANT_ROLE Resource= PROVIDER_DOMAIN:role.PROVIDER_ROLE Assign members to \u201cTENANT_ROLE\u201d as usual. Use Case: Domain Administration Delegation \u00b6 A product team has a top level domain called sales with its configured set of administrators. They also have created a subdomain sales.api for the sales API subproduct. Since Athenz subdomains are completely independent, sales.api has its own admin role and set of administrators. However, in the case of sales product these two domains must have the same set of administrators and the product owner does not want to maintain and manage the admin role members in two places. The sales.api domain wants to delegate administration privileges to the parent sales domain. Step 1: sales.api change: create an admin role for the delegation \u00b6 Since Athenz does not allow administrators to remove or modify the admin role and policy for a domain, first we're going to create a role that will be delegated to the parent sales domain: Select Add Role link on the left side of the screen underneath the Roles tab name. Select a role type as Delegated and enter the role name and tenant-domain name: Step 2: sales.api change: create an admin policy for the delegated role \u00b6 Next we're going to create a new policy that provides the same admin privileges to the delegated sales.admin role. The admin policy uses * for the action and * for the resource. Step 3: sales change: create a policy to assume the sales.admin role \u00b6 Now, the domain administrator for sales domain must agree to assume that role by creating a special policy in its domain. The unique requirements for this policy are the action which must be set to assume_role and the resource which must be set to the full role name ({domain-name}:role.{role-name} format) that is being delegated to this domain. You have a choice to delegate the membership to any of your local roles. In this use case since we want to have a single domain admin role, we're going to delegate the sales.admin role from the sales.api subdomain to the admin role in sales domain. Step 4: verify delegated role membership in sales.api domain \u00b6 First, let's check the members of the admin role in the sales domain - it shows two principals as members: user.janedoe and user.johndoe. For delegated roles, Athenz Web UI automatically retrieves the members of the role in the tenant-domain that this role is delegated to and displays them as members without the capability to modify the list. Now any sales domain administrator is automatically an administrator of the sales.api subdomain as well.","title":"Role Delegation"},{"location":"role_delegation/#definition-of-required-roles-and-rules","text":"The keywords PROVIDER_DOMAIN , TENANT_DOMAIN , PROVIDER_ROLE and TENANT_ROLE are place-holders for the actual id's. Steps for establishing a delegated role: In the provider-domain: Create the role PROVIDER_ROLE as \"delegated\" to the domain TENANT_DOMAIN . Create various rules for PROVIDER_ROLE as usual. In the tenant-domain: Create role TENANT_ROLE Create this rule: Allow Action= assume_role Role= TENANT_ROLE Resource= PROVIDER_DOMAIN:role.PROVIDER_ROLE Assign members to \u201cTENANT_ROLE\u201d as usual.","title":"Definition of required roles and rules"},{"location":"role_delegation/#use-case-domain-administration-delegation","text":"A product team has a top level domain called sales with its configured set of administrators. They also have created a subdomain sales.api for the sales API subproduct. Since Athenz subdomains are completely independent, sales.api has its own admin role and set of administrators. However, in the case of sales product these two domains must have the same set of administrators and the product owner does not want to maintain and manage the admin role members in two places. The sales.api domain wants to delegate administration privileges to the parent sales domain.","title":"Use Case: Domain Administration Delegation"},{"location":"role_delegation/#step-1-salesapi-change-create-an-admin-role-for-the-delegation","text":"Since Athenz does not allow administrators to remove or modify the admin role and policy for a domain, first we're going to create a role that will be delegated to the parent sales domain: Select Add Role link on the left side of the screen underneath the Roles tab name. Select a role type as Delegated and enter the role name and tenant-domain name:","title":"Step 1: sales.api change: create an admin role for the delegation"},{"location":"role_delegation/#step-2-salesapi-change-create-an-admin-policy-for-the-delegated-role","text":"Next we're going to create a new policy that provides the same admin privileges to the delegated sales.admin role. The admin policy uses * for the action and * for the resource.","title":"Step 2: sales.api change: create an admin policy for the delegated role"},{"location":"role_delegation/#step-3-sales-change-create-a-policy-to-assume-the-salesadmin-role","text":"Now, the domain administrator for sales domain must agree to assume that role by creating a special policy in its domain. The unique requirements for this policy are the action which must be set to assume_role and the resource which must be set to the full role name ({domain-name}:role.{role-name} format) that is being delegated to this domain. You have a choice to delegate the membership to any of your local roles. In this use case since we want to have a single domain admin role, we're going to delegate the sales.admin role from the sales.api subdomain to the admin role in sales domain.","title":"Step 3: sales change: create a policy to assume the sales.admin role"},{"location":"role_delegation/#step-4-verify-delegated-role-membership-in-salesapi-domain","text":"First, let's check the members of the admin role in the sales domain - it shows two principals as members: user.janedoe and user.johndoe. For delegated roles, Athenz Web UI automatically retrieves the members of the role in the tenant-domain that this role is delegated to and displays them as members without the capability to modify the list. Now any sales domain administrator is automatically an administrator of the sales.api subdomain as well.","title":"Step 4: verify delegated role membership in sales.api domain"},{"location":"self_serve_roles/","text":"Athenz now supports configuring roles in domains as self-served thus allowing users to request domain administrators to approve their request to be added to a role. Athenz can send email notifications for administrators. See Email Notifications section to enable notifications. Role Setup \u00b6 To designate a role as self-served, the domain administrator may use either Athenz UI or zms-cli utility. To use Athenz UI, the domain administrator will login to their domain role view and choose the Self Served slider for the appropriate role. For example, in the following case, the db_reader_access role is configured as self-served. The equivalent setup using zms-cli would be: zms-cli -d <domain-name> set-role-self-serve <role-name> true User Access Request \u00b6 The users can only add themselves (not other users or services) to any self-served roles. Their access is not active until one of the domain administrators approves the request. For example, in this use case, user.johndoe would like to be added to the db_reader_access role which is configured as self-served. When the user adds his principal id to the role, it will be added in the Pending Approval column. Domain Administrator Approval \u00b6 Once the pending request is processed, all domain administrators will receive an email notification (if notifications are enabled ) stating that user.johndoe would like to be added to the db_reader_access role and they need to either approve or reject the request. The email will include a link to the Athenz UI workflow page which can also be accessed by clicking on the notifications icon in the Athenz UI toolbar: Once in the approval view page, the domain administrator may either approve or reject the request. The domain administrator will need to provide a justification in the Audit Reference field and optionally specify an expiration date (even if the user didn't request one). Once approved, the principal will become an active/approved member of the role. If rejected, the principal's name will be removed from the Pending Approval column.","title":"Self-Served Roles"},{"location":"self_serve_roles/#role-setup","text":"To designate a role as self-served, the domain administrator may use either Athenz UI or zms-cli utility. To use Athenz UI, the domain administrator will login to their domain role view and choose the Self Served slider for the appropriate role. For example, in the following case, the db_reader_access role is configured as self-served. The equivalent setup using zms-cli would be: zms-cli -d <domain-name> set-role-self-serve <role-name> true","title":"Role Setup"},{"location":"self_serve_roles/#user-access-request","text":"The users can only add themselves (not other users or services) to any self-served roles. Their access is not active until one of the domain administrators approves the request. For example, in this use case, user.johndoe would like to be added to the db_reader_access role which is configured as self-served. When the user adds his principal id to the role, it will be added in the Pending Approval column.","title":"User Access Request"},{"location":"self_serve_roles/#domain-administrator-approval","text":"Once the pending request is processed, all domain administrators will receive an email notification (if notifications are enabled ) stating that user.johndoe would like to be added to the db_reader_access role and they need to either approve or reject the request. The email will include a link to the Athenz UI workflow page which can also be accessed by clicking on the notifications icon in the Athenz UI toolbar: Once in the approval view page, the domain administrator may either approve or reject the request. The domain administrator will need to provide a justification in the Audit Reference field and optionally specify an expiration date (even if the user didn't request one). Once approved, the principal will become an active/approved member of the role. If rejected, the principal's name will be removed from the Pending Approval column.","title":"Domain Administrator Approval"},{"location":"server_side_x509_credentials/","text":"In order to authenticate x.509 client certificates on Athenz enabled services, your server needs to be configured to authenticate TLS client certificates along with updated trust store with Athenz CA certificates. This section contains some examples how to setup your server to enable TLS client certificate authentication. Get Athenz CA Certificates \u00b6 First, get the CA Certificates of your Athenz instances and place them in a truststore. For our example, the truststore will be named athenz_certificate_bundle.jks . You must configure your container to recognize this truststure. If you are using other containers, you can set the SSL properties at the JVM level via system properties. -Djavax.net.ssl.trustStore=/home/example/athenz_certificate_bundle.jks Enable TLS client authentication in your container \u00b6 If you are using your own application server, you would need to set setNeedClientAuth to true. For example: SSLServerSocketFactory ssf = sc . getServerSocketFactory (); SSLServerSocket sslserversocket = ( SSLServerSocket ) ssf . createServerSocket ( 4443 ); sslserversocket . setNeedClientAuth ( true ); Please follow specific documentations provided by your container vendor on how to require client side TLS authentication. Extract Certificate and Verify \u00b6 If your trust store only has Athenz CA certificates, no need to extract and verify the issuer. If not, please follow below code example for verification. The client certificate is accessible from javax.servlet.request.X509Certificate HttpServletRequest attribute. Here is how you can get access to the TLS certificate: import java.security.cert.X509Certificate ; import javax.servlet.http.HttpServletRequest ; public static final String JAVAX_CERT_ATTR = \"javax.servlet.request.X509Certificate\" ; X509Certificate [] certs = ( X509Certificate [] ) servletRequest . getAttribute ( JAVAX_CERT_ATTR ); X509Certificate x509cert = null ; if ( null != certs && certs . length != 0 ) { for ( X509Certificate cert : certs ) { if ( null != cert ) { //find the first occurrence of non-null certificate x509cert = cert ; break ; } } } Then, validate the certificate issuers against a pre-configured set of Athenz CA issuers. Here is an example of how you may build the list of valid certificates from a truststore and then check that the issuer is valid. private static final String DEFAULT_ISSUERS_FILE_NAME = \"/home/example/athenz_certificate_bundle.jks\" ; private static Set < String > X509_ISSUERS = new HashSet <> (); X509Certificate [] certs = ( X509Certificate [] ) request . getAttribute ( JAVAX_CERT_ATTR ); X509Certificate x509cert = null ; if ( null != certs && certs . length != 0 ) { for ( X509Certificate cert : certs ) { if ( null != cert ) { //find the first occurrence of none null certificate x509cert = cert ; if ( LOG . isDebugEnabled ()) { LOG . debug ( \"Found x509 cert\" ); } break ; } } } if ( null == x509cert ) { // fail as x509cert is missing LOG . error ( \"x509 certificate is missing\" ); response . sendError ( HttpServletResponse . SC_UNAUTHORIZED ); return ; } // validate the certificate against CAs X500Principal issuerx500Principal = x509cert . getIssuerX500Principal (); String issuer = issuerx500Principal . getName (); if ( LOG . isDebugEnabled ()) { LOG . debug ( \"Found x509 cert issuer: {}\" , issuer ); } if ( issuer == null || issuer . isEmpty () || ! X509_ISSUERS . contains ( issuer )) { //fail LOG . error ( \"Issuer is missing or not apart of authorized Athenz CA\" ); response . sendError ( HttpServletResponse . SC_UNAUTHORIZED ); return ; } private final void setX509CAIssuers ( final String issuersFileName ) { if ( issuersFileName == null || issuersFileName . isEmpty ()) { return ; } try { Path path = Paths . get ( issuersFileName ); if ( ! path . isAbsolute ()) { path = Paths . get ( getClass (). getClassLoader (). getResource ( issuersFileName ). toURI ()); } KeyStore ks = null ; try ( InputStream in = new FileInputStream ( path . toString ())) { ks = KeyStore . getInstance ( KeyStore . getDefaultType ()); ks . load ( in , null ); } for ( Enumeration <?> e = ks . aliases (); e . hasMoreElements (); ) { String alias = ( String ) e . nextElement (); X509Certificate cert = ( X509Certificate ) ks . getCertificate ( alias ); X500Principal issuerx500Principal = cert . getIssuerX500Principal (); String issuer = issuerx500Principal . getName (); X509_ISSUERS . add ( issuer ); if ( LOG . isDebugEnabled ()) { LOG . debug ( \"issuer: {} \" , issuer ); } } } catch ( Throwable e ) { LOG . error ( \"Unable to set issuers from file \" + issuersFileName , e ); } }","title":"Server Side Service Identity Authentication"},{"location":"server_side_x509_credentials/#get-athenz-ca-certificates","text":"First, get the CA Certificates of your Athenz instances and place them in a truststore. For our example, the truststore will be named athenz_certificate_bundle.jks . You must configure your container to recognize this truststure. If you are using other containers, you can set the SSL properties at the JVM level via system properties. -Djavax.net.ssl.trustStore=/home/example/athenz_certificate_bundle.jks","title":"Get Athenz CA Certificates"},{"location":"server_side_x509_credentials/#enable-tls-client-authentication-in-your-container","text":"If you are using your own application server, you would need to set setNeedClientAuth to true. For example: SSLServerSocketFactory ssf = sc . getServerSocketFactory (); SSLServerSocket sslserversocket = ( SSLServerSocket ) ssf . createServerSocket ( 4443 ); sslserversocket . setNeedClientAuth ( true ); Please follow specific documentations provided by your container vendor on how to require client side TLS authentication.","title":"Enable TLS client authentication in your container"},{"location":"server_side_x509_credentials/#extract-certificate-and-verify","text":"If your trust store only has Athenz CA certificates, no need to extract and verify the issuer. If not, please follow below code example for verification. The client certificate is accessible from javax.servlet.request.X509Certificate HttpServletRequest attribute. Here is how you can get access to the TLS certificate: import java.security.cert.X509Certificate ; import javax.servlet.http.HttpServletRequest ; public static final String JAVAX_CERT_ATTR = \"javax.servlet.request.X509Certificate\" ; X509Certificate [] certs = ( X509Certificate [] ) servletRequest . getAttribute ( JAVAX_CERT_ATTR ); X509Certificate x509cert = null ; if ( null != certs && certs . length != 0 ) { for ( X509Certificate cert : certs ) { if ( null != cert ) { //find the first occurrence of non-null certificate x509cert = cert ; break ; } } } Then, validate the certificate issuers against a pre-configured set of Athenz CA issuers. Here is an example of how you may build the list of valid certificates from a truststore and then check that the issuer is valid. private static final String DEFAULT_ISSUERS_FILE_NAME = \"/home/example/athenz_certificate_bundle.jks\" ; private static Set < String > X509_ISSUERS = new HashSet <> (); X509Certificate [] certs = ( X509Certificate [] ) request . getAttribute ( JAVAX_CERT_ATTR ); X509Certificate x509cert = null ; if ( null != certs && certs . length != 0 ) { for ( X509Certificate cert : certs ) { if ( null != cert ) { //find the first occurrence of none null certificate x509cert = cert ; if ( LOG . isDebugEnabled ()) { LOG . debug ( \"Found x509 cert\" ); } break ; } } } if ( null == x509cert ) { // fail as x509cert is missing LOG . error ( \"x509 certificate is missing\" ); response . sendError ( HttpServletResponse . SC_UNAUTHORIZED ); return ; } // validate the certificate against CAs X500Principal issuerx500Principal = x509cert . getIssuerX500Principal (); String issuer = issuerx500Principal . getName (); if ( LOG . isDebugEnabled ()) { LOG . debug ( \"Found x509 cert issuer: {}\" , issuer ); } if ( issuer == null || issuer . isEmpty () || ! X509_ISSUERS . contains ( issuer )) { //fail LOG . error ( \"Issuer is missing or not apart of authorized Athenz CA\" ); response . sendError ( HttpServletResponse . SC_UNAUTHORIZED ); return ; } private final void setX509CAIssuers ( final String issuersFileName ) { if ( issuersFileName == null || issuersFileName . isEmpty ()) { return ; } try { Path path = Paths . get ( issuersFileName ); if ( ! path . isAbsolute ()) { path = Paths . get ( getClass (). getClassLoader (). getResource ( issuersFileName ). toURI ()); } KeyStore ks = null ; try ( InputStream in = new FileInputStream ( path . toString ())) { ks = KeyStore . getInstance ( KeyStore . getDefaultType ()); ks . load ( in , null ); } for ( Enumeration <?> e = ks . aliases (); e . hasMoreElements (); ) { String alias = ( String ) e . nextElement (); X509Certificate cert = ( X509Certificate ) ks . getCertificate ( alias ); X500Principal issuerx500Principal = cert . getIssuerX500Principal (); String issuer = issuerx500Principal . getName (); X509_ISSUERS . add ( issuer ); if ( LOG . isDebugEnabled ()) { LOG . debug ( \"issuer: {} \" , issuer ); } } } catch ( Throwable e ) { LOG . error ( \"Unable to set issuers from file \" + issuersFileName , e ); } }","title":"Extract Certificate and Verify"},{"location":"service_authentication/","text":"Athenz Service Authentication \u00b6 Copper Argos Using zts-svcvert Utility Athenz Service Identity x.509 certificates are used to establish standard mutual TLS communication with other Athenz Enabled Services. The services running on the instance can obtain X.509 certificates from zts using two approaches discussed below: Copper Argos(Prefered) \u00b6 Refer Copper Argos for full details. Using zts-svccert utility (Not recommended) \u00b6 Create a public/private key pair for your service and register the public key in Athenz. Refer Service Registration for complete details on registering services in Athenz. Store your private key securely. You can store that in a file on the host. The recommended approach is to use Key Management Store like HashiCorp. ZMS and ZTS Server use PrivateKeyStoreFactory interface to get access to its secrets. Refer Private Key Store for full details how to implement your private key store. Use the private key to obtain X.509 certificate from ZTS using zts-svccert utility as below: Download latest ZTS SVCCERT utility binary release from Bintray - click on the Files tab, choose the latest version directory and then download the athenz-utils-<latest-version>-bin.tar.gz file: $ tar xvfz athenz-utils-X.Y-bin.tar.gz You need to make sure to pass the correct key-version argument that matches to the key identifier that was used to register the public key for the service in Athenz. zts-svccert -domain <domain> -service <service> -private-key <private key file> -key-version <version> -zts <zts_url> -dns-domain <dns-name> -cert-file <output certificate file> The certificates and keys should be carefully rotated and service should repeatedly refresh them.","title":"Athenz Service Authentication"},{"location":"service_authentication/#athenz-service-authentication","text":"Copper Argos Using zts-svcvert Utility Athenz Service Identity x.509 certificates are used to establish standard mutual TLS communication with other Athenz Enabled Services. The services running on the instance can obtain X.509 certificates from zts using two approaches discussed below:","title":"Athenz Service Authentication"},{"location":"service_authentication/#copper-argosprefered","text":"Refer Copper Argos for full details.","title":"Copper Argos(Prefered)"},{"location":"service_authentication/#using-zts-svccert-utility-not-recommended","text":"Create a public/private key pair for your service and register the public key in Athenz. Refer Service Registration for complete details on registering services in Athenz. Store your private key securely. You can store that in a file on the host. The recommended approach is to use Key Management Store like HashiCorp. ZMS and ZTS Server use PrivateKeyStoreFactory interface to get access to its secrets. Refer Private Key Store for full details how to implement your private key store. Use the private key to obtain X.509 certificate from ZTS using zts-svccert utility as below: Download latest ZTS SVCCERT utility binary release from Bintray - click on the Files tab, choose the latest version directory and then download the athenz-utils-<latest-version>-bin.tar.gz file: $ tar xvfz athenz-utils-X.Y-bin.tar.gz You need to make sure to pass the correct key-version argument that matches to the key identifier that was used to register the public key for the service in Athenz. zts-svccert -domain <domain> -service <service> -private-key <private key file> -key-version <version> -zts <zts_url> -dns-domain <dns-name> -cert-file <output certificate file> The certificates and keys should be carefully rotated and service should repeatedly refresh them.","title":"Using zts-svccert utility (Not recommended)"},{"location":"service_x509_credentials/","text":"Once a domain has been registered in Athenz, the administrator will register service identities that are specified in domain roles and policy assertions. The latter can reference those roles having access to specified resources. Athenz supports service authentication with two types of credentials: X.509 Certificates (preferred approach) Public/Private Key Pairs Instructions To contact Athenz Services (ZMS/ZTS) or other Athenz Enabled services, the client service must first obtain an Athenz CA issued X.509 certificate. In this section we'll cover how to register the service identity and obtain X.509 certificates based on what environment your service will be running in. Use Case 1: Service Running in AWS EC2 \u00b6 If the service is running in AWS, Service Identity Agent (SIA) running on the instance is responsible for generating a private key for the service and obtaining a x.509 certificate from ZTS Service. The files are located in the following locations: private-key: /var/lib/sia/keys/<domain>.<service>.key.pem certificate: /var/lib/sia/certs/<domain>.<service>.cert.pem The certificate is valid for 30 days and SIA agent automatically will refresh the certificate daily. Follow these steps for full details how to configure SIA agent running in AWS as part of the foundation image. Use Case 2: Service running on-prem within an Athenz Enabled Framework (K8S) \u00b6 If the service is running within an Athenz enabled framework then it must already have access to service identity x.509 certificate that was generated for the service. Refer to the documentation provided by the framework to see where the files are located. Use Case 3: Service Running in AWS ECS (Elastic Container Service) \u00b6 If the service is running in AWS ECS, Service Identity Agent (SIA) included in your image is responsible for generating a private key for the service and obtaining a x.509 certificate from ZTS Service. The files are located in the following locations: private-key: /var/lib/sia/keys/<domain>.<service>.key.pem certificate: /var/lib/sia/certs/<domain>.<service>.cert.pem The certificate is valid for 30 days and SIA agent automatically will refresh the certificate daily. Follow these steps for full details how to configure SIA agent running in AWS as part of your image. Use Case 4: Service Running in AWS Lambda Function \u00b6 If the service is running in AWS Lambda function, the function being invoked will be responsible for generating a private key and then a csr for its request. It will submit that request to the ZTS Server to retrieve its X.509 certificate which then it can use along with its generated private key to establish TLS connections to other Athenz enabled services. Athenz Team provides functions/methods in Go and Java programming languages to quickly generate a private key and request its corresponding X.509 certificate from ZTS Server. The certificate is valid for 30 days. The short lifetime and stateless nature of the function means it cannot rotate its certificates. It just gets new ones when needed. Follow these steps for full details how to obtain service x.509 credentials within your function. Use Case 5: Service Running in AWS Fargate \u00b6 If the service is running in AWS Fargate, Service Identity Agent (SIA) included in your image is responsible for generating a private key for the service and obtaining a x.509 certificate from ZTS Service. The files are located in the following locations: private-key: /var/lib/sia/keys/<domain>.<service>.key.pem certificate: /var/lib/sia/certs/<domain>.<service>.cert.pem The certificate is valid for 7 days and SIA agent automatically will refresh the certificate daily. Follow these steps for full details how to configure SIA agent running in AWS as part of your image. Use Case 6: Service Running in AWS EKS \u00b6 If the service is running in AWS EKS, Service Identity Agent (SIA) included in your image is responsible for generating a private key for the service and obtaining a x.509 certificate from ZTS Service. The files are located in the following locations: private-key: /var/lib/sia/keys/<domain>.<service>.key.pem certificate: /var/lib/sia/certs/<domain>.<service>.cert.pem The certificate is valid for 7 days and SIA agent automatically will refresh the certificate daily. Follow these steps for full details how to configure SIA agent running in AWS as part of your image.","title":"Using X.509 Certificates"},{"location":"service_x509_credentials/#use-case-1-service-running-in-aws-ec2","text":"If the service is running in AWS, Service Identity Agent (SIA) running on the instance is responsible for generating a private key for the service and obtaining a x.509 certificate from ZTS Service. The files are located in the following locations: private-key: /var/lib/sia/keys/<domain>.<service>.key.pem certificate: /var/lib/sia/certs/<domain>.<service>.cert.pem The certificate is valid for 30 days and SIA agent automatically will refresh the certificate daily. Follow these steps for full details how to configure SIA agent running in AWS as part of the foundation image.","title":"Use Case 1: Service Running in AWS EC2"},{"location":"service_x509_credentials/#use-case-2-service-running-on-prem-within-an-athenz-enabled-framework-k8s","text":"If the service is running within an Athenz enabled framework then it must already have access to service identity x.509 certificate that was generated for the service. Refer to the documentation provided by the framework to see where the files are located.","title":"Use Case 2: Service running on-prem within an Athenz Enabled Framework (K8S)"},{"location":"service_x509_credentials/#use-case-3-service-running-in-aws-ecs-elastic-container-service","text":"If the service is running in AWS ECS, Service Identity Agent (SIA) included in your image is responsible for generating a private key for the service and obtaining a x.509 certificate from ZTS Service. The files are located in the following locations: private-key: /var/lib/sia/keys/<domain>.<service>.key.pem certificate: /var/lib/sia/certs/<domain>.<service>.cert.pem The certificate is valid for 30 days and SIA agent automatically will refresh the certificate daily. Follow these steps for full details how to configure SIA agent running in AWS as part of your image.","title":"Use Case 3: Service Running in AWS ECS (Elastic Container Service)"},{"location":"service_x509_credentials/#use-case-4-service-running-in-aws-lambda-function","text":"If the service is running in AWS Lambda function, the function being invoked will be responsible for generating a private key and then a csr for its request. It will submit that request to the ZTS Server to retrieve its X.509 certificate which then it can use along with its generated private key to establish TLS connections to other Athenz enabled services. Athenz Team provides functions/methods in Go and Java programming languages to quickly generate a private key and request its corresponding X.509 certificate from ZTS Server. The certificate is valid for 30 days. The short lifetime and stateless nature of the function means it cannot rotate its certificates. It just gets new ones when needed. Follow these steps for full details how to obtain service x.509 credentials within your function.","title":"Use Case 4: Service Running in AWS Lambda Function"},{"location":"service_x509_credentials/#use-case-5-service-running-in-aws-fargate","text":"If the service is running in AWS Fargate, Service Identity Agent (SIA) included in your image is responsible for generating a private key for the service and obtaining a x.509 certificate from ZTS Service. The files are located in the following locations: private-key: /var/lib/sia/keys/<domain>.<service>.key.pem certificate: /var/lib/sia/certs/<domain>.<service>.cert.pem The certificate is valid for 7 days and SIA agent automatically will refresh the certificate daily. Follow these steps for full details how to configure SIA agent running in AWS as part of your image.","title":"Use Case 5: Service Running in AWS Fargate"},{"location":"service_x509_credentials/#use-case-6-service-running-in-aws-eks","text":"If the service is running in AWS EKS, Service Identity Agent (SIA) included in your image is responsible for generating a private key for the service and obtaining a x.509 certificate from ZTS Service. The files are located in the following locations: private-key: /var/lib/sia/keys/<domain>.<service>.key.pem certificate: /var/lib/sia/certs/<domain>.<service>.cert.pem The certificate is valid for 7 days and SIA agent automatically will refresh the certificate daily. Follow these steps for full details how to configure SIA agent running in AWS as part of your image.","title":"Use Case 6: Service Running in AWS EKS"},{"location":"service_x509_credentials_aws/","text":"Bootstrapping AWS EC2 instances with Athenz Service x.509 Identities requires the instances to have network connectivity to both Athenz ZTS and AWS STS Services. Domain Registration \u00b6 Identify your Athenz domain before you can proceed by using Athenz UI. You may create a top-level domain or a sub domain using Athenz UI or zms-cli. Only Athenz System Administrators can create top level domains (members of the sys.auth domain's admin role). To create a top-level domain using zms-cli run the following: zms-cli add-domakn <domain-name> <unique-product-id> <domain-admins separated by space> If you already have top-level domain and need to create a sub domain using Athenz UI: click the \"Create\u201d link next to \"My Domains\" label in the top right corner and then click on \u201cSub Domain\u201d tab and follow the on screen instruction. Or using zms-cli: zms-cli add-doman <top-doman.sub-domain-name> <domain-admins separated by space> AWS Account ID Registration \u00b6 To register an AWS Account with a domain, run the following command: zms-cli -d <domain-name> set-aws-account <aws-account-id> Athenz Service Identity Registration \u00b6 Create a service identity for your AWS EC2 instances in your Athenz domain. This full service identity name <domain>.<service> will be the IAM role name that you will need to create in AWS IAM and set up a trust relationship with your EC2 Instance Role. In the Athenz UI, select your domain, select the Services tab and then choose Add a Service link in the top left corner. You must provide a service name and an optional description for your service. Athenz Service Identity Authorization \u00b6 Before ZTS can validate and issue X.509 TLS Certificates to the AWS EC2 instance, it must validate that the service owner has authorized its service to be launched by AWS EC2 Provider. In the Athenz UI select your service that was created in the previous step and click on the icon in the Providers column: Then, click on the Allow button to authorize your service to be launched by AWS EC2 provider. IAM Role Setup \u00b6 There are two IAM roles required for instances to obtain Athenz X.509 certificates: EC2 Instance Profile Role Athenz Service Identity Assume Role It is assumed that at this point you have already configured the first EC2 Instance Profile IAM Role that your EC2 instance will be launched with. The second Athenz Service Identity IAM Assume Role must be created and must have the <domain>.<service> name. This role will not have any permissions but instead will have a trust relationship with your EC2 instance role such that your EC2 instance role can assume this role. In the AWS Console, select IAM from the Services drop down and then click on the Roles link in the left sidebar. Choose the Create Role button. Under the AWS Service type, select EC2 , then EC2 again for the use case and finally choose Next: Permissions button in the bottom right corner. In the Attach permissions policy screen do not choose any permissions and just click on the Next: Review button in the bottom right corner to continue. Specify the Role name in the <domain>.<service> format and choose Create Role to complete the process. In the Roles list view, choose the role just created and choose the Trust Relationships tab. Click on Edit trust relationship button and append a block containing the following policy to the Statement block (Replace the <account-id> and <ec2-instance-role> values with their corresponding values for your environment: { \"Effect\": \"Allow\", \"Principal\": { \"AWS\": \"arn:aws:iam::<account-id>:role/<ec2-instance-role>\" }, \"Action\": \"sts:AssumeRole\" } Once correctly updated, your EC2 instance role must appear in the Trusted entities table: Setup for Services with Region Specific Instance Profile Roles \u00b6 The IAM Role setup is identical when you have the same service being deployed in multiple regions with role names that are specific to each region. Since IAM roles are global, you only need to create a single Athenz IAM Role in the <domain>.<service> format. Then, when you're setting up your trust relationship, you'll authorize all your region specific profile roles to have the capability to assume the Athenz <domain>.<service> role. Installing SIA \u00b6 The AWS SIA source is part of the Athenz project and can be found in: provider/aws/sia-ec2 Follow the readme for instructions on how to install it. SIA Configuration Setup \u00b6 When building your image, you can include the following configuration file called sia_config in the /etc/sia directory. It must include the following required fields: { \"version\": \"1.0.0\", \"service\": \"<service name>\", \"accounts\": [ { \"domain\": \"<domain name>\", \"account\": \"<aws account id associated with domain name>\" } ] } The domain/account/service values here must match to the IAM Role created earlier. For example, if the service identity name is api in domain sports whose corresponding aws account id is 123456789 , then the sia_config file will be as follows: { \"version\": \"1.0.0\", \"service\": \"api\", \"accounts\": [ { \"domain\": \"sports\", \"account\": \"123456789\" } ] } Private Key File Ownership \u00b6 By default SIA agent runs as root and the private key is only readable by root. If your service is running as another user, you can configure SIA agent to automatically change the ownership of the private key file to the configured user. For example, if you want the private key to be owned by ec2-user , then your sia_config configuration file would be as follows: { \"version\": \"1.0.0\", \"service\": \"api\", \"accounts\": [ { \"domain\": \"sports\", \"account\": \"123456789\", \"user\": \"ec2-user\" } ] } Private Key and Certificate Setup \u00b6 By default, the private key for the service identity is available in the /var/lib/sia/keys directory and has the name <domain>.<service>.key.pem . The private key is in PKCS#1 format. The corresponding X.509 certificate is in the /var/lib/sia/certs directory and has the name <domain>.<service>.cert.pem . The certificate is valid for 30 days and will be refreshed automatically by SIA every day. It is the responsibility of the application owner to update their container/application to refresh and use the latest certificate before it expires. In the same /var/lib/sia/certs directory SIA will also generate the Athenz CA certificate file called ca.cert.pem . Role Certificate Support \u00b6 In addition to requesting Athenz service identity certificate, SIA provides the capability to request Athenz Role Certificates as well. If you want to change the default behavior or request SIA to automatically retrieve role certificates for your service, as part of building your ami image, you can include the following additional fields in the configuration file: { \"version\": \"1.0.0\", \"service\": \"<service name>\", \"accounts\": [ { \"domain\": \"<domain name>\", \"account\": \"<aws account id associated with domain name>\", \"roles\": { \"<role-domain1>:role.<role-name1>\": { }, \"<role-domain2>:role.<role-name2>\": { } } } ] } The role certificates will also be stored in the /var/lib/sia/certs directory and have the name of <role-domain1>:role.<role-name1>.cert.pem . They are also valid for 30 days and SIA will automatically refresh them once a day. Setup Without SIA Configuration File \u00b6 If a property deploying their service in AWS meets the following 2 requirements: does not need any role certificates to be retrieved by SIA automatically has the option to name their EC2 instance role then they have the option for a simpler setup without including a sia configuration file in their image. In this model, the property would name their EC2 instance role as <domain>.<service>-service . The property must still follow the full steps as described in the IAM Role Setup section to setup the <domain>.<service> role, but the requirement to have a sia_config file is no longer present. When SIA is running and is not able to find the sia_config file, it will check if the instance profile arn has the <domain>.<service>-service format. If it does, then it would drop -service part to parse the rest of the string to extract the Athenz domain and service values and determine the assume role name that it needs to fetch temporary credentials for before contacting ZTS Server. Non Standard Instance Profile Name \u00b6 If a property deploying their service in AWS does not have the capability to name their instance profile role name as <domain>.<service>-service due to legacy requirements, the following steps can be followed to configure SIA to use the non-standard instance profile name. The property must still follow the full steps as described in the IAM Role Setup section to setup the <domain>.<service> role and the trust relationship. The property must install a SIA config file /etc/sia/sia_config specifying the service name that will be deployed on this instance Independent Instance Profile and Role Names \u00b6 It is possible to setup only a single role within AWS IAM in the format <domain>.<service> and name the IAM profile name as <domain>.<service>-service without creating a separate role. However, there is currently no support in the AWS UI console for naming your IAM role and IAM instance profile independently. You can do this with Cloud Formation, Ansible, TF, the AWS API, or the CLI. Here is an example using the CLI - replace <domain> , <service> and <account-id> parameters with their respective values for your environment: aws iam create-role --role-name <domain>.<service> --assume-role-policy-document='{\"Version\":\"2012-10-17\",\"Statement\":[{\"Effect\":\"Allow\",\"Principal\":{\"Service\":\"ec2.amazonaws.com\"},\"Action\":\"sts:AssumeRole\"}]}' aws iam create-instance-profile --instance-profile-name <domain>.<service>-service aws iam update-assume-role-policy --role-name <domain>.<service> --policy-document '{\"Version\":\"2012-10-17\",\"Statement\":[{\"Effect\":\"Allow\",\"Principal\":{\"Service\":\"ec2.amazonaws.com\"},\"Action\":\"sts:AssumeRole\"},{\"Effect\":\"Allow\",\"Principal\":{\"AWS\":\"arn:aws:iam::<account-id>:role/<domain>.<service>\"},\"Action\":\"sts:AssumeRole\"}]}' aws iam add-role-to-instance-profile --instance-profile-name <domain>.<service>-service --role-name <domain>.<service> However, this model is not recommended from security perspective if your <domain>.<service> role has access to other AWS services. Temporary credentials for that role are sent to Athenz ZTS service as your authentication credentials and, as such, you do not want to expose those additional access capabilities to the ZTS Server. Troubleshooting \u00b6 SIA process outputs all of its messages to syslog, so if there are any issues with your configuration, it will be reported in syslog. You can execute: sudo grep siad /var/log/messages and see what operation sia was not able to complete successfully. The agent is configured to run every 20 seconds in case of a failure, so you'll most likely see the same block being repeated multiple times. ZTS server allows instances to obtain x.509 certificates only during the first 30 minutes after the initial bootstrap time so even if you address the configuration issues, once the 30 mins have passed, the instance will no longer be able to obtain its x.509 service identity certificate. The only option at that time is to terminate and launch a new instance.","title":"Athenz Service Identity X.509 Certificate for AWS EC2 instances"},{"location":"service_x509_credentials_aws/#domain-registration","text":"Identify your Athenz domain before you can proceed by using Athenz UI. You may create a top-level domain or a sub domain using Athenz UI or zms-cli. Only Athenz System Administrators can create top level domains (members of the sys.auth domain's admin role). To create a top-level domain using zms-cli run the following: zms-cli add-domakn <domain-name> <unique-product-id> <domain-admins separated by space> If you already have top-level domain and need to create a sub domain using Athenz UI: click the \"Create\u201d link next to \"My Domains\" label in the top right corner and then click on \u201cSub Domain\u201d tab and follow the on screen instruction. Or using zms-cli: zms-cli add-doman <top-doman.sub-domain-name> <domain-admins separated by space>","title":"Domain Registration"},{"location":"service_x509_credentials_aws/#aws-account-id-registration","text":"To register an AWS Account with a domain, run the following command: zms-cli -d <domain-name> set-aws-account <aws-account-id>","title":"AWS Account ID Registration"},{"location":"service_x509_credentials_aws/#athenz-service-identity-registration","text":"Create a service identity for your AWS EC2 instances in your Athenz domain. This full service identity name <domain>.<service> will be the IAM role name that you will need to create in AWS IAM and set up a trust relationship with your EC2 Instance Role. In the Athenz UI, select your domain, select the Services tab and then choose Add a Service link in the top left corner. You must provide a service name and an optional description for your service.","title":"Athenz Service Identity Registration"},{"location":"service_x509_credentials_aws/#athenz-service-identity-authorization","text":"Before ZTS can validate and issue X.509 TLS Certificates to the AWS EC2 instance, it must validate that the service owner has authorized its service to be launched by AWS EC2 Provider. In the Athenz UI select your service that was created in the previous step and click on the icon in the Providers column: Then, click on the Allow button to authorize your service to be launched by AWS EC2 provider.","title":"Athenz Service Identity Authorization"},{"location":"service_x509_credentials_aws/#iam-role-setup","text":"There are two IAM roles required for instances to obtain Athenz X.509 certificates: EC2 Instance Profile Role Athenz Service Identity Assume Role It is assumed that at this point you have already configured the first EC2 Instance Profile IAM Role that your EC2 instance will be launched with. The second Athenz Service Identity IAM Assume Role must be created and must have the <domain>.<service> name. This role will not have any permissions but instead will have a trust relationship with your EC2 instance role such that your EC2 instance role can assume this role. In the AWS Console, select IAM from the Services drop down and then click on the Roles link in the left sidebar. Choose the Create Role button. Under the AWS Service type, select EC2 , then EC2 again for the use case and finally choose Next: Permissions button in the bottom right corner. In the Attach permissions policy screen do not choose any permissions and just click on the Next: Review button in the bottom right corner to continue. Specify the Role name in the <domain>.<service> format and choose Create Role to complete the process. In the Roles list view, choose the role just created and choose the Trust Relationships tab. Click on Edit trust relationship button and append a block containing the following policy to the Statement block (Replace the <account-id> and <ec2-instance-role> values with their corresponding values for your environment: { \"Effect\": \"Allow\", \"Principal\": { \"AWS\": \"arn:aws:iam::<account-id>:role/<ec2-instance-role>\" }, \"Action\": \"sts:AssumeRole\" } Once correctly updated, your EC2 instance role must appear in the Trusted entities table:","title":"IAM Role Setup"},{"location":"service_x509_credentials_aws/#setup-for-services-with-region-specific-instance-profile-roles","text":"The IAM Role setup is identical when you have the same service being deployed in multiple regions with role names that are specific to each region. Since IAM roles are global, you only need to create a single Athenz IAM Role in the <domain>.<service> format. Then, when you're setting up your trust relationship, you'll authorize all your region specific profile roles to have the capability to assume the Athenz <domain>.<service> role.","title":"Setup for Services with Region Specific Instance Profile Roles"},{"location":"service_x509_credentials_aws/#installing-sia","text":"The AWS SIA source is part of the Athenz project and can be found in: provider/aws/sia-ec2 Follow the readme for instructions on how to install it.","title":"Installing SIA"},{"location":"service_x509_credentials_aws/#sia-configuration-setup","text":"When building your image, you can include the following configuration file called sia_config in the /etc/sia directory. It must include the following required fields: { \"version\": \"1.0.0\", \"service\": \"<service name>\", \"accounts\": [ { \"domain\": \"<domain name>\", \"account\": \"<aws account id associated with domain name>\" } ] } The domain/account/service values here must match to the IAM Role created earlier. For example, if the service identity name is api in domain sports whose corresponding aws account id is 123456789 , then the sia_config file will be as follows: { \"version\": \"1.0.0\", \"service\": \"api\", \"accounts\": [ { \"domain\": \"sports\", \"account\": \"123456789\" } ] }","title":"SIA Configuration Setup"},{"location":"service_x509_credentials_aws/#private-key-file-ownership","text":"By default SIA agent runs as root and the private key is only readable by root. If your service is running as another user, you can configure SIA agent to automatically change the ownership of the private key file to the configured user. For example, if you want the private key to be owned by ec2-user , then your sia_config configuration file would be as follows: { \"version\": \"1.0.0\", \"service\": \"api\", \"accounts\": [ { \"domain\": \"sports\", \"account\": \"123456789\", \"user\": \"ec2-user\" } ] }","title":"Private Key File Ownership"},{"location":"service_x509_credentials_aws/#private-key-and-certificate-setup","text":"By default, the private key for the service identity is available in the /var/lib/sia/keys directory and has the name <domain>.<service>.key.pem . The private key is in PKCS#1 format. The corresponding X.509 certificate is in the /var/lib/sia/certs directory and has the name <domain>.<service>.cert.pem . The certificate is valid for 30 days and will be refreshed automatically by SIA every day. It is the responsibility of the application owner to update their container/application to refresh and use the latest certificate before it expires. In the same /var/lib/sia/certs directory SIA will also generate the Athenz CA certificate file called ca.cert.pem .","title":"Private Key and Certificate Setup"},{"location":"service_x509_credentials_aws/#role-certificate-support","text":"In addition to requesting Athenz service identity certificate, SIA provides the capability to request Athenz Role Certificates as well. If you want to change the default behavior or request SIA to automatically retrieve role certificates for your service, as part of building your ami image, you can include the following additional fields in the configuration file: { \"version\": \"1.0.0\", \"service\": \"<service name>\", \"accounts\": [ { \"domain\": \"<domain name>\", \"account\": \"<aws account id associated with domain name>\", \"roles\": { \"<role-domain1>:role.<role-name1>\": { }, \"<role-domain2>:role.<role-name2>\": { } } } ] } The role certificates will also be stored in the /var/lib/sia/certs directory and have the name of <role-domain1>:role.<role-name1>.cert.pem . They are also valid for 30 days and SIA will automatically refresh them once a day.","title":"Role Certificate Support"},{"location":"service_x509_credentials_aws/#setup-without-sia-configuration-file","text":"If a property deploying their service in AWS meets the following 2 requirements: does not need any role certificates to be retrieved by SIA automatically has the option to name their EC2 instance role then they have the option for a simpler setup without including a sia configuration file in their image. In this model, the property would name their EC2 instance role as <domain>.<service>-service . The property must still follow the full steps as described in the IAM Role Setup section to setup the <domain>.<service> role, but the requirement to have a sia_config file is no longer present. When SIA is running and is not able to find the sia_config file, it will check if the instance profile arn has the <domain>.<service>-service format. If it does, then it would drop -service part to parse the rest of the string to extract the Athenz domain and service values and determine the assume role name that it needs to fetch temporary credentials for before contacting ZTS Server.","title":"Setup Without SIA Configuration File"},{"location":"service_x509_credentials_aws/#non-standard-instance-profile-name","text":"If a property deploying their service in AWS does not have the capability to name their instance profile role name as <domain>.<service>-service due to legacy requirements, the following steps can be followed to configure SIA to use the non-standard instance profile name. The property must still follow the full steps as described in the IAM Role Setup section to setup the <domain>.<service> role and the trust relationship. The property must install a SIA config file /etc/sia/sia_config specifying the service name that will be deployed on this instance","title":"Non Standard Instance Profile Name"},{"location":"service_x509_credentials_aws/#independent-instance-profile-and-role-names","text":"It is possible to setup only a single role within AWS IAM in the format <domain>.<service> and name the IAM profile name as <domain>.<service>-service without creating a separate role. However, there is currently no support in the AWS UI console for naming your IAM role and IAM instance profile independently. You can do this with Cloud Formation, Ansible, TF, the AWS API, or the CLI. Here is an example using the CLI - replace <domain> , <service> and <account-id> parameters with their respective values for your environment: aws iam create-role --role-name <domain>.<service> --assume-role-policy-document='{\"Version\":\"2012-10-17\",\"Statement\":[{\"Effect\":\"Allow\",\"Principal\":{\"Service\":\"ec2.amazonaws.com\"},\"Action\":\"sts:AssumeRole\"}]}' aws iam create-instance-profile --instance-profile-name <domain>.<service>-service aws iam update-assume-role-policy --role-name <domain>.<service> --policy-document '{\"Version\":\"2012-10-17\",\"Statement\":[{\"Effect\":\"Allow\",\"Principal\":{\"Service\":\"ec2.amazonaws.com\"},\"Action\":\"sts:AssumeRole\"},{\"Effect\":\"Allow\",\"Principal\":{\"AWS\":\"arn:aws:iam::<account-id>:role/<domain>.<service>\"},\"Action\":\"sts:AssumeRole\"}]}' aws iam add-role-to-instance-profile --instance-profile-name <domain>.<service>-service --role-name <domain>.<service> However, this model is not recommended from security perspective if your <domain>.<service> role has access to other AWS services. Temporary credentials for that role are sent to Athenz ZTS service as your authentication credentials and, as such, you do not want to expose those additional access capabilities to the ZTS Server.","title":"Independent Instance Profile and Role Names"},{"location":"service_x509_credentials_aws/#troubleshooting","text":"SIA process outputs all of its messages to syslog, so if there are any issues with your configuration, it will be reported in syslog. You can execute: sudo grep siad /var/log/messages and see what operation sia was not able to complete successfully. The agent is configured to run every 20 seconds in case of a failure, so you'll most likely see the same block being repeated multiple times. ZTS server allows instances to obtain x.509 certificates only during the first 30 minutes after the initial bootstrap time so even if you address the configuration issues, once the 30 mins have passed, the instance will no longer be able to obtain its x.509 service identity certificate. The only option at that time is to terminate and launch a new instance.","title":"Troubleshooting"},{"location":"service_x509_credentials_aws_ecs/","text":"Domain Registration \u00b6 Identify your Athenz domain before you can proceed by visiting Athenz UI. Follow the instructions documented for EC2 instances to register your domain if one doesn't exist already. AWS Account ID Registration \u00b6 To register an AWS Account with a domain, run the following command: zms-cli -d <domain-name> set-aws-account <aws-account-id> Athenz Service Identity Registration \u00b6 Create a service identity for your AWS ECS containers in your Athenz domain. This full service identity name <domain>.<service> will be the IAM role name that you will need to create in AWS IAM and set up a trust relationship with your ECS Container Role. In the Athenz UI, select your domain, select the Services tab and then choose Add a Service link in the top left corner. You must provide a service name and an optional description for your service. Athenz Service Identity Authorization Role and Policy \u00b6 Before ZTS can validate and issue X.509 TLS Certificates to the AWS ECS, it must validate that the service owner has authorized its service to be launched by AWS ECS Provider. In the Athenz UI select your service that was created in the previous step and click on the icon in the Providers column: Then, click on the Allow button to authorize your service to be launched by AWS ECS provider. ECS Container Metadata Support \u00b6 In AWS the ECS must be configured with metadata support. This is required such that SIA agent can retrieve the Task ID that is used to identify the container uniquely. You need to set the ECS_ENABLE_CONTAINER_METADATA container agent variable to true . You can set this variable in the /etc/ecs/ecs.config configuration file and restart the ecs agent. You can also set it as a Docker environment variable at run time when the agent container is started. For more information, see Amazon ECS Container Metadata . IAM Role Setup \u00b6 There are two IAM roles required for instances to obtain Athenz X.509 certificates: ECS Container Profile Role Athenz Service Identity Assume Role It is assumed that at this point you have already configured the first ECS Container Profile IAM Role that your container will be launched with. The second Athenz Service Identity IAM Assume Role must be created and must have the <domain>.<service> name. This role will not have any permissions but instead will have a trust relationship with your ECS container role such that your ECS container role can assume this role. In the AWS Console, select IAM from the Services drop down and then click on the Roles link in the left sidebar. Choose the Create Role button. Under the AWS Service type, select EC2 , then EC2 again for the use case and finally choose Next: Permissions button in the bottom right corner. In the Attach permissions policy screen do not choose any permissions and just click on the Next: Review button in the bottom right corner to continue. Specify the Role name in the <domain>.<service> format and choose Create Role to complete the process. In the Roles list view, choose the role just created and choose the Trust Relationships tab. Click on Edit trust relationship button and append a block containing the following policy to the Statement block (Replace the <account-id> and <ecs-container-role> values with their corresponding values for your environment: { \"Effect\": \"Allow\", \"Principal\": { \"AWS\": \"arn:aws:iam::<account-id>:role/<ecs-container-role>\" }, \"Action\": \"sts:AssumeRole\" } Once correctly updated, your ECS container role must appear in the Trusted entities table: Installing SIA in Container \u00b6 The AWS SIA source is part of the Athenz project and can be found in: provider/aws/sia-ec2 Follow the readme for instructions on how to install it. Typically you run the siad binary in your container and let it run continuously to register and refresh your service certificate daily since systemd does not run in a typical docker image. If you only want to run siad as a command line utility that just registers and refreshes the service and role certificates when executed, you can use the following command line options (Register must be called once within the first 30 mins when the instance is bootstrapped): Instance Register: /usr/sbin/siad -cmd post Service Certificate Refresh: /usr/sbin/siad -cmd rotate Role Certificate Refresh: /usr/sbin/siad -cmd rolecert SIA Configuration Setup \u00b6 When building your container image, you must include the following configuration file called sia_config in the /etc/sia directory. It must include the following required fields: { \"version\": \"1.0.0\", \"service\": \"<service name>\", \"accounts\": [ { \"domain\": \"<domain name>\", \"account\": \"<aws account id associated with domain name>\" } ] } The domain/account/service values here must match to the IAM Role created earlier. For example, if the service identity name is api in domain sports whose corresponding aws account id is 123456789 , then the sia_config file will be as follows: { \"version\": \"1.0.0\", \"service\": \"api\", \"accounts\": [ { \"domain\": \"sports\", \"account\": \"123456789\" } ] } Private Key File Ownership \u00b6 By default SIA agent runs as root and the private key is only readable by root. If your service is running as another user, you can configure SIA agent to automatically change the ownership of the private key file to the configured user. For example, if you want the private key to be owned by ec2-user , then your sia_config configuration file would be as follows: { \"version\": \"1.0.0\", \"service\": \"api\", \"accounts\": [ { \"domain\": \"sports\", \"account\": \"123456789\", \"user\": \"ec2-user\" } ] } Private Key and Certificate Setup \u00b6 By default, the private key for the service identity is available in the /var/lib/sia/keys directory and has the name <domain>.<service>.key.pem . The private key is in PKCS#1 format. The corresponding X.509 certificate is in the /var/lib/sia/certs directory and has the name <domain>.<service>.cert.pem . The certificate is valid for 30 days and will be refreshed automatically by SIA every day. It is the responsibility of the application owner to update their container/application to refresh and use the latest certificate before it expires. In the same /var/lib/sia/certs directory SIA will also generate the Athenz CA certificate file called ca.cert.pem . In addition to requesting Athenz service identity certificate, SIA provides the capability to request Athenz Role Certificates as well. If you want to change the default behavior or request SIA to automatically retrieve role certificates for your service, as part of building your ami image, you can include the following additional fields in the configuration file: { \"version\": \"1.0.0\", \"service\": \"<service name>\", \"accounts\": [ { \"domain\": \"<domain name>\", \"account\": \"<aws account id associated with domain name>\", \"roles\": { \"<role-domain1>:role.<role-name1>\": { }, \"<role-domain2>:role.<role-name2>\": { } } } ] } The role certificates will also be stored in the /var/lib/sia/certs directory and have the name of <role-domain1>:role.<role-name1>.cert.pem . They are also valid for 30 days and SIA will automatically refresh them once a day.","title":"Athenz Service Identity X.509 Certificate for AWS ECS containers"},{"location":"service_x509_credentials_aws_ecs/#domain-registration","text":"Identify your Athenz domain before you can proceed by visiting Athenz UI. Follow the instructions documented for EC2 instances to register your domain if one doesn't exist already.","title":"Domain Registration"},{"location":"service_x509_credentials_aws_ecs/#aws-account-id-registration","text":"To register an AWS Account with a domain, run the following command: zms-cli -d <domain-name> set-aws-account <aws-account-id>","title":"AWS Account ID Registration"},{"location":"service_x509_credentials_aws_ecs/#athenz-service-identity-registration","text":"Create a service identity for your AWS ECS containers in your Athenz domain. This full service identity name <domain>.<service> will be the IAM role name that you will need to create in AWS IAM and set up a trust relationship with your ECS Container Role. In the Athenz UI, select your domain, select the Services tab and then choose Add a Service link in the top left corner. You must provide a service name and an optional description for your service.","title":"Athenz Service Identity Registration"},{"location":"service_x509_credentials_aws_ecs/#athenz-service-identity-authorization-role-and-policy","text":"Before ZTS can validate and issue X.509 TLS Certificates to the AWS ECS, it must validate that the service owner has authorized its service to be launched by AWS ECS Provider. In the Athenz UI select your service that was created in the previous step and click on the icon in the Providers column: Then, click on the Allow button to authorize your service to be launched by AWS ECS provider.","title":"Athenz Service Identity Authorization Role and Policy"},{"location":"service_x509_credentials_aws_ecs/#ecs-container-metadata-support","text":"In AWS the ECS must be configured with metadata support. This is required such that SIA agent can retrieve the Task ID that is used to identify the container uniquely. You need to set the ECS_ENABLE_CONTAINER_METADATA container agent variable to true . You can set this variable in the /etc/ecs/ecs.config configuration file and restart the ecs agent. You can also set it as a Docker environment variable at run time when the agent container is started. For more information, see Amazon ECS Container Metadata .","title":"ECS Container Metadata Support"},{"location":"service_x509_credentials_aws_ecs/#iam-role-setup","text":"There are two IAM roles required for instances to obtain Athenz X.509 certificates: ECS Container Profile Role Athenz Service Identity Assume Role It is assumed that at this point you have already configured the first ECS Container Profile IAM Role that your container will be launched with. The second Athenz Service Identity IAM Assume Role must be created and must have the <domain>.<service> name. This role will not have any permissions but instead will have a trust relationship with your ECS container role such that your ECS container role can assume this role. In the AWS Console, select IAM from the Services drop down and then click on the Roles link in the left sidebar. Choose the Create Role button. Under the AWS Service type, select EC2 , then EC2 again for the use case and finally choose Next: Permissions button in the bottom right corner. In the Attach permissions policy screen do not choose any permissions and just click on the Next: Review button in the bottom right corner to continue. Specify the Role name in the <domain>.<service> format and choose Create Role to complete the process. In the Roles list view, choose the role just created and choose the Trust Relationships tab. Click on Edit trust relationship button and append a block containing the following policy to the Statement block (Replace the <account-id> and <ecs-container-role> values with their corresponding values for your environment: { \"Effect\": \"Allow\", \"Principal\": { \"AWS\": \"arn:aws:iam::<account-id>:role/<ecs-container-role>\" }, \"Action\": \"sts:AssumeRole\" } Once correctly updated, your ECS container role must appear in the Trusted entities table:","title":"IAM Role Setup"},{"location":"service_x509_credentials_aws_ecs/#installing-sia-in-container","text":"The AWS SIA source is part of the Athenz project and can be found in: provider/aws/sia-ec2 Follow the readme for instructions on how to install it. Typically you run the siad binary in your container and let it run continuously to register and refresh your service certificate daily since systemd does not run in a typical docker image. If you only want to run siad as a command line utility that just registers and refreshes the service and role certificates when executed, you can use the following command line options (Register must be called once within the first 30 mins when the instance is bootstrapped): Instance Register: /usr/sbin/siad -cmd post Service Certificate Refresh: /usr/sbin/siad -cmd rotate Role Certificate Refresh: /usr/sbin/siad -cmd rolecert","title":"Installing SIA in Container"},{"location":"service_x509_credentials_aws_ecs/#sia-configuration-setup","text":"When building your container image, you must include the following configuration file called sia_config in the /etc/sia directory. It must include the following required fields: { \"version\": \"1.0.0\", \"service\": \"<service name>\", \"accounts\": [ { \"domain\": \"<domain name>\", \"account\": \"<aws account id associated with domain name>\" } ] } The domain/account/service values here must match to the IAM Role created earlier. For example, if the service identity name is api in domain sports whose corresponding aws account id is 123456789 , then the sia_config file will be as follows: { \"version\": \"1.0.0\", \"service\": \"api\", \"accounts\": [ { \"domain\": \"sports\", \"account\": \"123456789\" } ] }","title":"SIA Configuration Setup"},{"location":"service_x509_credentials_aws_ecs/#private-key-file-ownership","text":"By default SIA agent runs as root and the private key is only readable by root. If your service is running as another user, you can configure SIA agent to automatically change the ownership of the private key file to the configured user. For example, if you want the private key to be owned by ec2-user , then your sia_config configuration file would be as follows: { \"version\": \"1.0.0\", \"service\": \"api\", \"accounts\": [ { \"domain\": \"sports\", \"account\": \"123456789\", \"user\": \"ec2-user\" } ] }","title":"Private Key File Ownership"},{"location":"service_x509_credentials_aws_ecs/#private-key-and-certificate-setup","text":"By default, the private key for the service identity is available in the /var/lib/sia/keys directory and has the name <domain>.<service>.key.pem . The private key is in PKCS#1 format. The corresponding X.509 certificate is in the /var/lib/sia/certs directory and has the name <domain>.<service>.cert.pem . The certificate is valid for 30 days and will be refreshed automatically by SIA every day. It is the responsibility of the application owner to update their container/application to refresh and use the latest certificate before it expires. In the same /var/lib/sia/certs directory SIA will also generate the Athenz CA certificate file called ca.cert.pem . In addition to requesting Athenz service identity certificate, SIA provides the capability to request Athenz Role Certificates as well. If you want to change the default behavior or request SIA to automatically retrieve role certificates for your service, as part of building your ami image, you can include the following additional fields in the configuration file: { \"version\": \"1.0.0\", \"service\": \"<service name>\", \"accounts\": [ { \"domain\": \"<domain name>\", \"account\": \"<aws account id associated with domain name>\", \"roles\": { \"<role-domain1>:role.<role-name1>\": { }, \"<role-domain2>:role.<role-name2>\": { } } } ] } The role certificates will also be stored in the /var/lib/sia/certs directory and have the name of <role-domain1>:role.<role-name1>.cert.pem . They are also valid for 30 days and SIA will automatically refresh them once a day.","title":"Private Key and Certificate Setup"},{"location":"service_x509_credentials_aws_eks/","text":"Domain Registration \u00b6 Identify your Athenz domain before you can proceed by visiting Athenz UI. Follow the instructions documented for EC2 instances to register your domain if one doesn't exist already. AWS Account ID Registration \u00b6 To register an AWS Account with a domain, run the following command: zms-cli -d <domain-name> set-aws-account <aws-account-id> Athenz Service Identity Registration \u00b6 Create a service identity for your AWS EKS in your Athenz domain. This full service identity name <domain>.<service> will be the IAM role name that you will need to create in AWS IAM and set up a trust relationship with your EKS pod role. In the Athenz UI, select your domain, select the Services tab and then choose Add a Service link in the top left corner. You must provide a service name and an optional description for your service. Athenz Service Identity Authorization Role and Policy \u00b6 Before ZTS can validate and issue X.509 TLS Certificates to the AWS EKS pods, it must validate that the service owner has authorized its service to be launched by AWS EKS Provider. In the Athenz UI select your service that was created in the previous step and click on the icon in the Providers column: Then, click on the Allow button to authorize your service to be launched by AWS EC2/EKS/Fargate provider. IAM Role Setup \u00b6 There are two IAM roles required for instances to obtain Athenz X.509 certificates: EKS Role Athenz Service Identity Assume Role It is assumed that at this point you have already configured the first EKS Role that your pods will be launched with. This recommended name for this role is <domain>.<service>-service since this allows to automatically determine the service name (by stripping the -service suffix) without requiring the administrator to provide a sia_config file as part of the bootstrap. The second Athenz Service Identity IAM Assume Role must be created and must have the <domain>.<service> name. This role will not have any permissions but instead will have a trust relationship with your EKS pod role such that your EKS pod role can assume this role. In the AWS Console, select IAM from the Services drop down and then click on the Roles link in the left sidebar. Choose the Create Role button. Under the AWS Service type, select EKS and choose Next: Permissions button in the bottom right corner. In the Attach permissions policy screen do not choose any permissions and just click on the Next: Review button in the bottom right corner to continue. Specify the Role name in the <domain>.<service> format and choose Create Role to complete the process. In the Roles list view, choose the role just created and choose the Trust Relationships tab. Click on Edit trust relationship button and append a block containing the following policy to the Statement block Replace the <account-id> and <eks-pod-role> values with their corresponding values for your environment: { \"Effect\": \"Allow\", \"Principal\": { \"AWS\": \"arn:aws:iam::<account-id>:role/<eks-pod-role>\" }, \"Action\": \"sts:AssumeRole\" } Once correctly updated, your EKS pod role must appear in the Trusted entities table. Installing SIA in Container \u00b6 The AWS SIA source is part of the Athenz project and can be found in: provider/aws/sia-ec2 Follow the readme for instructions on how to install it. Typically you run the siad binary in your container and let it run continuously to register and refresh your service certificate daily since systemd does not run in a typical docker image. If you only want to run siad as a command line utility that just registers and refreshes the service and role certificates when executed, you can use the following command line options (Register must be called once within the first 30 mins when the instance is bootstrapped): Instance Register: /usr/sbin/siad -cmd post Service Certificate Refresh: /usr/sbin/siad -cmd rotate Role Certificate Refresh: /usr/sbin/siad -cmd rolecert Expiry Time \u00b6 Unlike EC2, Athenz x.509 Certificate for EKS are only issued for 7 days only due to different security requirements.","title":"Athenz Service Identity X.509 Certificate for AWS EKS pods"},{"location":"service_x509_credentials_aws_eks/#domain-registration","text":"Identify your Athenz domain before you can proceed by visiting Athenz UI. Follow the instructions documented for EC2 instances to register your domain if one doesn't exist already.","title":"Domain Registration"},{"location":"service_x509_credentials_aws_eks/#aws-account-id-registration","text":"To register an AWS Account with a domain, run the following command: zms-cli -d <domain-name> set-aws-account <aws-account-id>","title":"AWS Account ID Registration"},{"location":"service_x509_credentials_aws_eks/#athenz-service-identity-registration","text":"Create a service identity for your AWS EKS in your Athenz domain. This full service identity name <domain>.<service> will be the IAM role name that you will need to create in AWS IAM and set up a trust relationship with your EKS pod role. In the Athenz UI, select your domain, select the Services tab and then choose Add a Service link in the top left corner. You must provide a service name and an optional description for your service.","title":"Athenz Service Identity Registration"},{"location":"service_x509_credentials_aws_eks/#athenz-service-identity-authorization-role-and-policy","text":"Before ZTS can validate and issue X.509 TLS Certificates to the AWS EKS pods, it must validate that the service owner has authorized its service to be launched by AWS EKS Provider. In the Athenz UI select your service that was created in the previous step and click on the icon in the Providers column: Then, click on the Allow button to authorize your service to be launched by AWS EC2/EKS/Fargate provider.","title":"Athenz Service Identity Authorization Role and Policy"},{"location":"service_x509_credentials_aws_eks/#iam-role-setup","text":"There are two IAM roles required for instances to obtain Athenz X.509 certificates: EKS Role Athenz Service Identity Assume Role It is assumed that at this point you have already configured the first EKS Role that your pods will be launched with. This recommended name for this role is <domain>.<service>-service since this allows to automatically determine the service name (by stripping the -service suffix) without requiring the administrator to provide a sia_config file as part of the bootstrap. The second Athenz Service Identity IAM Assume Role must be created and must have the <domain>.<service> name. This role will not have any permissions but instead will have a trust relationship with your EKS pod role such that your EKS pod role can assume this role. In the AWS Console, select IAM from the Services drop down and then click on the Roles link in the left sidebar. Choose the Create Role button. Under the AWS Service type, select EKS and choose Next: Permissions button in the bottom right corner. In the Attach permissions policy screen do not choose any permissions and just click on the Next: Review button in the bottom right corner to continue. Specify the Role name in the <domain>.<service> format and choose Create Role to complete the process. In the Roles list view, choose the role just created and choose the Trust Relationships tab. Click on Edit trust relationship button and append a block containing the following policy to the Statement block Replace the <account-id> and <eks-pod-role> values with their corresponding values for your environment: { \"Effect\": \"Allow\", \"Principal\": { \"AWS\": \"arn:aws:iam::<account-id>:role/<eks-pod-role>\" }, \"Action\": \"sts:AssumeRole\" } Once correctly updated, your EKS pod role must appear in the Trusted entities table.","title":"IAM Role Setup"},{"location":"service_x509_credentials_aws_eks/#installing-sia-in-container","text":"The AWS SIA source is part of the Athenz project and can be found in: provider/aws/sia-ec2 Follow the readme for instructions on how to install it. Typically you run the siad binary in your container and let it run continuously to register and refresh your service certificate daily since systemd does not run in a typical docker image. If you only want to run siad as a command line utility that just registers and refreshes the service and role certificates when executed, you can use the following command line options (Register must be called once within the first 30 mins when the instance is bootstrapped): Instance Register: /usr/sbin/siad -cmd post Service Certificate Refresh: /usr/sbin/siad -cmd rotate Role Certificate Refresh: /usr/sbin/siad -cmd rolecert","title":"Installing SIA in Container"},{"location":"service_x509_credentials_aws_eks/#expiry-time","text":"Unlike EC2, Athenz x.509 Certificate for EKS are only issued for 7 days only due to different security requirements.","title":"Expiry Time"},{"location":"service_x509_credentials_aws_fargate/","text":"Domain Registration \u00b6 Identify your Athenz domain before you can proceed by visiting Athenz UI. Follow the instructions documented for EC2 instances to register your domain if one doesn't exist already. AWS Account ID Registration \u00b6 To register an AWS Account with a domain, run the following command: zms-cli -d <domain-name> set-aws-account <aws-account-id> Athenz Service Identity Registration \u00b6 Create a service identity for your AWS Fargate task in your Athenz domain. This full service identity name <domain>.<service> will be the IAM role name that you will need to create in AWS IAM and set up a trust relationship with your Fargate Task Service Role. In the Athenz UI, select your domain, select the Services tab and then choose Add a Service link in the top left corner. You must provide a service name and an optional description for your service. Since this is for AWS Fargate, you do not need to provide a public key as we'll obtain a client certificate based on AWS credentials. Athenz Service Identity Authorization Role and Policy \u00b6 Before ZTS can validate and issue X.509 TLS Certificates to the AWS Fargate tasks, it must validate that the service owner has authorized its service to be launched by AWS Fargate Provider. In the Athenz UI select your service that was created in the previous step and click on the icon in the Providers column: Then, click on the Allow button to authorize your service to be launched by AWS EC2/EKS/Fargate provider. IAM Role Setup \u00b6 There are two IAM roles required for instances to obtain Athenz X.509 certificates: Fargate Task Role Athenz Service Identity Assume Role It is assumed that at this point you have already configured the first Fargate Task Role that your code will be launched with. This recommended name for this role is <domain>.<service>-service since this allows to automatically determine the service name (by stripping the -service suffix) without requiring the administrator to provide a sia_config file as part of the bootstrap. The second Athenz Service Identity IAM Assume Role must be created and must have the <domain>.<service> name. This role will not have any permissions but instead will have a trust relationship with your Fargate task role such that your Fargate task role can assume this role. In the AWS Console, select IAM from the Services drop down and then click on the Roles link in the left sidebar. Choose the Create Role button. Under the AWS Service type, select Elastic Container Service and choose Next: Permissions button in the bottom right corner. In the Attach permissions policy screen do not choose any permissions and just click on the Next: Review button in the bottom right corner to continue. Specify the Role name in the <domain>.<service> format and choose Create Role to complete the process. In the Roles list view, choose the role just created and choose the Trust Relationships tab. Click on Edit trust relationship button and append a block containing the following policy to the Statement block Replace the <account-id> and <fargate-task-role> values with their corresponding values for your environment: { \"Effect\": \"Allow\", \"Principal\": { \"AWS\": \"arn:aws:iam::<account-id>:role/<fargate-task-role>\" }, \"Action\": \"sts:AssumeRole\" } Once correctly updated, your Fargate task role must appear in the Trusted entities table. Installing SIA in Container \u00b6 The AWS SIA source is part of the Athenz project and can be found in: provider/aws/sia-ec2 Follow the readme for instructions on how to install it. Typically you run the siad binary in your container and let it run continuously to register and refresh your service certificate daily since systemd does not run in a typical docker image. If you only want to run siad as a command line utility that just registers and refreshes the service and role certificates when executed, you can use the following command line options (Register must be called once within the first 30 mins when the instance is bootstrapped): Instance Register: /usr/sbin/siad -cmd post Service Certificate Refresh: /usr/sbin/siad -cmd rotate Role Certificate Refresh: /usr/sbin/siad -cmd rolecert Expiry Time \u00b6 Unlike EC2, Athenz x.509 Certificate for Fargate are only issued for 7 days only due to different security requirements.","title":"Athenz Service Identity X.509 Certificate for AWS Fargate tasks"},{"location":"service_x509_credentials_aws_fargate/#domain-registration","text":"Identify your Athenz domain before you can proceed by visiting Athenz UI. Follow the instructions documented for EC2 instances to register your domain if one doesn't exist already.","title":"Domain Registration"},{"location":"service_x509_credentials_aws_fargate/#aws-account-id-registration","text":"To register an AWS Account with a domain, run the following command: zms-cli -d <domain-name> set-aws-account <aws-account-id>","title":"AWS Account ID Registration"},{"location":"service_x509_credentials_aws_fargate/#athenz-service-identity-registration","text":"Create a service identity for your AWS Fargate task in your Athenz domain. This full service identity name <domain>.<service> will be the IAM role name that you will need to create in AWS IAM and set up a trust relationship with your Fargate Task Service Role. In the Athenz UI, select your domain, select the Services tab and then choose Add a Service link in the top left corner. You must provide a service name and an optional description for your service. Since this is for AWS Fargate, you do not need to provide a public key as we'll obtain a client certificate based on AWS credentials.","title":"Athenz Service Identity Registration"},{"location":"service_x509_credentials_aws_fargate/#athenz-service-identity-authorization-role-and-policy","text":"Before ZTS can validate and issue X.509 TLS Certificates to the AWS Fargate tasks, it must validate that the service owner has authorized its service to be launched by AWS Fargate Provider. In the Athenz UI select your service that was created in the previous step and click on the icon in the Providers column: Then, click on the Allow button to authorize your service to be launched by AWS EC2/EKS/Fargate provider.","title":"Athenz Service Identity Authorization Role and Policy"},{"location":"service_x509_credentials_aws_fargate/#iam-role-setup","text":"There are two IAM roles required for instances to obtain Athenz X.509 certificates: Fargate Task Role Athenz Service Identity Assume Role It is assumed that at this point you have already configured the first Fargate Task Role that your code will be launched with. This recommended name for this role is <domain>.<service>-service since this allows to automatically determine the service name (by stripping the -service suffix) without requiring the administrator to provide a sia_config file as part of the bootstrap. The second Athenz Service Identity IAM Assume Role must be created and must have the <domain>.<service> name. This role will not have any permissions but instead will have a trust relationship with your Fargate task role such that your Fargate task role can assume this role. In the AWS Console, select IAM from the Services drop down and then click on the Roles link in the left sidebar. Choose the Create Role button. Under the AWS Service type, select Elastic Container Service and choose Next: Permissions button in the bottom right corner. In the Attach permissions policy screen do not choose any permissions and just click on the Next: Review button in the bottom right corner to continue. Specify the Role name in the <domain>.<service> format and choose Create Role to complete the process. In the Roles list view, choose the role just created and choose the Trust Relationships tab. Click on Edit trust relationship button and append a block containing the following policy to the Statement block Replace the <account-id> and <fargate-task-role> values with their corresponding values for your environment: { \"Effect\": \"Allow\", \"Principal\": { \"AWS\": \"arn:aws:iam::<account-id>:role/<fargate-task-role>\" }, \"Action\": \"sts:AssumeRole\" } Once correctly updated, your Fargate task role must appear in the Trusted entities table.","title":"IAM Role Setup"},{"location":"service_x509_credentials_aws_fargate/#installing-sia-in-container","text":"The AWS SIA source is part of the Athenz project and can be found in: provider/aws/sia-ec2 Follow the readme for instructions on how to install it. Typically you run the siad binary in your container and let it run continuously to register and refresh your service certificate daily since systemd does not run in a typical docker image. If you only want to run siad as a command line utility that just registers and refreshes the service and role certificates when executed, you can use the following command line options (Register must be called once within the first 30 mins when the instance is bootstrapped): Instance Register: /usr/sbin/siad -cmd post Service Certificate Refresh: /usr/sbin/siad -cmd rotate Role Certificate Refresh: /usr/sbin/siad -cmd rolecert","title":"Installing SIA in Container"},{"location":"service_x509_credentials_aws_fargate/#expiry-time","text":"Unlike EC2, Athenz x.509 Certificate for Fargate are only issued for 7 days only due to different security requirements.","title":"Expiry Time"},{"location":"service_x509_credentials_aws_lambda/","text":"Important: Certificate Signing is an expensive operation (both on the client and the server side) so if your application is going to launch large number of instances of your lambda function, then you must not fetch Athenz x.509 certificates directly within your lambda function. The recommended approach for that scenario is have one lambda function to fetch the Athenz X.509 Certificate Identity private key and the public certificate, store them in AWS Parameter Store and update those daily. Then have all other lambda functions authorized based on their IAM credentials to fetch and use that x.509 certificate. Domain Registration \u00b6 Identify your Athenz domain before you can proceed by visiting Athenz UI. Follow the instructions documented for EC2 instances to register your domain if one doesn't exist already. AWS Account ID Registration \u00b6 To register an AWS Account with a domain, run the following command: zms-cli -d <domain-name> set-aws-account <aws-account-id> Athenz Service Identity Registration \u00b6 Create a service identity for your AWS Lambda function in your Athenz domain. This full service identity name <domain>.<service> will be the IAM role name that you will need to create in AWS IAM and set up a trust relationship with your Lambda Function Execution Role. In the Athenz UI, select your domain, select the Services tab and then choose Add a Service link in the top left corner. You must provide a service name and an optional description for your service. Athenz Service Identity Authorization Role and Policy \u00b6 Before ZTS can validate and issue X.509 TLS Certificates to the AWS Lambda, it must validate that the service owner has authorized its service to be launched by AWS Lambda Provider. The following role and policy must be created in your Athenz domain for this authorization: When viewing your domain details, choose the Roles tab and select Add Role link on the left side of the screen underneath the tab names. Role details are as follows (don't forget to press the Add button after specifying the role member before pressing the Submit button): Role Category: Regular Role Name: aws_lambda_launch_provider Add Member(s): athens.aws-lambda.* Then choose the Policies tab and select Add Policy link on the left side of the screen underneath the tab names. Policy details are as follows (make sure to replace <your-service-name> in the Rule Resource with your actual service name): Policy Name: aws_lambda_launch_provider Rule Effect: Allow Rule Action: launch Rule Role: aws_lambda_launch_provider Rule Resource: service.<your-service-name> IAM Role Setup \u00b6 There are two IAM roles required for instances to obtain Athenz X.509 certificates: Lambda Function Execution Role Athenz Service Identity Assume Role It is assumed that at this point you have already configured the first Lambda Function Execution Role that your code will be launched with (roles created through the AWS console are created with /service-role/ path). The second Athenz Service Identity IAM Assume Role must be created and must have the <domain>.<service> name. This role will not have any permissions but instead will have a trust relationship with your Lambda execution role such that your Lambda execution role can assume this role. In the AWS Console, select IAM from the Services drop down and then click on the Roles link in the left sidebar. Choose the Create Role button. Under the AWS Service type, select Lambda and choose Next: Permissions button in the bottom right corner. In the Attach permissions policy screen do not choose any permissions and just click on the Next: Review button in the bottom right corner to continue. Specify the Role name in the <domain>.<service> format and choose Create Role to complete the process. In the Roles list view, choose the role just created and choose the Trust Relationships tab. Click on Edit trust relationship button and append a block containing the following policy to the Statement block Replace the <account-id> and <lambda-execution-role> values with their corresponding values for your environment. For the <lambda-execution-role> make sure to include the full path since roles created through the AWS console are created with /service-role/ path: { \"Effect\": \"Allow\", \"Principal\": { \"AWS\": \"arn:aws:iam::<account-id>:role/<lambda-execution-role>\" }, \"Action\": \"sts:AssumeRole\" } Once correctly updated, your Lambda role must appear in the Trusted entities table: Private Key and Certificate Setup \u00b6 Since we're dealing with functions in this use case, we cannot have a SIA agent daemon running to generate a private key for the service and then retrieve a corresponding x.509 certificate from the ZTS Server. Instead, the function being invoked will be responsible for generating a private key and then a csr for its request. Finally, it will submit that request to the ZTS Server to retrieve its X.509 certificate which then it can use along with its generated private key to establish TLS connections to other Verizon Media Athenz enabled services. Athenz Team provides functions/methods in Go and Java programming languages to quickly generate a private key and request its corresponding X.509 certificate from ZTS Server. Important consideration when dealing with Lambda functions: The code to do this needs to prefetch and cache the certificate in a way that does not block every invocation, as minting a new certificate is somewhat expensive. The short lifetime and stateless nature of the function means it cannot rotate its certificates. It just gets new ones when needed. Java \u00b6 The following function is available in the Athenz ZTS Java Client: /** * For AWS Lambda functions generate a new private key, request a * x.509 certificate based on the requested CSR and return both to * the client in order to establish tls connections with other * Athenz enabled services. * @param domainName name of the athenz domain * @param serviceName name of the athenz service * @param account AWS account name that the function runs in * @param provider name of the provider service for AWS Lambda * @return AWSLambdaIdentity with private key and certificate */ public AWSLambdaIdentity getAWSLambdaServiceCertificate(String domainName, String serviceName, String account, String provider); For example, here is a quick program that can be compiled and packaged into lambda.jar and deployed as a Lambda function in AWS. It retrieves a private key and the corresponding x.509 certificate and returns as output. First you need to update your Java project pom.xml file to indicate the dependency on the Athenz zts java client libraries. Checkout the Bintray ZTS Java Client Package pages to make sure you're using the latest release version: <dependencies> <dependency> <groupId> com.yahoo.athenz </groupId> <artifactId> athenz-zts-java-client </artifactId> <version> 1.8.37 </version> </dependency> </dependencies> Next, is the Lambda function handler implementation: package com.amazonaws.lambda.demo; import com.amazonaws.services.lambda.runtime.Context; import com.amazonaws.services.lambda.runtime.RequestHandler; import com.yahoo.athenz.zts.AWSLambdaIdentity; import com.yahoo.athenz.zts.ZTSClient; public class LambdaFunctionHandler implements RequestHandler<Object, String> { @Override public String handleRequest(Object input, Context context) { final String athenzDomain = \"athens\"; // replace this with your domain name final String athenzService = \"lambda\"; // replace this with your service name final String awsAccount = \"123456789\"; // replace this with your account number final String athenzProvider = \"<lambada-name>.<lambada region>\"; // replace with labada name and region. for example: \"athens.aws-labmda.us-west-2\" final String ztsUrl = \"https://zts-address/zts/v1\"; // replace this with your zts Url (ending with /zts/v1) final String certDn = \"ou=Athenz,o=Oath\"; // the dn you want included in cert final String certDomain = \"aws.cert.domain\"; // cert domain // our key and cert to display for test purposes String certificate; String privateKey; // generate a private key and retrieve the corresponding // certificate from Athenz ZTS Service try (ZTSClient client = new ZTSClient(ztsUrl)) { ZTSClient.setX509CsrDetails(certDn, certDomain); AWSLambdaIdentity lambdaIdentity = client.getAWSLambdaServiceCertificate(athenzDomain, athenzService, awsAccount, athenzProvider); certificate = lambdaIdentity.getX509Certificate().toString(); privateKey = lambdaIdentity.getPrivateKey().toString(); } // just return our data so we can see it in our aws console return \"Lambda - Private Key: \" + privateKey + \" Certificate: \" + certificate; } } Go \u00b6 The following function is available in the /sia-ec2/util package: func GetAWSLambdaServiceCertificate(ztsUrl, domain, service, account, region string) (tls.Certificate, error) Change the ztsUrl field with your zts (ending with /zts/v1 ). The domain is your Athenz domain name while service is the service name that your Lambda function will run as. The account field is the AWS account id while region is where this function will be running. For example, here is a quick program that can be compiled and packaged into main.zip and deployed as a Lambda function in AWS. It retrieves a private key and the corresponding x.509 certificate and returns as output. package main import ( \"crypto/rsa\" \"encoding/pem\" \"fmt\" \"github.com/aws/aws-lambda-go/lambda\" \"util\" ) type Request struct { Zts string `json:\"zts\"` Region string `json:\"region\"` Domain string `json:\"domain\"` Account string `json:\"account\"` Service string `json:\"service\"` } type Response struct { PrivateKey string `json:\"privatekey\"` X509Certificate string `json:\"certificate\"` Message string `json:\"message\"` } func Handler(req Request) (Response, error) { x509Cert, err := util.GetAWSLambdaServiceCertificate(req.Zts, req.Domain, req.Service, req.Account, req.Region) var resp Response if err != nil { resp.Message = fmt.Sprintf(\"Unable to get certificate: %v\", err) } else { resp.PrivateKey = util.PrivatePem(x509Cert.PrivateKey.(*rsa.PrivateKey)) resp.X509Certificate = string(pem.EncodeToMemory(&pem.Block{Type: \"CERTIFICATE\", Bytes: x509Cert.Certificate[0]})) resp.Message = \"Success\" } return resp, err } func main() { lambda.Start(Handler) } Here is a sample input for this function. Our domain is called athens and the service is called lambda-function-test. { \"zts\": \"https://zts.com:4443/zts/v1\", \"region\": \"us-west-2\", \"domain\": \"athens\", \"service\": \"lambda-function-test\", \"account\": \"123456789\" }","title":"Athenz Service Identity X.509 Certificate for AWS Lambda functions"},{"location":"service_x509_credentials_aws_lambda/#domain-registration","text":"Identify your Athenz domain before you can proceed by visiting Athenz UI. Follow the instructions documented for EC2 instances to register your domain if one doesn't exist already.","title":"Domain Registration"},{"location":"service_x509_credentials_aws_lambda/#aws-account-id-registration","text":"To register an AWS Account with a domain, run the following command: zms-cli -d <domain-name> set-aws-account <aws-account-id>","title":"AWS Account ID Registration"},{"location":"service_x509_credentials_aws_lambda/#athenz-service-identity-registration","text":"Create a service identity for your AWS Lambda function in your Athenz domain. This full service identity name <domain>.<service> will be the IAM role name that you will need to create in AWS IAM and set up a trust relationship with your Lambda Function Execution Role. In the Athenz UI, select your domain, select the Services tab and then choose Add a Service link in the top left corner. You must provide a service name and an optional description for your service.","title":"Athenz Service Identity Registration"},{"location":"service_x509_credentials_aws_lambda/#athenz-service-identity-authorization-role-and-policy","text":"Before ZTS can validate and issue X.509 TLS Certificates to the AWS Lambda, it must validate that the service owner has authorized its service to be launched by AWS Lambda Provider. The following role and policy must be created in your Athenz domain for this authorization: When viewing your domain details, choose the Roles tab and select Add Role link on the left side of the screen underneath the tab names. Role details are as follows (don't forget to press the Add button after specifying the role member before pressing the Submit button): Role Category: Regular Role Name: aws_lambda_launch_provider Add Member(s): athens.aws-lambda.* Then choose the Policies tab and select Add Policy link on the left side of the screen underneath the tab names. Policy details are as follows (make sure to replace <your-service-name> in the Rule Resource with your actual service name): Policy Name: aws_lambda_launch_provider Rule Effect: Allow Rule Action: launch Rule Role: aws_lambda_launch_provider Rule Resource: service.<your-service-name>","title":"Athenz Service Identity Authorization Role and Policy"},{"location":"service_x509_credentials_aws_lambda/#iam-role-setup","text":"There are two IAM roles required for instances to obtain Athenz X.509 certificates: Lambda Function Execution Role Athenz Service Identity Assume Role It is assumed that at this point you have already configured the first Lambda Function Execution Role that your code will be launched with (roles created through the AWS console are created with /service-role/ path). The second Athenz Service Identity IAM Assume Role must be created and must have the <domain>.<service> name. This role will not have any permissions but instead will have a trust relationship with your Lambda execution role such that your Lambda execution role can assume this role. In the AWS Console, select IAM from the Services drop down and then click on the Roles link in the left sidebar. Choose the Create Role button. Under the AWS Service type, select Lambda and choose Next: Permissions button in the bottom right corner. In the Attach permissions policy screen do not choose any permissions and just click on the Next: Review button in the bottom right corner to continue. Specify the Role name in the <domain>.<service> format and choose Create Role to complete the process. In the Roles list view, choose the role just created and choose the Trust Relationships tab. Click on Edit trust relationship button and append a block containing the following policy to the Statement block Replace the <account-id> and <lambda-execution-role> values with their corresponding values for your environment. For the <lambda-execution-role> make sure to include the full path since roles created through the AWS console are created with /service-role/ path: { \"Effect\": \"Allow\", \"Principal\": { \"AWS\": \"arn:aws:iam::<account-id>:role/<lambda-execution-role>\" }, \"Action\": \"sts:AssumeRole\" } Once correctly updated, your Lambda role must appear in the Trusted entities table:","title":"IAM Role Setup"},{"location":"service_x509_credentials_aws_lambda/#private-key-and-certificate-setup","text":"Since we're dealing with functions in this use case, we cannot have a SIA agent daemon running to generate a private key for the service and then retrieve a corresponding x.509 certificate from the ZTS Server. Instead, the function being invoked will be responsible for generating a private key and then a csr for its request. Finally, it will submit that request to the ZTS Server to retrieve its X.509 certificate which then it can use along with its generated private key to establish TLS connections to other Verizon Media Athenz enabled services. Athenz Team provides functions/methods in Go and Java programming languages to quickly generate a private key and request its corresponding X.509 certificate from ZTS Server. Important consideration when dealing with Lambda functions: The code to do this needs to prefetch and cache the certificate in a way that does not block every invocation, as minting a new certificate is somewhat expensive. The short lifetime and stateless nature of the function means it cannot rotate its certificates. It just gets new ones when needed.","title":"Private Key and Certificate Setup"},{"location":"service_x509_credentials_aws_lambda/#java","text":"The following function is available in the Athenz ZTS Java Client: /** * For AWS Lambda functions generate a new private key, request a * x.509 certificate based on the requested CSR and return both to * the client in order to establish tls connections with other * Athenz enabled services. * @param domainName name of the athenz domain * @param serviceName name of the athenz service * @param account AWS account name that the function runs in * @param provider name of the provider service for AWS Lambda * @return AWSLambdaIdentity with private key and certificate */ public AWSLambdaIdentity getAWSLambdaServiceCertificate(String domainName, String serviceName, String account, String provider); For example, here is a quick program that can be compiled and packaged into lambda.jar and deployed as a Lambda function in AWS. It retrieves a private key and the corresponding x.509 certificate and returns as output. First you need to update your Java project pom.xml file to indicate the dependency on the Athenz zts java client libraries. Checkout the Bintray ZTS Java Client Package pages to make sure you're using the latest release version: <dependencies> <dependency> <groupId> com.yahoo.athenz </groupId> <artifactId> athenz-zts-java-client </artifactId> <version> 1.8.37 </version> </dependency> </dependencies> Next, is the Lambda function handler implementation: package com.amazonaws.lambda.demo; import com.amazonaws.services.lambda.runtime.Context; import com.amazonaws.services.lambda.runtime.RequestHandler; import com.yahoo.athenz.zts.AWSLambdaIdentity; import com.yahoo.athenz.zts.ZTSClient; public class LambdaFunctionHandler implements RequestHandler<Object, String> { @Override public String handleRequest(Object input, Context context) { final String athenzDomain = \"athens\"; // replace this with your domain name final String athenzService = \"lambda\"; // replace this with your service name final String awsAccount = \"123456789\"; // replace this with your account number final String athenzProvider = \"<lambada-name>.<lambada region>\"; // replace with labada name and region. for example: \"athens.aws-labmda.us-west-2\" final String ztsUrl = \"https://zts-address/zts/v1\"; // replace this with your zts Url (ending with /zts/v1) final String certDn = \"ou=Athenz,o=Oath\"; // the dn you want included in cert final String certDomain = \"aws.cert.domain\"; // cert domain // our key and cert to display for test purposes String certificate; String privateKey; // generate a private key and retrieve the corresponding // certificate from Athenz ZTS Service try (ZTSClient client = new ZTSClient(ztsUrl)) { ZTSClient.setX509CsrDetails(certDn, certDomain); AWSLambdaIdentity lambdaIdentity = client.getAWSLambdaServiceCertificate(athenzDomain, athenzService, awsAccount, athenzProvider); certificate = lambdaIdentity.getX509Certificate().toString(); privateKey = lambdaIdentity.getPrivateKey().toString(); } // just return our data so we can see it in our aws console return \"Lambda - Private Key: \" + privateKey + \" Certificate: \" + certificate; } }","title":"Java"},{"location":"service_x509_credentials_aws_lambda/#go","text":"The following function is available in the /sia-ec2/util package: func GetAWSLambdaServiceCertificate(ztsUrl, domain, service, account, region string) (tls.Certificate, error) Change the ztsUrl field with your zts (ending with /zts/v1 ). The domain is your Athenz domain name while service is the service name that your Lambda function will run as. The account field is the AWS account id while region is where this function will be running. For example, here is a quick program that can be compiled and packaged into main.zip and deployed as a Lambda function in AWS. It retrieves a private key and the corresponding x.509 certificate and returns as output. package main import ( \"crypto/rsa\" \"encoding/pem\" \"fmt\" \"github.com/aws/aws-lambda-go/lambda\" \"util\" ) type Request struct { Zts string `json:\"zts\"` Region string `json:\"region\"` Domain string `json:\"domain\"` Account string `json:\"account\"` Service string `json:\"service\"` } type Response struct { PrivateKey string `json:\"privatekey\"` X509Certificate string `json:\"certificate\"` Message string `json:\"message\"` } func Handler(req Request) (Response, error) { x509Cert, err := util.GetAWSLambdaServiceCertificate(req.Zts, req.Domain, req.Service, req.Account, req.Region) var resp Response if err != nil { resp.Message = fmt.Sprintf(\"Unable to get certificate: %v\", err) } else { resp.PrivateKey = util.PrivatePem(x509Cert.PrivateKey.(*rsa.PrivateKey)) resp.X509Certificate = string(pem.EncodeToMemory(&pem.Block{Type: \"CERTIFICATE\", Bytes: x509Cert.Certificate[0]})) resp.Message = \"Success\" } return resp, err } func main() { lambda.Start(Handler) } Here is a sample input for this function. Our domain is called athens and the service is called lambda-function-test. { \"zts\": \"https://zts.com:4443/zts/v1\", \"region\": \"us-west-2\", \"domain\": \"athens\", \"service\": \"lambda-function-test\", \"account\": \"123456789\" }","title":"Go"},{"location":"setup_ui/","text":"Setup Athenz UI \u00b6 Requirements Node.JS Getting Software Configuration Start/Stop UI Server UI Access Requirements \u00b6 The following tools are required to be installed on hosts configured to run UI server. Node.js \u00b6 UI Server is a Node.js application. Node.js JavaScript Runtime Verify that you have the required minimum version of node and nodemon binaries installed on your system and are included in your runtime path: $ node --version v12.14.0 $ npm install -g nodemon $ nodemon --version 2 .0.3 Getting Software \u00b6 Download latest Athenz UI release from Bintray - click on the Files tab, choose the latest version directory and then download the athenz-ui-<latest-version>-bin.tar.gz file: $ tar xvfz athenz-ui-X.Y-bin.tar.gz $ cd athenz-ui-X.Y Configuration \u00b6 To run UI Server, the system administrator must generate the keys, certificates and make necessary changes to the configuration settings. For our configuration script we need the ZMS server hostname and a copy of the server certificate file since ZMS Server is running with a self-signed certificate. From your ZMS Server installation, copy the zms_cert.pem file from the athenz-zms-X.Y/var/zms_server/certs directory to a local directory on the host that will be running the UI Server. For the zms-public-cert-path argument below pass the full path of the zms_cert.pem. $ cd athenz-ui-X.Y $ bin/setup_dev_ui.sh <zms-hostname> <zms-public-cert-path> <admin-username> <admin-fullname> Running this setup script completes the following tasks: Generate a unique public/private key pair that UI Server will use to sign user's authorized service tokens. The UI has already been authorized to be allowed to carry out the users' requested operations. Generate a self-signed X509 certificate for UI Server HTTPS support Create a new domain called athenz and register the ui service in that domain Start/Stop UI Server \u00b6 Set the following environment variable before starting the UI Server: $ cd athenz-ui-X.Y $ export UI_SERVER = <ui-server-host-name> ZMS_SERVER = <zms-server-host-name> NODE_ENV = production $ sudo -E bin/athenz_ui start Based on the sample configuration file provided, Athenz UI Server will be listening on port 443. To stop the UI server, execute the following commands: $ cd athenz-ui-X.Y $ export UI_SERVER = <ui-server-host-name> ZMS_SERVER = <zms-server-host-name> NODE_ENV = production $ sudo -E bin/athenz_ui stop UI Access \u00b6 To access Athenz UI in your browser, visit: https://<ui-server-host-name> Since the development setup is using self-signed X509 certificates for Athenz ZMS and UI servers, the administrator must add exceptions when accessing Athenz UI or install the self-signed certificates for those two servers into his/her own web browser. The administrator must first access the ZMS Server endpoint in the browser to accept the exception since the Athenz UI contacts ZMS Server to get an authorized token for the user when logging in. The administrator must access: https://<zms-server-host-name>:4443/zms/v1/schema first and accept the certificate exception before accessing Athenz UI. Alternatively, the administrator may decide to install the self-signed certificates for the ZMS and UI servers in their browser. For ZMS Server, the self-signed certificate is called zms_cert.pem and this file is located in the athenz-zms-X.Y/var/zms_server/certs directory. For UI Server, the self-signed certificate is called ui_cert.pem and this file is located in the athenz-ui-X.Y/keys directory.","title":"UI Server"},{"location":"setup_ui/#setup-athenz-ui","text":"Requirements Node.JS Getting Software Configuration Start/Stop UI Server UI Access","title":"Setup Athenz UI"},{"location":"setup_ui/#requirements","text":"The following tools are required to be installed on hosts configured to run UI server.","title":"Requirements"},{"location":"setup_ui/#nodejs","text":"UI Server is a Node.js application. Node.js JavaScript Runtime Verify that you have the required minimum version of node and nodemon binaries installed on your system and are included in your runtime path: $ node --version v12.14.0 $ npm install -g nodemon $ nodemon --version 2 .0.3","title":"Node.js"},{"location":"setup_ui/#getting-software","text":"Download latest Athenz UI release from Bintray - click on the Files tab, choose the latest version directory and then download the athenz-ui-<latest-version>-bin.tar.gz file: $ tar xvfz athenz-ui-X.Y-bin.tar.gz $ cd athenz-ui-X.Y","title":"Getting Software"},{"location":"setup_ui/#configuration","text":"To run UI Server, the system administrator must generate the keys, certificates and make necessary changes to the configuration settings. For our configuration script we need the ZMS server hostname and a copy of the server certificate file since ZMS Server is running with a self-signed certificate. From your ZMS Server installation, copy the zms_cert.pem file from the athenz-zms-X.Y/var/zms_server/certs directory to a local directory on the host that will be running the UI Server. For the zms-public-cert-path argument below pass the full path of the zms_cert.pem. $ cd athenz-ui-X.Y $ bin/setup_dev_ui.sh <zms-hostname> <zms-public-cert-path> <admin-username> <admin-fullname> Running this setup script completes the following tasks: Generate a unique public/private key pair that UI Server will use to sign user's authorized service tokens. The UI has already been authorized to be allowed to carry out the users' requested operations. Generate a self-signed X509 certificate for UI Server HTTPS support Create a new domain called athenz and register the ui service in that domain","title":"Configuration"},{"location":"setup_ui/#startstop-ui-server","text":"Set the following environment variable before starting the UI Server: $ cd athenz-ui-X.Y $ export UI_SERVER = <ui-server-host-name> ZMS_SERVER = <zms-server-host-name> NODE_ENV = production $ sudo -E bin/athenz_ui start Based on the sample configuration file provided, Athenz UI Server will be listening on port 443. To stop the UI server, execute the following commands: $ cd athenz-ui-X.Y $ export UI_SERVER = <ui-server-host-name> ZMS_SERVER = <zms-server-host-name> NODE_ENV = production $ sudo -E bin/athenz_ui stop","title":"Start/Stop UI Server"},{"location":"setup_ui/#ui-access","text":"To access Athenz UI in your browser, visit: https://<ui-server-host-name> Since the development setup is using self-signed X509 certificates for Athenz ZMS and UI servers, the administrator must add exceptions when accessing Athenz UI or install the self-signed certificates for those two servers into his/her own web browser. The administrator must first access the ZMS Server endpoint in the browser to accept the exception since the Athenz UI contacts ZMS Server to get an authorized token for the user when logging in. The administrator must access: https://<zms-server-host-name>:4443/zms/v1/schema first and accept the certificate exception before accessing Athenz UI. Alternatively, the administrator may decide to install the self-signed certificates for the ZMS and UI servers in their browser. For ZMS Server, the self-signed certificate is called zms_cert.pem and this file is located in the athenz-zms-X.Y/var/zms_server/certs directory. For UI Server, the self-signed certificate is called ui_cert.pem and this file is located in the athenz-ui-X.Y/keys directory.","title":"UI Access"},{"location":"setup_ui_prod/","text":"Setup Athenz UI for Production \u00b6 Requirements Node.JS Getting Software Configuration Private/Public Key Pair X509 Certificate Register UI Service Start/Stop UI Server Requirements \u00b6 The following tools are required to be installed on hosts configured to run UI server. Node.js \u00b6 UI Server is a Node.js application. Node.js JavaScript Runtime Verify that you have the required minimum version of node and nodemon binaries installed on your system and are included in your runtime path: $ node --version v12.14.0 $ nodemon --version 2 .0.3 Getting Software \u00b6 Download latest Athenz UI release from https://bintray.com/yahoo/maven/athenz-ui/_latestVersion#files $ tar xvfz athenz-ui-X.Y-bin.tar.gz $ cd athenz-ui-X.Y Configuration \u00b6 To run UI Server, the system administrator must generate the keys and make necessary changes to the configuration settings. Private/Public Key Pair \u00b6 Generate a unique private/public key pair that UI Server will use to sign user's authorized service tokens. The UI has already been authorized to be allowed to carry out the users' requested operations. From the athenz-ui-X.Y directory execute the following commands: $ cd keys $ openssl genrsa -out athenz.ui-server.pem 2048 $ openssl rsa -in athenz.ui-server.pem -pubout > athenz.ui-server_pub.pem X509 Certificate \u00b6 For Athenz UI production server it is strongly recommended to purchase a certificate for HTTPS access from a well known certificate authority. Follow the instructions provided by the Certificate Authority to generate your private key and then the Certificate Request (CSR). Once you have received your X509 certificate name your UI server private key as ui_key.pem and the X509 certificate as ui_cert.pem and copy those files into the keys subdirectory. Register UI Service \u00b6 In order for UI to access ZMS domain data, it must identify itself as a registered service in ZMS. Using the zms-cli utility, we will register a new service in athenz domain: $ cd athenz-ui-X.Y $ bin/<platform>/zms-cli -z https://<zms-server>:4443/zms/v1 add-domain athenz $ bin/<platform>/zms-cli -z https://<zms-server>:4443/zms/v1 -d athenz add-service ui-server 0 keys/athenz.ui-server_pub.pem Generate Athenz Configuration File \u00b6 Generate an Athenz configuration file athenz.conf in athenz-ui-X.Y/config directory to include the ZMS Server URL and the registered public keys that the athenz client libraries and utilities will use to establish connection and validate any data signed by the ZMS Server: $ cd athenz-ui-X.Y $ bin/<platform>/athenz-conf -o config/athenz.conf -z https://<zms-server>:4443/ Start/Stop UI Server \u00b6 Set the following environment variable before starting the UI Server: $ cd athenz-ui-X.Y $ export UI_SERVER = <ui-server-host-name> ZMS_SERVER = <zms-server-host-name> $ sudo -E bin/athenz_ui start Based on the sample configuration file provided, Athenz UI Server will be listening on port 443. To stop the UI server, execute the following commands: $ cd athenz-ui-X.Y $ export UI_SERVER = <ui-server-host-name> ZMS_SERVER = <zms-server-host-name> $ sudo -E bin/athenz_ui stop","title":"UI Server"},{"location":"setup_ui_prod/#setup-athenz-ui-for-production","text":"Requirements Node.JS Getting Software Configuration Private/Public Key Pair X509 Certificate Register UI Service Start/Stop UI Server","title":"Setup Athenz UI for Production"},{"location":"setup_ui_prod/#requirements","text":"The following tools are required to be installed on hosts configured to run UI server.","title":"Requirements"},{"location":"setup_ui_prod/#nodejs","text":"UI Server is a Node.js application. Node.js JavaScript Runtime Verify that you have the required minimum version of node and nodemon binaries installed on your system and are included in your runtime path: $ node --version v12.14.0 $ nodemon --version 2 .0.3","title":"Node.js"},{"location":"setup_ui_prod/#getting-software","text":"Download latest Athenz UI release from https://bintray.com/yahoo/maven/athenz-ui/_latestVersion#files $ tar xvfz athenz-ui-X.Y-bin.tar.gz $ cd athenz-ui-X.Y","title":"Getting Software"},{"location":"setup_ui_prod/#configuration","text":"To run UI Server, the system administrator must generate the keys and make necessary changes to the configuration settings.","title":"Configuration"},{"location":"setup_ui_prod/#privatepublic-key-pair","text":"Generate a unique private/public key pair that UI Server will use to sign user's authorized service tokens. The UI has already been authorized to be allowed to carry out the users' requested operations. From the athenz-ui-X.Y directory execute the following commands: $ cd keys $ openssl genrsa -out athenz.ui-server.pem 2048 $ openssl rsa -in athenz.ui-server.pem -pubout > athenz.ui-server_pub.pem","title":"Private/Public Key Pair"},{"location":"setup_ui_prod/#x509-certificate","text":"For Athenz UI production server it is strongly recommended to purchase a certificate for HTTPS access from a well known certificate authority. Follow the instructions provided by the Certificate Authority to generate your private key and then the Certificate Request (CSR). Once you have received your X509 certificate name your UI server private key as ui_key.pem and the X509 certificate as ui_cert.pem and copy those files into the keys subdirectory.","title":"X509 Certificate"},{"location":"setup_ui_prod/#register-ui-service","text":"In order for UI to access ZMS domain data, it must identify itself as a registered service in ZMS. Using the zms-cli utility, we will register a new service in athenz domain: $ cd athenz-ui-X.Y $ bin/<platform>/zms-cli -z https://<zms-server>:4443/zms/v1 add-domain athenz $ bin/<platform>/zms-cli -z https://<zms-server>:4443/zms/v1 -d athenz add-service ui-server 0 keys/athenz.ui-server_pub.pem","title":"Register UI Service"},{"location":"setup_ui_prod/#generate-athenz-configuration-file","text":"Generate an Athenz configuration file athenz.conf in athenz-ui-X.Y/config directory to include the ZMS Server URL and the registered public keys that the athenz client libraries and utilities will use to establish connection and validate any data signed by the ZMS Server: $ cd athenz-ui-X.Y $ bin/<platform>/athenz-conf -o config/athenz.conf -z https://<zms-server>:4443/","title":"Generate Athenz Configuration File"},{"location":"setup_ui_prod/#startstop-ui-server","text":"Set the following environment variable before starting the UI Server: $ cd athenz-ui-X.Y $ export UI_SERVER = <ui-server-host-name> ZMS_SERVER = <zms-server-host-name> $ sudo -E bin/athenz_ui start Based on the sample configuration file provided, Athenz UI Server will be listening on port 443. To stop the UI server, execute the following commands: $ cd athenz-ui-X.Y $ export UI_SERVER = <ui-server-host-name> ZMS_SERVER = <zms-server-host-name> $ sudo -E bin/athenz_ui stop","title":"Start/Stop UI Server"},{"location":"setup_zms/","text":"Setup ZMS (AuthoriZation Management System) \u00b6 Requirements JDK 8 Getting Software Configuration User Authentication System Administrators Start/Stop ZMS Server Requirements \u00b6 The following tools are required to be installed on hosts configured to run ZMS server. JDK 8 \u00b6 ZMS Server is written in Java and using embedded Jetty. Oracle Java Platform JDK 8 While ZMS has been developed and tested with Oracle Java Platform JDK 8 it should run successfully with OpenJDK 8 as well. Getting Software \u00b6 Download latest ZMS binary release from Bintray - click on the Files tab, choose the latest version directory and then download the athenz-zms-<latest-version>-bin.tar.gz file: $ tar xvfz athenz-zms-X.Y-bin.tar.gz Configuration \u00b6 To run ZMS Server, the system administrator must generate the keys and make necessary changes to the configuration settings. $ cd athenz-zms-X.Y $ bin/setup_dev_zms.sh Running this setup script completes the following two tasks: Generate a unique private key that ZMS Server will use to sign any NTokens it issues Generate a self-signed X509 certificate for ZMS Server HTTPS support User Authentication \u00b6 For a user to authenticate himself/herself in ZMS, the server must have the appropriate authentication authority implementation configured. By default, ZMS enables the following two authorities: Unix User Authority - using pam login profile to authenticate users Principal Authority - validating Principal Tokens that are issued when users authenticate using their unix login password. The server also provides other authorities - e.g. Kerberos, TLS Certificate that are not enabled by default. Since the default setup includes Unix Authority, the user that the ZMS process runs as must have read access to the /etc/shadow file. There are two options available: Run the process as root using sudo. This is only recommended for a local development installation. Create a special Unix group that has read access to the /etc/shadow file and set the user that the ZMS process will be running as a member of that group. Checkout the Principal Authentication section for full details on authorities. System Administrators \u00b6 When running the server very first time, ZMS Server automatically creates the required domains and sets the running user as the system administrator. The system administrators are the only ones authorized to create top level domains in Athenz. Before running the server very first time, you can configure the set of system administrators by following these steps: $ cd athenz-zms-X.Y $ vi conf/zms_server/zms.properties Modify the athenz.zms.domain_admin=user.admin line and include comma separated list of unix user ids that should be set as Athenz system administrators. e.g. athenz.zms.domain_admin=user.joe,user.john Start/Stop ZMS Server \u00b6 Start the ZMS Server by executing: $ cd athenz-zms-X.Y $ sudo -E bin/zms start See the User Authentication section above regarding an alternative solution of starting ZMS Server without using sudo. Based on the sample configuration file provided, ZMS Server will be listening on port 4443. Stop the ZMS Server by executing: $ cd athenz-zms-X.Y $ sudo -E bin/zms stop","title":"ZMS Server"},{"location":"setup_zms/#setup-zms-authorization-management-system","text":"Requirements JDK 8 Getting Software Configuration User Authentication System Administrators Start/Stop ZMS Server","title":"Setup ZMS (AuthoriZation Management System)"},{"location":"setup_zms/#requirements","text":"The following tools are required to be installed on hosts configured to run ZMS server.","title":"Requirements"},{"location":"setup_zms/#jdk-8","text":"ZMS Server is written in Java and using embedded Jetty. Oracle Java Platform JDK 8 While ZMS has been developed and tested with Oracle Java Platform JDK 8 it should run successfully with OpenJDK 8 as well.","title":"JDK 8"},{"location":"setup_zms/#getting-software","text":"Download latest ZMS binary release from Bintray - click on the Files tab, choose the latest version directory and then download the athenz-zms-<latest-version>-bin.tar.gz file: $ tar xvfz athenz-zms-X.Y-bin.tar.gz","title":"Getting Software"},{"location":"setup_zms/#configuration","text":"To run ZMS Server, the system administrator must generate the keys and make necessary changes to the configuration settings. $ cd athenz-zms-X.Y $ bin/setup_dev_zms.sh Running this setup script completes the following two tasks: Generate a unique private key that ZMS Server will use to sign any NTokens it issues Generate a self-signed X509 certificate for ZMS Server HTTPS support","title":"Configuration"},{"location":"setup_zms/#user-authentication","text":"For a user to authenticate himself/herself in ZMS, the server must have the appropriate authentication authority implementation configured. By default, ZMS enables the following two authorities: Unix User Authority - using pam login profile to authenticate users Principal Authority - validating Principal Tokens that are issued when users authenticate using their unix login password. The server also provides other authorities - e.g. Kerberos, TLS Certificate that are not enabled by default. Since the default setup includes Unix Authority, the user that the ZMS process runs as must have read access to the /etc/shadow file. There are two options available: Run the process as root using sudo. This is only recommended for a local development installation. Create a special Unix group that has read access to the /etc/shadow file and set the user that the ZMS process will be running as a member of that group. Checkout the Principal Authentication section for full details on authorities.","title":"User Authentication"},{"location":"setup_zms/#system-administrators","text":"When running the server very first time, ZMS Server automatically creates the required domains and sets the running user as the system administrator. The system administrators are the only ones authorized to create top level domains in Athenz. Before running the server very first time, you can configure the set of system administrators by following these steps: $ cd athenz-zms-X.Y $ vi conf/zms_server/zms.properties Modify the athenz.zms.domain_admin=user.admin line and include comma separated list of unix user ids that should be set as Athenz system administrators. e.g. athenz.zms.domain_admin=user.joe,user.john","title":"System Administrators"},{"location":"setup_zms/#startstop-zms-server","text":"Start the ZMS Server by executing: $ cd athenz-zms-X.Y $ sudo -E bin/zms start See the User Authentication section above regarding an alternative solution of starting ZMS Server without using sudo. Based on the sample configuration file provided, ZMS Server will be listening on port 4443. Stop the ZMS Server by executing: $ cd athenz-zms-X.Y $ sudo -E bin/zms stop","title":"Start/Stop ZMS Server"},{"location":"setup_zms_prod/","text":"Setup ZMS (AuthoriZation Management System) For Production \u00b6 The primary requirement for running ZMS in a Production environment is using JDBC (MySQL Server) to store the domain data as opposed to file based json documents. Requirements JDK 8 MySQL Server ZMS Server Schema Setup MySQL User and Permissions Getting Software Configuration DB Access Private Key Server X509 Certificate User Authentication System Administrators Start/Stop ZMS Server Requirements \u00b6 The following tools are required to be installed on hosts configured to run ZMS server. JDK 8 \u00b6 ZMS Server is written in Java and using embedded Jetty. Oracle Java Platform JDK 8 While ZMS has been developed and tested with Oracle Java Platform JDK 8 it should run successfully with OpenJDK 8 as well. MySQL Server \u00b6 On a separate host, download and install the latest version of MySQL Server ZMS Server Schema Setup \u00b6 Copy the zms_server.sql file from the Athenz Git repository (from the servers/zms/schema directory) onto this host and create the database: $ mysql -u root < zms_server.sql MySQL User and Permissions \u00b6 Follow MySQL documentation to create a user and grant this user full privileges over the zms_server database created. For example, let's assume our ZMS Server will be running on zms1.athenz.com host and we want to create a user called zms_admin with password \"rdvXC7wgvm3g\": $ mysql -u root mysql> CREATE USER 'zms_admin'@'zms1.athenz.com' IDENTIFIED BY 'rdvXC7wgvm3g'; mysql> GRANT ALL PRIVILEGES ON zms_server.* TO 'zms_admin'@'zms1.athenz.com'; mysql> FLUSH PRIVILEGES; We recommend to have a strong admin password for better security. Getting Software \u00b6 Download latest ZMS binary release from https://bintray.com/yahoo/maven/athenz-zms/_latestVersion#files $ tar xvfz athenz-zms-X.Y-bin.tar.gz $ cd athenz-zms-X.Y Configuration \u00b6 To run ZMS Server, the system administrator must generate the keys and make necessary changes to the configuration settings. DB Access \u00b6 In the \"MySQL Server\" section above we installed and configured the schema required for ZMS Server. We also created a zms admin user and granted full access over those tables. Now, we need to configure the ZMS with those access details: $ cd conf/zms_server $ vi zms.properties Make the following changes: Configure the ZMS Server to use JDBC object store implementation. Uncomment the #athenz.zms.object_store_factory_class= line and set it to point to the JDBC Factory class name. It should be set to: athenz.zms.object_store_factory_class=com.yahoo.athenz.zms.store.impl.JDBCObjectStoreFactory Uncomment the #athenz.zms.jdbcstore= line and set it to point to your MySQL Server instance. For example if your DB Server is running on a host called db1.athenz.com, then your line would be: athenz.zms.jdbc_store=jdbc:mysql://db1.athenz.com:3306/zms_server Uncomment the #athenz.zms.jdbc_user= line and set it to the user configured to have full access over zms server database: athenz.zms.jdbc_user=zms_admin Uncomment the #athenz.zms.jdbc_password= line and set it to the configured password the for the jdbc user with full access: athenz.zms.jdbc_password=rdvXC7wgvm3g Storing the password in property file is not secure. The more robust approach is to use a Key Management Store like HashiCorp Vault to store your passwords. Athenz provides a PrivateKeyStoreFactory interface for accessing secrets from your key management store. The recommended approach would to write your own implementation of this interface and configure ZMS server to use that factory to fetch the password for your database access. ZMS Server expect the private key store factory implementation class name in its athenz.zms.private_key_store_factory_class system property. Refer to Private Key Store section for full details how to implement your private key store. When storing the jdbc user password for your database access in your key management store with a given keyname like athenz.admin_db_password and using your own implementation of the PrivateKeyStoreFactory, then the value of the athenz.zms.jdbc_password property would be the key name. For example: athenz.zms.jdbc_password=athenz.admin_db_password The password is retrieved using the getApplicationSecret() of your private key store class that takes keyName ( athenz.admin_db_password in this case) as input and returns key value that is your configured password. Private Key \u00b6 Generate a unique private key that ZMS Server will use to sign any NTokens it issues. From the athenz-zms-X.Y directory execute the following commands: $ cd var/zms_server/keys $ openssl genrsa -out zms_private.pem 2048 If you have multiple ZMS servers in your environment, your private key must be stored in your key management store and securely installed on all hosts where ZMS servers will be running in the specified directory. Server X509 Certificate \u00b6 While it is still possible to generate and use a self-signed X509 certificate for ZMS Servers, it is recommended to purchase one for your production server from a well known certificate authority. Having such a certificate installed on your ZMS Servers will no longer require to distribute the server's CA certificate to other hosts (e.g. ZTS Servers, Hosts running ZPU). Follow the instructions provided by the Certificate Authority that you're going to purchase your certificate from to generate your private key and then the Certificate Request (CSR). Once you have received your X509 certificate, we just need to add that certificate along with its private key to a keystore for Jetty use. From the athenz-zms-X.Y directory execute the following command: $ openssl pkcs12 -export -out zms_keystore.pkcs12 -in zms_cert.pem -inkey zms_key.pem User Authentication \u00b6 For a user to authenticate himself/herself in ZMS, the server must have the appropriate authentication authority implementation configured. By default, ZMS enables the following two authorities: Unix User Authority - using pam login profile to authenticate users Principal Authority - validating Principal Tokens that are issued when users authenticate using their unix login password. The server also provides other authorities - e.g. Kerberos, TLS Certificate that are not enabled by default. Since the default setup includes Unix Authority, the user that the ZMS process runs as must have read access to the /etc/shadow file. There are two options available: Create a special Unix group that has read access to the /etc/shadow file and set the user that the ZMS process will be running as a member of that group. Run the process as root using sudo. This is not recommended for a production installation. To add your own authentication authority modify the athenz.zms.authority_classes=com.yahoo.athenz.auth.impl.PrincipalAuthority,com.yahoo.athenz.auth.impl.UserAuthority line and include comma separated list of authority implementation classes to support. System Administrators \u00b6 When running the server very first time, ZMS Server automatically creates the required domains and sets the running user as the system administrator. The system administrators are the only ones authorized to create top level domains in Athenz. Before running the server very first time, you can configure the set of system administrators by following these steps: $ cd athenz-zms-X.Y $ vi conf/zms_server/zms.properties Modify the athenz.zms.domain_admin=user.admin line and include comma separated list of unix user ids that should be set as Athenz system administrators. e.g. athenz.zms.domain_admin=user.joe,user.john Start/Stop ZMS Server \u00b6 Start the ZMS Server by executing: $ cd athenz-zms-X.Y $ bin/zms start If using the Unix Authority to authenticate users against their unix password, make sure the user that the ZMS Server process is running as has read access to the /etc/shadow file. For full details, please check out the User Authentication section above. Based on the sample configuration file provided, ZMS Server will be listening on port 4443. Stop the ZMS Server by executing: $ cd athenz-zms-X.Y $ bin/zms stop","title":"ZMS Server"},{"location":"setup_zms_prod/#setup-zms-authorization-management-system-for-production","text":"The primary requirement for running ZMS in a Production environment is using JDBC (MySQL Server) to store the domain data as opposed to file based json documents. Requirements JDK 8 MySQL Server ZMS Server Schema Setup MySQL User and Permissions Getting Software Configuration DB Access Private Key Server X509 Certificate User Authentication System Administrators Start/Stop ZMS Server","title":"Setup ZMS (AuthoriZation Management System) For Production"},{"location":"setup_zms_prod/#requirements","text":"The following tools are required to be installed on hosts configured to run ZMS server.","title":"Requirements"},{"location":"setup_zms_prod/#jdk-8","text":"ZMS Server is written in Java and using embedded Jetty. Oracle Java Platform JDK 8 While ZMS has been developed and tested with Oracle Java Platform JDK 8 it should run successfully with OpenJDK 8 as well.","title":"JDK 8"},{"location":"setup_zms_prod/#mysql-server","text":"On a separate host, download and install the latest version of MySQL Server","title":"MySQL Server"},{"location":"setup_zms_prod/#zms-server-schema-setup","text":"Copy the zms_server.sql file from the Athenz Git repository (from the servers/zms/schema directory) onto this host and create the database: $ mysql -u root < zms_server.sql","title":"ZMS Server Schema Setup"},{"location":"setup_zms_prod/#mysql-user-and-permissions","text":"Follow MySQL documentation to create a user and grant this user full privileges over the zms_server database created. For example, let's assume our ZMS Server will be running on zms1.athenz.com host and we want to create a user called zms_admin with password \"rdvXC7wgvm3g\": $ mysql -u root mysql> CREATE USER 'zms_admin'@'zms1.athenz.com' IDENTIFIED BY 'rdvXC7wgvm3g'; mysql> GRANT ALL PRIVILEGES ON zms_server.* TO 'zms_admin'@'zms1.athenz.com'; mysql> FLUSH PRIVILEGES; We recommend to have a strong admin password for better security.","title":"MySQL User and Permissions"},{"location":"setup_zms_prod/#getting-software","text":"Download latest ZMS binary release from https://bintray.com/yahoo/maven/athenz-zms/_latestVersion#files $ tar xvfz athenz-zms-X.Y-bin.tar.gz $ cd athenz-zms-X.Y","title":"Getting Software"},{"location":"setup_zms_prod/#configuration","text":"To run ZMS Server, the system administrator must generate the keys and make necessary changes to the configuration settings.","title":"Configuration"},{"location":"setup_zms_prod/#db-access","text":"In the \"MySQL Server\" section above we installed and configured the schema required for ZMS Server. We also created a zms admin user and granted full access over those tables. Now, we need to configure the ZMS with those access details: $ cd conf/zms_server $ vi zms.properties Make the following changes: Configure the ZMS Server to use JDBC object store implementation. Uncomment the #athenz.zms.object_store_factory_class= line and set it to point to the JDBC Factory class name. It should be set to: athenz.zms.object_store_factory_class=com.yahoo.athenz.zms.store.impl.JDBCObjectStoreFactory Uncomment the #athenz.zms.jdbcstore= line and set it to point to your MySQL Server instance. For example if your DB Server is running on a host called db1.athenz.com, then your line would be: athenz.zms.jdbc_store=jdbc:mysql://db1.athenz.com:3306/zms_server Uncomment the #athenz.zms.jdbc_user= line and set it to the user configured to have full access over zms server database: athenz.zms.jdbc_user=zms_admin Uncomment the #athenz.zms.jdbc_password= line and set it to the configured password the for the jdbc user with full access: athenz.zms.jdbc_password=rdvXC7wgvm3g Storing the password in property file is not secure. The more robust approach is to use a Key Management Store like HashiCorp Vault to store your passwords. Athenz provides a PrivateKeyStoreFactory interface for accessing secrets from your key management store. The recommended approach would to write your own implementation of this interface and configure ZMS server to use that factory to fetch the password for your database access. ZMS Server expect the private key store factory implementation class name in its athenz.zms.private_key_store_factory_class system property. Refer to Private Key Store section for full details how to implement your private key store. When storing the jdbc user password for your database access in your key management store with a given keyname like athenz.admin_db_password and using your own implementation of the PrivateKeyStoreFactory, then the value of the athenz.zms.jdbc_password property would be the key name. For example: athenz.zms.jdbc_password=athenz.admin_db_password The password is retrieved using the getApplicationSecret() of your private key store class that takes keyName ( athenz.admin_db_password in this case) as input and returns key value that is your configured password.","title":"DB Access"},{"location":"setup_zms_prod/#private-key","text":"Generate a unique private key that ZMS Server will use to sign any NTokens it issues. From the athenz-zms-X.Y directory execute the following commands: $ cd var/zms_server/keys $ openssl genrsa -out zms_private.pem 2048 If you have multiple ZMS servers in your environment, your private key must be stored in your key management store and securely installed on all hosts where ZMS servers will be running in the specified directory.","title":"Private Key"},{"location":"setup_zms_prod/#server-x509-certificate","text":"While it is still possible to generate and use a self-signed X509 certificate for ZMS Servers, it is recommended to purchase one for your production server from a well known certificate authority. Having such a certificate installed on your ZMS Servers will no longer require to distribute the server's CA certificate to other hosts (e.g. ZTS Servers, Hosts running ZPU). Follow the instructions provided by the Certificate Authority that you're going to purchase your certificate from to generate your private key and then the Certificate Request (CSR). Once you have received your X509 certificate, we just need to add that certificate along with its private key to a keystore for Jetty use. From the athenz-zms-X.Y directory execute the following command: $ openssl pkcs12 -export -out zms_keystore.pkcs12 -in zms_cert.pem -inkey zms_key.pem","title":"Server X509 Certificate"},{"location":"setup_zms_prod/#user-authentication","text":"For a user to authenticate himself/herself in ZMS, the server must have the appropriate authentication authority implementation configured. By default, ZMS enables the following two authorities: Unix User Authority - using pam login profile to authenticate users Principal Authority - validating Principal Tokens that are issued when users authenticate using their unix login password. The server also provides other authorities - e.g. Kerberos, TLS Certificate that are not enabled by default. Since the default setup includes Unix Authority, the user that the ZMS process runs as must have read access to the /etc/shadow file. There are two options available: Create a special Unix group that has read access to the /etc/shadow file and set the user that the ZMS process will be running as a member of that group. Run the process as root using sudo. This is not recommended for a production installation. To add your own authentication authority modify the athenz.zms.authority_classes=com.yahoo.athenz.auth.impl.PrincipalAuthority,com.yahoo.athenz.auth.impl.UserAuthority line and include comma separated list of authority implementation classes to support.","title":"User Authentication"},{"location":"setup_zms_prod/#system-administrators","text":"When running the server very first time, ZMS Server automatically creates the required domains and sets the running user as the system administrator. The system administrators are the only ones authorized to create top level domains in Athenz. Before running the server very first time, you can configure the set of system administrators by following these steps: $ cd athenz-zms-X.Y $ vi conf/zms_server/zms.properties Modify the athenz.zms.domain_admin=user.admin line and include comma separated list of unix user ids that should be set as Athenz system administrators. e.g. athenz.zms.domain_admin=user.joe,user.john","title":"System Administrators"},{"location":"setup_zms_prod/#startstop-zms-server","text":"Start the ZMS Server by executing: $ cd athenz-zms-X.Y $ bin/zms start If using the Unix Authority to authenticate users against their unix password, make sure the user that the ZMS Server process is running as has read access to the /etc/shadow file. For full details, please check out the User Authentication section above. Based on the sample configuration file provided, ZMS Server will be listening on port 4443. Stop the ZMS Server by executing: $ cd athenz-zms-X.Y $ bin/zms stop","title":"Start/Stop ZMS Server"},{"location":"setup_zpu/","text":"Setup ZPU (ZPE Policy Updater) \u00b6 ZPU is only needed to support decentralized authorization. The policy updater is the utility that retrieves from ZTS the policy files for provisioned domains on a host, which ZPE uses to evaluate access requests. Requirements JDK 8 Getting Software Configuration Domain Setting Generate Athenz Configuration File ZTS Certificate TrustStore ZPE Policy Directory Run ZPU Utility Periodic Update Policy File Details Requirements \u00b6 The following tools are required to be installed on hosts configured to run ZPE Policy Updater. JDK 8 \u00b6 ZPU Utility is a java application. Oracle Java Platform JDK 8 While ZPU has been developed and tested with Oracle Java Platform JDK 8 it should run successfully with OpenJDK 8 as well. Getting Software \u00b6 Download latest ZPU binary release from Bintray - click on the Files tab, choose the latest version directory and then download the athenz-zpu-<latest-version>-bin.tar.gz file:: $ tar xvfz athenz-zpu-X.Y-bin.tar.gz $ cd athenz-zpu-X.Y Configuration \u00b6 To successfully run ZPU, the domain administrator must update a couple of settings files and generate a java truststore the utility. Domain Setting \u00b6 Before running ZPU utility, the system administrator must configure what domains are provisioned on the host so the utility can retrieve the policy files for those domains only. $ cd athenz-zpu-X.Y $ vi conf/zpe_policy_updater/zpu.conf In the json file, edit the value for the \"domains\" field and specify a comma separated list of domain names. ZTS Certificate TrustStore \u00b6 ZPU needs to access ZTS Server to download all domain policies in order to execute authorization checks. Since ZTS Server is running with a self-signed certificate, we need to generate a truststore for the java http client to use when communicating with the ZTS Server. From your ZTS Server installation, copy the zts_cert.pem file from the athenz-zts-X.Y/var/zts_server/certs directory to the athenz-zpu-X.Y/var/zpe_policy_updater/certs directory and execute the following command: $ cd athenz-zpu-X.Y/var/zpe_policy_updater/certs $ keytool -importcert -noprompt -alias zts -keystore zpu_truststore.jks -file zts_cert.pem -storepass athenz Generate Athenz Configuration File \u00b6 Generate an Athenz configuration file athenz.conf in athenz-zpu-X.Y/conf/zpe_policy_updater directory to include the ZTS Server URL and the registered public keys that the athenz client libraries and utilities will use to establish connection and validate any data signed by the ZMS and ZTS Servers. To communicate with ZMS over SSL, the utility needs to have access to the ZMS Server's public certificate so you need to copy the zms_cert.pem file from the athenz-zms-X.Y/var/zms_server/certs directory to the athenz-zpu-X.Y/var/zpe_policy_updater/certs directory $ cd athenz-zpu-X.Y $ bin/<platform>/athenz-conf -o conf/zpe_policy_updater/athenz.conf -c var/zpe_policy_updater/certs/zms_cert.pem -z https://<zms-server>:4443/ -t https://<zts-server>:8443/ ZPE Policy Directory \u00b6 By default ZPU will save any downloaded policy files in the ${ROOT}/var/zpe directory. You need to make sure this is the directory where ZPE is configured to look for policy files. To change this directory, please update the UTILITY_POLICY_FILE_DIR setting in the conf/zpe_policy_updater/utility_settings file. Run ZPU Utility \u00b6 Set the required Athenz ROOT environment variable to the athenz-zpu-X.Y directory and from there start the ZPU utility by executing: $ export ROOT = <full-path-to-athenz-zpu-X.Y> $ bin/zpu_run.sh Periodic Update \u00b6 The ZPU utility needs to run periodically so it can automatically download any modified policy files for the configured list of domains. The system administrator should setup this utility to be automatically executed by cron utility at least once every couple of hours. Policy File Details \u00b6 Checkout the ZPU Policy File for details how to manually validate the signatures in the policy file. This would be necessary if you'll be writing your own authorization policy engine library instead of using the Athenz provided one.","title":"ZPU Utility"},{"location":"setup_zpu/#setup-zpu-zpe-policy-updater","text":"ZPU is only needed to support decentralized authorization. The policy updater is the utility that retrieves from ZTS the policy files for provisioned domains on a host, which ZPE uses to evaluate access requests. Requirements JDK 8 Getting Software Configuration Domain Setting Generate Athenz Configuration File ZTS Certificate TrustStore ZPE Policy Directory Run ZPU Utility Periodic Update Policy File Details","title":"Setup ZPU (ZPE Policy Updater)"},{"location":"setup_zpu/#requirements","text":"The following tools are required to be installed on hosts configured to run ZPE Policy Updater.","title":"Requirements"},{"location":"setup_zpu/#jdk-8","text":"ZPU Utility is a java application. Oracle Java Platform JDK 8 While ZPU has been developed and tested with Oracle Java Platform JDK 8 it should run successfully with OpenJDK 8 as well.","title":"JDK 8"},{"location":"setup_zpu/#getting-software","text":"Download latest ZPU binary release from Bintray - click on the Files tab, choose the latest version directory and then download the athenz-zpu-<latest-version>-bin.tar.gz file:: $ tar xvfz athenz-zpu-X.Y-bin.tar.gz $ cd athenz-zpu-X.Y","title":"Getting Software"},{"location":"setup_zpu/#configuration","text":"To successfully run ZPU, the domain administrator must update a couple of settings files and generate a java truststore the utility.","title":"Configuration"},{"location":"setup_zpu/#domain-setting","text":"Before running ZPU utility, the system administrator must configure what domains are provisioned on the host so the utility can retrieve the policy files for those domains only. $ cd athenz-zpu-X.Y $ vi conf/zpe_policy_updater/zpu.conf In the json file, edit the value for the \"domains\" field and specify a comma separated list of domain names.","title":"Domain Setting"},{"location":"setup_zpu/#zts-certificate-truststore","text":"ZPU needs to access ZTS Server to download all domain policies in order to execute authorization checks. Since ZTS Server is running with a self-signed certificate, we need to generate a truststore for the java http client to use when communicating with the ZTS Server. From your ZTS Server installation, copy the zts_cert.pem file from the athenz-zts-X.Y/var/zts_server/certs directory to the athenz-zpu-X.Y/var/zpe_policy_updater/certs directory and execute the following command: $ cd athenz-zpu-X.Y/var/zpe_policy_updater/certs $ keytool -importcert -noprompt -alias zts -keystore zpu_truststore.jks -file zts_cert.pem -storepass athenz","title":"ZTS Certificate TrustStore"},{"location":"setup_zpu/#generate-athenz-configuration-file","text":"Generate an Athenz configuration file athenz.conf in athenz-zpu-X.Y/conf/zpe_policy_updater directory to include the ZTS Server URL and the registered public keys that the athenz client libraries and utilities will use to establish connection and validate any data signed by the ZMS and ZTS Servers. To communicate with ZMS over SSL, the utility needs to have access to the ZMS Server's public certificate so you need to copy the zms_cert.pem file from the athenz-zms-X.Y/var/zms_server/certs directory to the athenz-zpu-X.Y/var/zpe_policy_updater/certs directory $ cd athenz-zpu-X.Y $ bin/<platform>/athenz-conf -o conf/zpe_policy_updater/athenz.conf -c var/zpe_policy_updater/certs/zms_cert.pem -z https://<zms-server>:4443/ -t https://<zts-server>:8443/","title":"Generate Athenz Configuration File"},{"location":"setup_zpu/#zpe-policy-directory","text":"By default ZPU will save any downloaded policy files in the ${ROOT}/var/zpe directory. You need to make sure this is the directory where ZPE is configured to look for policy files. To change this directory, please update the UTILITY_POLICY_FILE_DIR setting in the conf/zpe_policy_updater/utility_settings file.","title":"ZPE Policy Directory"},{"location":"setup_zpu/#run-zpu-utility","text":"Set the required Athenz ROOT environment variable to the athenz-zpu-X.Y directory and from there start the ZPU utility by executing: $ export ROOT = <full-path-to-athenz-zpu-X.Y> $ bin/zpu_run.sh","title":"Run ZPU Utility"},{"location":"setup_zpu/#periodic-update","text":"The ZPU utility needs to run periodically so it can automatically download any modified policy files for the configured list of domains. The system administrator should setup this utility to be automatically executed by cron utility at least once every couple of hours.","title":"Periodic Update"},{"location":"setup_zpu/#policy-file-details","text":"Checkout the ZPU Policy File for details how to manually validate the signatures in the policy file. This would be necessary if you'll be writing your own authorization policy engine library instead of using the Athenz provided one.","title":"Policy File Details"},{"location":"setup_zts/","text":"Setup ZTS (authoriZation Token System) \u00b6 Requirements JDK 8 Getting Software Configuration Athenz CA X.509 Certificate Issuing Start/Stop ZTS Server Requirements \u00b6 The following tools are required to be installed on hosts configured to run ZTS server. JDK 8 \u00b6 ZTS Server is written in Java and using embedded Jetty. Oracle Java Platform JDK 8 While ZTS has been developed and tested with Oracle Java Platform JDK 8 it should run successfully with OpenJDK 8 as well. Getting Software \u00b6 Download latest ZTS binary release from Bintray - click on the Files tab, choose the latest version directory and then download the athenz-zts-<latest-version>-bin.tar.gz file:: $ tar xvfz athenz-zts-X.Y-bin.tar.gz $ cd athenz-zts-X.Y Configuration \u00b6 To run ZTS Server, the system administrator must generate the keys, certificates and make necessary changes to the configuration settings. Since ZMS Server is running with a self-signed certificate, we need to generate a truststore for the java http client to use when communicating with the ZMS Server. For our configuration script we need the ZMS server hostname and a copy of the server certificate file. From your ZMS Server installation, copy the zms_cert.pem file from the athenz-zms-X.Y/var/zms_server/certs directory to a local directory on the host that will be running the ZTS Server. For the zms-public-cert-path argument below pass the full path of the zms_cert.pem. $ cd athenz-zts-X.Y $ bin/setup_dev_zts.sh <zms-hostname> <zms-public-cert-path> Running this setup script completes the following tasks: Generate a unique private key that ZTS Server will use to sign any ZTokens it issues Generate a self-signed X509 certificate for ZTS Server HTTPS support Generate a truststore for secure communication with the ZMS Server Registers the zts service in Athenz sys.auth domain Generates an Athenz configuration file Athenz CA X.509 Certificate Issuing \u00b6 For authenticating services using X509 certificates, ZTS Servers expect the configured cert signer factory class names in its athenz.zts.cert_signer_factory_class system property. Self Cert Signer com.yahoo.athenz.zts.cert.impl.SelfCertSignerFactory is a sample implementation of cert Signer we have for development environment. You can use SelfCertSigner or have your implementation of Cert Signer. Refer Certificate Signer for full details how to implement your cert signer. Start/Stop ZTS Server \u00b6 Start the ZTS Server by executing: $ cd athenz-zts-X.Y $ bin/zts start Based on the sample configuration file provided, ZTS Server will be listening on port 8443. Stop the ZTS Server by executing: $ cd athenz-zts-X.Y $ bin/zts stop","title":"ZTS Server"},{"location":"setup_zts/#setup-zts-authorization-token-system","text":"Requirements JDK 8 Getting Software Configuration Athenz CA X.509 Certificate Issuing Start/Stop ZTS Server","title":"Setup ZTS (authoriZation Token System)"},{"location":"setup_zts/#requirements","text":"The following tools are required to be installed on hosts configured to run ZTS server.","title":"Requirements"},{"location":"setup_zts/#jdk-8","text":"ZTS Server is written in Java and using embedded Jetty. Oracle Java Platform JDK 8 While ZTS has been developed and tested with Oracle Java Platform JDK 8 it should run successfully with OpenJDK 8 as well.","title":"JDK 8"},{"location":"setup_zts/#getting-software","text":"Download latest ZTS binary release from Bintray - click on the Files tab, choose the latest version directory and then download the athenz-zts-<latest-version>-bin.tar.gz file:: $ tar xvfz athenz-zts-X.Y-bin.tar.gz $ cd athenz-zts-X.Y","title":"Getting Software"},{"location":"setup_zts/#configuration","text":"To run ZTS Server, the system administrator must generate the keys, certificates and make necessary changes to the configuration settings. Since ZMS Server is running with a self-signed certificate, we need to generate a truststore for the java http client to use when communicating with the ZMS Server. For our configuration script we need the ZMS server hostname and a copy of the server certificate file. From your ZMS Server installation, copy the zms_cert.pem file from the athenz-zms-X.Y/var/zms_server/certs directory to a local directory on the host that will be running the ZTS Server. For the zms-public-cert-path argument below pass the full path of the zms_cert.pem. $ cd athenz-zts-X.Y $ bin/setup_dev_zts.sh <zms-hostname> <zms-public-cert-path> Running this setup script completes the following tasks: Generate a unique private key that ZTS Server will use to sign any ZTokens it issues Generate a self-signed X509 certificate for ZTS Server HTTPS support Generate a truststore for secure communication with the ZMS Server Registers the zts service in Athenz sys.auth domain Generates an Athenz configuration file","title":"Configuration"},{"location":"setup_zts/#athenz-ca-x509-certificate-issuing","text":"For authenticating services using X509 certificates, ZTS Servers expect the configured cert signer factory class names in its athenz.zts.cert_signer_factory_class system property. Self Cert Signer com.yahoo.athenz.zts.cert.impl.SelfCertSignerFactory is a sample implementation of cert Signer we have for development environment. You can use SelfCertSigner or have your implementation of Cert Signer. Refer Certificate Signer for full details how to implement your cert signer.","title":"Athenz CA X.509 Certificate Issuing"},{"location":"setup_zts/#startstop-zts-server","text":"Start the ZTS Server by executing: $ cd athenz-zts-X.Y $ bin/zts start Based on the sample configuration file provided, ZTS Server will be listening on port 8443. Stop the ZTS Server by executing: $ cd athenz-zts-X.Y $ bin/zts stop","title":"Start/Stop ZTS Server"},{"location":"setup_zts_prod/","text":"Setup ZTS (authoriZation Token System) for Production \u00b6 Requirements JDK 8 Getting Software Configuration Private/Public Key Pair Server X509 Certificate Register ZTS Service Generate Athenz Configuration File Athenz CA X.509 Certificate Issuing Start/Stop ZTS Server Requirements \u00b6 The following tools are required to be installed on hosts configured to run ZTS server. JDK 8 \u00b6 ZTS Server is written in Java and using embedded Jetty. Oracle Java Platform JDK 8 While ZTS has been developed and tested with Oracle Java Platform JDK 8 it should run successfully with OpenJDK 8 as well. Getting Software \u00b6 Download latest ZTS binary release from https://bintray.com/yahoo/maven/athenz-zts/_latestVersion#files $ tar xvfz athenz-zts-X.Y-bin.tar.gz $ cd athenz-zts-X.Y Configuration \u00b6 To run ZTS Server, the system administrator must generate the keys and make necessary changes to the configuration settings. Private/Public Key Pair \u00b6 Generate a unique private/public key pair that ZTS Server will use to sign any ZTokens it issues. From the athenz-zts-X.Y directory execute the following commands: $ cd var/zts_server/keys $ openssl genrsa -out zts_private.pem 2048 $ openssl rsa -in zts_private.pem -pubout > zts_public.pem Server X509 Certificate \u00b6 While it is still possible to generate and use a self-signed X509 certificate for ZTS Servers, it is recommended to purchase one for your production server from a well known certificate authority. Having such a certificate installed on your ZTS Servers will no longer require to distribute the server's public certificate to other hosts (e.g. Hosts running ZPU). Follow the instructions provided by the Certificate Authority to generate your private key and then the Certificate Request (CSR). Once you have received your X509 certificate, we just need to add that certificate along with its private key to a keystore for Jetty use. From the athenz-zts-X.Y directory execute the following command: $ openssl pkcs12 -export -out zts_keystore.pkcs12 -in zts_cert.pem -inkey zts_key.pem Register ZTS Service \u00b6 In order for ZTS to access ZMS domain data, it must identify itself as a registered service in ZMS. Using the zms-cli utility, we will register a new service in sys.auth domain. Since ZMS Servers should be running with a X509 certificate from a well know certificate authority (not a self-signed one) we don't need to reference the CA cert like we did for the local/development environment setup. $ cd athenz-zts-X.Y $ bin/<platform>/zms-cli -z https://<zms-server>:4443/zms/v1 -d sys.auth add-service zts 0 var/zts_server/keys zts_public.pem Athenz CA X.509 Certificate Issuing \u00b6 For authenticating services using X509 certificates, ZTS Servers expect the configured cert signer factory class names in its athenz.zts.cert_signer_factory_class system property. We already have below implementation of cert Signer: Self Cert Signer com.yahoo.athenz.zts.cert.impl.SelfCertSignerFactory for the dev environment. Http Cert Signer com.yahoo.athenz.zts.cert.impl.HttpCertSignerFactory for the production environment. You can use HttpCert Signer or have your implementation of Cert Signer. Refer Certificate Signer for full details how to implement your own certificate signer. Generate Athenz Configuration File \u00b6 Generate an Athenz configuration file athenz.conf in athenz-zts-X.Y/conf/zts_server directory to include the ZMS Server URL and the registered public keys that the athenz client libraries and utilities will use to establish connection and validate any data signed by the ZMS Server: $ cd athenz-zts-X.Y $ bin/<platform>/athenz-conf -o conf/zts_server/athenz.conf -z https://<zms-server>:4443/ -t https://<zts-server>:8443/ Start/Stop ZTS Server \u00b6 Start the ZTS Server by executing: $ cd athenz-zts-X.Y $ bin/zts start Based on the sample configuration file provided, ZTS Server will be listening on port 8443. Stop the ZTS Server by executing: $ cd athenz-zts-X.Y $ bin/zts stop","title":"ZTS Server"},{"location":"setup_zts_prod/#setup-zts-authorization-token-system-for-production","text":"Requirements JDK 8 Getting Software Configuration Private/Public Key Pair Server X509 Certificate Register ZTS Service Generate Athenz Configuration File Athenz CA X.509 Certificate Issuing Start/Stop ZTS Server","title":"Setup ZTS (authoriZation Token System) for Production"},{"location":"setup_zts_prod/#requirements","text":"The following tools are required to be installed on hosts configured to run ZTS server.","title":"Requirements"},{"location":"setup_zts_prod/#jdk-8","text":"ZTS Server is written in Java and using embedded Jetty. Oracle Java Platform JDK 8 While ZTS has been developed and tested with Oracle Java Platform JDK 8 it should run successfully with OpenJDK 8 as well.","title":"JDK 8"},{"location":"setup_zts_prod/#getting-software","text":"Download latest ZTS binary release from https://bintray.com/yahoo/maven/athenz-zts/_latestVersion#files $ tar xvfz athenz-zts-X.Y-bin.tar.gz $ cd athenz-zts-X.Y","title":"Getting Software"},{"location":"setup_zts_prod/#configuration","text":"To run ZTS Server, the system administrator must generate the keys and make necessary changes to the configuration settings.","title":"Configuration"},{"location":"setup_zts_prod/#privatepublic-key-pair","text":"Generate a unique private/public key pair that ZTS Server will use to sign any ZTokens it issues. From the athenz-zts-X.Y directory execute the following commands: $ cd var/zts_server/keys $ openssl genrsa -out zts_private.pem 2048 $ openssl rsa -in zts_private.pem -pubout > zts_public.pem","title":"Private/Public Key Pair"},{"location":"setup_zts_prod/#server-x509-certificate","text":"While it is still possible to generate and use a self-signed X509 certificate for ZTS Servers, it is recommended to purchase one for your production server from a well known certificate authority. Having such a certificate installed on your ZTS Servers will no longer require to distribute the server's public certificate to other hosts (e.g. Hosts running ZPU). Follow the instructions provided by the Certificate Authority to generate your private key and then the Certificate Request (CSR). Once you have received your X509 certificate, we just need to add that certificate along with its private key to a keystore for Jetty use. From the athenz-zts-X.Y directory execute the following command: $ openssl pkcs12 -export -out zts_keystore.pkcs12 -in zts_cert.pem -inkey zts_key.pem","title":"Server X509 Certificate"},{"location":"setup_zts_prod/#register-zts-service","text":"In order for ZTS to access ZMS domain data, it must identify itself as a registered service in ZMS. Using the zms-cli utility, we will register a new service in sys.auth domain. Since ZMS Servers should be running with a X509 certificate from a well know certificate authority (not a self-signed one) we don't need to reference the CA cert like we did for the local/development environment setup. $ cd athenz-zts-X.Y $ bin/<platform>/zms-cli -z https://<zms-server>:4443/zms/v1 -d sys.auth add-service zts 0 var/zts_server/keys zts_public.pem","title":"Register ZTS Service"},{"location":"setup_zts_prod/#athenz-ca-x509-certificate-issuing","text":"For authenticating services using X509 certificates, ZTS Servers expect the configured cert signer factory class names in its athenz.zts.cert_signer_factory_class system property. We already have below implementation of cert Signer: Self Cert Signer com.yahoo.athenz.zts.cert.impl.SelfCertSignerFactory for the dev environment. Http Cert Signer com.yahoo.athenz.zts.cert.impl.HttpCertSignerFactory for the production environment. You can use HttpCert Signer or have your implementation of Cert Signer. Refer Certificate Signer for full details how to implement your own certificate signer.","title":"Athenz CA X.509 Certificate Issuing"},{"location":"setup_zts_prod/#generate-athenz-configuration-file","text":"Generate an Athenz configuration file athenz.conf in athenz-zts-X.Y/conf/zts_server directory to include the ZMS Server URL and the registered public keys that the athenz client libraries and utilities will use to establish connection and validate any data signed by the ZMS Server: $ cd athenz-zts-X.Y $ bin/<platform>/athenz-conf -o conf/zts_server/athenz.conf -z https://<zms-server>:4443/ -t https://<zts-server>:8443/","title":"Generate Athenz Configuration File"},{"location":"setup_zts_prod/#startstop-zts-server","text":"Start the ZTS Server by executing: $ cd athenz-zts-X.Y $ bin/zts start Based on the sample configuration file provided, ZTS Server will be listening on port 8443. Stop the ZTS Server by executing: $ cd athenz-zts-X.Y $ bin/zts stop","title":"Start/Stop ZTS Server"},{"location":"system_view/","text":"Architecture - System View \u00b6 System Diagram ZMS ZTS SIA ZPE ZPU System Diagram \u00b6 Before we go into the details of the authorization flow, it's important to understand the subsystems involved. The authorization (AuthZ) system shown in the figure below consists of several logical subsystems, which we will elaborate on in the following section. ZMS (authZ Management System) \u00b6 ZMS is the source of truth for domains, roles, and policies for centralized authorization. In addition to allowing CRUD operations on the basic entities, ZMS provides an API to replicate the entities, per domain, to ZTS. ZMS supports a centralized call to check if a principal has access to a resource both for internal management system checks, as well as a simple centralized deployment. Because ZMS supports service identities, ZMS can authenticate services. For centralized authorization, ZMS may be the only Athenz subsystem that you need to interact with. ZTS (authZ Token System) \u00b6 ZTS, the authentication token service, is only needed to support decentralized or data plane functionality. In many ways, ZTS is like a local replica of ZMS's data to check a principal's authentication and confirm membership in roles within a domain. The authentication is in the form of a signed ZToken that can be presented to any decentralized service that wants to authorize access efficiently. Multiple ZTS instances can be distributed to different locations as needed to scale for issuing tokens. SIA (Service Identity Agent) Provider \u00b6 SIA (Service Identity Agent) Provider is part of the container, although likely built with Athenz libraries. As services are authenticated by their private keys, the job of the SIA Provider is to generate a X509 certificate and sign it with the given private key so that the service can present that certificate to ZMS/ZTS as its identity credentials. The corresponding public key must be registered in ZMS so Athenz services can validate the signature. ZPE (AuthZ Policy Engine) \u00b6 Like ZTS, ZPE, the authorization policy engine is only needed to support decentralized authorization. ZPE is the subsystem of Athenz that evaluates policies for a set of roles to yield an allowed or a denied response. ZPE is a library that your service calls and only refers to a local policy cache for your services domain (a small amount of data). ZPU (AuthZ PolicyEngine Updater) \u00b6 Like ZTS and ZPE, ZPU is only needed to support decentralized authorization. The policy updater is the utility that retrieves from ZTS the policy files for provisioned domains on a host, which ZPE uses to evaluate access requests.","title":"System View"},{"location":"system_view/#architecture-system-view","text":"System Diagram ZMS ZTS SIA ZPE ZPU","title":"Architecture - System View"},{"location":"system_view/#system-diagram","text":"Before we go into the details of the authorization flow, it's important to understand the subsystems involved. The authorization (AuthZ) system shown in the figure below consists of several logical subsystems, which we will elaborate on in the following section.","title":"System Diagram"},{"location":"system_view/#zms-authz-management-system","text":"ZMS is the source of truth for domains, roles, and policies for centralized authorization. In addition to allowing CRUD operations on the basic entities, ZMS provides an API to replicate the entities, per domain, to ZTS. ZMS supports a centralized call to check if a principal has access to a resource both for internal management system checks, as well as a simple centralized deployment. Because ZMS supports service identities, ZMS can authenticate services. For centralized authorization, ZMS may be the only Athenz subsystem that you need to interact with.","title":"ZMS (authZ Management System)"},{"location":"system_view/#zts-authz-token-system","text":"ZTS, the authentication token service, is only needed to support decentralized or data plane functionality. In many ways, ZTS is like a local replica of ZMS's data to check a principal's authentication and confirm membership in roles within a domain. The authentication is in the form of a signed ZToken that can be presented to any decentralized service that wants to authorize access efficiently. Multiple ZTS instances can be distributed to different locations as needed to scale for issuing tokens.","title":"ZTS (authZ Token System)"},{"location":"system_view/#sia-service-identity-agent-provider","text":"SIA (Service Identity Agent) Provider is part of the container, although likely built with Athenz libraries. As services are authenticated by their private keys, the job of the SIA Provider is to generate a X509 certificate and sign it with the given private key so that the service can present that certificate to ZMS/ZTS as its identity credentials. The corresponding public key must be registered in ZMS so Athenz services can validate the signature.","title":"SIA (Service Identity Agent) Provider"},{"location":"system_view/#zpe-authz-policy-engine","text":"Like ZTS, ZPE, the authorization policy engine is only needed to support decentralized authorization. ZPE is the subsystem of Athenz that evaluates policies for a set of roles to yield an allowed or a denied response. ZPE is a library that your service calls and only refers to a local policy cache for your services domain (a small amount of data).","title":"ZPE (AuthZ Policy Engine)"},{"location":"system_view/#zpu-authz-policyengine-updater","text":"Like ZTS and ZPE, ZPU is only needed to support decentralized authorization. The policy updater is the utility that retrieves from ZTS the policy files for provisioned domains on a host, which ZPE uses to evaluate access requests.","title":"ZPU (AuthZ PolicyEngine Updater)"},{"location":"token_expiration/","text":"By default, Athenz ZTS server allows principals to request access tokens with a maximum expiry of 30 days. However, the domain administrator has the capability to specify a maximum expiry limit for a given role or the full domain. This allows the domain administrators to control access to specific roles (or domains) such that the principals do not request tokens that are valid for up-to 30 days but instead are valid only for the configured number of minutes. Role Level Token Expiry Support \u00b6 The domain administrator may specify maximum token expiry setting in minutes for a specific role: zms-cli -d <domain-name> set-role-token-expiry-mins <role-name> <max-expiry-mins> If the domain administrator has specified a max token expiry mins of 30 to db.writers role, then ZTS will only issue access tokens with a maximum expiry of 30 mins even if the principal is requesting a longer one. If the principal is requesting a token with a smaller expiry that 30 mins, for example 15 mins, then it will be honored and the token will be issued for 15 mins. If the principal is requesting a token for multiple roles, then ZTS will lookup the max expiry setting for all the roles and issue a token with the smallest configured value. If none of the roles have a max token expiry setting configured, then ZTS will lookup to see if there is a max token expiry setting specified for the domain and use that if it's smaller than the requested token expiry value. If the domain administrator specifies a token expiry at both role and domain levels, then the role level always overrides the domain setting for the role - regardless if it's shorter or longer than the domain configured value. You can look at the currently configured value for a specific role using zms-cli -d <domain-name> show-role <role-name> command. To reset the configured limit back to its default behavior, set the limit to 0: zms-cli -d <domain-name> set-role-token-expiry-mins <role-name> 0 Domain Level Token Expiry Support \u00b6 The domain administrator may specify maximum token expiry setting in minutes for the full domain: zms-cli -d <domain-name> set-domain-token-expiry-mins <max-expiry-mins> If the domain administrator has specified a max token expiry mins of 90 to sales domain, then ZTS will only issue access tokens with a maximum expiry of 90 mins even if the principal is requesting a longer one. The exception to this rule is if the domain administrator has also specified a value for one of the roles requested in the token. If the domain administrator specifies a token expiry at both role and domain levels, then the role level always overrides the domain setting for the role - regardless if it's shorter or longer than the domain configured value. If the principal is requesting a token with a smaller expiry that 90 mins configured for the domain, for example 60 mins, and there are no per-role token expiry settings configured, then it will be honored and the token will be issued for 60 mins. You can look at the currently configured value for a specific domain using zms-cli -d <domain-name> show-domain command. To reset the configured limit back to its default behavior, set the limit to 0: zms-cli -d <domain-name> set-domain-token-expiry-mins 0","title":"Access token Limit Expiry Support"},{"location":"token_expiration/#role-level-token-expiry-support","text":"The domain administrator may specify maximum token expiry setting in minutes for a specific role: zms-cli -d <domain-name> set-role-token-expiry-mins <role-name> <max-expiry-mins> If the domain administrator has specified a max token expiry mins of 30 to db.writers role, then ZTS will only issue access tokens with a maximum expiry of 30 mins even if the principal is requesting a longer one. If the principal is requesting a token with a smaller expiry that 30 mins, for example 15 mins, then it will be honored and the token will be issued for 15 mins. If the principal is requesting a token for multiple roles, then ZTS will lookup the max expiry setting for all the roles and issue a token with the smallest configured value. If none of the roles have a max token expiry setting configured, then ZTS will lookup to see if there is a max token expiry setting specified for the domain and use that if it's smaller than the requested token expiry value. If the domain administrator specifies a token expiry at both role and domain levels, then the role level always overrides the domain setting for the role - regardless if it's shorter or longer than the domain configured value. You can look at the currently configured value for a specific role using zms-cli -d <domain-name> show-role <role-name> command. To reset the configured limit back to its default behavior, set the limit to 0: zms-cli -d <domain-name> set-role-token-expiry-mins <role-name> 0","title":"Role Level Token Expiry Support"},{"location":"token_expiration/#domain-level-token-expiry-support","text":"The domain administrator may specify maximum token expiry setting in minutes for the full domain: zms-cli -d <domain-name> set-domain-token-expiry-mins <max-expiry-mins> If the domain administrator has specified a max token expiry mins of 90 to sales domain, then ZTS will only issue access tokens with a maximum expiry of 90 mins even if the principal is requesting a longer one. The exception to this rule is if the domain administrator has also specified a value for one of the roles requested in the token. If the domain administrator specifies a token expiry at both role and domain levels, then the role level always overrides the domain setting for the role - regardless if it's shorter or longer than the domain configured value. If the principal is requesting a token with a smaller expiry that 90 mins configured for the domain, for example 60 mins, and there are no per-role token expiry settings configured, then it will be honored and the token will be issued for 60 mins. You can look at the currently configured value for a specific domain using zms-cli -d <domain-name> show-domain command. To reset the configured limit back to its default behavior, set the limit to 0: zms-cli -d <domain-name> set-domain-token-expiry-mins 0","title":"Domain Level Token Expiry Support"},{"location":"zms_api/","text":"ZMS API \u00b6 Introduction \u00b6 The Authorization Management Service (ZMS) API This API has the following attributes: Attribute Value namespace com.yahoo.auth.zms version 1 Authentication \u00b6 X.509 Certificate Support \u00b6 All ZMS API commands require that the client use a TLS certificate issued by Athenz. Services can use their Athenz Issued Service Identity certificates when communicating with ZMS. Authorization \u00b6 Every write request against ZMS server is authorized against the configured policy data to verify that the principal has been given the rights to make the requested change. Each request description below gives the authorization command that includes the action and resource that the ZMS Server will run the authorization check against. For example, the create subdomain command has the following authorize statement: authorize (\"create\", \"{parent}:domain\"); This indicates that the principal requesting to create subdomain called athens.ci must have grant rights to action \"create\" for resource called \"domain\" in domain \"athens\". Types \u00b6 Access \u00b6 Access can be checked and returned as this resource. Access is a Struct type with the following fields: Name Type Options Description Notes granted Bool ActionName \u00b6 An action (operation) name. ActionName is a String type with the following options: Option Value Notes pattern {CompoundName} Assertion \u00b6 A representation for the encapsulation of an action to be performed on a resource by a principal. Assertion is a Struct type with the following fields: Name Type Options Description Notes role String the subject of the assertion, a role resource String the object of the assertion. Must be in the local namespace. Can contain wildcard action String the predicate of the assertion. Can contain wildcard effect AssertionEffect optional, default-ALLOW the effect of the assertion in the policy language id Int64 optional The server assigned id for the assertion AssertionEffect \u00b6 Every assertion can have the effect of ALLOW or DENY. AssertionEffect is an Enum of the following values: Value Description ALLOW DENY AuthorityName \u00b6 Used as the prefix in a signed assertion. This uniquely identifies a signing authority. i.e. user AuthorityName is a String type with the following options: Option Value Notes pattern {CompoundName} CompoundName \u00b6 A compound name. Most names in this API are compound names. CompoundName is a String type with the following options: Option Value Notes pattern ({SimpleName} .) {SimpleName}* DefaultAdmins \u00b6 DefaultAdmins is a Struct type with the following fields: Name Type Options Description Notes admins Array<ResourceName> Domain \u00b6 A domain is an independent partition of users, roles, and resources. It's name represents the definition of a namespace; the only way a new namespace can be created, from the top, is by creating Domains. Administration of a domain is governed by the parent domain (using reverse-DNS namespaces). The top level domains are governed by the special sys.auth domain. Domain is a Struct type with the following fields: Name Type Options Description Notes name DomainName immutable. This is the common name to be referred to, the symbolic id. modified Timestamp optional id UUID optional generated on create, never reused description String optional org ResourceName optional a reference to an Organization. Auth doesn't use it, but it provides external hook (i.e. org:media) enabled Bool optional, default-true DomainData \u00b6 DomainData is a Struct type with the following fields: Name Type Options Description Notes name DomainName enabled Bool account String AWS account id ypmid Int32 OPM product id roles Array<Role role>> policies Array<Policy> serviceIds Array<ServiceIdentity> modified Timestamp DomainList \u00b6 A paginated list of domains. DomainList is a Struct type with the following fields: Name Type Options Description Notes names Array<DomainName> next String optional DomainMeta \u00b6 All domains have metadata that can be changed. DomainMeta is a Struct type with the following fields: Name Type Options Description Notes description String optional a description of the domain org ResourceName optional a reference to an Organization. Auth doesn't use it, but it provides external hook (i.e. org:media) enabled Bool optional, default-true DomainName \u00b6 A domain name is the general qualifier prefix, as its uniqueness is managed. DomainName is a String type with the following options: Option Value Notes pattern {CompoundName} DomainPolicies \u00b6 DomainPolicies is a Struct type with the following fields: Name Type Options Description Notes domain DomainName policies Array<Policy> modified Timestamp when the domain itself was last modified expires Timestamp how long this snapshot can be used DomainTemplateList \u00b6 List of solution templates to be applied to a domain DomainTemplateList is a Struct type with the following fields: Name Type Options Description Notes templateNames Array<SimpleName> Entity \u00b6 An entity is a name and a structured value some entity names/prefixes are reserved (i.e., role , policy , meta , domain ) Entity is a Struct type with the following fields: Name Type Options Description Notes name EntityName value Struct EntityName \u00b6 An entity name is a short form of a resource name, including only the domain and entity. EntityName is a String type with the following options: Option Value Notes pattern {CompoundName} LocationName \u00b6 A location name is not yet defined, but will be a dotted name like everything else. LocationName is a String type with the following options: Option Value Notes pattern {CompoundName} Membership \u00b6 Membership is a Struct type with the following fields: Name Type Options Description Notes memberName ResourceName isMember Bool optional, default-true roleName ResourceName optional Policies \u00b6 Policiies is a Struct type with the following fields: Name Type Options Description Notes list Array<Policy> Policy \u00b6 The representation for a named set of assertions, given a name and a version number that increments. Policy is a Struct type with the following fields: Name Type Options Description Notes name ResourceName modified Timestamp optional assertions Array<Assertion> PolicyList \u00b6 The representation for an enumeration of policies in the namespace, with pagination PolicyList is a Struct type with the following fields: Name Type Options Description Notes names Array<EntityName> next String optional PublicKeyEntry \u00b6 PublicKeyEntry is a Struct type with the following fields: Name Type Options Description Notes key String the public key for the service id String used to specify the id/version of the key (for GET operation only) ResourceName \u00b6 A shorthand for a YRN with no service or location. The 'tail' of a YRN, just the domain:entity. Note that the EntityName part is optional, that is, a domain name followed by a colon is valid resource name. ResourceName is a String type with the following options: Option Value Notes pattern {DomainName}(:{EntityName})? Role \u00b6 Role is a Struct type with the following fields: Name Type Options Description Notes name ResourceName modified Timestamp optional members Array<ResourceName> optional an explicit list of members. Might be empty or null, if trust is set. trust DomainName optional a trusted domain to delegate membership decisions to. auditLog Array<RoleAuditLog> optional an explicit list of audit log entries if requested. RoleAuditLog \u00b6 RoleAuditLog is a Struct type with the following fields: Name Type Options Description Notes member ResourceName admin ResourceName created Timestamp action String ADD or DELETE auditRef String optional RoleList \u00b6 RoleList is a Struct type with the following fields: Name Type Options Description Notes names Array<EntityName> next String optional Roles \u00b6 Roles is a Struct type with the following fields: Name Type Options Description Notes list Array<Role> ServerTemplateList \u00b6 List of solution templates available in the server ServerTemplateList is a Struct type with the following fields: Name Type Options Description Notes templateNames Array<SimpleName> ServiceIdentities \u00b6 ServiceIdentities is a Struct type with the following fields: Name Type Options Description Notes list Array<ServiceIdentity> ServiceName \u00b6 A service name will generally be a unique subdomain ServiceName is a String type with the following options: Option Value Notes pattern {CompoundName} ServiceIdentity \u00b6 ServiceIdentity is a Struct type with the following fields: Name Type Options Description Notes name ServiceName the full name, i.e. vespa.storage publicKey String optional the public key for the service publicKeys Array<PublicKeyEntry> optional array of public keys for key rotation providerEndpoint URI optional if present, then this service can provision tenants via this endpoint. modified Timestamp optional the time this entry was modified executable String optional the path of the executable that runs the service hosts Array<String> optional host names of hosts this service can run on user String optional local (unix) user name this service can run as group String optional local (unix) group name this service can run as ServiceIdentityList \u00b6 ServiceIdentityList is a Struct type with the following fields: Name Type Options Description Notes names Array<EntityName> next String optional ServicePrincipal \u00b6 ServicePrincipal is a Struct type with the following fields: Name Type Options Description Notes domain DomainName service EntityName token SignedToken SimpleName \u00b6 Option Value Notes pattern [a-zA-Z0-9_][a-zA-Z0-9_-]* SignedDomain \u00b6 If the get signed domain api is called with meta only flag set to true then the data returned from the ZMS Server is not signed thus signature and keyId are marked as optional for that use case. SignedDomain is a Struct type with the following fields: Name Type Options Description Notes domain DomainData signature String optional keyId String optional the version/id of the key used to sign the domain data SignedDomains \u00b6 SignedDomains is a Struct type with the following fields: Name Type Options Description Notes domains Array<SignedDomain> SignedToken \u00b6 A signed assertion if identity. For example: the YBY cookie value. This token will only make sense to the authority that generated it, so it is beneficial to have something in the value that is cheaply recognized to quickly reject if it belongs to another authority. SignedToken is a String type with the following options: Option Value Notes pattern [a-zA-Z0-9\\\\._%=;,-]* SubDomain \u00b6 A Subdomain is a TopLevelDomain, except it has a parent. SubDomain is a Struct type with the following fields: Name Type Options Description Notes description String optional a description of the domain org ResourceName optional a reference to an Organization. Auth doesn't use it, but it provides external hook (i.e. org:media) enabled Bool optional, default-true name SimpleName adminUsers Array<ResourceName> parent DomainName Template \u00b6 The representation for a solution template object defined on the server Template is a Struct type with the following fields: Name Type Options Description Notes roles Array<Role> policies Array<Policy> Tenancy \u00b6 Tenancy is a Struct type with the following fields: Name Type Options Description Notes domain DomainName the domain that is to get a tenancy service ServiceName the provider service on which the tenancy is to reside TenancyResourceGroup \u00b6 TenancyResourceGroup is a Struct type with the following fields: Name Type Options Description Notes domain DomainName the domain that is to get a tenancy service ServiceName the provider service on which the tenancy is to reside resourceGroup Tenant Resource Group resource group (e.g. table) allocated for tenant TenantDomains \u00b6 TenantDomains is a Struct type with the following fields: Name Type Options Description Notes tenantDomainNames Array<DomainName> TenantRoleAction \u00b6 TenantRoleAction is a Struct type with the following fields: Name Type Options Description Notes role SimpleName action String TopLevelDomain \u00b6 The required attributes to create a top level domain. Probably need an Organization or CostCenter or something... TopLevelDomain is a Struct type with the following fields: Name Type Options Description Notes description String optional a description of the domain org ResourceName optional a reference to an Organization. Auth doesn't use it, but it provides external hook (i.e. org:media) enabled Bool optional, default-true name SimpleName adminUsers Array<ResourceName> UserToken \u00b6 UserToken is a Struct type with the following fields: Name Type Options Description Notes token SignedToken YBase64 \u00b6 The Y-specific URL-safe Base64 variant. YBase64 is a String type with the following options: Option Value Notes pattern [a-zA-Z0-9\\._-]+ YEncoded \u00b6 YEncoded includes ybase64 chars, as well as - and %. This can represent a YBY cookie and URL-encoded values YEncoded is a String type with the following options: Option Value Notes pattern [a-zA-Z0-9\\._%--]* YRN \u00b6 A full Resource name (YRN) YRN is a String type with the following options: Option Value Notes pattern (yrn:({ServiceName})?:({LocationName})?:)?{ResourceName} Resources \u00b6 Access \u00b6 GET /access/{action} \u00b6 Authentication : Certificate Authorization : None Check access for the specified operation/action on the specified resource for the currently authenticated user if the principal query parameter is not specified. If the principal query parameter is specified, the access check verifies if that principal has access for the specified action on the resource. This is the slow centralized access for control-plane purposes. Request Parameters Name Type Source Options Description action ActionName path domain DomainName query: domain optional principal EntityName query: principal optional resource String query: resource required Responses Expected: Code Type 200 OK Access Exception: Code Type 400 Bad Request ResourceError 401 Unauthorized ResourceError 404 Not Found ResourceError Assertion \u00b6 GET /domain/{domainName}/policy/{policyName}/assertion/{assertionId} \u00b6 Authentication : Certificate Authorization : None Read the specified assertion from the policy. Request Parameters Name Type Source Options Description domainName DomainName path policyName EntityName path assertionId Int64 path Responses Expected: Code Type 200 OK Assertion Exception: Code Type 400 Bad Request ResourceError 401 Unauthorized ResourceError 404 Not Found ResourceError PUT /domain/{domainName}/policy/{policyName}/assertion \u00b6 Authentication : Certificate Authorization : authorize(\"update\", \"{domainName}:policy.{policyName}\") Add the provided assertion to the specified policy. Request Parameters Name Type Source Options Description domainName DomainName path policyName EntityName path assertion Assertion body Responses Expected: Code Type 204 No Content Exception: Code Type 400 Bad Request ResourceError 401 Unauthorized ResourceError 403 Forbidden ResourceError 404 Not Found ResourceError DELETE /domain/{domainName}/policy/{policyName}/assertion/{assertionId} \u00b6 Authentication : Certificate Authorization : authorize(\"update\", \"{domainName}:policy.{policyName}\") Delete the assertion with the given id from the specified policy. Request Parameters Name Type Source Options Description domainName DomainName path policyName EntityName path assertionId Int64 path Responses Expected: Code Type 204 No Content Exception: Code Type 400 Bad Request ResourceError 401 Unauthorized ResourceError 403 Forbidden ResourceError 404 Not Found ResourceError DefaultAdmins \u00b6 PUT /domain/{domainName}/admins \u00b6 Authentication : Certificate Authorization : authorize (\"update\", \"sys.auth:domain\"); Verify and, if necessary, fix domain roles and policies to make sure the given set of users have administrative access to the domain. This request is only restricted to \"sys.auth\" domain administrators and can be used when the domain administrators incorrectly have blocked their own access to their domains. Request Parameters Name Type Source Options Description domainName DomainName path defaultAdmins DefaultName body Responses Expected: Code Type 204 No Content Exception: Code Type 400 Bad Request ResourceError 401 Unauthorized ResourceError 403 Forbidden ResourceError 404 Not Found ResourceError Domain \u00b6 GET /domain/{domain} \u00b6 Authentication : Certificate Authorization : None Get info for the specified domain, by name. Request Parameters Name Type Source Options Description domain DomainName path Responses Expected: Code Type 200 OK Domain Exception: Code Type 401 Unauthorized ResourceError 404 Not Found ResourceError POST /domain \u00b6 Authentication : Certificate Authorization : authorize (\"create\", \"sys.auth:domain\") Create a new top level domain. This is a privileged action for the sys.auth administrators Request Parameters Name Type Source Options Description detail TopLevelDomain body Responses Expected: Code Type 200 OK Domain Exception: Code Type 400 Bad Request ResourceError 401 Unauthorized ResourceError 403 Forbidden ResourceError DELETE /domain/{name} \u00b6 Authentication : Certificate Authorization : authorize (\"delete\", \"sys.auth:domain\") Delete the specified domain. This is a privileged action for the sys.auth administrators. Request Parameters Name Type Source Options Description domain DomainName path Responses Expected: Code Type 204 No Content Exception: Code Type 400 Bad Request ResourceError 401 Unauthorized ResourceError 403 Forbidden ResourceError PUT /domain/{name}/meta \u00b6 Authentication : Certificate Authorization : authorize (\"update\", \"{name}:\") Update the specified domain metadata. Note that entities in the domain are not affected. you need update privileges on the domain itself. Request Parameters Name Type Source Options Description name DomainName path detail DomainMeta body Responses Expected: Code Type 204 No Content Exception: Code Type 400 Bad Request ResourceError 401 Unauthorized ResourceError 403 Forbidden ResourceError DomainList \u00b6 GET /domain \u00b6 Authentication : Certificate Authorization : None Enumerate domains. Can be filtered by prefix and depth, and paginated. This operation can be expensive, as it may span multiple domains. Request Parameters Name Type Source Options Description limit Integer query: limit optional skip String query: skip optional prefix String query: prefix optional depth Integer query: depth optional account String query: account optional AWS Account ypmid Integer query: ypmid optional YPM Product ID member String query: member optional role String query: role optional Some of these options are mutually exclusive. If the request contains either the account or ypmid query parameter, then the server carries out a domain lookup based on that query parameter only and ignores all other parameters. If the request contains no account and ypmid parameters, the server then looks for member and role query parameters. The member field filters the domain list to only return those where this user (e.g. user.userid) is member of any role and can be further restricted by passing the role parameter. For example, by passing \"user.john\" for member query parameter and \"admin\" for the role query parameter, the server will return all domains where the given user.john is in the admin role. If the member and role are not specified either, then the server carries out a standard domain list operation constrained by the other query parameters (limit, skip, prefix and depth). Responses Code Type 200 OK DomainList Exception: Code Type 401 Unauthorized ResourceError Entity \u00b6 PUT /domain/{domainName}/entity/{entityName} \u00b6 Authentication : Certificate Authorization : authorize (\"update\", \"{domainName}:{entityName}\") Put an entity into the domain. Request Parameters Name Type Source Options Description entityName EntityName path entity EntityName body domainName DomainName path Responses Expected: Code Type 204 No Content Exception: Code Type 400 Bad Request ResourceError 401 Unauthorized ResourceError 403 Forbidden ResourceError 404 Not Found ResourceError GET /domain/{domainName}/entity/{entityName} \u00b6 Authentication : Certificate Authorization : None Get a entity from a domain open for all authenticated users to read Request Parameters Name Type Source Options Description domainName DomainName path entityName EntityName path Responses Expected: Code Type 200 OK Entity Exception: Code Type 400 Bad Request ResourceError 401 Unauthorized ResourceError 404 Not Found ResourceError DELETE /domain/{domainName}/entity/{entityName} \u00b6 Authentication : Certificate Authorization : authorize (\"delete\", \"{domainName}:{entityName}\") Delete the entity from the domain. Request Parameters Name Type Source Options Description domainName DomainName path entityName EntityName path Responses Expected: Code Type 204 No Content Exception: Code Type 400 Bad Request ResourceError 401 Unauthorized ResourceError 403 Forbidden ResourceError 404 Not Found ResourceError Membership \u00b6 GET /domain/{domainName}/role/{roleName}/member/{memberName} \u00b6 Authentication : Certificate Authorization : None Get the specified role in the domain. Request Parameters Name Type Source Options Description domainName DomainName path roleName EntityName path memberName ResourceName path Responses Expected: Code Type 200 OK Membership Exception: Code Type 400 Bad Request ResourceError 401 Unauthorized ResourceError 404 Not Found ResourceError PUT /domain/{domainName}/role/{roleName}/member/{memberName} \u00b6 Authentication : Certificate Authorization : authorize (\"update\", \"{domainName}:role.{roleName}\" Create/update the specified role membership. Request Parameters Name Type Source Options Description membership Membership body domainName DomainName path roleName EntityName path memberName ResourceName path Responses Expected: Code Type 204 No Content Exception: Code Type 400 Bad Request ResourceError 401 Unauthorized ResourceError 403 Forbidden ResourceError 404 Not Found ResourceError DELETE /domain/{domainName}/role/{roleName}/member/{memberName} \u00b6 Authentication : Certificate Authorization : authorize (\"update\", \"{domainName}:role.{roleName}\" Delete the specified role membership. Request Parameters Name Type Source Options Description domainName DomainName path roleName EntityName path memberName ResourceName path Responses Expected: Code Type 204 No Content Exception: Code Type 400 Bad Request ResourceError 401 Unauthorized ResourceError 403 Forbidden ResourceError 404 Not Found ResourceError Policy \u00b6 GET /domain/{domainName}/policy/{policyName} \u00b6 Authentication : Certificate Authorization : None Read the specified policy. Request Parameters Name Type Source Options Description domainName DomainName path policyName EntityName path Responses Expected: Code Type 200 OK Policy Exception: Code Type 400 Bad Request ResourceError 401 Unauthorized ResourceError 404 Not Found ResourceError PUT /domain/{domainName}/policy/{policyName} \u00b6 Authentication : Certificate Authorization : authorize(\"update\", \"{domainName}:policy.{policyName}\") Create or update the specified policy. Request Parameters Name Type Source Options Description domainName DomainName path policyName EntityName path policy Policy body Responses Expected: Code Type 204 No Content Exception: Code Type 400 Bad Request ResourceError 401 Unauthorized ResourceError 403 Forbidden ResourceError 404 Not Found ResourceError DELETE /domain/{domainName}/policy/{policyName} \u00b6 Authentication : Certificate Authorization : authorize(\"delete\", \"{domainName}:policy.{policyName}\") Delete the specified policy. Request Parameters Name Type Source Options Description domainName DomainName path policyName EntityName path Responses Expected: Code Type 204 No Content Exception: Code Type 400 Bad Request ResourceError 401 Unauthorized ResourceError 403 Forbidden ResourceError 404 Not Found ResourceError Policies \u00b6 GET /domain/{domainName}/policies \u00b6 Authentication : Certificate Authorization : None Enumerate policies provisioned in this domain and returns the list including policy attributes (modified timestamp and assertions - if requested). Request Parameters Name Type Source Options Description domainName DomainName path assertions Bool query: assertions optional If the assertions query parameter is set to true, the server will return the list of assertions for all policies in the result set. Responses Expected: Code Type 200 OK Policies Exception: Code Type 400 Bad Request ResourceError 401 Unauthorized ResourceError 404 Not Found ResourceError PolicyList \u00b6 GET /domain/{domainName}/policy \u00b6 Authentication : Certificate Authorization : None List policies provisioned in this namespace. Request Parameters Name Type Source Options Description domainName DomainName path limit Integer query: limit optional skip String query: skip optional Responses Expected: Code Type 200 OK PolicyList Exception: Code Type 400 Bad Request ResourceError 401 Unauthorized ResourceError 404 Not Found ResourceError PublicKeyEntry \u00b6 PUT /domain/{domain}/service/{service}/publickey/{id} \u00b6 Authentication : Certificate Authorization : authorize (\"update\", \"{domain}:service.{service}\") Register the specified ServiceIdentity in the specified domain. Request Parameters Name Type Source Options Description detail ServiceIdentity body domain DomainName path service EntityName path id String path Responses Expected: Code Type 204 No Content Exception: Code Type 400 Bad Request ResourceError 401 Unauthorized ResourceError 403 Forbidden ResourceError 404 Not Found ResourceError 409 Conflict ResourceError GET /domain/{domain}/service/{service}/publickey/{id} \u00b6 Authentication : Certificate Authorization : None Get public key info for the specified service and key id. Request Parameters Name Type Source Options Description domain DomainName path service EntityName path id String path Responses Expected: Code Type 200 OK PublicKeyEntry Exception: Code Type 400 Bad Request ResourceError 401 Unauthorized ResourceError 404 Not Found ResourceError DELETE /domain/{domain}/service/{service}/publickey/{id} \u00b6 Authentication : Certificate Authorization : authorize (\"update\", \"{domain}:service.{service}\") Delete the specified PublicKey for a service. Request Parameters Name Type Source Options Description domain DomainName path service EntityName path id String path Responses Expected: Code Type 204 No Content Exception: Code Type 400 Bad Request ResourceError 401 Unauthorized ResourceError 403 Forbidden ResourceError 404 Not Found ResourceError 409 Conflict ResourceError Resource \u00b6 GET /resource \u00b6 Authentication : Certificate Authorization : None Return list of resources through the defined assertions that the given principal has access to. Even though the principal is marked as optional, it must be specified unless the caller has authorization from sys.auth domain to check access for all principals. If the query action specified is assume_aws_role , then ZMS will automatically query only regular users and update the value of the resource field in the assertion to generate an aws role value based on the aws account id registered for the domain. Request Parameters Name Type Source Options Description action ActionName query: action optional principal EntityName query: principal optional Responses Expected: Code Type 200 OK Access Exception: Code Type 400 Bad Request ResourceError 401 Unauthorized ResourceError 404 Not Found ResourceError Role \u00b6 GET /domain/{domainName}/role/{roleName} \u00b6 Authentication : Certificate Authorization : None Get the specified role in the domain. Request Parameters Name Type Source Options Description domainName DomainName path roleName EntityName path auditLog Bool query: auditLog optional expand Bool query: expand optional If the auditLog query parameter is set to true, the server will return the audit log detailing all the membership changes in this role. If the role is a delegated/trust role, then the expand query parameter will instruct the zms server to automatically lookup the members of the role in the delegated domain and return the members as part of the result set. Responses Code Type 200 OK Role Exception: Code Type 400 Bad Request ResourceError 401 Unauthorized ResourceError 403 Forbidden ResourceError 404 Not Found ResourceError PUT /domain/{domainName}/role/{roleName} \u00b6 Authentication : Certificate Authorization : authorize (\"update\", \"{domainName}:role.{roleName}\") Create/update the specified role. Request Parameters Name Type Source Options Description domainName DomainName path roleName EntityName path role Role body Responses Expected: Code Type 204 No Content Exception: Code Type 400 Bad Request ResourceError 401 Unauthorized ResourceError 403 Forbidden ResourceError 404 Not Found ResourceError DELETE /domain/{domainName}/role/{roleName} \u00b6 Authentication : Certificate Authorization : authorize (\"delete\", \"{domainName}:role.{roleName}\") Delete the specified role Request Parameters Name Type Source Options Description domainName DomainName path roleName EntityName path Responses Expected: Code Type 204 No Content Exception: Code Type 400 Bad Request ResourceError 401 Unauthorized ResourceError 403 Forbidden ResourceError 404 Not Found ResourceError RoleList \u00b6 GET /domain/{domainName}/role \u00b6 Authentication : Certificate Authorization : None Enumerate roles provisioned in this domain. Request Parameters Name Type Source Options Description domainName DomainName path limit Integer query: limit optional skip String query: skip optional Responses Expected: Code Type 200 OK RoleList Exception: Code Type 400 Bad Request ResourceError 401 Unauthorized ResourceError 404 Not Found ResourceError Roles \u00b6 GET /domain/{domainName}/roles \u00b6 Authentication : Certificate Authorization : None Enumerate roles provisioned in this domain and returns the list including role attributes (modified timestamp, delegated domain name and members - if requested). Request Parameters Name Type Source Options Description domainName DomainName path members Bool query: members optional If the members query parmeter is set to true, the server will return the list of members for all roles in the result set. Responses Expected: Code Type 200 OK Roles Exception: Code Type 400 Bad Request ResourceError 401 Unauthorized ResourceError 404 Not Found ResourceError ServiceIdentities \u00b6 GET /domain/{domainName}/services \u00b6 Authentication : Certificate Authorization : None Enumerate services provisioned in this domain and returns the list including service attributes (modified timestamp, user, group, executable, endpoint, public keys and hosts - if requested). Request Parameters Name Type Source Options Description domainName DomainName path publickeys Bool query: publickeys optional hosts Bool query: hosts optional If the publickeys query parameter is set to true, the server will return the list of public keys for all services in the result set. Similarly, if the hosts query parameter is set to true, the list of hosts configured per service will be returned in the result set. Responses Expected: Code Type 200 OK ServiceIdentities Exception: Code Type 400 Bad Request ResourceError 401 Unauthorized ResourceError 404 Not Found ResourceError ServiceIdentity \u00b6 PUT /domain/{domain}/service/{service} \u00b6 Authentication : Certificate Authorization : authorize (\"update\", \"{domain}:service\") Register the specified ServiceIdentity in the specified domain. Request Parameters Name Type Source Options Description detail ServiceIdentity body domain DomainName path service EntityName path Responses Expected: Code Type 204 No Content Exception: Code Type 400 Bad Request ResourceError 401 Unauthorized ResourceError 403 Forbidden ResourceError 404 Not Found ResourceError GET /domain/{domain}/service/{service} \u00b6 Authentication : Certificate Authorization : None Get info for the specified ServiceIdentity. Request Parameters Name Type Source Options Description domain DomainName path service EntityName path Responses Expected: Code Type 200 OK ServiceIdentity Exception: Code Type 400 Bad Request ResourceError 401 Unauthorized ResourceError 404 Not Found ResourceError DELETE /domain/{domain}/service/{service} \u00b6 Authentication : Certificate Authorization : authorize (\"delete\", \"{domain}:service\") Delete the specified ServiceIdentity. Request Parameters Name Type Source Options Description domain DomainName path service EntityName path Responses Expected: Code Type 204 No Content Exception: Code Type 400 Bad Request ResourceError 401 Unauthorized ResourceError 403 Forbidden ResourceError 404 Not Found ResourceError ServiceIdentityList \u00b6 GET /domain/{domainName}/service \u00b6 Authentication : Certificate Authorization : None Enumerate services provisioned in this domain. Request Parameters Name Type Source Options Description domainName DomainName path limit Integer query: limit optional skip String query: skip optional Responses Expected: Code Type 200 OK ServiceIdentityList Exception: Code Type 400 Bad Request ResourceError 401 Unauthorized ResourceError 404 Not Found ResourceError ServicePrincipal \u00b6 GET /principal \u00b6 Authentication : Certificate Authorization : None Return a principal object if the serviceToken passed as part of the authentication header is valid. Responses Expected: Code Type 200 OK ServicePrincipal Exception: Code Type 400 Bad Request ResourceError 401 Unauthorized ResourceError 404 Not Found ResourceError SignedDomains \u00b6 GET /sys/modified_domains \u00b6 Authentication : Certificate Authorization : None Retrieve the list of modified domains since the specified timestamp. The server will return the list of all modified domains and the latest modification timestamp as the value of the ETag header. The client will need to use this value during its next call to request the changes since the previous request. When metaonly set to true, don't add roles, policies or services, don't sign Request Parameters Name Type Source Options Description matchingTag String header: If-None-Match domain DomainName query: domain optional metaOnly String query: metaOnly optional true or false Response Parameters Name Type Destination Description tag String header: ETag Responses Code Type 200 OK SignedDomains 304 Not Modified Exception: Code Type 400 Bad Request ResourceError 401 Unauthorized ResourceError 403 Forbidden ResourceError 404 Not Found ResourceError SubDomain \u00b6 POST /subdomain/{parent} \u00b6 Authentication : Certificate Authorization : authorize (\"create\", \"{parent}:domain\") Create a new subdomain, The authorization is based on the parent domain. Request Parameters Name Type Source Options Description parent DomainName path detail SubDomain body Responses Code Type 200 OK Domain Exception: Code Type 400 Bad Request ResourceError 401 Unauthorized ResourceError 403 Forbidden ResourceError DELETE /subdomain/{parent}/{name} \u00b6 Authentication : Certificate Authorization : authorize (\"delete\", \"{parent}:domain\") Delete the specified subdomain. The {name} component in the URI must not include the parent domain. For example, if the user wants to delete athens.ci subdomain, then the URI for this request would be /subdomain/athens/ci. Request Parameters Name Type Source Options Description parent DomainName path name DomainName path Responses Code Type 204 No Content Exception: Code Type 400 Bad Request ResourceError 401 Unauthorized ResourceError 403 Forbidden ResourceError Templates \u00b6 PUT /domain/{name}/template \u00b6 Authentication : Certificate Authorization : authorize (\"update\", \"{name}:\" Update the given domain by applying the roles and policies defined in the specified solution templates. Caller must have update privileges on the domain itself. Request Parameters Name Type Source Options Description name DomainName path templates DomainTemplateList body Responses Expected: Code Type 204 No Content Exception: Code Type 400 Bad Request ResourceError 401 Unauthorized ResourceError 403 Forbidden ResourceError 404 Not Found ResourceError GET /domain/{name}/template \u00b6 Authentication : Certificate Authorization : None Get the list of solution templates applied to a domain Request Parameters Name Type Source Options Description name DomainName path Responses Expected: Code Type 200 OK DomainTemplateList Exception: Code Type 400 Bad Request ResourceError 401 Unauthorized ResourceError 404 Not Found ResourceError GET /template \u00b6 Authentication : Certificate Authorization : None Get the list of solution templates defined in the server Responses Expected: Code Type 200 OK ServerTemplateList Exception: Code Type 400 Bad Request ResourceError 401 Unauthorized ResourceError 404 Not Found ResourceError GET /template/{template} \u00b6 Authentication : Certificate Authorization : None Get solution template details. Includes the roles and policies that will be automatically provisioned when the template is applied to a domain Request Parameters Name Type Source Options Description template SimpleName path Responses Expected: Code Type 200 OK Template Exception: Code Type 400 Bad Request ResourceError 401 Unauthorized ResourceError 404 Not Found ResourceError Tenancy \u00b6 PUT /domain/{domain}/tenancy/{service} \u00b6 Authentication : Certificate Authorization : authorize (\"update\", \"{domain}:tenancy\") Add a tenant for the specified service. Request Parameters Name Type Source Options Description domain DomainName path service ServiceName path detail Tenancy body Responses Expected: Code Type 200 OK Tenancy 201 CREATED Tenancy Exception: Code Type 400 Bad Request ResourceError 401 Unauthorized ResourceError 403 Forbidden ResourceError 404 Not Found ResourceError DELETE /domain/{domain}/tenancy/{service} \u00b6 Authentication : Certificate Authorization : authorize (\"delete\", \"{domain}:tenancy\") Delete the tenant from the specified service. Upon successful completion of this delete request, the server will return NO_CONTENT status code without any data (no object will be returned). Request Parameters Name Type Source Options Description domain DomainName path service ServiceName path Responses Expected: Code Type 204 No Content Exception: Code Type 400 Bad Request ResourceError 401 Unauthorized ResourceError 403 Forbidden ResourceError 404 Not Found ResourceError PUT /domain/{domain}/tenancy/{service}/resourceGroup/{resourceGroup} \u00b6 Authentication : Certificate Authorization : authorize (\"update\", \"{domain}:tenancy.{service}\") Add a new resource group for the tenant for the specified service Request Parameters Name Type Source Options Description domain DomainName path service ServiceName path resourceGroup EntityName path detail TenancyResourceGroup body Responses Expected: Code Type 204 No Content Exception: Code Type 400 Bad Request ResourceError 401 Unauthorized ResourceError 403 Forbidden ResourceError 404 Not Found ResourceError DELETE /domain/{domain}/tenancy/{service}/resourceGroup/{resourceGroup} \u00b6 Authentication : Certificate Authorization : authorize (\"update\", \"{domain}:tenancy.{service}\") Delete the specified resource group for tenant from the specified service. Request Parameters Name Type Source Options Description domain DomainName path service ServiceName path resourceGroup Resource Group name path Responses Expected: Code Type 204 No Content Exception: Code Type 400 Bad Request ResourceError 401 Unauthorized ResourceError 403 Forbidden ResourceError 404 Not Found ResourceError GET /providerdomain/{providerDomainName}/user/{userName}?roleName={roleName} \u00b6 Authentication : Certificate Authorization : None Request Parameters Name Type Source Options Description providerDomainName DomainName path userName SimpleName path roleName SimpleName path Responses Expected: Code Type 200 OK TenantDomains Exception: Code Type 400 Bad Request ResourceError 401 Unauthorized ResourceError 404 Not Found ResourceError","title":"ZMS REST API"},{"location":"zms_api/#zms-api","text":"","title":"ZMS API"},{"location":"zms_api/#introduction","text":"The Authorization Management Service (ZMS) API This API has the following attributes: Attribute Value namespace com.yahoo.auth.zms version 1","title":"Introduction"},{"location":"zms_api/#authentication","text":"","title":"Authentication"},{"location":"zms_api/#x509-certificate-support","text":"All ZMS API commands require that the client use a TLS certificate issued by Athenz. Services can use their Athenz Issued Service Identity certificates when communicating with ZMS.","title":"X.509 Certificate Support"},{"location":"zms_api/#authorization","text":"Every write request against ZMS server is authorized against the configured policy data to verify that the principal has been given the rights to make the requested change. Each request description below gives the authorization command that includes the action and resource that the ZMS Server will run the authorization check against. For example, the create subdomain command has the following authorize statement: authorize (\"create\", \"{parent}:domain\"); This indicates that the principal requesting to create subdomain called athens.ci must have grant rights to action \"create\" for resource called \"domain\" in domain \"athens\".","title":"Authorization"},{"location":"zms_api/#types","text":"","title":"Types"},{"location":"zms_api/#access","text":"Access can be checked and returned as this resource. Access is a Struct type with the following fields: Name Type Options Description Notes granted Bool","title":"Access"},{"location":"zms_api/#actionname","text":"An action (operation) name. ActionName is a String type with the following options: Option Value Notes pattern {CompoundName}","title":"ActionName"},{"location":"zms_api/#assertion","text":"A representation for the encapsulation of an action to be performed on a resource by a principal. Assertion is a Struct type with the following fields: Name Type Options Description Notes role String the subject of the assertion, a role resource String the object of the assertion. Must be in the local namespace. Can contain wildcard action String the predicate of the assertion. Can contain wildcard effect AssertionEffect optional, default-ALLOW the effect of the assertion in the policy language id Int64 optional The server assigned id for the assertion","title":"Assertion"},{"location":"zms_api/#assertioneffect","text":"Every assertion can have the effect of ALLOW or DENY. AssertionEffect is an Enum of the following values: Value Description ALLOW DENY","title":"AssertionEffect"},{"location":"zms_api/#authorityname","text":"Used as the prefix in a signed assertion. This uniquely identifies a signing authority. i.e. user AuthorityName is a String type with the following options: Option Value Notes pattern {CompoundName}","title":"AuthorityName"},{"location":"zms_api/#compoundname","text":"A compound name. Most names in this API are compound names. CompoundName is a String type with the following options: Option Value Notes pattern ({SimpleName} .) {SimpleName}*","title":"CompoundName"},{"location":"zms_api/#defaultadmins","text":"DefaultAdmins is a Struct type with the following fields: Name Type Options Description Notes admins Array<ResourceName>","title":"DefaultAdmins"},{"location":"zms_api/#domain","text":"A domain is an independent partition of users, roles, and resources. It's name represents the definition of a namespace; the only way a new namespace can be created, from the top, is by creating Domains. Administration of a domain is governed by the parent domain (using reverse-DNS namespaces). The top level domains are governed by the special sys.auth domain. Domain is a Struct type with the following fields: Name Type Options Description Notes name DomainName immutable. This is the common name to be referred to, the symbolic id. modified Timestamp optional id UUID optional generated on create, never reused description String optional org ResourceName optional a reference to an Organization. Auth doesn't use it, but it provides external hook (i.e. org:media) enabled Bool optional, default-true","title":"Domain"},{"location":"zms_api/#domaindata","text":"DomainData is a Struct type with the following fields: Name Type Options Description Notes name DomainName enabled Bool account String AWS account id ypmid Int32 OPM product id roles Array<Role role>> policies Array<Policy> serviceIds Array<ServiceIdentity> modified Timestamp","title":"DomainData"},{"location":"zms_api/#domainlist","text":"A paginated list of domains. DomainList is a Struct type with the following fields: Name Type Options Description Notes names Array<DomainName> next String optional","title":"DomainList"},{"location":"zms_api/#domainmeta","text":"All domains have metadata that can be changed. DomainMeta is a Struct type with the following fields: Name Type Options Description Notes description String optional a description of the domain org ResourceName optional a reference to an Organization. Auth doesn't use it, but it provides external hook (i.e. org:media) enabled Bool optional, default-true","title":"DomainMeta"},{"location":"zms_api/#domainname","text":"A domain name is the general qualifier prefix, as its uniqueness is managed. DomainName is a String type with the following options: Option Value Notes pattern {CompoundName}","title":"DomainName"},{"location":"zms_api/#domainpolicies","text":"DomainPolicies is a Struct type with the following fields: Name Type Options Description Notes domain DomainName policies Array<Policy> modified Timestamp when the domain itself was last modified expires Timestamp how long this snapshot can be used","title":"DomainPolicies"},{"location":"zms_api/#domaintemplatelist","text":"List of solution templates to be applied to a domain DomainTemplateList is a Struct type with the following fields: Name Type Options Description Notes templateNames Array<SimpleName>","title":"DomainTemplateList"},{"location":"zms_api/#entity","text":"An entity is a name and a structured value some entity names/prefixes are reserved (i.e., role , policy , meta , domain ) Entity is a Struct type with the following fields: Name Type Options Description Notes name EntityName value Struct","title":"Entity"},{"location":"zms_api/#entityname","text":"An entity name is a short form of a resource name, including only the domain and entity. EntityName is a String type with the following options: Option Value Notes pattern {CompoundName}","title":"EntityName"},{"location":"zms_api/#locationname","text":"A location name is not yet defined, but will be a dotted name like everything else. LocationName is a String type with the following options: Option Value Notes pattern {CompoundName}","title":"LocationName"},{"location":"zms_api/#membership","text":"Membership is a Struct type with the following fields: Name Type Options Description Notes memberName ResourceName isMember Bool optional, default-true roleName ResourceName optional","title":"Membership"},{"location":"zms_api/#policies","text":"Policiies is a Struct type with the following fields: Name Type Options Description Notes list Array<Policy>","title":"Policies"},{"location":"zms_api/#policy","text":"The representation for a named set of assertions, given a name and a version number that increments. Policy is a Struct type with the following fields: Name Type Options Description Notes name ResourceName modified Timestamp optional assertions Array<Assertion>","title":"Policy"},{"location":"zms_api/#policylist","text":"The representation for an enumeration of policies in the namespace, with pagination PolicyList is a Struct type with the following fields: Name Type Options Description Notes names Array<EntityName> next String optional","title":"PolicyList"},{"location":"zms_api/#publickeyentry","text":"PublicKeyEntry is a Struct type with the following fields: Name Type Options Description Notes key String the public key for the service id String used to specify the id/version of the key (for GET operation only)","title":"PublicKeyEntry"},{"location":"zms_api/#resourcename","text":"A shorthand for a YRN with no service or location. The 'tail' of a YRN, just the domain:entity. Note that the EntityName part is optional, that is, a domain name followed by a colon is valid resource name. ResourceName is a String type with the following options: Option Value Notes pattern {DomainName}(:{EntityName})?","title":"ResourceName"},{"location":"zms_api/#role","text":"Role is a Struct type with the following fields: Name Type Options Description Notes name ResourceName modified Timestamp optional members Array<ResourceName> optional an explicit list of members. Might be empty or null, if trust is set. trust DomainName optional a trusted domain to delegate membership decisions to. auditLog Array<RoleAuditLog> optional an explicit list of audit log entries if requested.","title":"Role"},{"location":"zms_api/#roleauditlog","text":"RoleAuditLog is a Struct type with the following fields: Name Type Options Description Notes member ResourceName admin ResourceName created Timestamp action String ADD or DELETE auditRef String optional","title":"RoleAuditLog"},{"location":"zms_api/#rolelist","text":"RoleList is a Struct type with the following fields: Name Type Options Description Notes names Array<EntityName> next String optional","title":"RoleList"},{"location":"zms_api/#roles","text":"Roles is a Struct type with the following fields: Name Type Options Description Notes list Array<Role>","title":"Roles"},{"location":"zms_api/#servertemplatelist","text":"List of solution templates available in the server ServerTemplateList is a Struct type with the following fields: Name Type Options Description Notes templateNames Array<SimpleName>","title":"ServerTemplateList"},{"location":"zms_api/#serviceidentities","text":"ServiceIdentities is a Struct type with the following fields: Name Type Options Description Notes list Array<ServiceIdentity>","title":"ServiceIdentities"},{"location":"zms_api/#servicename","text":"A service name will generally be a unique subdomain ServiceName is a String type with the following options: Option Value Notes pattern {CompoundName}","title":"ServiceName"},{"location":"zms_api/#serviceidentity","text":"ServiceIdentity is a Struct type with the following fields: Name Type Options Description Notes name ServiceName the full name, i.e. vespa.storage publicKey String optional the public key for the service publicKeys Array<PublicKeyEntry> optional array of public keys for key rotation providerEndpoint URI optional if present, then this service can provision tenants via this endpoint. modified Timestamp optional the time this entry was modified executable String optional the path of the executable that runs the service hosts Array<String> optional host names of hosts this service can run on user String optional local (unix) user name this service can run as group String optional local (unix) group name this service can run as","title":"ServiceIdentity"},{"location":"zms_api/#serviceidentitylist","text":"ServiceIdentityList is a Struct type with the following fields: Name Type Options Description Notes names Array<EntityName> next String optional","title":"ServiceIdentityList"},{"location":"zms_api/#serviceprincipal","text":"ServicePrincipal is a Struct type with the following fields: Name Type Options Description Notes domain DomainName service EntityName token SignedToken","title":"ServicePrincipal"},{"location":"zms_api/#simplename","text":"Option Value Notes pattern [a-zA-Z0-9_][a-zA-Z0-9_-]*","title":"SimpleName"},{"location":"zms_api/#signeddomain","text":"If the get signed domain api is called with meta only flag set to true then the data returned from the ZMS Server is not signed thus signature and keyId are marked as optional for that use case. SignedDomain is a Struct type with the following fields: Name Type Options Description Notes domain DomainData signature String optional keyId String optional the version/id of the key used to sign the domain data","title":"SignedDomain"},{"location":"zms_api/#signeddomains","text":"SignedDomains is a Struct type with the following fields: Name Type Options Description Notes domains Array<SignedDomain>","title":"SignedDomains"},{"location":"zms_api/#signedtoken","text":"A signed assertion if identity. For example: the YBY cookie value. This token will only make sense to the authority that generated it, so it is beneficial to have something in the value that is cheaply recognized to quickly reject if it belongs to another authority. SignedToken is a String type with the following options: Option Value Notes pattern [a-zA-Z0-9\\\\._%=;,-]*","title":"SignedToken"},{"location":"zms_api/#subdomain","text":"A Subdomain is a TopLevelDomain, except it has a parent. SubDomain is a Struct type with the following fields: Name Type Options Description Notes description String optional a description of the domain org ResourceName optional a reference to an Organization. Auth doesn't use it, but it provides external hook (i.e. org:media) enabled Bool optional, default-true name SimpleName adminUsers Array<ResourceName> parent DomainName","title":"SubDomain"},{"location":"zms_api/#template","text":"The representation for a solution template object defined on the server Template is a Struct type with the following fields: Name Type Options Description Notes roles Array<Role> policies Array<Policy>","title":"Template"},{"location":"zms_api/#tenancy","text":"Tenancy is a Struct type with the following fields: Name Type Options Description Notes domain DomainName the domain that is to get a tenancy service ServiceName the provider service on which the tenancy is to reside","title":"Tenancy"},{"location":"zms_api/#tenancyresourcegroup","text":"TenancyResourceGroup is a Struct type with the following fields: Name Type Options Description Notes domain DomainName the domain that is to get a tenancy service ServiceName the provider service on which the tenancy is to reside resourceGroup Tenant Resource Group resource group (e.g. table) allocated for tenant","title":"TenancyResourceGroup"},{"location":"zms_api/#tenantdomains","text":"TenantDomains is a Struct type with the following fields: Name Type Options Description Notes tenantDomainNames Array<DomainName>","title":"TenantDomains"},{"location":"zms_api/#tenantroleaction","text":"TenantRoleAction is a Struct type with the following fields: Name Type Options Description Notes role SimpleName action String","title":"TenantRoleAction"},{"location":"zms_api/#topleveldomain","text":"The required attributes to create a top level domain. Probably need an Organization or CostCenter or something... TopLevelDomain is a Struct type with the following fields: Name Type Options Description Notes description String optional a description of the domain org ResourceName optional a reference to an Organization. Auth doesn't use it, but it provides external hook (i.e. org:media) enabled Bool optional, default-true name SimpleName adminUsers Array<ResourceName>","title":"TopLevelDomain"},{"location":"zms_api/#usertoken","text":"UserToken is a Struct type with the following fields: Name Type Options Description Notes token SignedToken","title":"UserToken"},{"location":"zms_api/#ybase64","text":"The Y-specific URL-safe Base64 variant. YBase64 is a String type with the following options: Option Value Notes pattern [a-zA-Z0-9\\._-]+","title":"YBase64"},{"location":"zms_api/#yencoded","text":"YEncoded includes ybase64 chars, as well as - and %. This can represent a YBY cookie and URL-encoded values YEncoded is a String type with the following options: Option Value Notes pattern [a-zA-Z0-9\\._%--]*","title":"YEncoded"},{"location":"zms_api/#yrn","text":"A full Resource name (YRN) YRN is a String type with the following options: Option Value Notes pattern (yrn:({ServiceName})?:({LocationName})?:)?{ResourceName}","title":"YRN"},{"location":"zms_api/#resources","text":"","title":"Resources"},{"location":"zms_api/#access_1","text":"","title":"Access"},{"location":"zms_api/#get-accessaction","text":"Authentication : Certificate Authorization : None Check access for the specified operation/action on the specified resource for the currently authenticated user if the principal query parameter is not specified. If the principal query parameter is specified, the access check verifies if that principal has access for the specified action on the resource. This is the slow centralized access for control-plane purposes.","title":"GET /access/{action}"},{"location":"zms_api/#assertion_1","text":"","title":"Assertion"},{"location":"zms_api/#get-domaindomainnamepolicypolicynameassertionassertionid","text":"Authentication : Certificate Authorization : None Read the specified assertion from the policy.","title":"GET /domain/{domainName}/policy/{policyName}/assertion/{assertionId}"},{"location":"zms_api/#put-domaindomainnamepolicypolicynameassertion","text":"Authentication : Certificate Authorization : authorize(\"update\", \"{domainName}:policy.{policyName}\") Add the provided assertion to the specified policy.","title":"PUT /domain/{domainName}/policy/{policyName}/assertion"},{"location":"zms_api/#delete-domaindomainnamepolicypolicynameassertionassertionid","text":"Authentication : Certificate Authorization : authorize(\"update\", \"{domainName}:policy.{policyName}\") Delete the assertion with the given id from the specified policy.","title":"DELETE /domain/{domainName}/policy/{policyName}/assertion/{assertionId}"},{"location":"zms_api/#defaultadmins_1","text":"","title":"DefaultAdmins"},{"location":"zms_api/#put-domaindomainnameadmins","text":"Authentication : Certificate Authorization : authorize (\"update\", \"sys.auth:domain\"); Verify and, if necessary, fix domain roles and policies to make sure the given set of users have administrative access to the domain. This request is only restricted to \"sys.auth\" domain administrators and can be used when the domain administrators incorrectly have blocked their own access to their domains.","title":"PUT /domain/{domainName}/admins"},{"location":"zms_api/#domain_1","text":"","title":"Domain"},{"location":"zms_api/#get-domaindomain","text":"Authentication : Certificate Authorization : None Get info for the specified domain, by name.","title":"GET /domain/{domain}"},{"location":"zms_api/#post-domain","text":"Authentication : Certificate Authorization : authorize (\"create\", \"sys.auth:domain\") Create a new top level domain. This is a privileged action for the sys.auth administrators","title":"POST /domain"},{"location":"zms_api/#delete-domainname","text":"Authentication : Certificate Authorization : authorize (\"delete\", \"sys.auth:domain\") Delete the specified domain. This is a privileged action for the sys.auth administrators.","title":"DELETE /domain/{name}"},{"location":"zms_api/#put-domainnamemeta","text":"Authentication : Certificate Authorization : authorize (\"update\", \"{name}:\") Update the specified domain metadata. Note that entities in the domain are not affected. you need update privileges on the domain itself.","title":"PUT /domain/{name}/meta"},{"location":"zms_api/#domainlist_1","text":"","title":"DomainList"},{"location":"zms_api/#get-domain","text":"Authentication : Certificate Authorization : None Enumerate domains. Can be filtered by prefix and depth, and paginated. This operation can be expensive, as it may span multiple domains.","title":"GET /domain"},{"location":"zms_api/#entity_1","text":"","title":"Entity"},{"location":"zms_api/#put-domaindomainnameentityentityname","text":"Authentication : Certificate Authorization : authorize (\"update\", \"{domainName}:{entityName}\") Put an entity into the domain.","title":"PUT /domain/{domainName}/entity/{entityName}"},{"location":"zms_api/#get-domaindomainnameentityentityname","text":"Authentication : Certificate Authorization : None Get a entity from a domain open for all authenticated users to read","title":"GET /domain/{domainName}/entity/{entityName}"},{"location":"zms_api/#delete-domaindomainnameentityentityname","text":"Authentication : Certificate Authorization : authorize (\"delete\", \"{domainName}:{entityName}\") Delete the entity from the domain.","title":"DELETE /domain/{domainName}/entity/{entityName}"},{"location":"zms_api/#membership_1","text":"","title":"Membership"},{"location":"zms_api/#get-domaindomainnamerolerolenamemembermembername","text":"Authentication : Certificate Authorization : None Get the specified role in the domain.","title":"GET /domain/{domainName}/role/{roleName}/member/{memberName}"},{"location":"zms_api/#put-domaindomainnamerolerolenamemembermembername","text":"Authentication : Certificate Authorization : authorize (\"update\", \"{domainName}:role.{roleName}\" Create/update the specified role membership.","title":"PUT /domain/{domainName}/role/{roleName}/member/{memberName}"},{"location":"zms_api/#delete-domaindomainnamerolerolenamemembermembername","text":"Authentication : Certificate Authorization : authorize (\"update\", \"{domainName}:role.{roleName}\" Delete the specified role membership.","title":"DELETE /domain/{domainName}/role/{roleName}/member/{memberName}"},{"location":"zms_api/#policy_1","text":"","title":"Policy"},{"location":"zms_api/#get-domaindomainnamepolicypolicyname","text":"Authentication : Certificate Authorization : None Read the specified policy.","title":"GET /domain/{domainName}/policy/{policyName}"},{"location":"zms_api/#put-domaindomainnamepolicypolicyname","text":"Authentication : Certificate Authorization : authorize(\"update\", \"{domainName}:policy.{policyName}\") Create or update the specified policy.","title":"PUT /domain/{domainName}/policy/{policyName}"},{"location":"zms_api/#delete-domaindomainnamepolicypolicyname","text":"Authentication : Certificate Authorization : authorize(\"delete\", \"{domainName}:policy.{policyName}\") Delete the specified policy.","title":"DELETE /domain/{domainName}/policy/{policyName}"},{"location":"zms_api/#policies_1","text":"","title":"Policies"},{"location":"zms_api/#get-domaindomainnamepolicies","text":"Authentication : Certificate Authorization : None Enumerate policies provisioned in this domain and returns the list including policy attributes (modified timestamp and assertions - if requested).","title":"GET /domain/{domainName}/policies"},{"location":"zms_api/#policylist_1","text":"","title":"PolicyList"},{"location":"zms_api/#get-domaindomainnamepolicy","text":"Authentication : Certificate Authorization : None List policies provisioned in this namespace.","title":"GET /domain/{domainName}/policy"},{"location":"zms_api/#publickeyentry_1","text":"","title":"PublicKeyEntry"},{"location":"zms_api/#put-domaindomainserviceservicepublickeyid","text":"Authentication : Certificate Authorization : authorize (\"update\", \"{domain}:service.{service}\") Register the specified ServiceIdentity in the specified domain.","title":"PUT /domain/{domain}/service/{service}/publickey/{id}"},{"location":"zms_api/#get-domaindomainserviceservicepublickeyid","text":"Authentication : Certificate Authorization : None Get public key info for the specified service and key id.","title":"GET /domain/{domain}/service/{service}/publickey/{id}"},{"location":"zms_api/#delete-domaindomainserviceservicepublickeyid","text":"Authentication : Certificate Authorization : authorize (\"update\", \"{domain}:service.{service}\") Delete the specified PublicKey for a service.","title":"DELETE /domain/{domain}/service/{service}/publickey/{id}"},{"location":"zms_api/#resource","text":"","title":"Resource"},{"location":"zms_api/#get-resource","text":"Authentication : Certificate Authorization : None Return list of resources through the defined assertions that the given principal has access to. Even though the principal is marked as optional, it must be specified unless the caller has authorization from sys.auth domain to check access for all principals. If the query action specified is assume_aws_role , then ZMS will automatically query only regular users and update the value of the resource field in the assertion to generate an aws role value based on the aws account id registered for the domain.","title":"GET /resource"},{"location":"zms_api/#role_1","text":"","title":"Role"},{"location":"zms_api/#get-domaindomainnamerolerolename","text":"Authentication : Certificate Authorization : None Get the specified role in the domain.","title":"GET /domain/{domainName}/role/{roleName}"},{"location":"zms_api/#put-domaindomainnamerolerolename","text":"Authentication : Certificate Authorization : authorize (\"update\", \"{domainName}:role.{roleName}\") Create/update the specified role.","title":"PUT /domain/{domainName}/role/{roleName}"},{"location":"zms_api/#delete-domaindomainnamerolerolename","text":"Authentication : Certificate Authorization : authorize (\"delete\", \"{domainName}:role.{roleName}\") Delete the specified role","title":"DELETE /domain/{domainName}/role/{roleName}"},{"location":"zms_api/#rolelist_1","text":"","title":"RoleList"},{"location":"zms_api/#get-domaindomainnamerole","text":"Authentication : Certificate Authorization : None Enumerate roles provisioned in this domain.","title":"GET /domain/{domainName}/role"},{"location":"zms_api/#roles_1","text":"","title":"Roles"},{"location":"zms_api/#get-domaindomainnameroles","text":"Authentication : Certificate Authorization : None Enumerate roles provisioned in this domain and returns the list including role attributes (modified timestamp, delegated domain name and members - if requested).","title":"GET /domain/{domainName}/roles"},{"location":"zms_api/#serviceidentities_1","text":"","title":"ServiceIdentities"},{"location":"zms_api/#get-domaindomainnameservices","text":"Authentication : Certificate Authorization : None Enumerate services provisioned in this domain and returns the list including service attributes (modified timestamp, user, group, executable, endpoint, public keys and hosts - if requested).","title":"GET /domain/{domainName}/services"},{"location":"zms_api/#serviceidentity_1","text":"","title":"ServiceIdentity"},{"location":"zms_api/#put-domaindomainserviceservice","text":"Authentication : Certificate Authorization : authorize (\"update\", \"{domain}:service\") Register the specified ServiceIdentity in the specified domain.","title":"PUT /domain/{domain}/service/{service}"},{"location":"zms_api/#get-domaindomainserviceservice","text":"Authentication : Certificate Authorization : None Get info for the specified ServiceIdentity.","title":"GET /domain/{domain}/service/{service}"},{"location":"zms_api/#delete-domaindomainserviceservice","text":"Authentication : Certificate Authorization : authorize (\"delete\", \"{domain}:service\") Delete the specified ServiceIdentity.","title":"DELETE /domain/{domain}/service/{service}"},{"location":"zms_api/#serviceidentitylist_1","text":"","title":"ServiceIdentityList"},{"location":"zms_api/#get-domaindomainnameservice","text":"Authentication : Certificate Authorization : None Enumerate services provisioned in this domain.","title":"GET /domain/{domainName}/service"},{"location":"zms_api/#serviceprincipal_1","text":"","title":"ServicePrincipal"},{"location":"zms_api/#get-principal","text":"Authentication : Certificate Authorization : None Return a principal object if the serviceToken passed as part of the authentication header is valid.","title":"GET /principal"},{"location":"zms_api/#signeddomains_1","text":"","title":"SignedDomains"},{"location":"zms_api/#get-sysmodified_domains","text":"Authentication : Certificate Authorization : None Retrieve the list of modified domains since the specified timestamp. The server will return the list of all modified domains and the latest modification timestamp as the value of the ETag header. The client will need to use this value during its next call to request the changes since the previous request. When metaonly set to true, don't add roles, policies or services, don't sign","title":"GET /sys/modified_domains"},{"location":"zms_api/#subdomain_1","text":"","title":"SubDomain"},{"location":"zms_api/#post-subdomainparent","text":"Authentication : Certificate Authorization : authorize (\"create\", \"{parent}:domain\") Create a new subdomain, The authorization is based on the parent domain.","title":"POST /subdomain/{parent}"},{"location":"zms_api/#delete-subdomainparentname","text":"Authentication : Certificate Authorization : authorize (\"delete\", \"{parent}:domain\") Delete the specified subdomain. The {name} component in the URI must not include the parent domain. For example, if the user wants to delete athens.ci subdomain, then the URI for this request would be /subdomain/athens/ci.","title":"DELETE /subdomain/{parent}/{name}"},{"location":"zms_api/#templates","text":"","title":"Templates"},{"location":"zms_api/#put-domainnametemplate","text":"Authentication : Certificate Authorization : authorize (\"update\", \"{name}:\" Update the given domain by applying the roles and policies defined in the specified solution templates. Caller must have update privileges on the domain itself.","title":"PUT /domain/{name}/template"},{"location":"zms_api/#get-domainnametemplate","text":"Authentication : Certificate Authorization : None Get the list of solution templates applied to a domain","title":"GET /domain/{name}/template"},{"location":"zms_api/#get-template","text":"Authentication : Certificate Authorization : None Get the list of solution templates defined in the server","title":"GET /template"},{"location":"zms_api/#get-templatetemplate","text":"Authentication : Certificate Authorization : None Get solution template details. Includes the roles and policies that will be automatically provisioned when the template is applied to a domain","title":"GET /template/{template}"},{"location":"zms_api/#tenancy_1","text":"","title":"Tenancy"},{"location":"zms_api/#put-domaindomaintenancyservice","text":"Authentication : Certificate Authorization : authorize (\"update\", \"{domain}:tenancy\") Add a tenant for the specified service.","title":"PUT /domain/{domain}/tenancy/{service}"},{"location":"zms_api/#delete-domaindomaintenancyservice","text":"Authentication : Certificate Authorization : authorize (\"delete\", \"{domain}:tenancy\") Delete the tenant from the specified service. Upon successful completion of this delete request, the server will return NO_CONTENT status code without any data (no object will be returned).","title":"DELETE /domain/{domain}/tenancy/{service}"},{"location":"zms_api/#put-domaindomaintenancyserviceresourcegroupresourcegroup","text":"Authentication : Certificate Authorization : authorize (\"update\", \"{domain}:tenancy.{service}\") Add a new resource group for the tenant for the specified service","title":"PUT /domain/{domain}/tenancy/{service}/resourceGroup/{resourceGroup}"},{"location":"zms_api/#delete-domaindomaintenancyserviceresourcegroupresourcegroup","text":"Authentication : Certificate Authorization : authorize (\"update\", \"{domain}:tenancy.{service}\") Delete the specified resource group for tenant from the specified service.","title":"DELETE /domain/{domain}/tenancy/{service}/resourceGroup/{resourceGroup}"},{"location":"zms_api/#get-providerdomainproviderdomainnameuserusernamerolenamerolename","text":"Authentication : Certificate Authorization : None","title":"GET /providerdomain/{providerDomainName}/user/{userName}?roleName={roleName}"},{"location":"zms_client/","text":"ZMS Client Utility \u00b6 Overview Getting Software Prerequisites Getting Help Specifying ZMS Environments How the ZMS Client Authenticates Listing registered domains in Athenz Displaying Administrators for a Product Domain Adding Domains Parameters Examples Registering Personal Domains Adding and Removing Administrators Adding a Group Role Parameters Example Managing a Group Role Membership Parameters Example Adding a temporary Role Membership with expiration date Parameters Example Adding a Policy Parameters Example Overview \u00b6 The ZMS client utility allows administrators to manage Athenz domains, to check domain details, create personal domains, and add other administrators. Getting Software \u00b6 Download latest ZMS Client utility binary release from Bintray - click on the Files tab, choose the latest version directory and then download the athenz-utils-<latest-version>-bin.tar.gz file:: $ tar xvfz athenz-utils-X.Y-bin.tar.gz Prerequisites \u00b6 Before you can use the ZMS client utility, you need to have asked the Athenz administrators to create your top level domain. Getting Help \u00b6 The help argument for the utility will display all commands available through utility. $ zms-cli help To get additional details about a specific command: $ zms - cli help [ command ] For example, to get complete details on how to add a domain including examples: $ zms-cli help add-domain Specifying ZMS Environments \u00b6 Use the -z option to point to the required environment for executing commands. $ zms-cli -z https://zms-server.athenzcompany.com:4443/zms/v1 -d athenz show-domain How the ZMS Client Authenticates \u00b6 The Athenz ZMS server requires the user to provide its UserToken or use a User certificate and private key for MTLS to authenticate with ZMS (depending on the Principal Authority used). ZMS will then authorize the request based on the configured authority. Listing registered domains in Athenz \u00b6 To find out what domains have been provisioned in Athenz, run the following: $ zms-cli list-domain The list-domain command also takes an optional prefix argument to filter the domains and only return those that start with the specified string. For example, if the user wants to list only the domains that have been configured in the athenz product domain, he/she will run the following command: $ zms-cli list-domain athenz domains: - athenz - athenz.ci - athenz.qa Displaying Administrators for a Product Domain \u00b6 To view the full list of administrators for a given domain, run the following: $ zms-cli -d <domain-name> show-role admin For example, to view the Athenz system administrators for the domain media.news : $ zms-cli -d media.news show-role admin Adding Domains \u00b6 The Top Level Product Domains in ZMS are provisioned by Athenz administrators. Once the Product Domain has been created, the designated domain administrators can create any subdomains as necessary. To create a new domain, the administrator uses the add-domain command: $ zms-cli add-domain <product sub domain> [ <admin1> <admin2> ... ] Parameters \u00b6 <domain> The name of the domain to be added, which could either be a product domain or a subdomain. For example, to add a subdomain called storage in the athenz domain, the value for <domain> would be athenz.storage . The parent domain must exist before a subdomain can be created. The domain name can only include any letters, digits and the '-' character. The maximum length of the domain name (including all subdomain parts) is 256 bytes. [<admin1> ...] A space-separated list of administrators for the domain. The user creating the domain is automatically added as an administrator. Examples \u00b6 If user joe executes the command below, the product domain coretech is created and will include user.joe as an administrator: $ zms-cli add-domain coretech When user joe executes the command below, the sub domain athenz.ci is created and will have the administrators yby.joe , yby.john , and yby.jane : $ zms-cli add-domain athenz.ci yby.john yby.jane Registering Personal Domains \u00b6 ZMS supports Personal Domains. These domains are provisioned for users in the User user domain and have the same functionality as Product Domains in Athenz. The Personal Domain uses the syntax user.<user-id> and can have configured number of subdomains (default 2). For example, if your user ID is joe and you'd like to create a Personal Domain, you would run the following command: $ zms-cli add-domain user.joe Then, to create a subdomain called athenz-test in your Personal Domain, you would run the following command: $ zms-cli add-domain user.joe.athenz-test If the user wants to list only his/her personal domains that have been registered, he/she will run the following command: $ zms-cli list-domain user.<user-id> Adding and Removing Administrators \u00b6 Domain administrators are the principals listed as members of the role admin . When you create a domain, the role and corresponding policy role are created. Administrators can manage the list of current domain administrators by adding or removing members in the admin role. To add one or more administrators: $ zms-cli -d <domain> add-member admin <user1> [ <user2> ... ] To remove existing domain administrators: $ zms-cli -d <domain> delete-member admin <user1> [ <user2> ... ] ZMS allows you to remove yourself from the admin role. Once you 've been removed, you' ll need to ask another domain administrator to re - add you to the `admin` role . Adding a Group Role \u00b6 To add new group role to a domain, the administrator will execute the following zms-cli command: $ zms-cli -d <domain> add-group-role <role> <member> [ <member> ... ] Parameters <domain> The name of the domain that the new role belongs to. <role> The name of the new role to be added. <member> [<member> ...] A space-separated list of members for the role. At least one member must be specified. If the member is a regular user, then user's id must be prefixed with user. . Once the group has been created, the administrator can add and/or delete members using the add-member and delete-member commands. Example \u00b6 When the domain administrator executes the command below, a new role called readers will be added to the the domain athenz.ci will have the following members: user - yby.john and service - media.sports.storage : $ zms-cli -d athenz.ci add-group-role readers yby.john media.sports.storage Managing a Group Role Membership \u00b6 To add and/or delete members to/from a given role in a domain, the administrator will execute the following zms-cli commands: $ zms-cli -d <domain> add-member <role> <member> [ <member> ... ] $ zms-cli -d <domain> delete-member <role> <member> [ <member> ... ] Parameters <domain> The name of the domain that the role belongs to. <role> The name of the role that will be modified to add or remove members. <member> [<member> ...] A space-separated list of members to be added to the role or to be removed from the role. At least one member must be specified. If the member is a regular user, the user's id must be prefixed with user. . When specifying service identities as members you must provide the full service name in then <domain-name>.<service-name> format. Example To add two new members: service \"media.sports.storage\" and user \"yby.john\", to a role called \"readers\" in the domain \"athenz\", the domain administrator will execute the following command: $ zms-cli -d athenz add-member readers yby.john media.sports.storage To delete member \"media.sports.storage\" from a role called \"writers\" in the domain \"athenz\", the domain administrator will execute the following command: $ zms-cli -d athenz delete-member writers media.sports.storage Adding a temporary Role Membership with expiration date \u00b6 To add a temporary member to a given role in a domain, the administrator will execute the following zms-cli commands: $ zms-cli -d <domain> add-temporary-member <role> <member> <expiration> Parameters <domain> The name of the domain that the role belongs to. <role> The name of the role that will be modified to add. <member> A member to be added to the role. Only one member must be specified. If the member is a regular user, the user's short id must be prefixed with user. . <expiration> Expiration date. It is expected to be in UTC timezone in the form of YYYY-MM-DDTHH:MM:SSZ - for example: 2017-03-02T15:04:00Z Example To add a new member: user user.john , to a role called readers in the domain sports.nhl , with expiration date set to 1PM UTC time on Sep. 3 rd , 2018, the domain administrator will execute the following command: $ zms-cli -d sports.nhl add-temporary-member readers user.john 2018-09-03T13:00:00Z Adding a Policy \u00b6 To add new policy to a domain, the administrator will execute the following zms-cli command: $ zms-cli -d <domain> add-policy <policy> [ <assertion> ] Parameters <domain> The name of the domain that the new policy belongs to. <policy> The name of the new policy to be added. [<assertion>] where <assertion> is '<effect> <action> to <role> on <resource>' The value effect must be either 'grant' or 'deny'. The action is the domain administrator defined action available for the resource (e.g. read, write, delete). The role is the name of the role this assertion applies to. The resource is the name of the resource this assertion applies to. Once the policy has been created, the administrator can add and/or delete assertions using the add-assertion and delete-assertion commands. Example When the domain administrator executes the command below, a new policy called writers will be added to the the domain athenz.ci that will grant write access to all the members of the sports_writers role on articles.sports.* : $ zms-cli -d athenz.ci add-policy writers grant write to sports_writers on 'articles.sports.*'","title":"ZMS Client Utility"},{"location":"zms_client/#zms-client-utility","text":"Overview Getting Software Prerequisites Getting Help Specifying ZMS Environments How the ZMS Client Authenticates Listing registered domains in Athenz Displaying Administrators for a Product Domain Adding Domains Parameters Examples Registering Personal Domains Adding and Removing Administrators Adding a Group Role Parameters Example Managing a Group Role Membership Parameters Example Adding a temporary Role Membership with expiration date Parameters Example Adding a Policy Parameters Example","title":"ZMS Client Utility"},{"location":"zms_client/#overview","text":"The ZMS client utility allows administrators to manage Athenz domains, to check domain details, create personal domains, and add other administrators.","title":"Overview"},{"location":"zms_client/#getting-software","text":"Download latest ZMS Client utility binary release from Bintray - click on the Files tab, choose the latest version directory and then download the athenz-utils-<latest-version>-bin.tar.gz file:: $ tar xvfz athenz-utils-X.Y-bin.tar.gz","title":"Getting Software"},{"location":"zms_client/#prerequisites","text":"Before you can use the ZMS client utility, you need to have asked the Athenz administrators to create your top level domain.","title":"Prerequisites"},{"location":"zms_client/#getting-help","text":"The help argument for the utility will display all commands available through utility. $ zms-cli help To get additional details about a specific command: $ zms - cli help [ command ] For example, to get complete details on how to add a domain including examples: $ zms-cli help add-domain","title":"Getting Help"},{"location":"zms_client/#specifying-zms-environments","text":"Use the -z option to point to the required environment for executing commands. $ zms-cli -z https://zms-server.athenzcompany.com:4443/zms/v1 -d athenz show-domain","title":"Specifying ZMS Environments"},{"location":"zms_client/#how-the-zms-client-authenticates","text":"The Athenz ZMS server requires the user to provide its UserToken or use a User certificate and private key for MTLS to authenticate with ZMS (depending on the Principal Authority used). ZMS will then authorize the request based on the configured authority.","title":"How the ZMS Client Authenticates"},{"location":"zms_client/#listing-registered-domains-in-athenz","text":"To find out what domains have been provisioned in Athenz, run the following: $ zms-cli list-domain The list-domain command also takes an optional prefix argument to filter the domains and only return those that start with the specified string. For example, if the user wants to list only the domains that have been configured in the athenz product domain, he/she will run the following command: $ zms-cli list-domain athenz domains: - athenz - athenz.ci - athenz.qa","title":"Listing registered domains in Athenz"},{"location":"zms_client/#displaying-administrators-for-a-product-domain","text":"To view the full list of administrators for a given domain, run the following: $ zms-cli -d <domain-name> show-role admin For example, to view the Athenz system administrators for the domain media.news : $ zms-cli -d media.news show-role admin","title":"Displaying Administrators for a Product Domain"},{"location":"zms_client/#adding-domains","text":"The Top Level Product Domains in ZMS are provisioned by Athenz administrators. Once the Product Domain has been created, the designated domain administrators can create any subdomains as necessary. To create a new domain, the administrator uses the add-domain command: $ zms-cli add-domain <product sub domain> [ <admin1> <admin2> ... ]","title":"Adding Domains"},{"location":"zms_client/#parameters","text":"<domain> The name of the domain to be added, which could either be a product domain or a subdomain. For example, to add a subdomain called storage in the athenz domain, the value for <domain> would be athenz.storage . The parent domain must exist before a subdomain can be created. The domain name can only include any letters, digits and the '-' character. The maximum length of the domain name (including all subdomain parts) is 256 bytes. [<admin1> ...] A space-separated list of administrators for the domain. The user creating the domain is automatically added as an administrator.","title":"Parameters"},{"location":"zms_client/#examples","text":"If user joe executes the command below, the product domain coretech is created and will include user.joe as an administrator: $ zms-cli add-domain coretech When user joe executes the command below, the sub domain athenz.ci is created and will have the administrators yby.joe , yby.john , and yby.jane : $ zms-cli add-domain athenz.ci yby.john yby.jane","title":"Examples"},{"location":"zms_client/#registering-personal-domains","text":"ZMS supports Personal Domains. These domains are provisioned for users in the User user domain and have the same functionality as Product Domains in Athenz. The Personal Domain uses the syntax user.<user-id> and can have configured number of subdomains (default 2). For example, if your user ID is joe and you'd like to create a Personal Domain, you would run the following command: $ zms-cli add-domain user.joe Then, to create a subdomain called athenz-test in your Personal Domain, you would run the following command: $ zms-cli add-domain user.joe.athenz-test If the user wants to list only his/her personal domains that have been registered, he/she will run the following command: $ zms-cli list-domain user.<user-id>","title":"Registering Personal Domains"},{"location":"zms_client/#adding-and-removing-administrators","text":"Domain administrators are the principals listed as members of the role admin . When you create a domain, the role and corresponding policy role are created. Administrators can manage the list of current domain administrators by adding or removing members in the admin role. To add one or more administrators: $ zms-cli -d <domain> add-member admin <user1> [ <user2> ... ] To remove existing domain administrators: $ zms-cli -d <domain> delete-member admin <user1> [ <user2> ... ] ZMS allows you to remove yourself from the admin role. Once you 've been removed, you' ll need to ask another domain administrator to re - add you to the `admin` role .","title":"Adding and Removing Administrators"},{"location":"zms_client/#adding-a-group-role","text":"To add new group role to a domain, the administrator will execute the following zms-cli command: $ zms-cli -d <domain> add-group-role <role> <member> [ <member> ... ]","title":"Adding a Group Role"},{"location":"zms_client/#example","text":"When the domain administrator executes the command below, a new role called readers will be added to the the domain athenz.ci will have the following members: user - yby.john and service - media.sports.storage : $ zms-cli -d athenz.ci add-group-role readers yby.john media.sports.storage","title":"Example"},{"location":"zms_client/#managing-a-group-role-membership","text":"To add and/or delete members to/from a given role in a domain, the administrator will execute the following zms-cli commands: $ zms-cli -d <domain> add-member <role> <member> [ <member> ... ] $ zms-cli -d <domain> delete-member <role> <member> [ <member> ... ]","title":"Managing a Group Role Membership"},{"location":"zms_client/#adding-a-temporary-role-membership-with-expiration-date","text":"To add a temporary member to a given role in a domain, the administrator will execute the following zms-cli commands: $ zms-cli -d <domain> add-temporary-member <role> <member> <expiration>","title":"Adding a temporary Role Membership with expiration date"},{"location":"zms_client/#adding-a-policy","text":"To add new policy to a domain, the administrator will execute the following zms-cli command: $ zms-cli -d <domain> add-policy <policy> [ <assertion> ]","title":"Adding a Policy"},{"location":"zpu_policy_file/","text":"ZPU Policy File \u00b6 Policy File Signature Validation ZTS Signature Validation ZMS Signature Validation Policy File Structure ZPU is only needed to support decentralized authorization. The policy updater is the utility that retrieves from ZTS the policy files for provisioned domains on a host, which ZPE uses to evaluate access requests. The ZPE library automatically parses the policy file, validates it, and uses it for authorization checks. This document describes the format and how to validate the policy file. Policy File Signature Validation \u00b6 The policy file data which is provided in json format is signed by both ZMS and ZTS servers since ZMS is the authority on policy data but the file is downloaded from ZTS servers. ZTS Signature Validation \u00b6 To validate the ZTS signature, the json is presented in the following structure: {\"signedPolicyData\":<zts-data>,\"keyId\":\"<key-id>,\"signature\":\"<signature>\"} a) Extract the <key-id> and fetch the public key with that key identifier from Athenz for service zts in domain sys.auth . For example, using zms-cli command line utility: $ zms-cli -d sys.auth show-public-key zts zts1.0 public-key: keyID: zts1.0 value: LS0tLS1CRUdJTiBQVUJMSUMgS0VZLS0tLS0KTUZrd0V...WS0tLS0tCg-- The public key is encoded in YBase64 encoding so it must be decoded before the public key can be used to validate the signature. Checkout YBase64 class implemenation in athenz-auth-core library for details. b) Validate the signature of the extracted <zts-data> string using Bouncycastle. <signature> field is also YBase64 encoded, so it must be decoded before using in the verify function. 1) Load the public key retrieved in step (a) and generate a PublicKey object. 2) Generate the signature algorithm based on the public key algorithm. ZTS server is using SHA256 digest algorithm with either RSA or ECSDA keys so the possible values are either RSA_SHA256 or ECDSA_SHA256. 3) Generate a signer and verify the signature (include proper exception handling): java.security.Signature signer = java.security.Signature.getInstance(signatureAlgorithm, BC_PROVIDER); signer.initVerify(publicKey); signer.update(utf8Bytes(ztsData)); boolean valid = signer.verify(signature); ZMS Signature Validation \u00b6 To validate the ZMS signature, we need to further parse the <zts-data> object we retrieved in the ZTS Signture validation section. That json has the following structure: {\"expires\":\"<expiry-date>\",\"modified\":\"<modified-date>\",\"policyData\":<zms-data>,\"zmsKeyId\":\"<key-id>,\"zmsSignature\":\"<signature>\"} a) Extract the <key-id> and fetch the public key with that key identifier from Athenz for service zms in domain sys.auth . For example, using zms-cli command line utility: $ zms-cli -d sys.auth show-public-key zms zms1.0 public-key: keyID: zms1.0 value: LS0tLS1CRUdJTiBQVUJMSUMgS0VZLS0tLS0KTUZrd0V...WS0tLS0tCg-- The public key is encoded in YBase64 encoding so it must be decoded before the public key can be used to validate the signature. Checkout YBase64 class implemenation in athenz-auth-core library for details. b) Validate the signature of the extracted <zms-data> string using Bouncycastle. <signature> field is also YBase64 encoded, so it must be decoded before using in the verify function. 1) Load the public key retrieved in step (a) and generate a PublicKey object. 2) Generate the signature algorithm based on the public key algorithm. ZMS server is using SHA256 digest algorithm with either RSA or ECSDA keys so the possible values are either RSA_SHA256 or ECDSA_SHA256. 3) Generate a signer and verify the signature (include proper exception handling): java.security.Signature signer = java.security.Signature.getInstance(signatureAlgorithm, BC_PROVIDER); signer.initVerify(publicKey); signer.update(utf8Bytes(zmsData)); boolean valid = signer.verify(signature); Policy File Structure \u00b6 Athenz Services are using RDL to represent its objects. These should directly map to json objects: type DomainSignedPolicyData Struct { SignedPolicyData signedPolicyData; //policy data signed by ZMS String signature; //signature generated based on the domain policies object String keyId; //the identifier of the key used to generate the signature } type SignedPolicyData Struct { PolicyData policyData; //list of policies defined in a domain String zmsSignature; //zms signature generated based on the domain policies object String zmsKeyId; //the identifier of the zms key used to generate the signature Timestamp modified; //when the domain itself was last modified Timestamp expires; //timestamp specifying the expiration time for using this set of policies } type PolicyData Struct { DomainName domain; //name of the domain Array<Policy> policies; //list of policies defined in this server } type Policy Struct { ResourceName name; //name of the policy Timestamp modified (optional); //last modification timestamp of this policy Array<Assertion> assertions; //list of defined assertions for this policy } type Assertion Struct { String role; //the subject of the assertion, a role String resource; //the object of the assertion. Must be in the local namespace. Can contain wildcards String action; //the predicate of the assertion. Can contain wildcards AssertionEffect effect (optional, default=ALLOW); //the effect of the assertion in the policy language Int64 id (optional); //assertion id - auto generated by server } type AssertionEffect Enum { ALLOW, DENY } DomainName and ResourceName reference regular Strings. The zts java model classes are available in the athenz-zts-core library. <dependencies> <dependency> <groupId>com.yahoo.athenz</groupId> <artifactId>athenz-zts-core</artifactId> <version>1.7.51</version> </dependency> </dependencies> <repositories> <repository> <snapshots> <enabled>false</enabled> </snapshots> <id>bintray-yahoo-maven</id> <name>bintray</name> <url>https://yahoo.bintray.com/maven</url> </repository> </repositories>","title":"ZPU Policy File"},{"location":"zpu_policy_file/#zpu-policy-file","text":"Policy File Signature Validation ZTS Signature Validation ZMS Signature Validation Policy File Structure ZPU is only needed to support decentralized authorization. The policy updater is the utility that retrieves from ZTS the policy files for provisioned domains on a host, which ZPE uses to evaluate access requests. The ZPE library automatically parses the policy file, validates it, and uses it for authorization checks. This document describes the format and how to validate the policy file.","title":"ZPU Policy File"},{"location":"zpu_policy_file/#policy-file-signature-validation","text":"The policy file data which is provided in json format is signed by both ZMS and ZTS servers since ZMS is the authority on policy data but the file is downloaded from ZTS servers.","title":"Policy File Signature Validation"},{"location":"zpu_policy_file/#zts-signature-validation","text":"To validate the ZTS signature, the json is presented in the following structure: {\"signedPolicyData\":<zts-data>,\"keyId\":\"<key-id>,\"signature\":\"<signature>\"} a) Extract the <key-id> and fetch the public key with that key identifier from Athenz for service zts in domain sys.auth . For example, using zms-cli command line utility: $ zms-cli -d sys.auth show-public-key zts zts1.0 public-key: keyID: zts1.0 value: LS0tLS1CRUdJTiBQVUJMSUMgS0VZLS0tLS0KTUZrd0V...WS0tLS0tCg-- The public key is encoded in YBase64 encoding so it must be decoded before the public key can be used to validate the signature. Checkout YBase64 class implemenation in athenz-auth-core library for details. b) Validate the signature of the extracted <zts-data> string using Bouncycastle. <signature> field is also YBase64 encoded, so it must be decoded before using in the verify function. 1) Load the public key retrieved in step (a) and generate a PublicKey object. 2) Generate the signature algorithm based on the public key algorithm. ZTS server is using SHA256 digest algorithm with either RSA or ECSDA keys so the possible values are either RSA_SHA256 or ECDSA_SHA256. 3) Generate a signer and verify the signature (include proper exception handling): java.security.Signature signer = java.security.Signature.getInstance(signatureAlgorithm, BC_PROVIDER); signer.initVerify(publicKey); signer.update(utf8Bytes(ztsData)); boolean valid = signer.verify(signature);","title":"ZTS Signature Validation"},{"location":"zpu_policy_file/#zms-signature-validation","text":"To validate the ZMS signature, we need to further parse the <zts-data> object we retrieved in the ZTS Signture validation section. That json has the following structure: {\"expires\":\"<expiry-date>\",\"modified\":\"<modified-date>\",\"policyData\":<zms-data>,\"zmsKeyId\":\"<key-id>,\"zmsSignature\":\"<signature>\"} a) Extract the <key-id> and fetch the public key with that key identifier from Athenz for service zms in domain sys.auth . For example, using zms-cli command line utility: $ zms-cli -d sys.auth show-public-key zms zms1.0 public-key: keyID: zms1.0 value: LS0tLS1CRUdJTiBQVUJMSUMgS0VZLS0tLS0KTUZrd0V...WS0tLS0tCg-- The public key is encoded in YBase64 encoding so it must be decoded before the public key can be used to validate the signature. Checkout YBase64 class implemenation in athenz-auth-core library for details. b) Validate the signature of the extracted <zms-data> string using Bouncycastle. <signature> field is also YBase64 encoded, so it must be decoded before using in the verify function. 1) Load the public key retrieved in step (a) and generate a PublicKey object. 2) Generate the signature algorithm based on the public key algorithm. ZMS server is using SHA256 digest algorithm with either RSA or ECSDA keys so the possible values are either RSA_SHA256 or ECDSA_SHA256. 3) Generate a signer and verify the signature (include proper exception handling): java.security.Signature signer = java.security.Signature.getInstance(signatureAlgorithm, BC_PROVIDER); signer.initVerify(publicKey); signer.update(utf8Bytes(zmsData)); boolean valid = signer.verify(signature);","title":"ZMS Signature Validation"},{"location":"zpu_policy_file/#policy-file-structure","text":"Athenz Services are using RDL to represent its objects. These should directly map to json objects: type DomainSignedPolicyData Struct { SignedPolicyData signedPolicyData; //policy data signed by ZMS String signature; //signature generated based on the domain policies object String keyId; //the identifier of the key used to generate the signature } type SignedPolicyData Struct { PolicyData policyData; //list of policies defined in a domain String zmsSignature; //zms signature generated based on the domain policies object String zmsKeyId; //the identifier of the zms key used to generate the signature Timestamp modified; //when the domain itself was last modified Timestamp expires; //timestamp specifying the expiration time for using this set of policies } type PolicyData Struct { DomainName domain; //name of the domain Array<Policy> policies; //list of policies defined in this server } type Policy Struct { ResourceName name; //name of the policy Timestamp modified (optional); //last modification timestamp of this policy Array<Assertion> assertions; //list of defined assertions for this policy } type Assertion Struct { String role; //the subject of the assertion, a role String resource; //the object of the assertion. Must be in the local namespace. Can contain wildcards String action; //the predicate of the assertion. Can contain wildcards AssertionEffect effect (optional, default=ALLOW); //the effect of the assertion in the policy language Int64 id (optional); //assertion id - auto generated by server } type AssertionEffect Enum { ALLOW, DENY } DomainName and ResourceName reference regular Strings. The zts java model classes are available in the athenz-zts-core library. <dependencies> <dependency> <groupId>com.yahoo.athenz</groupId> <artifactId>athenz-zts-core</artifactId> <version>1.7.51</version> </dependency> </dependencies> <repositories> <repository> <snapshots> <enabled>false</enabled> </snapshots> <id>bintray-yahoo-maven</id> <name>bintray</name> <url>https://yahoo.bintray.com/maven</url> </repository> </repositories>","title":"Policy File Structure"},{"location":"zts_access_token_guide/","text":"Access Tokens are used to authorize access to service provider resources. The Access Token contains the set of roles (identified in the token as scopes) a client belongs to for a specified domain. So, when a client wants to access a resource, this client must obtain the appropriate Access Token from ZTS and use the token in the header of the subsequent HTTP client request. If enabled, the service will also return an ID Token if requested. ID Token identifies the authenticated principal for a given Athenz Service Identity. Support for accessing OAuth2 access/id tokens is based on Client Credentials authentication workflow as defined in RFC6749: The OAuth 2.0 Authorization Framework . Access/ID Token Request \u00b6 Request \u00b6 To request an access token from ZTS Server, the client will send a POST request with application/x-www-form-urlencoded content-type to /oauth2/token endpoint. The request body must contain the following parameters: grant_type : Value MUST be set to \"client_credentials\" scope : list of scopes/roles requested in the access token. The caller can either specify to include all roles the principal has access to in a specific domain (e.g. <domain-name>:domain) or ask for specific roles only (e.g. <domain-name>:role.<role1>). Scopes are separated by spaces. To request an ID token, the scope must include 'openid' and audience service name (e.g. <domain-name>:service.<service-name>). The domain name in id token request match the domain name in the access token scope. expires_in : requested expiry time for access token in seconds For example, when a principal requests an access token only for accessing demo domain and wants to include all roles it has access to in that domain, the request would be: POST /zts/v1/oauth2/token HTTP/1.1 Host: <zts-address> Content-Type: application/x-www-form-urlencoded grant_type=client_credentials&scope=demo%3Adomain If the principal requests an access token only for accessing demo domain and wants to include readers and writers roles it has access to in that domain, the request would be: POST /zts/v1/oauth2/token HTTP/1.1 Host: <zts-address> Content-Type: application/x-www-form-urlencoded grant_type=client_credentials&scope=demo%3Arole.readers+sherpa%3Arole.writers If the principal requests an access token along with an id token for accessing demo domain for backend service and wants to include readers and writers roles it has access to in that domain, the request would be: POST /zts/v1/oauth2/token HTTP/1.1 Host: <zts-address> Content-Type: application/x-www-form-urlencoded grant_type=client_credentials&scope=openid+demo%3Aservice.backend+demo%3Arole.readers+demo%3Arole.writers Response \u00b6 If the access token request is valid and authorized, the ZTS server issues an access token (and id token if requested). The response contains the following json document: { \"access_token\":\"<generated-token>\", \"id_token\":\"<generated-token>\", \"token_type\":\"Bearer\", \"expires_in\":3600 } Access Token format \u00b6 An access token is a JSON web token (JWT) encoded in Base64 URL-encoded format that contains a header, payload, and signature. An application server can authorize the principal to access specific resources based on the scopes (roles) defined in the access token. Access Token Header \u00b6 The Access token header contains the Athenz ZTS Server Private key id and the algorithm used to sign the payload. { \"alg\": \"ES256\", \"kid\": \"<zts server private key id>\" } Access Token Payload \u00b6 The Access Token Payload contains the following claims: ver : version of the access token iss : token issuer aud : the audience (the Athenz Domain name) that the access token is intended for uid : unique identifier for the principal (same as client Id) sub : subject of the access token (same as client Id) iat : token issue time in seconds (Unix time) exp : token expiry time in seconds (Unix time) scp : array of scopes are granted to this access token. This is the list of roles that principal can assume in the audience domain client_id : client ID (Athenz Principal) of the client that requested the access token Here is an example of an access token that alpha.api retrieved to access some resource in beta domain. The principal alpha.api is authorized to assume readers and writers roles in the beta domain. { \"ver\": 1, \"iss\": \"athenz\", \"aud\": \"beta\", \"client_id\": \"alpha.api\", \"uid\": \"alpha.api\", \"sub\": \"alpha.api\", \"iat\": 1554491974, \"exp\": 1554495574, \"scp\": [ \"readers\", \"writers\" ] } Access Token Validation \u00b6 You can use any standards based JWT library to validate the access token generated by ZTS Server. You can also implement your own verifier by following the RFC7519: Section 7.2: Validating a JWT . ID Token format \u00b6 An ID token is a JSON web token (JWT) encoded in Base64 URL-encoded format that contains a header, payload, and signature. The ID token, if enabled, can be issued for clients to authenticate themselves along with their access token to the requested Athenz service. ZTS Server never issues ID Tokens on its own. They're always returned along with access tokens. ID Token Header \u00b6 The ID token header contains the Athenz ZTS Server Private key id and the algorithm used to sign the payload. { \"alg\": \"ES256\", \"kid\": \"<zts server private key id>\" } ID Token Payload \u00b6 The ID Token Payload contains the following claims: ver : version of the id token iss : token issuer aud : the audience (the Athenz Service name) that the id token is intended for sub : subject of the id token - athenz pricnipal name requesting the token iat : token issue time in seconds (Unix time) exp : token expiry time in seconds (Unix time) auth_time: authentication time in seconds (Unix time) Here is an example of an id token that alpha.api retrieved for its authorization request to beta.backend service. { \"ver\": 1, \"iss\": \"athenz\", \"aud\": \"beta.backend\", \"sub\": \"alpha.api\", \"iat\": 1554491974, \"auth_time\": 1554491974, \"exp\": 1554495574 } ID Token Validation \u00b6 You can use any standards based JWT library to validate the id token generated by ZTS Server. You can also implement your own verifier by following the RFC7519: Section 7.2: Validating a JWT . Fetching Access Tokens with Java Client Library \u00b6 First you need to update your Java project pom.xml file to indicate the dependency on the Athenz zts java client library. Checkout the Bintray ZTS Java Client Package page to make sure you're using the latest release version (You must use 1.8.37 or newer version of the client library). ZTS Client Object \u00b6 ZTS Client Library provides several constructors. The recommended approach is to use an SSL context that includes service's Athenz issued CA certificate. ZTSClient object must be closed to release any allocated resources. ZTSClient class implements Closeable interface. However, to correctly handle auto-refresh of access tokens, the client used to fetch the token cannot be closed since the background tasks need to use the same client to refresh the access token. Our general recommendation is that you create a single ZTSClient object and use that for all requests (it is thread safe) and then close the client when your application is shutting down. ** Important ** During the shutdown of the application, ZTSClient.cancelPrefetch() must be called to stop the timer thread that automatically fetches and refreshes any cached tokens in the ZTS Client. Athenz Issued CA certificate \u00b6 You will need to provide the ZTSClient with the ZTS Server's URL and an SSLContext. The following examples will show how to generate an SSLContext /** * Constructs a new ZTSClient object with the given SSLContext object * and ZTS Server Url. Default read and connect timeout values are * 30000ms (30sec). The application can change these values by using the * athenz.zts.client.read_timeout and athenz.zts.client.connect_timeout * system properties. The values specified for timeouts must be in milliseconds. * @param ztsUrl ZTS Server's URL * @param sslContext SSLContext that includes service's private key and x.509 certificate * for authenticating requests */ public ZTSClient ( String ztsUrl , SSLContext sslContext ); First update your pom.xml to include dependency on athenz-cert-refresher package which provides support to create a SSLContext object based on our private key and certificate: < dependency > < groupId > com . yahoo . athenz </ groupId > < artifactId > athenz - cert - refresher </ artifactId > < version > VERSION - NUMBER </ version > </ dependency > The SSLContext contains a KeyRefresher with the following arguments: - The service private key - The service public key - The path of the truststore containing the CA certificate - The password for the truststore containing the CA certificate For example: // Create our SSL Context object based on our private key and // certificate and jdk truststore KeyRefresher keyRefresher = Utils . generateKeyRefresher ( trustStorePath , trustStorePassword , certPath , keyPath ); SSLContext sslContext = Utils . buildSSLContext ( keyRefresher . getKeyManagerProxy (), keyRefresher . getTrustManagerProxy ()); keyRefresher . startup (); ZTSClient ztsClient = new ZTSClient ( ztsUrl , sslContext ); Obtaining an Access Token \u00b6 To obtain an Access Token, the application would use the following method from the ZTSClient class: /** * For the specified requester(user/service) return the corresponding Access Token that * includes the list of roles that the principal has access to in the specified domain * @param domainName name of the domain * @param roleNames (optional) only interested in roles with these names * @param expiryTime (optional) specifies that the returned Access must be * at least valid for specified number of seconds. Pass 0 to use * server default timeout. * @return ZTS generated Access Token Response object. ZTSClientException will be thrown in case of failure */ public AccessTokenResponse getAccessToken ( String domainName , List < String > roleNames , long expiryTime ); In the simplest case, the method only requires the caller to specify the domain that the application will be accessing. Thus, it needs an Access Token for that domain. For example, if the alpha.storage service identifier is trying to access a resource from a domain beta , then the API call to retrieve the access token valid for 4 hours would be the following: AccessTokenResponse tokenResponse = null ; try { tokenResponse = ztsClient . getAccessToken ( \"beta\" , null , 14400 ); } catch ( ZTSClientException ex ) { // log error using ex.getCode() and ex.getMessage() } final String accessToken = tokenResponse . getAccess_token (); Then the client will include the retrieved Access Token value as one of its headers when submitting its request to the provider service. Token Caching \u00b6 The ZTS Client Library automatically caches any tokens returned by the ZTS Server, so any subsequent requests for an Access Token for the same domain are fulfilled from the local cache as opposed to connecting to the ZTS Server every time. This provides better performance by reusing the same Access Token because they\u2019re valid for two hours by default. The client library will only return cached Access Tokens if they\u2019re valid for at least \u00bc of the requested timeout in minutes (default 30 minutes). Least Privilege Access \u00b6 By default, the method getAccess returns all the roles that the given service identity can access within a domain. The method, however, has the roleNames parameter that allow applications to request access tokens for specific roles within a domain. Thus, the server need only check and return an access token for the specified roles. For example, the service has access to several roles within the alpha domain but is only interested in two roles readers and searchers . With this use case, the api call would be: AccessTokenResponse tokenResponse = null ; List < String > roles = new ArrayList <> (); roles . add ( \"readers); roles.add(\" searchers \"); try { tokenResponse = ztsClient.getAccessToken(\" alpha \", roles, 14400); } catch (ZTSClientException ex) { // log error using ex.getCode() and ex.getMessage() } final String accessToken = tokenResponse.getAccess_token(); Command Line Utility to Fetch Access Tokens \u00b6 Athenz team also provides a command line utility called zts-accesstoken that can be used to fetch access/id tokens from the ZTS Server for a given domain and/or specific roles. $ zts-accesstoken -domain alpha.prod -service api -svc-key-file beta.api.key.pem -svc-cert-file beta.api.cert.pem -zts https://<zts-address>/zts/v1 Check out the zts-accesstoken user guide for full details. Troubleshooting \u00b6 When communicating with ZTS Server to obtain an Access Token, the ZTS Server will return the following 4xx error codes if it's unable to successfully process the request: 400 The domain name specified in the request to issue an access token is inconsistent with other scopes. 401 The request could not be successfully authenticated. 403 The service identity does not have access to any resources in the specified domain. 404 The domain specified in the request to issue an Access Token for does not exist.","title":"Obtaining OAuth2 Access Tokens from ZTS"},{"location":"zts_access_token_guide/#accessid-token-request","text":"","title":"Access/ID Token Request"},{"location":"zts_access_token_guide/#request","text":"To request an access token from ZTS Server, the client will send a POST request with application/x-www-form-urlencoded content-type to /oauth2/token endpoint. The request body must contain the following parameters: grant_type : Value MUST be set to \"client_credentials\" scope : list of scopes/roles requested in the access token. The caller can either specify to include all roles the principal has access to in a specific domain (e.g. <domain-name>:domain) or ask for specific roles only (e.g. <domain-name>:role.<role1>). Scopes are separated by spaces. To request an ID token, the scope must include 'openid' and audience service name (e.g. <domain-name>:service.<service-name>). The domain name in id token request match the domain name in the access token scope. expires_in : requested expiry time for access token in seconds For example, when a principal requests an access token only for accessing demo domain and wants to include all roles it has access to in that domain, the request would be: POST /zts/v1/oauth2/token HTTP/1.1 Host: <zts-address> Content-Type: application/x-www-form-urlencoded grant_type=client_credentials&scope=demo%3Adomain If the principal requests an access token only for accessing demo domain and wants to include readers and writers roles it has access to in that domain, the request would be: POST /zts/v1/oauth2/token HTTP/1.1 Host: <zts-address> Content-Type: application/x-www-form-urlencoded grant_type=client_credentials&scope=demo%3Arole.readers+sherpa%3Arole.writers If the principal requests an access token along with an id token for accessing demo domain for backend service and wants to include readers and writers roles it has access to in that domain, the request would be: POST /zts/v1/oauth2/token HTTP/1.1 Host: <zts-address> Content-Type: application/x-www-form-urlencoded grant_type=client_credentials&scope=openid+demo%3Aservice.backend+demo%3Arole.readers+demo%3Arole.writers","title":"Request"},{"location":"zts_access_token_guide/#response","text":"If the access token request is valid and authorized, the ZTS server issues an access token (and id token if requested). The response contains the following json document: { \"access_token\":\"<generated-token>\", \"id_token\":\"<generated-token>\", \"token_type\":\"Bearer\", \"expires_in\":3600 }","title":"Response"},{"location":"zts_access_token_guide/#access-token-format","text":"An access token is a JSON web token (JWT) encoded in Base64 URL-encoded format that contains a header, payload, and signature. An application server can authorize the principal to access specific resources based on the scopes (roles) defined in the access token.","title":"Access Token format"},{"location":"zts_access_token_guide/#access-token-header","text":"The Access token header contains the Athenz ZTS Server Private key id and the algorithm used to sign the payload. { \"alg\": \"ES256\", \"kid\": \"<zts server private key id>\" }","title":"Access Token Header"},{"location":"zts_access_token_guide/#access-token-payload","text":"The Access Token Payload contains the following claims: ver : version of the access token iss : token issuer aud : the audience (the Athenz Domain name) that the access token is intended for uid : unique identifier for the principal (same as client Id) sub : subject of the access token (same as client Id) iat : token issue time in seconds (Unix time) exp : token expiry time in seconds (Unix time) scp : array of scopes are granted to this access token. This is the list of roles that principal can assume in the audience domain client_id : client ID (Athenz Principal) of the client that requested the access token Here is an example of an access token that alpha.api retrieved to access some resource in beta domain. The principal alpha.api is authorized to assume readers and writers roles in the beta domain. { \"ver\": 1, \"iss\": \"athenz\", \"aud\": \"beta\", \"client_id\": \"alpha.api\", \"uid\": \"alpha.api\", \"sub\": \"alpha.api\", \"iat\": 1554491974, \"exp\": 1554495574, \"scp\": [ \"readers\", \"writers\" ] }","title":"Access Token Payload"},{"location":"zts_access_token_guide/#access-token-validation","text":"You can use any standards based JWT library to validate the access token generated by ZTS Server. You can also implement your own verifier by following the RFC7519: Section 7.2: Validating a JWT .","title":"Access Token Validation"},{"location":"zts_access_token_guide/#id-token-format","text":"An ID token is a JSON web token (JWT) encoded in Base64 URL-encoded format that contains a header, payload, and signature. The ID token, if enabled, can be issued for clients to authenticate themselves along with their access token to the requested Athenz service. ZTS Server never issues ID Tokens on its own. They're always returned along with access tokens.","title":"ID Token format"},{"location":"zts_access_token_guide/#id-token-header","text":"The ID token header contains the Athenz ZTS Server Private key id and the algorithm used to sign the payload. { \"alg\": \"ES256\", \"kid\": \"<zts server private key id>\" }","title":"ID Token Header"},{"location":"zts_access_token_guide/#id-token-payload","text":"The ID Token Payload contains the following claims: ver : version of the id token iss : token issuer aud : the audience (the Athenz Service name) that the id token is intended for sub : subject of the id token - athenz pricnipal name requesting the token iat : token issue time in seconds (Unix time) exp : token expiry time in seconds (Unix time) auth_time: authentication time in seconds (Unix time) Here is an example of an id token that alpha.api retrieved for its authorization request to beta.backend service. { \"ver\": 1, \"iss\": \"athenz\", \"aud\": \"beta.backend\", \"sub\": \"alpha.api\", \"iat\": 1554491974, \"auth_time\": 1554491974, \"exp\": 1554495574 }","title":"ID Token Payload"},{"location":"zts_access_token_guide/#id-token-validation","text":"You can use any standards based JWT library to validate the id token generated by ZTS Server. You can also implement your own verifier by following the RFC7519: Section 7.2: Validating a JWT .","title":"ID Token Validation"},{"location":"zts_access_token_guide/#fetching-access-tokens-with-java-client-library","text":"First you need to update your Java project pom.xml file to indicate the dependency on the Athenz zts java client library. Checkout the Bintray ZTS Java Client Package page to make sure you're using the latest release version (You must use 1.8.37 or newer version of the client library).","title":"Fetching Access Tokens with Java Client Library"},{"location":"zts_access_token_guide/#zts-client-object","text":"ZTS Client Library provides several constructors. The recommended approach is to use an SSL context that includes service's Athenz issued CA certificate. ZTSClient object must be closed to release any allocated resources. ZTSClient class implements Closeable interface. However, to correctly handle auto-refresh of access tokens, the client used to fetch the token cannot be closed since the background tasks need to use the same client to refresh the access token. Our general recommendation is that you create a single ZTSClient object and use that for all requests (it is thread safe) and then close the client when your application is shutting down. ** Important ** During the shutdown of the application, ZTSClient.cancelPrefetch() must be called to stop the timer thread that automatically fetches and refreshes any cached tokens in the ZTS Client.","title":"ZTS Client Object"},{"location":"zts_access_token_guide/#athenz-issued-ca-certificate","text":"You will need to provide the ZTSClient with the ZTS Server's URL and an SSLContext. The following examples will show how to generate an SSLContext /** * Constructs a new ZTSClient object with the given SSLContext object * and ZTS Server Url. Default read and connect timeout values are * 30000ms (30sec). The application can change these values by using the * athenz.zts.client.read_timeout and athenz.zts.client.connect_timeout * system properties. The values specified for timeouts must be in milliseconds. * @param ztsUrl ZTS Server's URL * @param sslContext SSLContext that includes service's private key and x.509 certificate * for authenticating requests */ public ZTSClient ( String ztsUrl , SSLContext sslContext ); First update your pom.xml to include dependency on athenz-cert-refresher package which provides support to create a SSLContext object based on our private key and certificate: < dependency > < groupId > com . yahoo . athenz </ groupId > < artifactId > athenz - cert - refresher </ artifactId > < version > VERSION - NUMBER </ version > </ dependency > The SSLContext contains a KeyRefresher with the following arguments: - The service private key - The service public key - The path of the truststore containing the CA certificate - The password for the truststore containing the CA certificate For example: // Create our SSL Context object based on our private key and // certificate and jdk truststore KeyRefresher keyRefresher = Utils . generateKeyRefresher ( trustStorePath , trustStorePassword , certPath , keyPath ); SSLContext sslContext = Utils . buildSSLContext ( keyRefresher . getKeyManagerProxy (), keyRefresher . getTrustManagerProxy ()); keyRefresher . startup (); ZTSClient ztsClient = new ZTSClient ( ztsUrl , sslContext );","title":"Athenz Issued CA certificate"},{"location":"zts_access_token_guide/#obtaining-an-access-token","text":"To obtain an Access Token, the application would use the following method from the ZTSClient class: /** * For the specified requester(user/service) return the corresponding Access Token that * includes the list of roles that the principal has access to in the specified domain * @param domainName name of the domain * @param roleNames (optional) only interested in roles with these names * @param expiryTime (optional) specifies that the returned Access must be * at least valid for specified number of seconds. Pass 0 to use * server default timeout. * @return ZTS generated Access Token Response object. ZTSClientException will be thrown in case of failure */ public AccessTokenResponse getAccessToken ( String domainName , List < String > roleNames , long expiryTime ); In the simplest case, the method only requires the caller to specify the domain that the application will be accessing. Thus, it needs an Access Token for that domain. For example, if the alpha.storage service identifier is trying to access a resource from a domain beta , then the API call to retrieve the access token valid for 4 hours would be the following: AccessTokenResponse tokenResponse = null ; try { tokenResponse = ztsClient . getAccessToken ( \"beta\" , null , 14400 ); } catch ( ZTSClientException ex ) { // log error using ex.getCode() and ex.getMessage() } final String accessToken = tokenResponse . getAccess_token (); Then the client will include the retrieved Access Token value as one of its headers when submitting its request to the provider service.","title":"Obtaining an Access Token"},{"location":"zts_access_token_guide/#token-caching","text":"The ZTS Client Library automatically caches any tokens returned by the ZTS Server, so any subsequent requests for an Access Token for the same domain are fulfilled from the local cache as opposed to connecting to the ZTS Server every time. This provides better performance by reusing the same Access Token because they\u2019re valid for two hours by default. The client library will only return cached Access Tokens if they\u2019re valid for at least \u00bc of the requested timeout in minutes (default 30 minutes).","title":"Token Caching"},{"location":"zts_access_token_guide/#least-privilege-access","text":"By default, the method getAccess returns all the roles that the given service identity can access within a domain. The method, however, has the roleNames parameter that allow applications to request access tokens for specific roles within a domain. Thus, the server need only check and return an access token for the specified roles. For example, the service has access to several roles within the alpha domain but is only interested in two roles readers and searchers . With this use case, the api call would be: AccessTokenResponse tokenResponse = null ; List < String > roles = new ArrayList <> (); roles . add ( \"readers); roles.add(\" searchers \"); try { tokenResponse = ztsClient.getAccessToken(\" alpha \", roles, 14400); } catch (ZTSClientException ex) { // log error using ex.getCode() and ex.getMessage() } final String accessToken = tokenResponse.getAccess_token();","title":"Least Privilege Access"},{"location":"zts_access_token_guide/#command-line-utility-to-fetch-access-tokens","text":"Athenz team also provides a command line utility called zts-accesstoken that can be used to fetch access/id tokens from the ZTS Server for a given domain and/or specific roles. $ zts-accesstoken -domain alpha.prod -service api -svc-key-file beta.api.key.pem -svc-cert-file beta.api.cert.pem -zts https://<zts-address>/zts/v1 Check out the zts-accesstoken user guide for full details.","title":"Command Line Utility to Fetch Access Tokens"},{"location":"zts_access_token_guide/#troubleshooting","text":"When communicating with ZTS Server to obtain an Access Token, the ZTS Server will return the following 4xx error codes if it's unable to successfully process the request: 400 The domain name specified in the request to issue an access token is inconsistent with other scopes. 401 The request could not be successfully authenticated. 403 The service identity does not have access to any resources in the specified domain. 404 The domain specified in the request to issue an Access Token for does not exist.","title":"Troubleshooting"},{"location":"zts_accesstoken/","text":"Overview Getting Software Prerequisites Usage Overview \u00b6 ZTS OAuth2 Access Token Client application in Go to request an access token from ZTS Server for the given identity to access a role in a provider domain. Getting Software \u00b6 Download latest ZTS OAuth2 Access Token Client binary release from Bintray - click on the Files tab, choose the latest version directory and then download the athenz-utils-<latest-version>-bin.tar.gz file:: $ tar xvfz athenz-utils-X.Y-bin.tar.gz Prerequisites \u00b6 Before you can use the ZTS AccessToken utility, you need to have asked the Athenz administrators to create your top level domain. Usage \u00b6 An access token from ZTS service can be fetched using Service Identity x.509 certificates. The optional expire-time argument specifies how long the access token should be valid for. The value must be specified in minutes. The default if no value is specified is 120 minutes. The optional roles argument requests an access token for the given roles only (comma separated) as opposed to all the roles the service identity has access to in the requested domain. The optional service argument requests an id token for the given service. The full domain.service value will be set as the audience for the id token. Using Athenz Identity X.509 Certificates \u00b6 $ zts-accesstoken -domain <domain> [-roles <roles>] [-service <service>] -svc-key-file <private-key-file> -svc-cert-file <service-cert-file> -zts <ZTS url> [-expire-time <expire-time-in-mins>]","title":"ZTS OAuth2 Access Token Client"},{"location":"zts_accesstoken/#overview","text":"ZTS OAuth2 Access Token Client application in Go to request an access token from ZTS Server for the given identity to access a role in a provider domain.","title":"Overview"},{"location":"zts_accesstoken/#getting-software","text":"Download latest ZTS OAuth2 Access Token Client binary release from Bintray - click on the Files tab, choose the latest version directory and then download the athenz-utils-<latest-version>-bin.tar.gz file:: $ tar xvfz athenz-utils-X.Y-bin.tar.gz","title":"Getting Software"},{"location":"zts_accesstoken/#prerequisites","text":"Before you can use the ZTS AccessToken utility, you need to have asked the Athenz administrators to create your top level domain.","title":"Prerequisites"},{"location":"zts_accesstoken/#usage","text":"An access token from ZTS service can be fetched using Service Identity x.509 certificates. The optional expire-time argument specifies how long the access token should be valid for. The value must be specified in minutes. The default if no value is specified is 120 minutes. The optional roles argument requests an access token for the given roles only (comma separated) as opposed to all the roles the service identity has access to in the requested domain. The optional service argument requests an id token for the given service. The full domain.service value will be set as the audience for the id token.","title":"Usage"},{"location":"zts_accesstoken/#using-athenz-identity-x509-certificates","text":"$ zts-accesstoken -domain <domain> [-roles <roles>] [-service <service>] -svc-key-file <private-key-file> -svc-cert-file <service-cert-file> -zts <ZTS url> [-expire-time <expire-time-in-mins>]","title":"Using Athenz Identity X.509 Certificates"},{"location":"zts_api/","text":"ZTS API \u00b6 Introduction \u00b6 The Authorization Token Service (ZTS) API This API has the following attributes: Attribute Value namespace com.yahoo.auth.zts version 1 Authentication \u00b6 X.509 Certificate Support \u00b6 All ZMS API commands require that the client use a TLS certificate issued by Athenz. Services can use their Athenz Issued Service Identity certificates when communicating with ZMS. Authorization \u00b6 Limited number of ZTS API endpoints are authorized against the configured policy data to verify that the principal has been given the rights to make the requested change. Each request description below gives the authorization command that includes the action and resource that the ZTS Server will run the authorization check against. For example, to delete an instance from the local database we have the following authorize statement: authorize(\"delete\", \"{domain}:instance.{instanceId}\"); This indicates that the principal requesting to delete instance id host001 from athenz.ci domain must have grant rights to action \"delete\" for resource called \"instance.host001\" in domain \"athenz.ci\". Types \u00b6 Access \u00b6 Access can be checked and returned as this resource. Access is a Struct type with the following fields: Name Type Options Description Notes granted Bool AccessTokenResponse \u00b6 OAuth2 Access Token response. AccessTokenResponse is a Struct type with the following fields: Name Type Options Description Notes access_token String Oauth2 Access token in JWT format token_type String For Athenz this will always be Bearer expires_in Int32 Number of seconds the access token is valid for scope List List of roles the principal has access to refresh_token String Not issued by Athenz id_token String ID token valid for 1 hour Returned only if openid/service-name scopes provided as part of the request ActionName \u00b6 An action (operation) name. ActionName is a String type with the following options: Option Value Notes pattern {CompoundName} AuthorityName \u00b6 Used as the prefix in a signed assertion. This uniquely identifies a signing authority. i.e. user AuthorityName is a String type with the following options: Option Value Notes pattern {CompoundName} AWSArnRoleName \u00b6 AWS full role name with path AWSArnRoleName is a String type with the following options: Option Value Notes pattern ({AWSRolePath})*{AWSRoleName} AWSRoleName \u00b6 AWS role name without the path AWSRoleName is a String type with the following options: Option Value Notes pattern [a-zA-Z0-9-\\\\._=+@,]* AWSRolePath \u00b6 AWS role path AWSRolePath is a String type with the following options: Option Value Notes pattern ({AWSRolePathElement}/)+ AWSRolePathElement \u00b6 AWS role path single element AWSRolePathElement is a String type with the following options: Option Value Notes pattern [a-zA-Z0-9][a-zA-Z0-9-\\\\._]* AWSTemporaryCredentials \u00b6 AWS Temporary credentials AWSTemporaryCredentials is a Struct type with the following fields: Name Type Options Description Notes accessKeyId String secretAccessKey String sessionToken String expiration Timestamp CompoundName \u00b6 A compound name. Most names in this API are compound names. CompoundName is a String type with the following options: Option Value Notes pattern ({SimpleName} .) {SimpleName}* DomainName \u00b6 A domain name is the general qualifier prefix, as its uniqueness is managed. DomainName is a String type with the following options: Option Value Notes pattern {CompoundName} EntityName \u00b6 An entity name is a short form of a resource name, including only the domain and entity. EntityName is a String type with the following options: Option Value Notes pattern {CompoundName} Identity \u00b6 A signed identity object that is a client certificate. Identity is a Struct type with the following fields: Name Type Options Description Notes name CompoundName Name of the identity certificate String optional TLS Certificate caCertBundle String optional CA certificate chain sshServerCert String optional SSH server certificate attributes Map<String, String> optional config like attributes InstanceIdentity \u00b6 A signed instance identity object that includes client certificate InstanceIdentity is a Struct type with the following fields: Name Type Options Description Notes provider ServiceName provider service name name ServiceName Name of the identity instanceId PathElement unique instance id x509Certificate String optional TLS Certificate x509CertificateSigner String optional CA certificate chain sshCertificate String optional SSH server certificate sshCertificateSigner String optional SSH server certificate signer pubilc key attributes Map<String, String> optional config like attributes InstanceRefreshRequest \u00b6 A certificate refresh request. InstanceRefreshRequest is a Struct type with the following fields: Name Type Options Description Notes csr String optional cert CSR if requesting TLS certificate expiryTime Int32 optional In seconds how long certificate should be valid for keyId String optional public key identifier InstanceRegisterInformation \u00b6 Request to request an instance with ZTS and request X.509 Certificate for the service. InstanceRegisterInformation is a Struct type with the following fields: Name Type Options Description Notes provider ServiceName provider service name e.g. athenz.aws.us-west-2 domain DomainName instance domain name service ServiceName instance service name attestationData String identity attestation data csr String cert CSR if requesting TLS certificate ssh String optional ssh CSR if requesting SSH certificate JWK \u00b6 Json Web Key. JWK is a Struct type with the following fields: Name Type Options Description Notes kty String key type e.g. EC or RSA kid String key id alg String key algorithm e.g. RS256 or ES256 use String key usage e.g. sig for signing or enc for encryption crv String EC curve name e.g. prime256v1, P-256 x String EC key x value y String EC key y value n String RSA key modulus value e String RSA key public exponent value JWKList \u00b6 Json Web Key List JWKList is a Struct type with the following fields: Name Type Options Description Notes keys Array List of JWKs PathElement \u00b6 A uri safe path element PathElement is a String type with the following options: Option Value Notes pattern [a-zA-Z0-9-\\\\._~=+@$,:]* ResourceName \u00b6 A shorthand for a YRN with no service or location. The 'tail' of a YRN, just the domain:entity. Note that the EntityName part is optional, that is, a domain name followed by a colon is valid resource name. ResourceName is a String type with the following options: Option Value Notes pattern {DomainName}(:{EntityName})? RoleAccess \u00b6 RoleAccess is a Struct type with the following fields: Name Type Options Description Notes roles Array<EntityName> list of roles principal has access to RoleCertificateRequest \u00b6 A role certificate request. RoleCertificateRequest is a Struct type with the following fields: Name Type Options Description Notes csr String optional cert CSR if requesting TLS certificate expiryTime Int32 optional In seconds how long certificate should be valid for ServiceName \u00b6 A service name will generally be a unique subdomain ServiceName is a String type with the following options: Option Value Notes pattern {CompoundName} SignedToken \u00b6 A signed assertion if identity. For example: the YBY cookie value. This token will only make sense to the authority that generated it, so it is beneficial to have something in the value that is cheaply recognized to quickly reject if it belongs to another authority. SignedToken is a String type with the following options: Option Value Notes pattern [a-zA-Z0-9\\\\._%=;,-]* SimpleName \u00b6 Option Value Notes pattern [a-zA-Z0-9_][a-zA-Z0-9_-]* YBase64 \u00b6 The Y-specific URL-safe Base64 variant. YBase64 is a String type with the following options: Option Value Notes pattern [a-zA-Z0-9\\._-]+ YEncoded \u00b6 YEncoded includes ybase64 chars, as well as - and %. This can represent a YBY cookie and URL-encoded values YEncoded is a String type with the following options: Option Value Notes pattern [a-zA-Z0-9\\._%--]* YRN \u00b6 A full Resource name (YRN) YRN is a String type with the following options: Option Value Notes pattern (yrn:({ServiceName})?:({LocationName})?:)?{ResourceName} Resources \u00b6 Access \u00b6 GET /access/{action} \u00b6 Authentication : Certificate Authorization : None Check access for the specified operation/action on the specified resource for the currently authenticated user if the principal query parameter is not specified. If the principal query parameter is specified, the access check verifies if that principal has access for the specified action on the resource. This is the slow centralized access for control-plane purposes. Request Parameters Name Type Source Options Description action ActionName path domain DomainName query: domain optional principal EntityName query: principal optional resource String query: resource required Responses Expected: Code Type 200 OK Access Exception: Code Type 400 Bad Request ResourceError 401 Unauthorized ResourceError 404 Not Found ResourceError AccessToken \u00b6 POST \"/oauth2/token\" \u00b6 Authentication : Certificate Authorization : None Return an oauth2 access token for the specific set of roles in the namespace that the user can assume. To request an access token from ZTS Server, the client will send a POST request with application/x-www-form-urlencoded content-type and the request body must contain the following parameters: grant_type : Value MUST be set to \"client_credentials\" scope : list of scopes/roles requested in the access token. The caller can either specify to include all roles the principal has access to in a specific domain (e.g. <domain-name>:domain) or ask for specific roles only (e.g. <domain-name>:role.<role1>). Scopes are separated by spaces. To request an ID token, the scope must include 'openid' and audience service name (e.g. <domain-name>:service.<service-name>). The domain name in id token request match the domain name in the access token scope. expires_in : requested expiry time for access token in seconds Request Parameters Name Type Source Options Description req String body request to fetch access token (see above) Responses Expected: Code Type 200 OK AccessTokenResponse 403 FORBIDDEN Principal does not have access to any roles in this domain Exception: Code Type 400 Bad Request ResourceError 401 Unauthorized ResourceError 403 Forbidden ResourceError 404 Not Found ResourceError AWS Temporary Credentials \u00b6 GET \"/domain/{domainName}/role/{roleName}/creds\" \u00b6 Authentication : Certificate Authorization : None Perform an AWS AssumeRole of the target role and return the credentials. ZTS must have been granted the ability to assume the role in IAM, and granted the ability to ASSUME_AWS_ROLE in Athenz for this to succeed. There are two optional query parameters to specify the duration in seconds for the requested credentials and the external id. Both of these options require the role to be configured accordingly in AWS IAM. Request Parameters Name Type Source Options Description domainName DomainName path roleName EntityName path durationSeconds Integer query: durationSeconds optional Duration in seconds - min: 900, max: 43200. Must be configured in IAM externalId String query: externalId optional External ID configured in IAM for the given role Responses Expected: Code Type 200 OK Access Exception: Code Type 400 Bad Request ResourceError 401 Unauthorized ResourceError 403 Forbidden ResourceError 404 Not Found ResourceError IdentityRefresh \u00b6 POST \"/instance/{domain}/{service}/refresh\" \u00b6 Authentication : Certificate Authorization : None Refresh self identity if the original identity was issued by ZTS. The token must include the original requestor's name and the server will verify that the service still has authorization to grant inception to the current service requesting to refresh its identity Request Parameters Name Type Source Options Description domain DomainName path service SimpleName path req InstanceRefreshRequest body Responses Expected: Code Type 200 OK Identity Exception: Code Type 400 Bad Request ResourceError 401 Unauthorized ResourceError 403 Forbidden ResourceError 404 Not Found ResourceError InstanceDelete \u00b6 DELETE \"/instance/{provider}/{domain}/{service}/{instanceId}\" \u00b6 Authentication : Certificate Authorization : authorize(\"delete\", \"{domain}:instance.{instanceId}\"); Delete the specified instance and no longer allow certificate refresh. Request Parameters Name Type Source Options Description provider ServiceName path service SimpleName path instanceId PathElement path unique instance id in provider's namespace Responses Expected: Code Type 204 Exception: Code Type 400 Bad Request ResourceError 401 Unauthorized ResourceError 403 Forbidden ResourceError 404 Not Found ResourceError 500 Internal Server Error ResourceError InstanceRefresh \u00b6 POST \"/instance/{provider}/{domain}/{service}/{instanceId}\" \u00b6 Authentication : Certificate Authorization : None Refresh the current certificate for this instance. Request Parameters Name Type Source Options Description provider ServiceName path service SimpleName path instanceId PathElement path unique instance id in provider's namespace info InstanceRefreshInformation body Responses Expected: Code Type 200 OK InstanceIdentity Exception: Code Type 400 Bad Request ResourceError 401 Unauthorized ResourceError 403 Forbidden ResourceError 404 Not Found ResourceError 500 Internal Server Error ResourceError InstanceRegister \u00b6 POST \"/instance\" \u00b6 Authentication : None Authorization : None Register the instance for a given provider and return x.509 certificate for the service to identity itself against other Athenz enabled services. Responses Expected: Code Type 201 CREATED InstanceIdentity Exception: Code Type 400 Bad Request ResourceError 401 Unauthorized ResourceError 403 Forbidden ResourceError 404 Not Found ResourceError 500 Internal Server Error ResourceError JWKList \u00b6 GET \"/oauth2/keys\" \u00b6 Authentication : Certificate Authorization : None Returns list of Json Web Keys (JWKs) that can be used by the ZTS Server to sign OAuth2 Access/Id Tokens. If the optional rfc=true query argument is specified, then we return the EC key curve names strictly based on the JWK RFC - e.g. P-256. Request Parameters Name Type Source Options Description rfc Boolean query: rfc optional if true then use rfc defined curve names - e.g. P-256 Responses Expected: Code Type 200 OK JWKList Exception: Code Type 400 Bad Request ResourceError 401 Unauthorized ResourceError RoleAccess \u00b6 GET \"/access/domain/{domainName}/principal/{principal}\" \u00b6 Authentication : Certificate Authorization : None List the roles that the given principal has in the domain. Request Parameters Name Type Source Options Description domainName DomainName path principal EntityName path Responses Expected: Code Type 200 OK RoleAccess Exception: Code Type 400 Bad Request ResourceError 401 Unauthorized ResourceError 403 Forbidden ResourceError 404 Not Found ResourceError RoleCertificate \u00b6 POST \"/domain/{domainName}/role/{roleName}/token\" \u00b6 Authentication : Certificate Authorization : None Return a TLS certificate for the specific role in the namespace that the principal can assume. Role certificates are valid for 30 days by default. Request Parameters Name Type Source Options Description domainName DomainName path roleName EntityName path req RoleCertificateRequest body csr request Responses Expected: Code Type 200 OK RoleToken 403 FORBIDDEN Principal does not have access to any roles in this domain Exception: Code Type 400 Bad Request ResourceError 401 Unauthorized ResourceError 403 Forbidden ResourceError 404 Not Found ResourceError RoleCheckAccess \u00b6 GET \"/access/domain/{domainName}/role/{roleName}/principal/{principal}\" \u00b6 Authentication : Certificate Authorization : None Check whether or not the given principal is included in the given role in the specified domain. Request Parameters Name Type Source Options Description domainName DomainName path roleName EntityName path principal EntityName path Responses Expected: Code Type 200 OK Access Exception: Code Type 400 Bad Request ResourceError 401 Unauthorized ResourceError 403 Forbidden ResourceError 404 Not Found ResourceError","title":"ZTS REST API"},{"location":"zts_api/#zts-api","text":"","title":"ZTS API"},{"location":"zts_api/#introduction","text":"The Authorization Token Service (ZTS) API This API has the following attributes: Attribute Value namespace com.yahoo.auth.zts version 1","title":"Introduction"},{"location":"zts_api/#authentication","text":"","title":"Authentication"},{"location":"zts_api/#x509-certificate-support","text":"All ZMS API commands require that the client use a TLS certificate issued by Athenz. Services can use their Athenz Issued Service Identity certificates when communicating with ZMS.","title":"X.509 Certificate Support"},{"location":"zts_api/#authorization","text":"Limited number of ZTS API endpoints are authorized against the configured policy data to verify that the principal has been given the rights to make the requested change. Each request description below gives the authorization command that includes the action and resource that the ZTS Server will run the authorization check against. For example, to delete an instance from the local database we have the following authorize statement: authorize(\"delete\", \"{domain}:instance.{instanceId}\"); This indicates that the principal requesting to delete instance id host001 from athenz.ci domain must have grant rights to action \"delete\" for resource called \"instance.host001\" in domain \"athenz.ci\".","title":"Authorization"},{"location":"zts_api/#types","text":"","title":"Types"},{"location":"zts_api/#access","text":"Access can be checked and returned as this resource. Access is a Struct type with the following fields: Name Type Options Description Notes granted Bool","title":"Access"},{"location":"zts_api/#accesstokenresponse","text":"OAuth2 Access Token response. AccessTokenResponse is a Struct type with the following fields: Name Type Options Description Notes access_token String Oauth2 Access token in JWT format token_type String For Athenz this will always be Bearer expires_in Int32 Number of seconds the access token is valid for scope List List of roles the principal has access to refresh_token String Not issued by Athenz id_token String ID token valid for 1 hour Returned only if openid/service-name scopes provided as part of the request","title":"AccessTokenResponse"},{"location":"zts_api/#actionname","text":"An action (operation) name. ActionName is a String type with the following options: Option Value Notes pattern {CompoundName}","title":"ActionName"},{"location":"zts_api/#authorityname","text":"Used as the prefix in a signed assertion. This uniquely identifies a signing authority. i.e. user AuthorityName is a String type with the following options: Option Value Notes pattern {CompoundName}","title":"AuthorityName"},{"location":"zts_api/#awsarnrolename","text":"AWS full role name with path AWSArnRoleName is a String type with the following options: Option Value Notes pattern ({AWSRolePath})*{AWSRoleName}","title":"AWSArnRoleName"},{"location":"zts_api/#awsrolename","text":"AWS role name without the path AWSRoleName is a String type with the following options: Option Value Notes pattern [a-zA-Z0-9-\\\\._=+@,]*","title":"AWSRoleName"},{"location":"zts_api/#awsrolepath","text":"AWS role path AWSRolePath is a String type with the following options: Option Value Notes pattern ({AWSRolePathElement}/)+","title":"AWSRolePath"},{"location":"zts_api/#awsrolepathelement","text":"AWS role path single element AWSRolePathElement is a String type with the following options: Option Value Notes pattern [a-zA-Z0-9][a-zA-Z0-9-\\\\._]*","title":"AWSRolePathElement"},{"location":"zts_api/#awstemporarycredentials","text":"AWS Temporary credentials AWSTemporaryCredentials is a Struct type with the following fields: Name Type Options Description Notes accessKeyId String secretAccessKey String sessionToken String expiration Timestamp","title":"AWSTemporaryCredentials"},{"location":"zts_api/#compoundname","text":"A compound name. Most names in this API are compound names. CompoundName is a String type with the following options: Option Value Notes pattern ({SimpleName} .) {SimpleName}*","title":"CompoundName"},{"location":"zts_api/#domainname","text":"A domain name is the general qualifier prefix, as its uniqueness is managed. DomainName is a String type with the following options: Option Value Notes pattern {CompoundName}","title":"DomainName"},{"location":"zts_api/#entityname","text":"An entity name is a short form of a resource name, including only the domain and entity. EntityName is a String type with the following options: Option Value Notes pattern {CompoundName}","title":"EntityName"},{"location":"zts_api/#identity","text":"A signed identity object that is a client certificate. Identity is a Struct type with the following fields: Name Type Options Description Notes name CompoundName Name of the identity certificate String optional TLS Certificate caCertBundle String optional CA certificate chain sshServerCert String optional SSH server certificate attributes Map<String, String> optional config like attributes","title":"Identity"},{"location":"zts_api/#instanceidentity","text":"A signed instance identity object that includes client certificate InstanceIdentity is a Struct type with the following fields: Name Type Options Description Notes provider ServiceName provider service name name ServiceName Name of the identity instanceId PathElement unique instance id x509Certificate String optional TLS Certificate x509CertificateSigner String optional CA certificate chain sshCertificate String optional SSH server certificate sshCertificateSigner String optional SSH server certificate signer pubilc key attributes Map<String, String> optional config like attributes","title":"InstanceIdentity"},{"location":"zts_api/#instancerefreshrequest","text":"A certificate refresh request. InstanceRefreshRequest is a Struct type with the following fields: Name Type Options Description Notes csr String optional cert CSR if requesting TLS certificate expiryTime Int32 optional In seconds how long certificate should be valid for keyId String optional public key identifier","title":"InstanceRefreshRequest"},{"location":"zts_api/#instanceregisterinformation","text":"Request to request an instance with ZTS and request X.509 Certificate for the service. InstanceRegisterInformation is a Struct type with the following fields: Name Type Options Description Notes provider ServiceName provider service name e.g. athenz.aws.us-west-2 domain DomainName instance domain name service ServiceName instance service name attestationData String identity attestation data csr String cert CSR if requesting TLS certificate ssh String optional ssh CSR if requesting SSH certificate","title":"InstanceRegisterInformation"},{"location":"zts_api/#jwk","text":"Json Web Key. JWK is a Struct type with the following fields: Name Type Options Description Notes kty String key type e.g. EC or RSA kid String key id alg String key algorithm e.g. RS256 or ES256 use String key usage e.g. sig for signing or enc for encryption crv String EC curve name e.g. prime256v1, P-256 x String EC key x value y String EC key y value n String RSA key modulus value e String RSA key public exponent value","title":"JWK"},{"location":"zts_api/#jwklist","text":"Json Web Key List JWKList is a Struct type with the following fields: Name Type Options Description Notes keys Array List of JWKs","title":"JWKList"},{"location":"zts_api/#pathelement","text":"A uri safe path element PathElement is a String type with the following options: Option Value Notes pattern [a-zA-Z0-9-\\\\._~=+@$,:]*","title":"PathElement"},{"location":"zts_api/#resourcename","text":"A shorthand for a YRN with no service or location. The 'tail' of a YRN, just the domain:entity. Note that the EntityName part is optional, that is, a domain name followed by a colon is valid resource name. ResourceName is a String type with the following options: Option Value Notes pattern {DomainName}(:{EntityName})?","title":"ResourceName"},{"location":"zts_api/#roleaccess","text":"RoleAccess is a Struct type with the following fields: Name Type Options Description Notes roles Array<EntityName> list of roles principal has access to","title":"RoleAccess"},{"location":"zts_api/#rolecertificaterequest","text":"A role certificate request. RoleCertificateRequest is a Struct type with the following fields: Name Type Options Description Notes csr String optional cert CSR if requesting TLS certificate expiryTime Int32 optional In seconds how long certificate should be valid for","title":"RoleCertificateRequest"},{"location":"zts_api/#servicename","text":"A service name will generally be a unique subdomain ServiceName is a String type with the following options: Option Value Notes pattern {CompoundName}","title":"ServiceName"},{"location":"zts_api/#signedtoken","text":"A signed assertion if identity. For example: the YBY cookie value. This token will only make sense to the authority that generated it, so it is beneficial to have something in the value that is cheaply recognized to quickly reject if it belongs to another authority. SignedToken is a String type with the following options: Option Value Notes pattern [a-zA-Z0-9\\\\._%=;,-]*","title":"SignedToken"},{"location":"zts_api/#simplename","text":"Option Value Notes pattern [a-zA-Z0-9_][a-zA-Z0-9_-]*","title":"SimpleName"},{"location":"zts_api/#ybase64","text":"The Y-specific URL-safe Base64 variant. YBase64 is a String type with the following options: Option Value Notes pattern [a-zA-Z0-9\\._-]+","title":"YBase64"},{"location":"zts_api/#yencoded","text":"YEncoded includes ybase64 chars, as well as - and %. This can represent a YBY cookie and URL-encoded values YEncoded is a String type with the following options: Option Value Notes pattern [a-zA-Z0-9\\._%--]*","title":"YEncoded"},{"location":"zts_api/#yrn","text":"A full Resource name (YRN) YRN is a String type with the following options: Option Value Notes pattern (yrn:({ServiceName})?:({LocationName})?:)?{ResourceName}","title":"YRN"},{"location":"zts_api/#resources","text":"","title":"Resources"},{"location":"zts_api/#access_1","text":"","title":"Access"},{"location":"zts_api/#get-accessaction","text":"Authentication : Certificate Authorization : None Check access for the specified operation/action on the specified resource for the currently authenticated user if the principal query parameter is not specified. If the principal query parameter is specified, the access check verifies if that principal has access for the specified action on the resource. This is the slow centralized access for control-plane purposes.","title":"GET /access/{action}"},{"location":"zts_api/#accesstoken","text":"","title":"AccessToken"},{"location":"zts_api/#post-oauth2token","text":"Authentication : Certificate Authorization : None Return an oauth2 access token for the specific set of roles in the namespace that the user can assume. To request an access token from ZTS Server, the client will send a POST request with application/x-www-form-urlencoded content-type and the request body must contain the following parameters: grant_type : Value MUST be set to \"client_credentials\" scope : list of scopes/roles requested in the access token. The caller can either specify to include all roles the principal has access to in a specific domain (e.g. <domain-name>:domain) or ask for specific roles only (e.g. <domain-name>:role.<role1>). Scopes are separated by spaces. To request an ID token, the scope must include 'openid' and audience service name (e.g. <domain-name>:service.<service-name>). The domain name in id token request match the domain name in the access token scope. expires_in : requested expiry time for access token in seconds","title":"POST \"/oauth2/token\""},{"location":"zts_api/#aws-temporary-credentials","text":"","title":"AWS Temporary Credentials"},{"location":"zts_api/#get-domaindomainnamerolerolenamecreds","text":"Authentication : Certificate Authorization : None Perform an AWS AssumeRole of the target role and return the credentials. ZTS must have been granted the ability to assume the role in IAM, and granted the ability to ASSUME_AWS_ROLE in Athenz for this to succeed. There are two optional query parameters to specify the duration in seconds for the requested credentials and the external id. Both of these options require the role to be configured accordingly in AWS IAM.","title":"GET \"/domain/{domainName}/role/{roleName}/creds\""},{"location":"zts_api/#identityrefresh","text":"","title":"IdentityRefresh"},{"location":"zts_api/#post-instancedomainservicerefresh","text":"Authentication : Certificate Authorization : None Refresh self identity if the original identity was issued by ZTS. The token must include the original requestor's name and the server will verify that the service still has authorization to grant inception to the current service requesting to refresh its identity","title":"POST \"/instance/{domain}/{service}/refresh\""},{"location":"zts_api/#instancedelete","text":"","title":"InstanceDelete"},{"location":"zts_api/#delete-instanceproviderdomainserviceinstanceid","text":"Authentication : Certificate Authorization : authorize(\"delete\", \"{domain}:instance.{instanceId}\"); Delete the specified instance and no longer allow certificate refresh.","title":"DELETE \"/instance/{provider}/{domain}/{service}/{instanceId}\""},{"location":"zts_api/#instancerefresh","text":"","title":"InstanceRefresh"},{"location":"zts_api/#post-instanceproviderdomainserviceinstanceid","text":"Authentication : Certificate Authorization : None Refresh the current certificate for this instance.","title":"POST \"/instance/{provider}/{domain}/{service}/{instanceId}\""},{"location":"zts_api/#instanceregister","text":"","title":"InstanceRegister"},{"location":"zts_api/#post-instance","text":"Authentication : None Authorization : None Register the instance for a given provider and return x.509 certificate for the service to identity itself against other Athenz enabled services.","title":"POST \"/instance\""},{"location":"zts_api/#jwklist_1","text":"","title":"JWKList"},{"location":"zts_api/#get-oauth2keys","text":"Authentication : Certificate Authorization : None Returns list of Json Web Keys (JWKs) that can be used by the ZTS Server to sign OAuth2 Access/Id Tokens. If the optional rfc=true query argument is specified, then we return the EC key curve names strictly based on the JWK RFC - e.g. P-256.","title":"GET \"/oauth2/keys\""},{"location":"zts_api/#roleaccess_1","text":"","title":"RoleAccess"},{"location":"zts_api/#get-accessdomaindomainnameprincipalprincipal","text":"Authentication : Certificate Authorization : None List the roles that the given principal has in the domain.","title":"GET \"/access/domain/{domainName}/principal/{principal}\""},{"location":"zts_api/#rolecertificate","text":"","title":"RoleCertificate"},{"location":"zts_api/#post-domaindomainnamerolerolenametoken","text":"Authentication : Certificate Authorization : None Return a TLS certificate for the specific role in the namespace that the principal can assume. Role certificates are valid for 30 days by default.","title":"POST \"/domain/{domainName}/role/{roleName}/token\""},{"location":"zts_api/#rolecheckaccess","text":"","title":"RoleCheckAccess"},{"location":"zts_api/#get-accessdomaindomainnamerolerolenameprincipalprincipal","text":"Authentication : Certificate Authorization : None Check whether or not the given principal is included in the given role in the specified domain.","title":"GET \"/access/domain/{domainName}/role/{roleName}/principal/{principal}\""},{"location":"zts_rolecert/","text":"Overview Getting Software Prerequisites Usage Overview \u00b6 ZTS Role Certificate Client utility uses Athenz Service Identity certificate to request a X509 Certificate for the requested role from ZTS Server. Once ZTS validates the service identity certificate, it will issue a new 30-day X509 Certificate for the role. Unlike access tokens, role certificates are issued for a given role only. Getting Software \u00b6 Download latest ZTS Role Certificate Client utility binary release from Bintray - click on the Files tab, choose the latest version directory and then download the athenz-utils-<latest-version>-bin.tar.gz file:: $ tar xvfz athenz-utils-X.Y-bin.tar.gz Prerequisites \u00b6 Before you can use the ZTS RoleCertificate utility, you need to have asked the Athenz administrators to create your top level domain. Usage \u00b6 Role X.509 certificates can only be requested using Athenz x.509 Identity certificates. Typically you configure your service identity agent (SIA) to automatically fetch and refresh the role certificates. Requesting Role Certificates \u00b6 $ zts-rolecert -svc-key-file <key-file> -svc-cert-file <cert-file> -zts https://zts-server.athenzcompany.com:4443/zts/v1 -role-domain <domain> -role-name <name> -dns-domain <dns-domain> [-role-cert-file <output-cert-file>]","title":"ZTS Role Certificate Client Utility"},{"location":"zts_rolecert/#overview","text":"ZTS Role Certificate Client utility uses Athenz Service Identity certificate to request a X509 Certificate for the requested role from ZTS Server. Once ZTS validates the service identity certificate, it will issue a new 30-day X509 Certificate for the role. Unlike access tokens, role certificates are issued for a given role only.","title":"Overview"},{"location":"zts_rolecert/#getting-software","text":"Download latest ZTS Role Certificate Client utility binary release from Bintray - click on the Files tab, choose the latest version directory and then download the athenz-utils-<latest-version>-bin.tar.gz file:: $ tar xvfz athenz-utils-X.Y-bin.tar.gz","title":"Getting Software"},{"location":"zts_rolecert/#prerequisites","text":"Before you can use the ZTS RoleCertificate utility, you need to have asked the Athenz administrators to create your top level domain.","title":"Prerequisites"},{"location":"zts_rolecert/#usage","text":"Role X.509 certificates can only be requested using Athenz x.509 Identity certificates. Typically you configure your service identity agent (SIA) to automatically fetch and refresh the role certificates.","title":"Usage"},{"location":"zts_rolecert/#requesting-role-certificates","text":"$ zts-rolecert -svc-key-file <key-file> -svc-cert-file <cert-file> -zts https://zts-server.athenzcompany.com:4443/zts/v1 -role-domain <domain> -role-name <name> -dns-domain <dns-domain> [-role-cert-file <output-cert-file>]","title":"Requesting Role Certificates"}]}