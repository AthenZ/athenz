//
// This file generated by rdl 1.5.2. Do not modify!
//

package com.yahoo.athenz.msd;
import com.yahoo.rdl.*;

public class MSDSchema {

    private final static Schema INSTANCE = build();
    public static Schema instance() {
        return INSTANCE;
    }

    private static Schema build() {
        SchemaBuilder sb = new SchemaBuilder("MSD");
        sb.version(1);
        sb.namespace("com.yahoo.athenz.msd");
        sb.comment("Copyright The Athenz Authors Licensed under the terms of the Apache version 2.0 license. See LICENSE file for terms. The Micro Segmentation Defense (MSD) API");

        sb.stringType("SimpleName")
            .comment("Copyright The Athenz Authors Licensed under the terms of the Apache version 2.0 license. See LICENSE file for terms. Common name types used by several API definitions A simple identifier, an element of compound name.")
            .pattern("[a-zA-Z0-9_][a-zA-Z0-9_-]*");

        sb.stringType("CompoundName")
            .comment("A compound name. Most names in this API are compound names.")
            .pattern("([a-zA-Z0-9_][a-zA-Z0-9_-]*\\.)*[a-zA-Z0-9_][a-zA-Z0-9_-]*");

        sb.stringType("DomainName")
            .comment("A domain name is the general qualifier prefix, as its uniqueness is managed.")
            .pattern("([a-zA-Z0-9_][a-zA-Z0-9_-]*\\.)*[a-zA-Z0-9_][a-zA-Z0-9_-]*");

        sb.stringType("EntityName")
            .comment("An entity name is a short form of a resource name, including only the domain and entity.")
            .pattern("([a-zA-Z0-9_][a-zA-Z0-9_-]*\\.)*[a-zA-Z0-9_][a-zA-Z0-9_-]*");

        sb.stringType("EntityList")
            .comment("An Entity list is comma separated compound Names")
            .pattern("(([a-zA-Z0-9_][a-zA-Z0-9_-]*\\.)*[a-zA-Z0-9_][a-zA-Z0-9_-]*,)*([a-zA-Z0-9_][a-zA-Z0-9_-]*\\.)*[a-zA-Z0-9_][a-zA-Z0-9_-]*");

        sb.stringType("ServiceName")
            .comment("A service name will generally be a unique subdomain.")
            .pattern("([a-zA-Z0-9_][a-zA-Z0-9_-]*\\.)*[a-zA-Z0-9_][a-zA-Z0-9_-]*");

        sb.stringType("ActionName")
            .comment("An action (operation) name.")
            .pattern("([a-zA-Z0-9_][a-zA-Z0-9_-]*\\.)*[a-zA-Z0-9_][a-zA-Z0-9_-]*");

        sb.stringType("ResourceName")
            .comment("A resource name Note that the EntityName part is optional, that is, a domain name followed by a colon is valid resource name.")
            .pattern("([a-zA-Z0-9_][a-zA-Z0-9_-]*\\.)*[a-zA-Z0-9_][a-zA-Z0-9_-]*(:([a-zA-Z0-9_][a-zA-Z0-9_-]*\\.)*[a-zA-Z0-9_][a-zA-Z0-9_-]*)?");

        sb.stringType("YBase64")
            .comment("The Y-specific URL-safe Base64 variant.")
            .pattern("[a-zA-Z0-9\\._-]+");

        sb.stringType("YEncoded")
            .comment("YEncoded includes ybase64 chars, as well as = and %. This can represent a user cookie and URL-encoded values.")
            .pattern("[a-zA-Z0-9\\._%=-]*");

        sb.stringType("AuthorityName")
            .comment("Used as the prefix in a signed assertion. This uniquely identifies a signing authority.")
            .pattern("([a-zA-Z0-9_][a-zA-Z0-9_-]*\\.)*[a-zA-Z0-9_][a-zA-Z0-9_-]*");

        sb.stringType("PathElement")
            .comment("A uri-safe path element")
            .pattern("[a-zA-Z0-9-\\._~=+@$,:]*");

        sb.enumType("TransportPolicyEnforcementState")
            .comment("Types of transport policy enforcement states")
            .element("ENFORCE")
            .element("REPORT");

        sb.enumType("TransportPolicyProtocol")
            .comment("Types of transport policy protocols")
            .element("TCP")
            .element("UDP");

        sb.structType("TransportPolicySubject")
            .comment("Subject for a transport policy")
            .field("domainName", "DomainName", false, "Name of the domain")
            .field("serviceName", "EntityName", false, "Name of the service");

        sb.structType("TransportPolicyCondition")
            .comment("Transport policy condition. Used to specify additional restrictions for the subject of a transport policy")
            .field("enforcementState", "TransportPolicyEnforcementState", false, "State of transport policy enforcement ( ENFORCE / REPORT )")
            .arrayField("instances", "String", true, "Acts as restrictions. If present, this transport policy should be restricted to only mentioned instances.");

        sb.structType("TransportPolicyPort")
            .comment("Transport policy port")
            .field("port", "Int32", false, "Start port of the port range. port and endPort will have same values for a single port definition.")
            .field("endPort", "Int32", false, "End port of the port range. port and endPort will have same values for a single port definition.")
            .field("protocol", "TransportPolicyProtocol", false, "Protocol for this transport policy");

        sb.structType("TransportPolicyMatch")
            .comment("Selector for the subject of a transport policy")
            .field("athenzService", "TransportPolicySubject", false, "Subject where this transport policy applies")
            .arrayField("conditions", "TransportPolicyCondition", false, "List of additional requirements for restrictions. Requirements are ANDed.");

        sb.structType("TransportPolicyPeer")
            .comment("Source or destination for a transport policy")
            .arrayField("athenzServices", "TransportPolicySubject", false, "List of transport policy subjects")
            .arrayField("ports", "TransportPolicyPort", false, "List of network traffic port part of this transport policy");

        sb.structType("TransportPolicyEntitySelector")
            .comment("Entity to which a transport policy applies. Describes the subject and port(s) for a transport policy.")
            .field("match", "TransportPolicyMatch", false, "Requirements for selecting the subject for this transport policy.")
            .arrayField("ports", "TransportPolicyPort", false, "List of network traffic port of the subject eligible for the transport policy");

        sb.structType("TransportPolicyIngressRule")
            .comment("Transport policy ingress rule")
            .field("id", "Int64", false, "Assertion id associated with this transport policy")
            .field("lastModified", "Timestamp", false, "Last modification timestamp of this transport policy")
            .field("entitySelector", "TransportPolicyEntitySelector", false, "Describes the entity to which this transport policy applies")
            .field("from", "TransportPolicyPeer", false, "Source of network traffic");

        sb.structType("TransportPolicyEgressRule")
            .comment("Transport policy egress rule")
            .field("id", "Int64", false, "Assertion id associated with this transport policy")
            .field("lastModified", "Timestamp", false, "Last modification timestamp of this transport policy")
            .field("entitySelector", "TransportPolicyEntitySelector", false, "Entity to which this transport policy applies")
            .field("to", "TransportPolicyPeer", false, "Destination of network traffic");

        sb.structType("TransportPolicyRules")
            .comment("Transport policy containing ingress and egress rules")
            .arrayField("ingress", "TransportPolicyIngressRule", false, "List of ingress rules")
            .arrayField("egress", "TransportPolicyEgressRule", false, "List of egress rules");

        sb.structType("Workload")
            .comment("workload type describing workload associated with an identity")
            .field("domainName", "DomainName", false, "name of the domain, optional for getWorkloadsByService API call")
            .field("serviceName", "EntityName", false, "name of the service, , optional for getWorkloadsByService API call")
            .field("uuid", "String", false, "unique identifier for the workload, usually defined by provider")
            .arrayField("ipAddresses", "String", false, "list of IP addresses associated with the workload, optional for getWorkloadsByIP API call")
            .field("hostname", "String", false, "hostname associated with the workload")
            .field("provider", "String", false, "infrastructure provider e.g. k8s, AWS, Azure, openstack etc.")
            .field("updateTime", "Timestamp", false, "most recent update timestamp in the backend")
            .field("certExpiryTime", "Timestamp", false, "certificate expiry time (ex: getNotAfter)");

        sb.structType("Workloads")
            .comment("list of workloads")
            .arrayField("workloadList", "Workload", false, "list of workloads");


        sb.resource("TransportPolicyRules", "GET", "/transportpolicies")
            .comment("API endpoint to get the transport policy rules defined in Athenz")
            .headerParam("If-None-Match", "matchingTag", "String", null, "Retrieved from the previous request, this timestamp specifies to the server to return any policies modified since this time")
            .output("ETag", "tag", "String", "The current latest modification timestamp is returned in this header")
            .auth("", "", true)
            .expected("OK")
            .exception("BAD_REQUEST", "ResourceError", "")

            .exception("FORBIDDEN", "ResourceError", "")

            .exception("NOT_FOUND", "ResourceError", "")

            .exception("TOO_MANY_REQUESTS", "ResourceError", "")

            .exception("UNAUTHORIZED", "ResourceError", "")
;

        sb.resource("Workloads", "GET", "/domain/{domainName}/service/{serviceName}/workloads")
            .name("getWorkloadsByService")
            .pathParam("domainName", "DomainName", "name of the domain")
            .pathParam("serviceName", "EntityName", "name of the service")
            .headerParam("If-None-Match", "matchingTag", "String", null, "Retrieved from the previous request, this timestamp specifies to the server to return any workloads modified since this time")
            .output("ETag", "tag", "String", "The current latest modification timestamp is returned in this header")
            .auth("", "", true)
            .expected("OK")
            .exception("BAD_REQUEST", "ResourceError", "")

            .exception("FORBIDDEN", "ResourceError", "")

            .exception("NOT_FOUND", "ResourceError", "")

            .exception("TOO_MANY_REQUESTS", "ResourceError", "")

            .exception("UNAUTHORIZED", "ResourceError", "")
;

        sb.resource("Workloads", "GET", "/workloads/{ip}")
            .name("getWorkloadsByIP")
            .pathParam("ip", "String", "ip address to query")
            .headerParam("If-None-Match", "matchingTag", "String", null, "Retrieved from the previous request, this timestamp specifies to the server to return any workloads modified since this time")
            .output("ETag", "tag", "String", "The current latest modification timestamp is returned in this header")
            .auth("", "", true)
            .expected("OK")
            .exception("BAD_REQUEST", "ResourceError", "")

            .exception("FORBIDDEN", "ResourceError", "")

            .exception("NOT_FOUND", "ResourceError", "")

            .exception("TOO_MANY_REQUESTS", "ResourceError", "")

            .exception("UNAUTHORIZED", "ResourceError", "")
;


        return sb.build();
    }

}
