//
// This file generated by rdl 1.5.2. Do not modify!
//
package com.yahoo.athenz.zms;

import com.yahoo.rdl.*;
import jakarta.ws.rs.*;
import jakarta.ws.rs.core.*;
import jakarta.servlet.ServletContext;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.inject.Inject;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;

@Path("/v1")
public class ZMSResources {

    @GET
    @Path("/domain/{domain}")
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "Get info for the specified domain, by name. This request only returns the configured domain attributes and not any domain objects like roles, policies or service identities.")
    public Domain getDomain(
        @Parameter(description = "name of the domain", required = true) @PathParam("domain") String domain) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "getDomain");
            context.authenticate();
            return this.delegate.getDomain(context, domain);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.BAD_REQUEST:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.FORBIDDEN:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.NOT_FOUND:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource getDomain");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.recordMetrics(context, code);
        }
    }

    @GET
    @Path("/domain")
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "Enumerate domains. Can be filtered by prefix and depth, and paginated. Most of the query options that are looking for specific domain attributes (e.g. aws account, azure subscriptions, gcp project, business service, tags, etc) are mutually exclusive. The server will only process the first query argument and ignore the others.")
    public DomainList getDomainList(
        @Parameter(description = "restrict the number of results in this call", required = false) @QueryParam("limit") Integer limit,
        @Parameter(description = "restrict the set to those after the specified \"next\" token returned from a previous call", required = false) @QueryParam("skip") String skip,
        @Parameter(description = "restrict to names that start with the prefix", required = false) @QueryParam("prefix") String prefix,
        @Parameter(description = "restrict the depth of the name, specifying the number of '.' characters that can appear", required = false) @QueryParam("depth") Integer depth,
        @Parameter(description = "restrict to domain names that have specified account name", required = false) @QueryParam("account") String account,
        @Parameter(description = "restrict the domain names that have specified product number", required = false) @QueryParam("ypmid") Integer productNumber,
        @Parameter(description = "restrict the domain names where the specified user is in a role - see roleName", required = false) @QueryParam("member") String roleMember,
        @Parameter(description = "restrict the domain names where the specified user is in this role - see roleMember", required = false) @QueryParam("role") String roleName,
        @Parameter(description = "restrict to domain names that have specified azure subscription name", required = false) @QueryParam("azure") String subscription,
        @Parameter(description = "restrict to domain names that have specified gcp project name", required = false) @QueryParam("gcp") String project,
        @Parameter(description = "flag to query all domains that have a given tagName", required = false) @QueryParam("tagKey") String tagKey,
        @Parameter(description = "flag to query all domains that have a given tag name and value", required = false) @QueryParam("tagValue") String tagValue,
        @Parameter(description = "restrict to domain names that have specified business service name", required = false) @QueryParam("businessService") String businessService,
        @Parameter(description = "restrict the domain names that have specified product id", required = false) @QueryParam("productId") String productId,
        @Parameter(description = "This header specifies to the server to return any domains modified since this HTTP date", required = true) @HeaderParam("If-Modified-Since") String modifiedSince) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "getDomainList");
            context.authenticate();
            return this.delegate.getDomainList(context, limit, skip, prefix, depth, account, productNumber, roleMember, roleName, subscription, project, tagKey, tagValue, businessService, productId, modifiedSince);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource getDomainList");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.recordMetrics(context, code);
        }
    }

    @POST
    @Path("/domain")
    @Consumes(MediaType.APPLICATION_JSON)
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "Create a new top level domain. This is a privileged action for the \"sys.auth\" administrators.")
    public Domain postTopLevelDomain(
        @Parameter(description = "Audit param required(not empty) if domain auditEnabled is true.", required = true) @HeaderParam("Y-Audit-Ref") String auditRef,
        @Parameter(description = "Resource owner for the request", required = true) @HeaderParam("Athenz-Resource-Owner") String resourceOwner,
        @Parameter(description = "TopLevelDomain object to be created", required = true) TopLevelDomain detail) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "postTopLevelDomain");
            context.authorize("create", "sys.auth:domain", null);
            return this.delegate.postTopLevelDomain(context, auditRef, resourceOwner, detail);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.BAD_REQUEST:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.FORBIDDEN:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource postTopLevelDomain");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.publishChangeMessage(context, code);
            this.delegate.recordMetrics(context, code);
        }
    }

    @POST
    @Path("/subdomain/{parent}")
    @Consumes(MediaType.APPLICATION_JSON)
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "Create a new subdomain. The domain administrators of the {parent} domain have the privilege to create subdomains.")
    public Domain postSubDomain(
        @Parameter(description = "name of the parent domain", required = true) @PathParam("parent") String parent,
        @Parameter(description = "Audit param required(not empty) if domain auditEnabled is true.", required = true) @HeaderParam("Y-Audit-Ref") String auditRef,
        @Parameter(description = "Resource owner for the request", required = true) @HeaderParam("Athenz-Resource-Owner") String resourceOwner,
        @Parameter(description = "Subdomain object to be created", required = true) SubDomain detail) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "postSubDomain");
            context.authorize("create", "" + parent + ":domain", null);
            return this.delegate.postSubDomain(context, parent, auditRef, resourceOwner, detail);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.BAD_REQUEST:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.FORBIDDEN:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.NOT_FOUND:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource postSubDomain");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.publishChangeMessage(context, code);
            this.delegate.recordMetrics(context, code);
        }
    }

    @POST
    @Path("/userdomain/{name}")
    @Consumes(MediaType.APPLICATION_JSON)
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "Create a new user domain. The user domain will be created in the user top level domain and the user himself will be set as the administrator for this domain.")
    public Domain postUserDomain(
        @Parameter(description = "name of the domain which will be the user id", required = true) @PathParam("name") String name,
        @Parameter(description = "Audit param required(not empty) if domain auditEnabled is true.", required = true) @HeaderParam("Y-Audit-Ref") String auditRef,
        @Parameter(description = "Resource owner for the request", required = true) @HeaderParam("Athenz-Resource-Owner") String resourceOwner,
        @Parameter(description = "UserDomain object to be created", required = true) UserDomain detail) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "postUserDomain");
            context.authorize("create", "user." + name + ":domain", null);
            return this.delegate.postUserDomain(context, name, auditRef, resourceOwner, detail);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.BAD_REQUEST:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.FORBIDDEN:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.NOT_FOUND:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource postUserDomain");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.publishChangeMessage(context, code);
            this.delegate.recordMetrics(context, code);
        }
    }

    @DELETE
    @Path("/domain/{name}")
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "Delete the specified domain.  This is a privileged action for the \"sys.auth\" administrators. Upon successful completion of this delete request, the server will return NO_CONTENT status code without any data (no object will be returned).")
    public void deleteTopLevelDomain(
        @Parameter(description = "name of the domain to be deleted", required = true) @PathParam("name") String name,
        @Parameter(description = "Audit param required(not empty) if domain auditEnabled is true.", required = true) @HeaderParam("Y-Audit-Ref") String auditRef,
        @Parameter(description = "Resource owner for the request", required = true) @HeaderParam("Athenz-Resource-Owner") String resourceOwner) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "deleteTopLevelDomain");
            context.authorize("delete", "sys.auth:domain", null);
            this.delegate.deleteTopLevelDomain(context, name, auditRef, resourceOwner);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.BAD_REQUEST:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.FORBIDDEN:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.NOT_FOUND:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource deleteTopLevelDomain");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.publishChangeMessage(context, code);
            this.delegate.recordMetrics(context, code);
        }
    }

    @DELETE
    @Path("/subdomain/{parent}/{name}")
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "Delete the specified subdomain. Caller must have domain delete permissions in parent or in the domain itself. Therefore, the RDL requires authentication only and the server will perform the authorization check based on the caller's identity. Upon successful completion of this delete request, the server will return NO_CONTENT status code without any data (no object will be returned).")
    public void deleteSubDomain(
        @Parameter(description = "name of the parent domain", required = true) @PathParam("parent") String parent,
        @Parameter(description = "name of the subdomain to be deleted", required = true) @PathParam("name") String name,
        @Parameter(description = "Audit param required(not empty) if domain auditEnabled is true.", required = true) @HeaderParam("Y-Audit-Ref") String auditRef,
        @Parameter(description = "Resource owner for the request", required = true) @HeaderParam("Athenz-Resource-Owner") String resourceOwner) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "deleteSubDomain");
            context.authenticate();
            this.delegate.deleteSubDomain(context, parent, name, auditRef, resourceOwner);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.BAD_REQUEST:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.FORBIDDEN:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.NOT_FOUND:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource deleteSubDomain");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.publishChangeMessage(context, code);
            this.delegate.recordMetrics(context, code);
        }
    }

    @DELETE
    @Path("/userdomain/{name}")
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "Delete the specified userdomain. Caller must have domain delete permissions in the domain. Upon successful completion of this delete request, the server will return NO_CONTENT status code without any data (no object will be returned).")
    public void deleteUserDomain(
        @Parameter(description = "name of the domain to be deleted which will be the user id", required = true) @PathParam("name") String name,
        @Parameter(description = "Audit param required(not empty) if domain auditEnabled is true.", required = true) @HeaderParam("Y-Audit-Ref") String auditRef,
        @Parameter(description = "Resource owner for the request", required = true) @HeaderParam("Athenz-Resource-Owner") String resourceOwner) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "deleteUserDomain");
            context.authorize("delete", "user." + name + ":domain", null);
            this.delegate.deleteUserDomain(context, name, auditRef, resourceOwner);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.BAD_REQUEST:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.FORBIDDEN:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.NOT_FOUND:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource deleteUserDomain");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.publishChangeMessage(context, code);
            this.delegate.recordMetrics(context, code);
        }
    }

    @PUT
    @Path("/domain/{name}/meta")
    @Consumes(MediaType.APPLICATION_JSON)
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "Update the specified top level domain metadata. Note that entities in the domain are not affected. Caller must have update privileges on the domain itself.")
    public void putDomainMeta(
        @Parameter(description = "name of the domain to be updated", required = true) @PathParam("name") String name,
        @Parameter(description = "Audit param required(not empty) if domain auditEnabled is true.", required = true) @HeaderParam("Y-Audit-Ref") String auditRef,
        @Parameter(description = "Resource owner for the request", required = true) @HeaderParam("Athenz-Resource-Owner") String resourceOwner,
        @Parameter(description = "DomainMeta object with updated attribute values", required = true) DomainMeta detail) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "putDomainMeta");
            context.authorize("update", "" + name + ":", null);
            this.delegate.putDomainMeta(context, name, auditRef, resourceOwner, detail);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.BAD_REQUEST:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.CONFLICT:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.FORBIDDEN:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.NOT_FOUND:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource putDomainMeta");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.publishChangeMessage(context, code);
            this.delegate.recordMetrics(context, code);
        }
    }

    @PUT
    @Path("/domain/{name}/meta/system/{attribute}")
    @Consumes(MediaType.APPLICATION_JSON)
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "Set the specified top level domain metadata. Note that entities in the domain are not affected. Caller must have update privileges on the domain itself. If the system attribute is one of the string attributes, then the caller must also have delete action on the same resource in order to reset the configured value")
    public void putDomainSystemMeta(
        @Parameter(description = "name of the domain to be updated", required = true) @PathParam("name") String name,
        @Parameter(description = "name of the system attribute to be modified", required = true) @PathParam("attribute") String attribute,
        @Parameter(description = "Audit param required(not empty) if domain auditEnabled is true.", required = true) @HeaderParam("Y-Audit-Ref") String auditRef,
        @Parameter(description = "DomainMeta object with updated attribute values", required = true) DomainMeta detail) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "putDomainSystemMeta");
            context.authorize("update", "sys.auth:meta.domain." + attribute + "." + name + "", null);
            this.delegate.putDomainSystemMeta(context, name, attribute, auditRef, detail);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.BAD_REQUEST:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.CONFLICT:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.FORBIDDEN:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.NOT_FOUND:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource putDomainSystemMeta");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.publishChangeMessage(context, code);
            this.delegate.recordMetrics(context, code);
        }
    }

    @PUT
    @Path("/domain/{name}/template")
    @Consumes(MediaType.APPLICATION_JSON)
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "Update the given domain by applying the roles and policies defined in the specified solution template(s). Caller must have UPDATE privileges on the domain itself.")
    public void putDomainTemplate(
        @Parameter(description = "name of the domain to be updated", required = true) @PathParam("name") String name,
        @Parameter(description = "Audit param required(not empty) if domain auditEnabled is true.", required = true) @HeaderParam("Y-Audit-Ref") String auditRef,
        @Parameter(description = "DomainTemplate object with solution template name(s)", required = true) DomainTemplate domainTemplate) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "putDomainTemplate");
            context.authorize("update", "" + name + ":template", null);
            this.delegate.putDomainTemplate(context, name, auditRef, domainTemplate);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.BAD_REQUEST:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.CONFLICT:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.FORBIDDEN:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.NOT_FOUND:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource putDomainTemplate");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.publishChangeMessage(context, code);
            this.delegate.recordMetrics(context, code);
        }
    }

    @PUT
    @Path("/domain/{name}/template/{template}")
    @Consumes(MediaType.APPLICATION_JSON)
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "Update the given domain by applying the roles and policies defined in the specified solution template(s). Caller must have UPDATE privileges on the domain itself.")
    public void putDomainTemplateExt(
        @Parameter(description = "name of the domain to be updated", required = true) @PathParam("name") String name,
        @Parameter(description = "name of the solution template", required = true) @PathParam("template") String template,
        @Parameter(description = "Audit param required(not empty) if domain auditEnabled is true.", required = true) @HeaderParam("Y-Audit-Ref") String auditRef,
        @Parameter(description = "DomainTemplate object with a single template name to match URI", required = true) DomainTemplate domainTemplate) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "putDomainTemplateExt");
            context.authorize("update", "" + name + ":template." + template + "", null);
            this.delegate.putDomainTemplateExt(context, name, template, auditRef, domainTemplate);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.BAD_REQUEST:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.CONFLICT:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.FORBIDDEN:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.NOT_FOUND:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource putDomainTemplateExt");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.publishChangeMessage(context, code);
            this.delegate.recordMetrics(context, code);
        }
    }

    @GET
    @Path("/domain/{name}/template")
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "Get the list of solution templates applied to a domain")
    public DomainTemplateList getDomainTemplateList(
        @Parameter(description = "name of the domain", required = true) @PathParam("name") String name) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "getDomainTemplateList");
            context.authenticate();
            return this.delegate.getDomainTemplateList(context, name);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.BAD_REQUEST:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.NOT_FOUND:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource getDomainTemplateList");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.recordMetrics(context, code);
        }
    }

    @DELETE
    @Path("/domain/{name}/template/{template}")
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "Update the given domain by deleting the specified template from the domain template list. Cycles through the roles and policies defined in the template and deletes them. Caller must have delete privileges on the domain itself.")
    public void deleteDomainTemplate(
        @Parameter(description = "name of the domain to be updated", required = true) @PathParam("name") String name,
        @Parameter(description = "name of the solution template", required = true) @PathParam("template") String template,
        @Parameter(description = "Audit param required(not empty) if domain auditEnabled is true.", required = true) @HeaderParam("Y-Audit-Ref") String auditRef) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "deleteDomainTemplate");
            context.authorize("delete", "" + name + ":template." + template + "", null);
            this.delegate.deleteDomainTemplate(context, name, template, auditRef);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.BAD_REQUEST:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.CONFLICT:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.FORBIDDEN:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.NOT_FOUND:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource deleteDomainTemplate");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.publishChangeMessage(context, code);
            this.delegate.recordMetrics(context, code);
        }
    }

    @GET
    @Path("/domain/metastore")
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "List all valid values for the given attribute and user")
    public DomainMetaStoreValidValuesList getDomainMetaStoreValidValuesList(
        @Parameter(description = "name of attribute", required = true) @QueryParam("attribute") String attributeName,
        @Parameter(description = "restrict to values associated with the given user", required = false) @QueryParam("user") String userName) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "getDomainMetaStoreValidValuesList");
            context.authenticate();
            return this.delegate.getDomainMetaStoreValidValuesList(context, attributeName, userName);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.BAD_REQUEST:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.NOT_FOUND:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource getDomainMetaStoreValidValuesList");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.recordMetrics(context, code);
        }
    }

    @GET
    @Path("/domain/{domainName}/history/auth")
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "Get the authorization and token requests history for the domain")
    public AuthHistoryDependencies getAuthHistoryDependencies(
        @Parameter(description = "name of the domain", required = true) @PathParam("domainName") String domainName) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "getAuthHistoryDependencies");
            context.authenticate();
            return this.delegate.getAuthHistoryDependencies(context, domainName);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.BAD_REQUEST:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.NOT_FOUND:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource getAuthHistoryDependencies");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.recordMetrics(context, code);
        }
    }

    @DELETE
    @Path("/expired-members")
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "Delete expired principals This command will purge expired members of the following resources based on the purgeResources value 0 - none of them will be purged 1 - only roles will be purged 2 - only groups will be purged default/3 - both of them will be purged")
    public Response deleteExpiredMembers(
        @Parameter(description = "defining which resources will be purged. by default all resources will be purged", required = false) @QueryParam("purgeResources") Integer purgeResources,
        @Parameter(description = "Audit reference", required = true) @HeaderParam("Y-Audit-Ref") String auditRef,
        @Parameter(description = "Return object param updated object back.", required = false) @HeaderParam("Athenz-Return-Object") Boolean returnObj) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "deleteExpiredMembers");
            context.authorize("delete", "sys.auth:expired_members", null);
            return this.delegate.deleteExpiredMembers(context, purgeResources, auditRef, returnObj);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.BAD_REQUEST:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.FORBIDDEN:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource deleteExpiredMembers");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.publishChangeMessage(context, code);
            this.delegate.recordMetrics(context, code);
        }
    }

    @PUT
    @Path("/domain/{domainName}/ownership")
    @Consumes(MediaType.APPLICATION_JSON)
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "Set the resource ownership for the given domain")
    public void putResourceDomainOwnership(
        @Parameter(description = "name of the domain", required = true) @PathParam("domainName") String domainName,
        @Parameter(description = "Audit param required(not empty) if domain auditEnabled is true.", required = true) @HeaderParam("Y-Audit-Ref") String auditRef,
        @Parameter(description = "resource ownership to be set for the given domain", required = true) ResourceDomainOwnership resourceOwnership) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "putResourceDomainOwnership");
            context.authorize("update", "" + domainName + ":meta.domain.ownership", null);
            this.delegate.putResourceDomainOwnership(context, domainName, auditRef, resourceOwnership);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.BAD_REQUEST:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.FORBIDDEN:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.NOT_FOUND:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource putResourceDomainOwnership");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.publishChangeMessage(context, code);
            this.delegate.recordMetrics(context, code);
        }
    }

    @GET
    @Path("/domain/{domainName}/check")
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "Carry out data check operation for the specified domain.")
    public DomainDataCheck getDomainDataCheck(
        @Parameter(description = "name of the domain", required = true) @PathParam("domainName") String domainName) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "getDomainDataCheck");
            context.authenticate();
            return this.delegate.getDomainDataCheck(context, domainName);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.FORBIDDEN:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.NOT_FOUND:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource getDomainDataCheck");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.recordMetrics(context, code);
        }
    }

    @PUT
    @Path("/domain/{domainName}/entity/{entityName}")
    @Consumes(MediaType.APPLICATION_JSON)
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "Put an entity into the domain.")
    public void putEntity(
        @Parameter(description = "name of the domain", required = true) @PathParam("domainName") String domainName,
        @Parameter(description = "name of entity", required = true) @PathParam("entityName") String entityName,
        @Parameter(description = "Audit param required(not empty) if domain auditEnabled is true.", required = true) @HeaderParam("Y-Audit-Ref") String auditRef,
        @Parameter(description = "Entity object to be added to the domain", required = true) Entity entity) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "putEntity");
            context.authorize("update", "" + domainName + ":entity." + entityName + "", null);
            this.delegate.putEntity(context, domainName, entityName, auditRef, entity);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.BAD_REQUEST:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.CONFLICT:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.FORBIDDEN:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.NOT_FOUND:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource putEntity");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.publishChangeMessage(context, code);
            this.delegate.recordMetrics(context, code);
        }
    }

    @GET
    @Path("/domain/{domainName}/entity/{entityName}")
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "Get a entity from a domain. open for all authenticated users to read")
    public Entity getEntity(
        @Parameter(description = "name of the domain", required = true) @PathParam("domainName") String domainName,
        @Parameter(description = "name of entity", required = true) @PathParam("entityName") String entityName) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "getEntity");
            context.authenticate();
            return this.delegate.getEntity(context, domainName, entityName);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.BAD_REQUEST:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.FORBIDDEN:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.NOT_FOUND:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource getEntity");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.recordMetrics(context, code);
        }
    }

    @DELETE
    @Path("/domain/{domainName}/entity/{entityName}")
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "Delete the entity from the domain. Upon successful completion of this delete request, the server will return NO_CONTENT status code without any data (no object will be returned).")
    public void deleteEntity(
        @Parameter(description = "name of the domain", required = true) @PathParam("domainName") String domainName,
        @Parameter(description = "name of entity", required = true) @PathParam("entityName") String entityName,
        @Parameter(description = "Audit param required(not empty) if domain auditEnabled is true.", required = true) @HeaderParam("Y-Audit-Ref") String auditRef) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "deleteEntity");
            context.authorize("delete", "" + domainName + ":entity." + entityName + "", null);
            this.delegate.deleteEntity(context, domainName, entityName, auditRef);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.BAD_REQUEST:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.CONFLICT:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.FORBIDDEN:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.NOT_FOUND:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource deleteEntity");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.publishChangeMessage(context, code);
            this.delegate.recordMetrics(context, code);
        }
    }

    @GET
    @Path("/domain/{domainName}/entity")
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "Enumerate entities provisioned in this domain.")
    public EntityList getEntityList(
        @Parameter(description = "name of the domain", required = true) @PathParam("domainName") String domainName) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "getEntityList");
            context.authenticate();
            return this.delegate.getEntityList(context, domainName);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.BAD_REQUEST:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.NOT_FOUND:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource getEntityList");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.recordMetrics(context, code);
        }
    }

    @GET
    @Path("/domain/{domainName}/role")
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "Enumerate roles provisioned in this domain.")
    public RoleList getRoleList(
        @Parameter(description = "name of the domain", required = true) @PathParam("domainName") String domainName,
        @Parameter(description = "restrict the number of results in this call", required = false) @QueryParam("limit") Integer limit,
        @Parameter(description = "restrict the set to those after the specified \"next\" token returned from a previous call", required = false) @QueryParam("skip") String skip) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "getRoleList");
            context.authenticate();
            return this.delegate.getRoleList(context, domainName, limit, skip);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.BAD_REQUEST:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.FORBIDDEN:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.NOT_FOUND:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource getRoleList");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.recordMetrics(context, code);
        }
    }

    @GET
    @Path("/domain/{domainName}/roles")
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "Get the list of all roles in a domain with optional flag whether or not include members")
    public Roles getRoles(
        @Parameter(description = "name of the domain", required = true) @PathParam("domainName") String domainName,
        @Parameter(description = "return list of members in the role", required = false) @QueryParam("members") @DefaultValue("false") Boolean members,
        @Parameter(description = "flag to query all roles that have a given tagName", required = false) @QueryParam("tagKey") String tagKey,
        @Parameter(description = "flag to query all roles that have a given tag name and value", required = false) @QueryParam("tagValue") String tagValue) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "getRoles");
            context.authenticate();
            return this.delegate.getRoles(context, domainName, members, tagKey, tagValue);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.BAD_REQUEST:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.NOT_FOUND:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource getRoles");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.recordMetrics(context, code);
        }
    }

    @GET
    @Path("/domain/{domainName}/role/{roleName}")
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "Get the specified role in the domain.")
    public Role getRole(
        @Parameter(description = "name of the domain", required = true) @PathParam("domainName") String domainName,
        @Parameter(description = "name of the role to be retrieved", required = true) @PathParam("roleName") String roleName,
        @Parameter(description = "flag to indicate whether or not to return role audit log", required = false) @QueryParam("auditLog") @DefaultValue("false") Boolean auditLog,
        @Parameter(description = "expand delegated trust roles and return trusted members", required = false) @QueryParam("expand") @DefaultValue("false") Boolean expand,
        @Parameter(description = "include pending members", required = false) @QueryParam("pending") @DefaultValue("false") Boolean pending) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "getRole");
            context.authenticate();
            return this.delegate.getRole(context, domainName, roleName, auditLog, expand, pending);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.BAD_REQUEST:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.FORBIDDEN:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.NOT_FOUND:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource getRole");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.recordMetrics(context, code);
        }
    }

    @PUT
    @Path("/domain/{domainName}/role/{roleName}")
    @Consumes(MediaType.APPLICATION_JSON)
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "Create/update the specified role.")
    public Response putRole(
        @Parameter(description = "name of the domain", required = true) @PathParam("domainName") String domainName,
        @Parameter(description = "name of the role to be added/updated", required = true) @PathParam("roleName") String roleName,
        @Parameter(description = "Audit param required(not empty) if domain auditEnabled is true.", required = true) @HeaderParam("Y-Audit-Ref") String auditRef,
        @Parameter(description = "Return object param updated object back.", required = false) @HeaderParam("Athenz-Return-Object") Boolean returnObj,
        @Parameter(description = "Resource owner for the request", required = true) @HeaderParam("Athenz-Resource-Owner") String resourceOwner,
        @Parameter(description = "Role object to be added/updated in the domain", required = true) Role role) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "putRole");
            context.authorize("update", "" + domainName + ":role." + roleName + "", null);
            return this.delegate.putRole(context, domainName, roleName, auditRef, returnObj, resourceOwner, role);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.BAD_REQUEST:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.CONFLICT:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.FORBIDDEN:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.NOT_FOUND:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource putRole");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.publishChangeMessage(context, code);
            this.delegate.recordMetrics(context, code);
        }
    }

    @DELETE
    @Path("/domain/{domainName}/role/{roleName}")
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "Delete the specified role. Upon successful completion of this delete request, the server will return NO_CONTENT status code without any data (no object will be returned).")
    public void deleteRole(
        @Parameter(description = "name of the domain", required = true) @PathParam("domainName") String domainName,
        @Parameter(description = "name of the role to be deleted", required = true) @PathParam("roleName") String roleName,
        @Parameter(description = "Audit param required(not empty) if domain auditEnabled is true.", required = true) @HeaderParam("Y-Audit-Ref") String auditRef,
        @Parameter(description = "Resource owner for the request", required = true) @HeaderParam("Athenz-Resource-Owner") String resourceOwner) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "deleteRole");
            context.authorize("delete", "" + domainName + ":role." + roleName + "", null);
            this.delegate.deleteRole(context, domainName, roleName, auditRef, resourceOwner);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.BAD_REQUEST:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.CONFLICT:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.FORBIDDEN:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.NOT_FOUND:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource deleteRole");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.publishChangeMessage(context, code);
            this.delegate.recordMetrics(context, code);
        }
    }

    @GET
    @Path("/domain/{domainName}/role/{roleName}/member/{memberName}")
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "Get the membership status for a specified user in a role.")
    public Membership getMembership(
        @Parameter(description = "name of the domain", required = true) @PathParam("domainName") String domainName,
        @Parameter(description = "name of the role", required = true) @PathParam("roleName") String roleName,
        @Parameter(description = "user name to be checked for membership", required = true) @PathParam("memberName") String memberName,
        @Parameter(description = "the expiration timestamp", required = false) @QueryParam("expiration") String expiration) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "getMembership");
            context.authenticate();
            return this.delegate.getMembership(context, domainName, roleName, memberName, expiration);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.BAD_REQUEST:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.FORBIDDEN:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.NOT_FOUND:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource getMembership");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.recordMetrics(context, code);
        }
    }

    @GET
    @Path("/domain/{domainName}/overdue")
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "Get members with overdue review")
    public DomainRoleMembers getOverdueReview(
        @Parameter(description = "name of the domain", required = true) @PathParam("domainName") String domainName) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "getOverdueReview");
            context.authenticate();
            return this.delegate.getOverdueReview(context, domainName);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.BAD_REQUEST:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.FORBIDDEN:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.NOT_FOUND:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource getOverdueReview");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.recordMetrics(context, code);
        }
    }

    @GET
    @Path("/domain/{domainName}/member")
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "Get list of principals defined in roles in the given domain")
    public DomainRoleMembers getDomainRoleMembers(
        @Parameter(description = "name of the domain", required = true) @PathParam("domainName") String domainName) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "getDomainRoleMembers");
            context.authenticate();
            return this.delegate.getDomainRoleMembers(context, domainName);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.BAD_REQUEST:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.FORBIDDEN:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.NOT_FOUND:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource getDomainRoleMembers");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.recordMetrics(context, code);
        }
    }

    @GET
    @Path("/role")
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "Fetch all the roles across domains by either calling or specified principal The optional expand argument will include all direct and indirect roles, however, it will force authorization that you must be either the principal or for service accounts have update access to the service identity: 1. authenticated principal is the same as the check principal 2. system authorized (\"access\", \"sys.auth:meta.role.lookup\") 3. service admin (\"update\", \"{principal}\") 4. domain authorized (\"access\", \"{domainName}:meta.role.lookup\") if domainName is provided")
    public DomainRoleMember getPrincipalRoles(
        @Parameter(description = "If not present, will return roles for the user making the call", required = false) @QueryParam("principal") String principal,
        @Parameter(description = "If not present, will return roles from all domains", required = false) @QueryParam("domain") String domainName,
        @Parameter(description = "expand to include group and delegated trust role membership", required = false) @QueryParam("expand") @DefaultValue("false") Boolean expand) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "getPrincipalRoles");
            context.authenticate();
            return this.delegate.getPrincipalRoles(context, principal, domainName, expand);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.BAD_REQUEST:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.FORBIDDEN:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.NOT_FOUND:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource getPrincipalRoles");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.recordMetrics(context, code);
        }
    }

    @PUT
    @Path("/domain/{domainName}/role/{roleName}/member/{memberName}")
    @Consumes(MediaType.APPLICATION_JSON)
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "Add the specified user to the role's member list. If the role is selfRenewEnabled, then an existing member may extend their expiration time by the configured number of minutes (selfRenewMins) by calling this API regardless or not the user is expired or active. If the role is neither auditEnabled nor selfserve, then it will use authorize (\"update\", \"{domainName}:role.{roleName}\") or (\"update_members\", \"{domainName}:role.{roleName}\"). This only allows access to members and not role attributes. otherwise membership will be sent for approval to either designated delegates ( in case of auditEnabled roles ) or to domain admins ( in case of selfserve roles )")
    public Response putMembership(
        @Parameter(description = "name of the domain", required = true) @PathParam("domainName") String domainName,
        @Parameter(description = "name of the role", required = true) @PathParam("roleName") String roleName,
        @Parameter(description = "name of the user to be added as a member", required = true) @PathParam("memberName") String memberName,
        @Parameter(description = "Audit param required(not empty) if domain auditEnabled is true.", required = true) @HeaderParam("Y-Audit-Ref") String auditRef,
        @Parameter(description = "Return object param updated object back.", required = false) @HeaderParam("Athenz-Return-Object") Boolean returnObj,
        @Parameter(description = "Resource owner for the request", required = true) @HeaderParam("Athenz-Resource-Owner") String resourceOwner,
        @Parameter(description = "Membership object (must contain role/member names as specified in the URI)", required = true) Membership membership) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "putMembership");
            context.authenticate();
            return this.delegate.putMembership(context, domainName, roleName, memberName, auditRef, returnObj, resourceOwner, membership);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.BAD_REQUEST:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.CONFLICT:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.FORBIDDEN:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.NOT_FOUND:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource putMembership");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.publishChangeMessage(context, code);
            this.delegate.recordMetrics(context, code);
        }
    }

    @DELETE
    @Path("/domain/{domainName}/role/{roleName}/member/{memberName}")
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "Delete the specified role membership. Upon successful completion of this delete request, the server will return NO_CONTENT status code without any data (no object will be returned). The required authorization includes three options: 1. (\"update\", \"{domainName}:role.{roleName}\") 2. (\"update_members\", \"{domainName}:role.{roleName}\") 3. principal matches memberName")
    public void deleteMembership(
        @Parameter(description = "name of the domain", required = true) @PathParam("domainName") String domainName,
        @Parameter(description = "name of the role", required = true) @PathParam("roleName") String roleName,
        @Parameter(description = "name of the user to be removed as a member", required = true) @PathParam("memberName") String memberName,
        @Parameter(description = "Audit param required(not empty) if domain auditEnabled is true.", required = true) @HeaderParam("Y-Audit-Ref") String auditRef,
        @Parameter(description = "Resource owner for the request", required = true) @HeaderParam("Athenz-Resource-Owner") String resourceOwner) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "deleteMembership");
            context.authenticate();
            this.delegate.deleteMembership(context, domainName, roleName, memberName, auditRef, resourceOwner);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.BAD_REQUEST:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.CONFLICT:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.FORBIDDEN:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.NOT_FOUND:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource deleteMembership");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.publishChangeMessage(context, code);
            this.delegate.recordMetrics(context, code);
        }
    }

    @DELETE
    @Path("/domain/{domainName}/role/{roleName}/pendingmember/{memberName}")
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "Delete the specified pending role membership. Upon successful completion of this delete request, the server will return NO_CONTENT status code without any data (no object will be returned). Authorization will be completed within the server itself since there are two possibilities: 1) The domain admins can delete any pending requests 2) the requestor can also delete his/her own pending request.")
    public void deletePendingMembership(
        @Parameter(description = "name of the domain", required = true) @PathParam("domainName") String domainName,
        @Parameter(description = "name of the role", required = true) @PathParam("roleName") String roleName,
        @Parameter(description = "name of the user to be removed as a pending member", required = true) @PathParam("memberName") String memberName,
        @Parameter(description = "Audit param required(not empty) if domain auditEnabled is true.", required = true) @HeaderParam("Y-Audit-Ref") String auditRef) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "deletePendingMembership");
            context.authenticate();
            this.delegate.deletePendingMembership(context, domainName, roleName, memberName, auditRef);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.BAD_REQUEST:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.CONFLICT:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.FORBIDDEN:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.NOT_FOUND:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource deletePendingMembership");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.publishChangeMessage(context, code);
            this.delegate.recordMetrics(context, code);
        }
    }

    @PUT
    @Path("/domain/{domainName}/admins")
    @Consumes(MediaType.APPLICATION_JSON)
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "Verify and, if necessary, fix domain roles and policies to make sure the given set of users have administrative access to the domain. This request is only restricted to \"sys.auth\" domain administrators and can be used when the domain administrators incorrectly have blocked their own access to their domains.")
    public void putDefaultAdmins(
        @Parameter(description = "name of the domain", required = true) @PathParam("domainName") String domainName,
        @Parameter(description = "Audit param required(not empty) if domain auditEnabled is true.", required = true) @HeaderParam("Y-Audit-Ref") String auditRef,
        @Parameter(description = "list of domain administrators", required = true) DefaultAdmins defaultAdmins) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "putDefaultAdmins");
            context.authorize("update", "sys.auth:domain", null);
            this.delegate.putDefaultAdmins(context, domainName, auditRef, defaultAdmins);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.BAD_REQUEST:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.FORBIDDEN:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.NOT_FOUND:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource putDefaultAdmins");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.publishChangeMessage(context, code);
            this.delegate.recordMetrics(context, code);
        }
    }

    @PUT
    @Path("/domain/{domainName}/role/{roleName}/meta/system/{attribute}")
    @Consumes(MediaType.APPLICATION_JSON)
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "Set the specified role metadata. Caller must have update privileges on the sys.auth domain. If the system attribute is one of the string attributes, then the caller must also have delete action on the same resource in order to reset the configured value")
    public void putRoleSystemMeta(
        @Parameter(description = "name of the domain", required = true) @PathParam("domainName") String domainName,
        @Parameter(description = "name of the role", required = true) @PathParam("roleName") String roleName,
        @Parameter(description = "name of the system attribute to be modified", required = true) @PathParam("attribute") String attribute,
        @Parameter(description = "Audit param required(not empty) if domain auditEnabled is true.", required = true) @HeaderParam("Y-Audit-Ref") String auditRef,
        @Parameter(description = "RoleSystemMeta object with updated attribute values", required = true) RoleSystemMeta detail) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "putRoleSystemMeta");
            context.authorize("update", "sys.auth:meta.role." + attribute + "." + domainName + "", null);
            this.delegate.putRoleSystemMeta(context, domainName, roleName, attribute, auditRef, detail);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.BAD_REQUEST:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.CONFLICT:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.FORBIDDEN:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.NOT_FOUND:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource putRoleSystemMeta");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.publishChangeMessage(context, code);
            this.delegate.recordMetrics(context, code);
        }
    }

    @PUT
    @Path("/domain/{domainName}/role/{roleName}/meta")
    @Consumes(MediaType.APPLICATION_JSON)
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "Update the specified role metadata. Caller must have update privileges on the domain itself.")
    public void putRoleMeta(
        @Parameter(description = "name of the domain to be updated", required = true) @PathParam("domainName") String domainName,
        @Parameter(description = "name of the role", required = true) @PathParam("roleName") String roleName,
        @Parameter(description = "Audit param required(not empty) if domain auditEnabled is true.", required = true) @HeaderParam("Y-Audit-Ref") String auditRef,
        @Parameter(description = "Resource owner for the request", required = true) @HeaderParam("Athenz-Resource-Owner") String resourceOwner,
        @Parameter(description = "RoleMeta object with updated attribute values", required = true) RoleMeta detail) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "putRoleMeta");
            context.authenticate();
            this.delegate.putRoleMeta(context, domainName, roleName, auditRef, resourceOwner, detail);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.BAD_REQUEST:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.CONFLICT:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.FORBIDDEN:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.NOT_FOUND:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource putRoleMeta");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.publishChangeMessage(context, code);
            this.delegate.recordMetrics(context, code);
        }
    }

    @PUT
    @Path("/domain/{domainName}/role/{roleName}/member/{memberName}/decision")
    @Consumes(MediaType.APPLICATION_JSON)
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "Approve or Reject the request to add specified user to role membership. This endpoint will be used by 2 use cases: 1. Audit enabled roles with authorize (\"update\", \"sys.auth:meta.role.{attribute}.{domainName}\") 2. Selfserve roles in any domain with authorize (\"update\", \"{domainName}:\")")
    public void putMembershipDecision(
        @Parameter(description = "name of the domain", required = true) @PathParam("domainName") String domainName,
        @Parameter(description = "name of the role", required = true) @PathParam("roleName") String roleName,
        @Parameter(description = "name of the user to be added as a member", required = true) @PathParam("memberName") String memberName,
        @Parameter(description = "Audit param required(not empty) if domain auditEnabled is true.", required = true) @HeaderParam("Y-Audit-Ref") String auditRef,
        @Parameter(description = "Membership object (must contain role/member names as specified in the URI)", required = true) Membership membership) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "putMembershipDecision");
            context.authenticate();
            this.delegate.putMembershipDecision(context, domainName, roleName, memberName, auditRef, membership);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.BAD_REQUEST:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.CONFLICT:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.FORBIDDEN:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.NOT_FOUND:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource putMembershipDecision");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.publishChangeMessage(context, code);
            this.delegate.recordMetrics(context, code);
        }
    }

    @PUT
    @Path("/domain/{domainName}/role/{roleName}/review")
    @Consumes(MediaType.APPLICATION_JSON)
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "Review role membership and take action to either extend and/or delete existing members.")
    public Response putRoleReview(
        @Parameter(description = "name of the domain", required = true) @PathParam("domainName") String domainName,
        @Parameter(description = "name of the role", required = true) @PathParam("roleName") String roleName,
        @Parameter(description = "Audit param required(not empty) if domain auditEnabled is true.", required = true) @HeaderParam("Y-Audit-Ref") String auditRef,
        @Parameter(description = "Return object param updated object back.", required = false) @HeaderParam("Athenz-Return-Object") Boolean returnObj,
        @Parameter(description = "Resource owner for the request", required = true) @HeaderParam("Athenz-Resource-Owner") String resourceOwner,
        @Parameter(description = "Role object with updated and/or deleted members", required = true) Role role) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "putRoleReview");
            context.authorize("update", "" + domainName + ":role." + roleName + "", null);
            return this.delegate.putRoleReview(context, domainName, roleName, auditRef, returnObj, resourceOwner, role);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.BAD_REQUEST:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.CONFLICT:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.FORBIDDEN:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.NOT_FOUND:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource putRoleReview");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.publishChangeMessage(context, code);
            this.delegate.recordMetrics(context, code);
        }
    }

    @PUT
    @Path("/domain/{domainName}/role/{roleName}/ownership")
    @Consumes(MediaType.APPLICATION_JSON)
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "Set the resource ownership for the given role")
    public void putResourceRoleOwnership(
        @Parameter(description = "name of the domain", required = true) @PathParam("domainName") String domainName,
        @Parameter(description = "name of the role", required = true) @PathParam("roleName") String roleName,
        @Parameter(description = "Audit param required(not empty) if domain auditEnabled is true.", required = true) @HeaderParam("Y-Audit-Ref") String auditRef,
        @Parameter(description = "resource ownership to be set for the given role", required = true) ResourceRoleOwnership resourceOwnership) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "putResourceRoleOwnership");
            context.authorize("update", "" + domainName + ":meta.role.ownership." + roleName + "", null);
            this.delegate.putResourceRoleOwnership(context, domainName, roleName, auditRef, resourceOwnership);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.BAD_REQUEST:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.FORBIDDEN:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.NOT_FOUND:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource putResourceRoleOwnership");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.publishChangeMessage(context, code);
            this.delegate.recordMetrics(context, code);
        }
    }

    @GET
    @Path("/domain/{domainName}/groups")
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "Get the list of all groups in a domain with optional flag whether or not include members")
    public Groups getGroups(
        @Parameter(description = "name of the domain", required = true) @PathParam("domainName") String domainName,
        @Parameter(description = "return list of members in the group", required = false) @QueryParam("members") @DefaultValue("false") Boolean members,
        @Parameter(description = "flag to query all groups that have a given tagName", required = false) @QueryParam("tagKey") String tagKey,
        @Parameter(description = "flag to query all groups that have a given tag name and value", required = false) @QueryParam("tagValue") String tagValue) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "getGroups");
            context.authenticate();
            return this.delegate.getGroups(context, domainName, members, tagKey, tagValue);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.BAD_REQUEST:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.NOT_FOUND:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource getGroups");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.recordMetrics(context, code);
        }
    }

    @GET
    @Path("/domain/{domainName}/group/{groupName}")
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "Get the specified group in the domain.")
    public Group getGroup(
        @Parameter(description = "name of the domain", required = true) @PathParam("domainName") String domainName,
        @Parameter(description = "name of the group to be retrieved", required = true) @PathParam("groupName") String groupName,
        @Parameter(description = "flag to indicate whether or not to return group audit log", required = false) @QueryParam("auditLog") @DefaultValue("false") Boolean auditLog,
        @Parameter(description = "include pending members", required = false) @QueryParam("pending") @DefaultValue("false") Boolean pending) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "getGroup");
            context.authenticate();
            return this.delegate.getGroup(context, domainName, groupName, auditLog, pending);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.BAD_REQUEST:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.FORBIDDEN:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.NOT_FOUND:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource getGroup");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.recordMetrics(context, code);
        }
    }

    @PUT
    @Path("/domain/{domainName}/group/{groupName}")
    @Consumes(MediaType.APPLICATION_JSON)
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "Create/update the specified group.")
    public Response putGroup(
        @Parameter(description = "name of the domain", required = true) @PathParam("domainName") String domainName,
        @Parameter(description = "name of the group to be added/updated", required = true) @PathParam("groupName") String groupName,
        @Parameter(description = "Audit param required(not empty) if domain auditEnabled is true.", required = true) @HeaderParam("Y-Audit-Ref") String auditRef,
        @Parameter(description = "Return object param updated object back.", required = false) @HeaderParam("Athenz-Return-Object") Boolean returnObj,
        @Parameter(description = "Resource owner for the request", required = true) @HeaderParam("Athenz-Resource-Owner") String resourceOwner,
        @Parameter(description = "Group object to be added/updated in the domain", required = true) Group group) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "putGroup");
            context.authorize("update", "" + domainName + ":group." + groupName + "", null);
            return this.delegate.putGroup(context, domainName, groupName, auditRef, returnObj, resourceOwner, group);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.BAD_REQUEST:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.CONFLICT:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.FORBIDDEN:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.NOT_FOUND:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource putGroup");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.publishChangeMessage(context, code);
            this.delegate.recordMetrics(context, code);
        }
    }

    @DELETE
    @Path("/domain/{domainName}/group/{groupName}")
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "Delete the specified group. Upon successful completion of this delete request, the server will return NO_CONTENT status code without any data (no object will be returned).")
    public void deleteGroup(
        @Parameter(description = "name of the domain", required = true) @PathParam("domainName") String domainName,
        @Parameter(description = "name of the group to be deleted", required = true) @PathParam("groupName") String groupName,
        @Parameter(description = "Audit param required(not empty) if domain auditEnabled is true.", required = true) @HeaderParam("Y-Audit-Ref") String auditRef,
        @Parameter(description = "Resource owner for the request", required = true) @HeaderParam("Athenz-Resource-Owner") String resourceOwner) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "deleteGroup");
            context.authorize("delete", "" + domainName + ":group." + groupName + "", null);
            this.delegate.deleteGroup(context, domainName, groupName, auditRef, resourceOwner);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.BAD_REQUEST:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.CONFLICT:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.FORBIDDEN:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.NOT_FOUND:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource deleteGroup");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.publishChangeMessage(context, code);
            this.delegate.recordMetrics(context, code);
        }
    }

    @GET
    @Path("/domain/{domainName}/group/{groupName}/member/{memberName}")
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "Get the membership status for a specified user in a group.")
    public GroupMembership getGroupMembership(
        @Parameter(description = "name of the domain", required = true) @PathParam("domainName") String domainName,
        @Parameter(description = "name of the group", required = true) @PathParam("groupName") String groupName,
        @Parameter(description = "user name to be checked for membership", required = true) @PathParam("memberName") String memberName,
        @Parameter(description = "the expiration timestamp", required = false) @QueryParam("expiration") String expiration) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "getGroupMembership");
            context.authenticate();
            return this.delegate.getGroupMembership(context, domainName, groupName, memberName, expiration);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.BAD_REQUEST:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.FORBIDDEN:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.NOT_FOUND:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource getGroupMembership");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.recordMetrics(context, code);
        }
    }

    @GET
    @Path("/group")
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "Fetch all the groups across domains by either calling or specified principal")
    public DomainGroupMember getPrincipalGroups(
        @Parameter(description = "If not present, will return groups for the user making the call", required = false) @QueryParam("principal") String principal,
        @Parameter(description = "If not present, will return groups from all domains", required = false) @QueryParam("domain") String domainName) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "getPrincipalGroups");
            context.authenticate();
            return this.delegate.getPrincipalGroups(context, principal, domainName);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.BAD_REQUEST:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.FORBIDDEN:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.NOT_FOUND:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource getPrincipalGroups");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.recordMetrics(context, code);
        }
    }

    @PUT
    @Path("/domain/{domainName}/group/{groupName}/member/{memberName}")
    @Consumes(MediaType.APPLICATION_JSON)
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "Add the specified user to the group's member list. If the group is selfRenewEnabled, then an existing member may extend their expiration time by the configured number of minutes (selfRenewMins) by calling this API regardless or not the user is expired or active. If the group is neither auditEnabled nor selfserve, then it will use authorize (\"update\", \"{domainName}:group.{groupName}\") otherwise membership will be sent for approval to either designated delegates ( in case of auditEnabled groups ) or to domain admins ( in case of selfserve groups )")
    public Response putGroupMembership(
        @Parameter(description = "name of the domain", required = true) @PathParam("domainName") String domainName,
        @Parameter(description = "name of the group", required = true) @PathParam("groupName") String groupName,
        @Parameter(description = "name of the user to be added as a member", required = true) @PathParam("memberName") String memberName,
        @Parameter(description = "Audit param required(not empty) if domain auditEnabled is true.", required = true) @HeaderParam("Y-Audit-Ref") String auditRef,
        @Parameter(description = "Return object param updated object back.", required = false) @HeaderParam("Athenz-Return-Object") Boolean returnObj,
        @Parameter(description = "Resource owner for the request", required = true) @HeaderParam("Athenz-Resource-Owner") String resourceOwner,
        @Parameter(description = "Membership object (must contain group/member names as specified in the URI)", required = true) GroupMembership membership) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "putGroupMembership");
            context.authenticate();
            return this.delegate.putGroupMembership(context, domainName, groupName, memberName, auditRef, returnObj, resourceOwner, membership);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.BAD_REQUEST:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.CONFLICT:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.FORBIDDEN:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.NOT_FOUND:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource putGroupMembership");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.publishChangeMessage(context, code);
            this.delegate.recordMetrics(context, code);
        }
    }

    @DELETE
    @Path("/domain/{domainName}/group/{groupName}/member/{memberName}")
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "Delete the specified group membership. Upon successful completion of this delete request, the server will return NO_CONTENT status code without any data (no object will be returned). The required authorization includes three options: 1. (\"update\", \"{domainName}:group.{groupName}\") 2. (\"update_members\", \"{domainName}:group.{groupName}\") 3. principal matches memberName")
    public void deleteGroupMembership(
        @Parameter(description = "name of the domain", required = true) @PathParam("domainName") String domainName,
        @Parameter(description = "name of the group", required = true) @PathParam("groupName") String groupName,
        @Parameter(description = "name of the user to be removed as a member", required = true) @PathParam("memberName") String memberName,
        @Parameter(description = "Audit param required(not empty) if domain auditEnabled is true.", required = true) @HeaderParam("Y-Audit-Ref") String auditRef,
        @Parameter(description = "Resource owner for the request", required = true) @HeaderParam("Athenz-Resource-Owner") String resourceOwner) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "deleteGroupMembership");
            context.authenticate();
            this.delegate.deleteGroupMembership(context, domainName, groupName, memberName, auditRef, resourceOwner);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.BAD_REQUEST:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.CONFLICT:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.FORBIDDEN:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.NOT_FOUND:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource deleteGroupMembership");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.publishChangeMessage(context, code);
            this.delegate.recordMetrics(context, code);
        }
    }

    @DELETE
    @Path("/domain/{domainName}/group/{groupName}/pendingmember/{memberName}")
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "Delete the specified pending group membership. Upon successful completion of this delete request, the server will return NO_CONTENT status code without any data (no object will be returned). Authorization will be completed within the server itself since there are two possibilities: 1) The domain admins can delete any pending requests 2) the requestor can also delete his/her own pending request.")
    public void deletePendingGroupMembership(
        @Parameter(description = "name of the domain", required = true) @PathParam("domainName") String domainName,
        @Parameter(description = "name of the group", required = true) @PathParam("groupName") String groupName,
        @Parameter(description = "name of the user to be removed as a pending member", required = true) @PathParam("memberName") String memberName,
        @Parameter(description = "Audit param required(not empty) if domain auditEnabled is true.", required = true) @HeaderParam("Y-Audit-Ref") String auditRef) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "deletePendingGroupMembership");
            context.authenticate();
            this.delegate.deletePendingGroupMembership(context, domainName, groupName, memberName, auditRef);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.BAD_REQUEST:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.CONFLICT:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.FORBIDDEN:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.NOT_FOUND:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource deletePendingGroupMembership");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.publishChangeMessage(context, code);
            this.delegate.recordMetrics(context, code);
        }
    }

    @PUT
    @Path("/domain/{domainName}/group/{groupName}/meta/system/{attribute}")
    @Consumes(MediaType.APPLICATION_JSON)
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "Set the specified group metadata. Caller must have update privileges on the sys.auth domain. If the system attribute is one of the string attributes, then the caller must also have delete action on the same resource in order to reset the configured value")
    public void putGroupSystemMeta(
        @Parameter(description = "name of the domain", required = true) @PathParam("domainName") String domainName,
        @Parameter(description = "name of the group", required = true) @PathParam("groupName") String groupName,
        @Parameter(description = "name of the system attribute to be modified", required = true) @PathParam("attribute") String attribute,
        @Parameter(description = "Audit param required(not empty) if domain auditEnabled is true.", required = true) @HeaderParam("Y-Audit-Ref") String auditRef,
        @Parameter(description = "GroupSystemMeta object with updated attribute values", required = true) GroupSystemMeta detail) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "putGroupSystemMeta");
            context.authorize("update", "sys.auth:meta.group." + attribute + "." + domainName + "", null);
            this.delegate.putGroupSystemMeta(context, domainName, groupName, attribute, auditRef, detail);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.BAD_REQUEST:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.CONFLICT:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.FORBIDDEN:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.NOT_FOUND:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource putGroupSystemMeta");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.publishChangeMessage(context, code);
            this.delegate.recordMetrics(context, code);
        }
    }

    @PUT
    @Path("/domain/{domainName}/group/{groupName}/meta")
    @Consumes(MediaType.APPLICATION_JSON)
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "Update the specified group metadata. Caller must have update privileges on the domain itself.")
    public void putGroupMeta(
        @Parameter(description = "name of the domain to be updated", required = true) @PathParam("domainName") String domainName,
        @Parameter(description = "name of the group", required = true) @PathParam("groupName") String groupName,
        @Parameter(description = "Audit param required(not empty) if domain auditEnabled is true.", required = true) @HeaderParam("Y-Audit-Ref") String auditRef,
        @Parameter(description = "Resource owner for the request", required = true) @HeaderParam("Athenz-Resource-Owner") String resourceOwner,
        @Parameter(description = "GroupMeta object with updated attribute values", required = true) GroupMeta detail) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "putGroupMeta");
            context.authorize("update", "" + domainName + ":group." + groupName + "", null);
            this.delegate.putGroupMeta(context, domainName, groupName, auditRef, resourceOwner, detail);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.BAD_REQUEST:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.CONFLICT:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.FORBIDDEN:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.NOT_FOUND:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource putGroupMeta");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.publishChangeMessage(context, code);
            this.delegate.recordMetrics(context, code);
        }
    }

    @PUT
    @Path("/domain/{domainName}/group/{groupName}/member/{memberName}/decision")
    @Consumes(MediaType.APPLICATION_JSON)
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "Approve or Reject the request to add specified user to group membership. This endpoint will be used by 2 use cases: 1. Audit enabled groups with authorize (\"update\", \"sys.auth:meta.group.{attribute}.{domainName}\") 2. Selfserve groups in any domain with authorize (\"update\", \"{domainName}:\")")
    public void putGroupMembershipDecision(
        @Parameter(description = "name of the domain", required = true) @PathParam("domainName") String domainName,
        @Parameter(description = "name of the group", required = true) @PathParam("groupName") String groupName,
        @Parameter(description = "name of the user to be added as a member", required = true) @PathParam("memberName") String memberName,
        @Parameter(description = "Audit param required(not empty) if domain auditEnabled is true.", required = true) @HeaderParam("Y-Audit-Ref") String auditRef,
        @Parameter(description = "GroupMembership object (must contain group/member names as specified in the URI)", required = true) GroupMembership membership) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "putGroupMembershipDecision");
            context.authenticate();
            this.delegate.putGroupMembershipDecision(context, domainName, groupName, memberName, auditRef, membership);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.BAD_REQUEST:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.CONFLICT:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.FORBIDDEN:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.NOT_FOUND:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource putGroupMembershipDecision");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.publishChangeMessage(context, code);
            this.delegate.recordMetrics(context, code);
        }
    }

    @PUT
    @Path("/domain/{domainName}/group/{groupName}/review")
    @Consumes(MediaType.APPLICATION_JSON)
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "Review group membership and take action to either extend and/or delete existing members.")
    public Response putGroupReview(
        @Parameter(description = "name of the domain", required = true) @PathParam("domainName") String domainName,
        @Parameter(description = "name of the group", required = true) @PathParam("groupName") String groupName,
        @Parameter(description = "Audit param required(not empty) if domain auditEnabled is true.", required = true) @HeaderParam("Y-Audit-Ref") String auditRef,
        @Parameter(description = "Return object param updated object back.", required = false) @HeaderParam("Athenz-Return-Object") Boolean returnObj,
        @Parameter(description = "Resource owner for the request", required = true) @HeaderParam("Athenz-Resource-Owner") String resourceOwner,
        @Parameter(description = "Group object with updated and/or deleted members", required = true) Group group) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "putGroupReview");
            context.authorize("update", "" + domainName + ":group." + groupName + "", null);
            return this.delegate.putGroupReview(context, domainName, groupName, auditRef, returnObj, resourceOwner, group);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.BAD_REQUEST:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.CONFLICT:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.FORBIDDEN:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.NOT_FOUND:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource putGroupReview");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.publishChangeMessage(context, code);
            this.delegate.recordMetrics(context, code);
        }
    }

    @GET
    @Path("/pending_group_members")
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "List of domains containing groups and corresponding members to be approved by either calling or specified principal")
    public DomainGroupMembership getPendingDomainGroupMembersList(
        @Parameter(description = "If present, return pending list for this principal", required = false) @QueryParam("principal") String principal,
        @Parameter(description = "If present, return pending list for this domain", required = false) @QueryParam("domain") String domainName) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "getPendingDomainGroupMembersList");
            context.authenticate();
            return this.delegate.getPendingDomainGroupMembersList(context, principal, domainName);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.BAD_REQUEST:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.FORBIDDEN:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.NOT_FOUND:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource getPendingDomainGroupMembersList");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.recordMetrics(context, code);
        }
    }

    @PUT
    @Path("/domain/{domainName}/group/{groupName}/ownership")
    @Consumes(MediaType.APPLICATION_JSON)
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "Set the resource ownership for the given group")
    public void putResourceGroupOwnership(
        @Parameter(description = "name of the domain", required = true) @PathParam("domainName") String domainName,
        @Parameter(description = "name of the group", required = true) @PathParam("groupName") String groupName,
        @Parameter(description = "Audit param required(not empty) if domain auditEnabled is true.", required = true) @HeaderParam("Y-Audit-Ref") String auditRef,
        @Parameter(description = "resource ownership to be set for the given group", required = true) ResourceGroupOwnership resourceOwnership) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "putResourceGroupOwnership");
            context.authorize("update", "" + domainName + ":meta.group.ownership." + groupName + "", null);
            this.delegate.putResourceGroupOwnership(context, domainName, groupName, auditRef, resourceOwnership);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.BAD_REQUEST:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.FORBIDDEN:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.NOT_FOUND:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource putResourceGroupOwnership");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.publishChangeMessage(context, code);
            this.delegate.recordMetrics(context, code);
        }
    }

    @GET
    @Path("/domain/{domainName}/policy")
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "List policies provisioned in this namespace.")
    public PolicyList getPolicyList(
        @Parameter(description = "name of the domain", required = true) @PathParam("domainName") String domainName,
        @Parameter(description = "restrict the number of results in this call", required = false) @QueryParam("limit") Integer limit,
        @Parameter(description = "restrict the set to those after the specified \"next\" token returned from a previous call", required = false) @QueryParam("skip") String skip) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "getPolicyList");
            context.authenticate();
            return this.delegate.getPolicyList(context, domainName, limit, skip);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.BAD_REQUEST:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.FORBIDDEN:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.NOT_FOUND:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource getPolicyList");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.recordMetrics(context, code);
        }
    }

    @GET
    @Path("/domain/{domainName}/policies")
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "List policies provisioned in this namespace.")
    public Policies getPolicies(
        @Parameter(description = "name of the domain", required = true) @PathParam("domainName") String domainName,
        @Parameter(description = "return list of assertions in the policy", required = false) @QueryParam("assertions") @DefaultValue("false") Boolean assertions,
        @Parameter(description = "include non-active policy versions", required = false) @QueryParam("includeNonActive") @DefaultValue("false") Boolean includeNonActive,
        @Parameter(description = "flag to query all policies that have a given tagName", required = false) @QueryParam("tagKey") String tagKey,
        @Parameter(description = "flag to query all policies that have a given tag name and value", required = false) @QueryParam("tagValue") String tagValue) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "getPolicies");
            context.authenticate();
            return this.delegate.getPolicies(context, domainName, assertions, includeNonActive, tagKey, tagValue);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.BAD_REQUEST:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.NOT_FOUND:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource getPolicies");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.recordMetrics(context, code);
        }
    }

    @GET
    @Path("/domain/{domainName}/policy/{policyName}")
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "Read the specified policy.")
    public Policy getPolicy(
        @Parameter(description = "name of the domain", required = true) @PathParam("domainName") String domainName,
        @Parameter(description = "name of the policy to be retrieved", required = true) @PathParam("policyName") String policyName) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "getPolicy");
            context.authenticate();
            return this.delegate.getPolicy(context, domainName, policyName);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.BAD_REQUEST:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.FORBIDDEN:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.NOT_FOUND:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource getPolicy");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.recordMetrics(context, code);
        }
    }

    @PUT
    @Path("/domain/{domainName}/policy/{policyName}")
    @Consumes(MediaType.APPLICATION_JSON)
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "Create or update the specified policy.")
    public Response putPolicy(
        @Parameter(description = "name of the domain", required = true) @PathParam("domainName") String domainName,
        @Parameter(description = "name of the policy to be added/updated", required = true) @PathParam("policyName") String policyName,
        @Parameter(description = "Audit param required(not empty) if domain auditEnabled is true.", required = true) @HeaderParam("Y-Audit-Ref") String auditRef,
        @Parameter(description = "Return object param updated object back.", required = false) @HeaderParam("Athenz-Return-Object") Boolean returnObj,
        @Parameter(description = "Resource owner for the request", required = true) @HeaderParam("Athenz-Resource-Owner") String resourceOwner,
        @Parameter(description = "Policy object to be added or updated in the domain", required = true) Policy policy) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "putPolicy");
            context.authorize("update", "" + domainName + ":policy." + policyName + "", null);
            return this.delegate.putPolicy(context, domainName, policyName, auditRef, returnObj, resourceOwner, policy);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.BAD_REQUEST:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.CONFLICT:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.FORBIDDEN:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.NOT_FOUND:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource putPolicy");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.publishChangeMessage(context, code);
            this.delegate.recordMetrics(context, code);
        }
    }

    @DELETE
    @Path("/domain/{domainName}/policy/{policyName}")
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "Delete the specified policy. Upon successful completion of this delete request, the server will return NO_CONTENT status code without any data (no object will be returned).")
    public void deletePolicy(
        @Parameter(description = "name of the domain", required = true) @PathParam("domainName") String domainName,
        @Parameter(description = "name of the policy to be deleted", required = true) @PathParam("policyName") String policyName,
        @Parameter(description = "Audit param required(not empty) if domain auditEnabled is true.", required = true) @HeaderParam("Y-Audit-Ref") String auditRef,
        @Parameter(description = "Resource owner for the request", required = true) @HeaderParam("Athenz-Resource-Owner") String resourceOwner) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "deletePolicy");
            context.authorize("delete", "" + domainName + ":policy." + policyName + "", null);
            this.delegate.deletePolicy(context, domainName, policyName, auditRef, resourceOwner);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.BAD_REQUEST:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.CONFLICT:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.FORBIDDEN:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.NOT_FOUND:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource deletePolicy");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.publishChangeMessage(context, code);
            this.delegate.recordMetrics(context, code);
        }
    }

    @GET
    @Path("/domain/{domainName}/policy/{policyName}/assertion/{assertionId}")
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "Get the assertion details with specified id in the given policy")
    public Assertion getAssertion(
        @Parameter(description = "name of the domain", required = true) @PathParam("domainName") String domainName,
        @Parameter(description = "name of the policy", required = true) @PathParam("policyName") String policyName,
        @Parameter(description = "assertion id", required = true) @PathParam("assertionId") Long assertionId) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "getAssertion");
            context.authenticate();
            return this.delegate.getAssertion(context, domainName, policyName, assertionId);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.BAD_REQUEST:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.FORBIDDEN:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.NOT_FOUND:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource getAssertion");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.recordMetrics(context, code);
        }
    }

    @PUT
    @Path("/domain/{domainName}/policy/{policyName}/assertion")
    @Consumes(MediaType.APPLICATION_JSON)
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "Add the specified assertion to the given policy")
    public Assertion putAssertion(
        @Parameter(description = "name of the domain", required = true) @PathParam("domainName") String domainName,
        @Parameter(description = "name of the policy", required = true) @PathParam("policyName") String policyName,
        @Parameter(description = "Audit param required(not empty) if domain auditEnabled is true.", required = true) @HeaderParam("Y-Audit-Ref") String auditRef,
        @Parameter(description = "Resource owner for the request", required = true) @HeaderParam("Athenz-Resource-Owner") String resourceOwner,
        @Parameter(description = "Assertion object to be added to the given policy", required = true) Assertion assertion) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "putAssertion");
            context.authorize("update", "" + domainName + ":policy." + policyName + "", null);
            return this.delegate.putAssertion(context, domainName, policyName, auditRef, resourceOwner, assertion);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.BAD_REQUEST:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.CONFLICT:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.FORBIDDEN:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.NOT_FOUND:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource putAssertion");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.publishChangeMessage(context, code);
            this.delegate.recordMetrics(context, code);
        }
    }

    @PUT
    @Path("/domain/{domainName}/policy/{policyName}/version/{version}/assertion")
    @Consumes(MediaType.APPLICATION_JSON)
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "Add the specified assertion to the given policy version")
    public Assertion putAssertionPolicyVersion(
        @Parameter(description = "name of the domain", required = true) @PathParam("domainName") String domainName,
        @Parameter(description = "name of the policy", required = true) @PathParam("policyName") String policyName,
        @Parameter(description = "name of the version", required = true) @PathParam("version") String version,
        @Parameter(description = "Audit param required(not empty) if domain auditEnabled is true.", required = true) @HeaderParam("Y-Audit-Ref") String auditRef,
        @Parameter(description = "Resource owner for the request", required = true) @HeaderParam("Athenz-Resource-Owner") String resourceOwner,
        @Parameter(description = "Assertion object to be added to the given policy version", required = true) Assertion assertion) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "putAssertionPolicyVersion");
            context.authorize("update", "" + domainName + ":policy." + policyName + "", null);
            return this.delegate.putAssertionPolicyVersion(context, domainName, policyName, version, auditRef, resourceOwner, assertion);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.BAD_REQUEST:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.CONFLICT:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.FORBIDDEN:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.NOT_FOUND:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource putAssertionPolicyVersion");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.publishChangeMessage(context, code);
            this.delegate.recordMetrics(context, code);
        }
    }

    @DELETE
    @Path("/domain/{domainName}/policy/{policyName}/assertion/{assertionId}")
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "Delete the specified policy assertion. Upon successful completion of this delete request, the server will return NO_CONTENT status code without any data (no object will be returned).")
    public void deleteAssertion(
        @Parameter(description = "name of the domain", required = true) @PathParam("domainName") String domainName,
        @Parameter(description = "name of the policy", required = true) @PathParam("policyName") String policyName,
        @Parameter(description = "assertion id", required = true) @PathParam("assertionId") Long assertionId,
        @Parameter(description = "Audit param required(not empty) if domain auditEnabled is true.", required = true) @HeaderParam("Y-Audit-Ref") String auditRef,
        @Parameter(description = "Resource owner for the request", required = true) @HeaderParam("Athenz-Resource-Owner") String resourceOwner) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "deleteAssertion");
            context.authorize("update", "" + domainName + ":policy." + policyName + "", null);
            this.delegate.deleteAssertion(context, domainName, policyName, assertionId, auditRef, resourceOwner);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.BAD_REQUEST:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.CONFLICT:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.FORBIDDEN:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.NOT_FOUND:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource deleteAssertion");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.publishChangeMessage(context, code);
            this.delegate.recordMetrics(context, code);
        }
    }

    @DELETE
    @Path("/domain/{domainName}/policy/{policyName}/version/{version}/assertion/{assertionId}")
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "Delete the specified policy version assertion. Upon successful completion of this delete request, the server will return NO_CONTENT status code without any data (no object will be returned).")
    public void deleteAssertionPolicyVersion(
        @Parameter(description = "name of the domain", required = true) @PathParam("domainName") String domainName,
        @Parameter(description = "name of the policy", required = true) @PathParam("policyName") String policyName,
        @Parameter(description = "name of the version", required = true) @PathParam("version") String version,
        @Parameter(description = "assertion id", required = true) @PathParam("assertionId") Long assertionId,
        @Parameter(description = "Audit param required(not empty) if domain auditEnabled is true.", required = true) @HeaderParam("Y-Audit-Ref") String auditRef,
        @Parameter(description = "Resource owner for the request", required = true) @HeaderParam("Athenz-Resource-Owner") String resourceOwner) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "deleteAssertionPolicyVersion");
            context.authorize("update", "" + domainName + ":policy." + policyName + "", null);
            this.delegate.deleteAssertionPolicyVersion(context, domainName, policyName, version, assertionId, auditRef, resourceOwner);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.BAD_REQUEST:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.CONFLICT:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.FORBIDDEN:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.NOT_FOUND:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource deleteAssertionPolicyVersion");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.publishChangeMessage(context, code);
            this.delegate.recordMetrics(context, code);
        }
    }

    @PUT
    @Path("/domain/{domainName}/policy/{policyName}/assertion/{assertionId}/conditions")
    @Consumes(MediaType.APPLICATION_JSON)
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "Add the specified conditions to the given assertion")
    public AssertionConditions putAssertionConditions(
        @Parameter(description = "name of the domain", required = true) @PathParam("domainName") String domainName,
        @Parameter(description = "name of the policy", required = true) @PathParam("policyName") String policyName,
        @Parameter(description = "assertion id", required = true) @PathParam("assertionId") Long assertionId,
        @Parameter(description = "Audit param required(not empty) if domain auditEnabled is true.", required = true) @HeaderParam("Y-Audit-Ref") String auditRef,
        @Parameter(description = "Resource owner for the request", required = true) @HeaderParam("Athenz-Resource-Owner") String resourceOwner,
        @Parameter(description = "Assertion conditions object to be added to the given assertion", required = true) AssertionConditions assertionConditions) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "putAssertionConditions");
            context.authorize("update", "" + domainName + ":policy." + policyName + "", null);
            return this.delegate.putAssertionConditions(context, domainName, policyName, assertionId, auditRef, resourceOwner, assertionConditions);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.BAD_REQUEST:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.CONFLICT:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.FORBIDDEN:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.NOT_FOUND:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource putAssertionConditions");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.publishChangeMessage(context, code);
            this.delegate.recordMetrics(context, code);
        }
    }

    @PUT
    @Path("/domain/{domainName}/policy/{policyName}/assertion/{assertionId}/condition")
    @Consumes(MediaType.APPLICATION_JSON)
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "Add the specified condition to the existing assertion conditions of an assertion")
    public AssertionCondition putAssertionCondition(
        @Parameter(description = "name of the domain", required = true) @PathParam("domainName") String domainName,
        @Parameter(description = "name of the policy", required = true) @PathParam("policyName") String policyName,
        @Parameter(description = "assertion id", required = true) @PathParam("assertionId") Long assertionId,
        @Parameter(description = "Audit param required(not empty) if domain auditEnabled is true.", required = true) @HeaderParam("Y-Audit-Ref") String auditRef,
        @Parameter(description = "Resource owner for the request", required = true) @HeaderParam("Athenz-Resource-Owner") String resourceOwner,
        @Parameter(description = "Assertion conditions object to be added to the given assertion", required = true) AssertionCondition assertionCondition) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "putAssertionCondition");
            context.authorize("update", "" + domainName + ":policy." + policyName + "", null);
            return this.delegate.putAssertionCondition(context, domainName, policyName, assertionId, auditRef, resourceOwner, assertionCondition);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.BAD_REQUEST:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.CONFLICT:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.FORBIDDEN:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.NOT_FOUND:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource putAssertionCondition");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.publishChangeMessage(context, code);
            this.delegate.recordMetrics(context, code);
        }
    }

    @DELETE
    @Path("/domain/{domainName}/policy/{policyName}/assertion/{assertionId}/conditions")
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "Delete all assertion conditions for specified assertion id. Upon successful completion of this delete request, the server will return NO_CONTENT status code without any data (no object will be returned).")
    public void deleteAssertionConditions(
        @Parameter(description = "name of the domain", required = true) @PathParam("domainName") String domainName,
        @Parameter(description = "name of the policy", required = true) @PathParam("policyName") String policyName,
        @Parameter(description = "assertion id", required = true) @PathParam("assertionId") Long assertionId,
        @Parameter(description = "Audit param required(not empty) if domain auditEnabled is true.", required = true) @HeaderParam("Y-Audit-Ref") String auditRef,
        @Parameter(description = "Resource owner for the request", required = true) @HeaderParam("Athenz-Resource-Owner") String resourceOwner) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "deleteAssertionConditions");
            context.authorize("update", "" + domainName + ":policy." + policyName + "", null);
            this.delegate.deleteAssertionConditions(context, domainName, policyName, assertionId, auditRef, resourceOwner);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.BAD_REQUEST:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.CONFLICT:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.FORBIDDEN:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.NOT_FOUND:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource deleteAssertionConditions");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.publishChangeMessage(context, code);
            this.delegate.recordMetrics(context, code);
        }
    }

    @DELETE
    @Path("/domain/{domainName}/policy/{policyName}/assertion/{assertionId}/condition/{conditionId}")
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "Delete the assertion condition(s) for specified assertion id and condition id. Upon successful completion of this delete request, the server will return NO_CONTENT status code without any data (no object will be returned).")
    public void deleteAssertionCondition(
        @Parameter(description = "name of the domain", required = true) @PathParam("domainName") String domainName,
        @Parameter(description = "name of the policy", required = true) @PathParam("policyName") String policyName,
        @Parameter(description = "assertion id", required = true) @PathParam("assertionId") Long assertionId,
        @Parameter(description = "condition id", required = true) @PathParam("conditionId") Integer conditionId,
        @Parameter(description = "Audit param required(not empty) if domain auditEnabled is true.", required = true) @HeaderParam("Y-Audit-Ref") String auditRef,
        @Parameter(description = "Resource owner for the request", required = true) @HeaderParam("Athenz-Resource-Owner") String resourceOwner) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "deleteAssertionCondition");
            context.authorize("update", "" + domainName + ":policy." + policyName + "", null);
            this.delegate.deleteAssertionCondition(context, domainName, policyName, assertionId, conditionId, auditRef, resourceOwner);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.BAD_REQUEST:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.CONFLICT:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.FORBIDDEN:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.NOT_FOUND:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource deleteAssertionCondition");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.publishChangeMessage(context, code);
            this.delegate.recordMetrics(context, code);
        }
    }

    @GET
    @Path("/domain/{domainName}/policy/{policyName}/version")
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "List policy versions.")
    public PolicyList getPolicyVersionList(
        @Parameter(description = "name of the domain", required = true) @PathParam("domainName") String domainName,
        @Parameter(description = "name of the policy", required = true) @PathParam("policyName") String policyName) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "getPolicyVersionList");
            context.authenticate();
            return this.delegate.getPolicyVersionList(context, domainName, policyName);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.BAD_REQUEST:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.FORBIDDEN:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.NOT_FOUND:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource getPolicyVersionList");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.recordMetrics(context, code);
        }
    }

    @GET
    @Path("/domain/{domainName}/policy/{policyName}/version/{version}")
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "Get the specified policy version.")
    public Policy getPolicyVersion(
        @Parameter(description = "name of the domain", required = true) @PathParam("domainName") String domainName,
        @Parameter(description = "name of the policy", required = true) @PathParam("policyName") String policyName,
        @Parameter(description = "name of the version to be retrieved", required = true) @PathParam("version") String version) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "getPolicyVersion");
            context.authenticate();
            return this.delegate.getPolicyVersion(context, domainName, policyName, version);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.BAD_REQUEST:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.FORBIDDEN:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.NOT_FOUND:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource getPolicyVersion");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.recordMetrics(context, code);
        }
    }

    @PUT
    @Path("/domain/{domainName}/policy/{policyName}/version/create")
    @Consumes(MediaType.APPLICATION_JSON)
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "Create a new disabled policy version based on active policy")
    public Response putPolicyVersion(
        @Parameter(description = "name of the domain", required = true) @PathParam("domainName") String domainName,
        @Parameter(description = "name of the policy to be added/updated", required = true) @PathParam("policyName") String policyName,
        @Parameter(description = "name of the source version to copy from and name of new version", required = true) PolicyOptions policyOptions,
        @Parameter(description = "Audit param required(not empty) if domain auditEnabled is true.", required = true) @HeaderParam("Y-Audit-Ref") String auditRef,
        @Parameter(description = "Return object param updated object back.", required = false) @HeaderParam("Athenz-Return-Object") Boolean returnObj,
        @Parameter(description = "Resource owner for the request", required = true) @HeaderParam("Athenz-Resource-Owner") String resourceOwner) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "putPolicyVersion");
            context.authorize("update", "" + domainName + ":policy." + policyName + "", null);
            return this.delegate.putPolicyVersion(context, domainName, policyName, policyOptions, auditRef, returnObj, resourceOwner);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.BAD_REQUEST:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.CONFLICT:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.FORBIDDEN:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.NOT_FOUND:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource putPolicyVersion");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.publishChangeMessage(context, code);
            this.delegate.recordMetrics(context, code);
        }
    }

    @PUT
    @Path("/domain/{domainName}/policy/{policyName}/version/active")
    @Consumes(MediaType.APPLICATION_JSON)
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "Mark the specified policy version as active")
    public void setActivePolicyVersion(
        @Parameter(description = "name of the domain", required = true) @PathParam("domainName") String domainName,
        @Parameter(description = "name of the policy", required = true) @PathParam("policyName") String policyName,
        @Parameter(description = "name of the version", required = true) PolicyOptions policyOptions,
        @Parameter(description = "Audit param required(not empty) if domain auditEnabled is true.", required = true) @HeaderParam("Y-Audit-Ref") String auditRef,
        @Parameter(description = "Resource owner for the request", required = true) @HeaderParam("Athenz-Resource-Owner") String resourceOwner) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "setActivePolicyVersion");
            context.authorize("update", "" + domainName + ":policy." + policyName + "", null);
            this.delegate.setActivePolicyVersion(context, domainName, policyName, policyOptions, auditRef, resourceOwner);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.BAD_REQUEST:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.CONFLICT:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.FORBIDDEN:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.NOT_FOUND:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource setActivePolicyVersion");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.publishChangeMessage(context, code);
            this.delegate.recordMetrics(context, code);
        }
    }

    @DELETE
    @Path("/domain/{domainName}/policy/{policyName}/version/{version}")
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "Delete the specified policy version. Upon successful completion of this delete request, the server will return NO_CONTENT status code without any data (no object will be returned).")
    public void deletePolicyVersion(
        @Parameter(description = "name of the domain", required = true) @PathParam("domainName") String domainName,
        @Parameter(description = "name of the policy", required = true) @PathParam("policyName") String policyName,
        @Parameter(description = "name of the version to be deleted", required = true) @PathParam("version") String version,
        @Parameter(description = "Audit param required(not empty) if domain auditEnabled is true.", required = true) @HeaderParam("Y-Audit-Ref") String auditRef,
        @Parameter(description = "Resource owner for the request", required = true) @HeaderParam("Athenz-Resource-Owner") String resourceOwner) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "deletePolicyVersion");
            context.authorize("delete", "" + domainName + ":policy." + policyName + "", null);
            this.delegate.deletePolicyVersion(context, domainName, policyName, version, auditRef, resourceOwner);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.BAD_REQUEST:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.CONFLICT:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.FORBIDDEN:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.NOT_FOUND:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource deletePolicyVersion");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.publishChangeMessage(context, code);
            this.delegate.recordMetrics(context, code);
        }
    }

    @PUT
    @Path("/domain/{domainName}/policy/{policyName}/ownership")
    @Consumes(MediaType.APPLICATION_JSON)
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "Set the resource ownership for the given policy")
    public void putResourcePolicyOwnership(
        @Parameter(description = "name of the domain", required = true) @PathParam("domainName") String domainName,
        @Parameter(description = "name of the policy", required = true) @PathParam("policyName") String policyName,
        @Parameter(description = "Audit param required(not empty) if domain auditEnabled is true.", required = true) @HeaderParam("Y-Audit-Ref") String auditRef,
        @Parameter(description = "resource ownership to be set for the given policy", required = true) ResourcePolicyOwnership resourceOwnership) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "putResourcePolicyOwnership");
            context.authorize("update", "" + domainName + ":meta.policy.ownership." + policyName + "", null);
            this.delegate.putResourcePolicyOwnership(context, domainName, policyName, auditRef, resourceOwnership);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.BAD_REQUEST:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.FORBIDDEN:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.NOT_FOUND:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource putResourcePolicyOwnership");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.publishChangeMessage(context, code);
            this.delegate.recordMetrics(context, code);
        }
    }

    @PUT
    @Path("/domain/{domain}/service/{service}")
    @Consumes(MediaType.APPLICATION_JSON)
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "Register the specified ServiceIdentity in the specified domain")
    public Response putServiceIdentity(
        @Parameter(description = "name of the domain", required = true) @PathParam("domain") String domain,
        @Parameter(description = "name of the service", required = true) @PathParam("service") String service,
        @Parameter(description = "Audit param required(not empty) if domain auditEnabled is true.", required = true) @HeaderParam("Y-Audit-Ref") String auditRef,
        @Parameter(description = "Return object param updated object back.", required = false) @HeaderParam("Athenz-Return-Object") Boolean returnObj,
        @Parameter(description = "Resource owner for the request", required = true) @HeaderParam("Athenz-Resource-Owner") String resourceOwner,
        @Parameter(description = "ServiceIdentity object to be added/updated in the domain", required = true) ServiceIdentity detail) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "putServiceIdentity");
            context.authorize("update", "" + domain + ":service." + service + "", null);
            return this.delegate.putServiceIdentity(context, domain, service, auditRef, returnObj, resourceOwner, detail);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.BAD_REQUEST:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.CONFLICT:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.FORBIDDEN:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.NOT_FOUND:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource putServiceIdentity");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.publishChangeMessage(context, code);
            this.delegate.recordMetrics(context, code);
        }
    }

    @GET
    @Path("/domain/{domain}/service/{service}")
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "Get info for the specified ServiceIdentity.")
    public ServiceIdentity getServiceIdentity(
        @Parameter(description = "name of the domain", required = true) @PathParam("domain") String domain,
        @Parameter(description = "name of the service to be retrieved", required = true) @PathParam("service") String service) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "getServiceIdentity");
            context.authenticate();
            return this.delegate.getServiceIdentity(context, domain, service);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.BAD_REQUEST:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.FORBIDDEN:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.NOT_FOUND:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource getServiceIdentity");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.recordMetrics(context, code);
        }
    }

    @DELETE
    @Path("/domain/{domain}/service/{service}")
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "Delete the specified ServiceIdentity. Upon successful completion of this delete request, the server will return NO_CONTENT status code without any data (no object will be returned).")
    public void deleteServiceIdentity(
        @Parameter(description = "name of the domain", required = true) @PathParam("domain") String domain,
        @Parameter(description = "name of the service to be deleted", required = true) @PathParam("service") String service,
        @Parameter(description = "Audit param required(not empty) if domain auditEnabled is true.", required = true) @HeaderParam("Y-Audit-Ref") String auditRef,
        @Parameter(description = "Resource owner for the request", required = true) @HeaderParam("Athenz-Resource-Owner") String resourceOwner) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "deleteServiceIdentity");
            context.authorize("delete", "" + domain + ":service." + service + "", null);
            this.delegate.deleteServiceIdentity(context, domain, service, auditRef, resourceOwner);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.BAD_REQUEST:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.CONFLICT:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.FORBIDDEN:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.NOT_FOUND:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource deleteServiceIdentity");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.publishChangeMessage(context, code);
            this.delegate.recordMetrics(context, code);
        }
    }

    @GET
    @Path("/domain/{domainName}/services")
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "Retrieve list of service identities")
    public ServiceIdentities getServiceIdentities(
        @Parameter(description = "name of the domain", required = true) @PathParam("domainName") String domainName,
        @Parameter(description = "return list of public keys in the service", required = false) @QueryParam("publickeys") @DefaultValue("false") Boolean publickeys,
        @Parameter(description = "return list of hosts in the service", required = false) @QueryParam("hosts") @DefaultValue("false") Boolean hosts,
        @Parameter(description = "flag to query all services that have a given tagName", required = false) @QueryParam("tagKey") String tagKey,
        @Parameter(description = "flag to query all services that have a given tag name and value", required = false) @QueryParam("tagValue") String tagValue) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "getServiceIdentities");
            context.authenticate();
            return this.delegate.getServiceIdentities(context, domainName, publickeys, hosts, tagKey, tagValue);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.BAD_REQUEST:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.NOT_FOUND:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource getServiceIdentities");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.recordMetrics(context, code);
        }
    }

    @GET
    @Path("/domain/{domainName}/service")
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "Enumerate services provisioned in this domain.")
    public ServiceIdentityList getServiceIdentityList(
        @Parameter(description = "name of the domain", required = true) @PathParam("domainName") String domainName,
        @Parameter(description = "restrict the number of results in this call", required = false) @QueryParam("limit") Integer limit,
        @Parameter(description = "restrict the set to those after the specified \"next\" token returned from a previous call", required = false) @QueryParam("skip") String skip) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "getServiceIdentityList");
            context.authenticate();
            return this.delegate.getServiceIdentityList(context, domainName, limit, skip);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.BAD_REQUEST:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.FORBIDDEN:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.NOT_FOUND:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource getServiceIdentityList");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.recordMetrics(context, code);
        }
    }

    @GET
    @Path("/domain/{domain}/service/{service}/publickey/{id}")
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "Retrieve the specified public key from the service.")
    public PublicKeyEntry getPublicKeyEntry(
        @Parameter(description = "name of the domain", required = true) @PathParam("domain") String domain,
        @Parameter(description = "name of the service", required = true) @PathParam("service") String service,
        @Parameter(description = "the identifier of the public key to be retrieved", required = true) @PathParam("id") String id) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "getPublicKeyEntry");
            context.authenticate();
            return this.delegate.getPublicKeyEntry(context, domain, service, id);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.BAD_REQUEST:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.FORBIDDEN:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.NOT_FOUND:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource getPublicKeyEntry");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.recordMetrics(context, code);
        }
    }

    @PUT
    @Path("/domain/{domain}/service/{service}/publickey/{id}")
    @Consumes(MediaType.APPLICATION_JSON)
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "Add the specified public key to the service.")
    public void putPublicKeyEntry(
        @Parameter(description = "name of the domain", required = true) @PathParam("domain") String domain,
        @Parameter(description = "name of the service", required = true) @PathParam("service") String service,
        @Parameter(description = "the identifier of the public key to be added", required = true) @PathParam("id") String id,
        @Parameter(description = "Audit param required(not empty) if domain auditEnabled is true.", required = true) @HeaderParam("Y-Audit-Ref") String auditRef,
        @Parameter(description = "Resource owner for the request", required = true) @HeaderParam("Athenz-Resource-Owner") String resourceOwner,
        @Parameter(description = "PublicKeyEntry object to be added/updated in the service", required = true) PublicKeyEntry publicKeyEntry) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "putPublicKeyEntry");
            context.authorize("update", "" + domain + ":service." + service + "", null);
            this.delegate.putPublicKeyEntry(context, domain, service, id, auditRef, resourceOwner, publicKeyEntry);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.BAD_REQUEST:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.CONFLICT:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.FORBIDDEN:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.NOT_FOUND:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource putPublicKeyEntry");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.publishChangeMessage(context, code);
            this.delegate.recordMetrics(context, code);
        }
    }

    @DELETE
    @Path("/domain/{domain}/service/{service}/publickey/{id}")
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "Remove the specified public key from the service. Upon successful completion of this delete request, the server will return NO_CONTENT status code without any data (no object will be returned).")
    public void deletePublicKeyEntry(
        @Parameter(description = "name of the domain", required = true) @PathParam("domain") String domain,
        @Parameter(description = "name of the service", required = true) @PathParam("service") String service,
        @Parameter(description = "the identifier of the public key to be deleted", required = true) @PathParam("id") String id,
        @Parameter(description = "Audit param required(not empty) if domain auditEnabled is true.", required = true) @HeaderParam("Y-Audit-Ref") String auditRef,
        @Parameter(description = "Resource owner for the request", required = true) @HeaderParam("Athenz-Resource-Owner") String resourceOwner) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "deletePublicKeyEntry");
            context.authorize("update", "" + domain + ":service." + service + "", null);
            this.delegate.deletePublicKeyEntry(context, domain, service, id, auditRef, resourceOwner);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.BAD_REQUEST:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.CONFLICT:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.FORBIDDEN:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.NOT_FOUND:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource deletePublicKeyEntry");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.publishChangeMessage(context, code);
            this.delegate.recordMetrics(context, code);
        }
    }

    @PUT
    @Path("/domain/{domain}/service/{service}/meta/system/{attribute}")
    @Consumes(MediaType.APPLICATION_JSON)
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "Set the specified service metadata. Caller must have update privileges on the sys.auth domain.")
    public void putServiceIdentitySystemMeta(
        @Parameter(description = "name of the domain", required = true) @PathParam("domain") String domain,
        @Parameter(description = "name of the service", required = true) @PathParam("service") String service,
        @Parameter(description = "name of the system attribute to be modified", required = true) @PathParam("attribute") String attribute,
        @Parameter(description = "Audit param required(not empty) if domain auditEnabled is true.", required = true) @HeaderParam("Y-Audit-Ref") String auditRef,
        @Parameter(description = "ServiceIdentitySystemMeta object with updated attribute values", required = true) ServiceIdentitySystemMeta detail) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "putServiceIdentitySystemMeta");
            context.authorize("update", "sys.auth:meta.service." + attribute + "." + domain + "", null);
            this.delegate.putServiceIdentitySystemMeta(context, domain, service, attribute, auditRef, detail);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.BAD_REQUEST:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.CONFLICT:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.FORBIDDEN:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.NOT_FOUND:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource putServiceIdentitySystemMeta");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.publishChangeMessage(context, code);
            this.delegate.recordMetrics(context, code);
        }
    }

    @PUT
    @Path("/domain/{domainName}/service/{service}/ownership")
    @Consumes(MediaType.APPLICATION_JSON)
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "Set the resource ownership for the given service")
    public void putResourceServiceIdentityOwnership(
        @Parameter(description = "name of the domain", required = true) @PathParam("domainName") String domainName,
        @Parameter(description = "name of the service", required = true) @PathParam("service") String service,
        @Parameter(description = "Audit param required(not empty) if domain auditEnabled is true.", required = true) @HeaderParam("Y-Audit-Ref") String auditRef,
        @Parameter(description = "resource ownership to be set for the given service", required = true) ResourceServiceIdentityOwnership resourceOwnership) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "putResourceServiceIdentityOwnership");
            context.authorize("update", "" + domainName + ":meta.service.ownership." + service + "", null);
            this.delegate.putResourceServiceIdentityOwnership(context, domainName, service, auditRef, resourceOwnership);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.BAD_REQUEST:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.FORBIDDEN:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.NOT_FOUND:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource putResourceServiceIdentityOwnership");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.publishChangeMessage(context, code);
            this.delegate.recordMetrics(context, code);
        }
    }

    @PUT
    @Path("/domain/{domain}/tenancy/{service}")
    @Consumes(MediaType.APPLICATION_JSON)
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "Register the provider service in the tenant's domain.")
    public void putTenancy(
        @Parameter(description = "name of the tenant domain", required = true) @PathParam("domain") String domain,
        @Parameter(description = "name of the provider service", required = true) @PathParam("service") String service,
        @Parameter(description = "Audit param required(not empty) if domain auditEnabled is true.", required = true) @HeaderParam("Y-Audit-Ref") String auditRef,
        @Parameter(description = "tenancy object", required = true) Tenancy detail) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "putTenancy");
            context.authorize("update", "" + domain + ":tenancy", null);
            this.delegate.putTenancy(context, domain, service, auditRef, detail);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.BAD_REQUEST:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.CONFLICT:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.FORBIDDEN:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.NOT_FOUND:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource putTenancy");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.publishChangeMessage(context, code);
            this.delegate.recordMetrics(context, code);
        }
    }

    @DELETE
    @Path("/domain/{domain}/tenancy/{service}")
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "Delete the provider service from the specified tenant domain. Upon successful completion of this delete request, the server will return NO_CONTENT status code without any data (no object will be returned).")
    public void deleteTenancy(
        @Parameter(description = "name of the tenant domain", required = true) @PathParam("domain") String domain,
        @Parameter(description = "name of the provider service", required = true) @PathParam("service") String service,
        @Parameter(description = "Audit param required(not empty) if domain auditEnabled is true.", required = true) @HeaderParam("Y-Audit-Ref") String auditRef) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "deleteTenancy");
            context.authorize("delete", "" + domain + ":tenancy", null);
            this.delegate.deleteTenancy(context, domain, service, auditRef);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.BAD_REQUEST:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.CONFLICT:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.FORBIDDEN:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.NOT_FOUND:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource deleteTenancy");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.publishChangeMessage(context, code);
            this.delegate.recordMetrics(context, code);
        }
    }

    @PUT
    @Path("/domain/{domain}/service/{service}/tenant/{tenantDomain}")
    @Consumes(MediaType.APPLICATION_JSON)
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "Register a tenant domain for given provider service")
    public void putTenant(
        @Parameter(description = "name of the provider domain", required = true) @PathParam("domain") String domain,
        @Parameter(description = "name of the provider service", required = true) @PathParam("service") String service,
        @Parameter(description = "name of the tenant domain", required = true) @PathParam("tenantDomain") String tenantDomain,
        @Parameter(description = "Audit param required(not empty) if domain auditEnabled is true.", required = true) @HeaderParam("Y-Audit-Ref") String auditRef,
        @Parameter(description = "tenancy object", required = true) Tenancy detail) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "putTenant");
            context.authorize("update", "" + domain + ":tenant." + service + "", null);
            this.delegate.putTenant(context, domain, service, tenantDomain, auditRef, detail);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.BAD_REQUEST:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.CONFLICT:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.FORBIDDEN:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.NOT_FOUND:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource putTenant");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.publishChangeMessage(context, code);
            this.delegate.recordMetrics(context, code);
        }
    }

    @DELETE
    @Path("/domain/{domain}/service/{service}/tenant/{tenantDomain}")
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "Delete the tenant domain from the provider service. Upon successful completion of this delete request, the server will return NO_CONTENT status code without any data (no object will be returned).")
    public void deleteTenant(
        @Parameter(description = "name of the provider domain", required = true) @PathParam("domain") String domain,
        @Parameter(description = "name of the provider service", required = true) @PathParam("service") String service,
        @Parameter(description = "name of the tenant domain", required = true) @PathParam("tenantDomain") String tenantDomain,
        @Parameter(description = "Audit param required(not empty) if domain auditEnabled is true.", required = true) @HeaderParam("Y-Audit-Ref") String auditRef) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "deleteTenant");
            context.authorize("delete", "" + domain + ":tenant." + service + "", null);
            this.delegate.deleteTenant(context, domain, service, tenantDomain, auditRef);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.BAD_REQUEST:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.CONFLICT:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.FORBIDDEN:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.NOT_FOUND:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource deleteTenant");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.publishChangeMessage(context, code);
            this.delegate.recordMetrics(context, code);
        }
    }

    @PUT
    @Path("/domain/{domain}/service/{service}/tenant/{tenantDomain}/resourceGroup/{resourceGroup}")
    @Consumes(MediaType.APPLICATION_JSON)
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "Create/update set of roles for a given tenant and resource group")
    public TenantResourceGroupRoles putTenantResourceGroupRoles(
        @Parameter(description = "name of the provider domain", required = true) @PathParam("domain") String domain,
        @Parameter(description = "name of the provider service", required = true) @PathParam("service") String service,
        @Parameter(description = "name of the tenant domain", required = true) @PathParam("tenantDomain") String tenantDomain,
        @Parameter(description = "tenant resource group", required = true) @PathParam("resourceGroup") String resourceGroup,
        @Parameter(description = "Audit param required(not empty) if domain auditEnabled is true.", required = true) @HeaderParam("Y-Audit-Ref") String auditRef,
        @Parameter(description = "list of roles to be added/updated for the tenant", required = true) TenantResourceGroupRoles detail) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "putTenantResourceGroupRoles");
            context.authorize("update", "" + domain + ":tenant." + service + "", null);
            return this.delegate.putTenantResourceGroupRoles(context, domain, service, tenantDomain, resourceGroup, auditRef, detail);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.BAD_REQUEST:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.CONFLICT:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.FORBIDDEN:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.NOT_FOUND:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource putTenantResourceGroupRoles");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.publishChangeMessage(context, code);
            this.delegate.recordMetrics(context, code);
        }
    }

    @GET
    @Path("/domain/{domain}/service/{service}/tenant/{tenantDomain}/resourceGroup/{resourceGroup}")
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "Retrieve the configured set of roles for the tenant and resource group")
    public TenantResourceGroupRoles getTenantResourceGroupRoles(
        @Parameter(description = "name of the provider domain", required = true) @PathParam("domain") String domain,
        @Parameter(description = "name of the provider service", required = true) @PathParam("service") String service,
        @Parameter(description = "name of the tenant domain", required = true) @PathParam("tenantDomain") String tenantDomain,
        @Parameter(description = "tenant resource group", required = true) @PathParam("resourceGroup") String resourceGroup) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "getTenantResourceGroupRoles");
            context.authenticate();
            return this.delegate.getTenantResourceGroupRoles(context, domain, service, tenantDomain, resourceGroup);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.BAD_REQUEST:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.FORBIDDEN:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.NOT_FOUND:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource getTenantResourceGroupRoles");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.recordMetrics(context, code);
        }
    }

    @DELETE
    @Path("/domain/{domain}/service/{service}/tenant/{tenantDomain}/resourceGroup/{resourceGroup}")
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "Delete the configured set of roles for the tenant and resource group")
    public void deleteTenantResourceGroupRoles(
        @Parameter(description = "name of the provider domain", required = true) @PathParam("domain") String domain,
        @Parameter(description = "name of the provider service", required = true) @PathParam("service") String service,
        @Parameter(description = "name of the tenant domain", required = true) @PathParam("tenantDomain") String tenantDomain,
        @Parameter(description = "tenant resource group", required = true) @PathParam("resourceGroup") String resourceGroup,
        @Parameter(description = "Audit param required(not empty) if domain auditEnabled is true.", required = true) @HeaderParam("Y-Audit-Ref") String auditRef) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "deleteTenantResourceGroupRoles");
            context.authorize("update", "" + domain + ":tenant." + service + "", null);
            this.delegate.deleteTenantResourceGroupRoles(context, domain, service, tenantDomain, resourceGroup, auditRef);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.BAD_REQUEST:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.CONFLICT:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.FORBIDDEN:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.NOT_FOUND:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource deleteTenantResourceGroupRoles");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.publishChangeMessage(context, code);
            this.delegate.recordMetrics(context, code);
        }
    }

    @PUT
    @Path("/domain/{tenantDomain}/provDomain/{provDomain}/provService/{provService}/resourceGroup/{resourceGroup}")
    @Consumes(MediaType.APPLICATION_JSON)
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "Create/update set of roles for a given provider and resource group")
    public ProviderResourceGroupRoles putProviderResourceGroupRoles(
        @Parameter(description = "name of the tenant domain", required = true) @PathParam("tenantDomain") String tenantDomain,
        @Parameter(description = "name of the provider domain", required = true) @PathParam("provDomain") String provDomain,
        @Parameter(description = "name of the provider service", required = true) @PathParam("provService") String provService,
        @Parameter(description = "tenant resource group", required = true) @PathParam("resourceGroup") String resourceGroup,
        @Parameter(description = "Audit param required(not empty) if domain auditEnabled is true.", required = true) @HeaderParam("Y-Audit-Ref") String auditRef,
        @Parameter(description = "list of roles to be added/updated for the provider", required = true) ProviderResourceGroupRoles detail) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "putProviderResourceGroupRoles");
            context.authorize("update", "" + tenantDomain + ":tenancy." + provDomain + "." + provService + "", null);
            return this.delegate.putProviderResourceGroupRoles(context, tenantDomain, provDomain, provService, resourceGroup, auditRef, detail);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.BAD_REQUEST:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.CONFLICT:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.FORBIDDEN:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.NOT_FOUND:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource putProviderResourceGroupRoles");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.publishChangeMessage(context, code);
            this.delegate.recordMetrics(context, code);
        }
    }

    @GET
    @Path("/domain/{tenantDomain}/provDomain/{provDomain}/provService/{provService}/resourceGroup/{resourceGroup}")
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "Retrieve the configured set of roles for the provider and resource group")
    public ProviderResourceGroupRoles getProviderResourceGroupRoles(
        @Parameter(description = "name of the tenant domain", required = true) @PathParam("tenantDomain") String tenantDomain,
        @Parameter(description = "name of the provider domain", required = true) @PathParam("provDomain") String provDomain,
        @Parameter(description = "name of the provider service", required = true) @PathParam("provService") String provService,
        @Parameter(description = "tenant resource group", required = true) @PathParam("resourceGroup") String resourceGroup) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "getProviderResourceGroupRoles");
            context.authenticate();
            return this.delegate.getProviderResourceGroupRoles(context, tenantDomain, provDomain, provService, resourceGroup);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.BAD_REQUEST:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.FORBIDDEN:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.NOT_FOUND:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource getProviderResourceGroupRoles");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.recordMetrics(context, code);
        }
    }

    @DELETE
    @Path("/domain/{tenantDomain}/provDomain/{provDomain}/provService/{provService}/resourceGroup/{resourceGroup}")
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "Delete the configured set of roles for the provider and resource group")
    public void deleteProviderResourceGroupRoles(
        @Parameter(description = "name of the tenant domain", required = true) @PathParam("tenantDomain") String tenantDomain,
        @Parameter(description = "name of the provider domain", required = true) @PathParam("provDomain") String provDomain,
        @Parameter(description = "name of the provider service", required = true) @PathParam("provService") String provService,
        @Parameter(description = "tenant resource group", required = true) @PathParam("resourceGroup") String resourceGroup,
        @Parameter(description = "Audit param required(not empty) if domain auditEnabled is true.", required = true) @HeaderParam("Y-Audit-Ref") String auditRef) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "deleteProviderResourceGroupRoles");
            context.authorize("update", "" + tenantDomain + ":tenancy." + provDomain + "." + provService + "", null);
            this.delegate.deleteProviderResourceGroupRoles(context, tenantDomain, provDomain, provService, resourceGroup, auditRef);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.BAD_REQUEST:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.CONFLICT:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.FORBIDDEN:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.NOT_FOUND:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource deleteProviderResourceGroupRoles");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.publishChangeMessage(context, code);
            this.delegate.recordMetrics(context, code);
        }
    }

    @GET
    @Path("/access/{action}/{resource}")
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "Check access for the specified operation on the specified resource for the currently authenticated user. This is the slow centralized access for control-plane purposes. Use distributed mechanisms for decentralized (data-plane) access by fetching signed policies and role tokens for users. With this endpoint the resource is part of the uri and restricted to its strict definition of resource name. If needed, you can use the GetAccessExt api that allows resource name to be less restrictive.")
    public Access getAccess(
        @Parameter(description = "action as specified in the policy assertion, i.e. update or read", required = true) @PathParam("action") String action,
        @Parameter(description = "the resource to check access against, i.e. \"media.news:articles\"", required = true) @PathParam("resource") String resource,
        @Parameter(description = "usually null. If present, it specifies an alternate domain for cross-domain trust relation", required = false) @QueryParam("domain") String domain,
        @Parameter(description = "usually null. If present, carry out the access check for this principal", required = false) @QueryParam("principal") String checkPrincipal) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "getAccess");
            context.authenticate();
            return this.delegate.getAccess(context, action, resource, domain, checkPrincipal);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.BAD_REQUEST:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.FORBIDDEN:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.NOT_FOUND:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource getAccess");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.recordMetrics(context, code);
        }
    }

    @GET
    @Path("/access/{action}")
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "Check access for the specified operation on the specified resource for the currently authenticated user. This is the slow centralized access for control-plane purposes.")
    public Access getAccessExt(
        @Parameter(description = "action as specified in the policy assertion, i.e. update or read", required = true) @PathParam("action") String action,
        @Parameter(description = "the resource to check access against, i.e. \"media.news:articles\"", required = true) @QueryParam("resource") String resource,
        @Parameter(description = "usually null. If present, it specifies an alternate domain for cross-domain trust relation", required = false) @QueryParam("domain") String domain,
        @Parameter(description = "usually null. If present, carry out the access check for this principal", required = false) @QueryParam("principal") String checkPrincipal) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "getAccessExt");
            context.authenticate();
            return this.delegate.getAccessExt(context, action, resource, domain, checkPrincipal);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.BAD_REQUEST:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.FORBIDDEN:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.NOT_FOUND:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource getAccessExt");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.recordMetrics(context, code);
        }
    }

    @GET
    @Path("/resource")
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "Return list of resources that the given principal has access to. Even though the principal is marked as optional, it must be specified")
    public ResourceAccessList getResourceAccessList(
        @Parameter(description = "specifies principal to query the resource list for", required = false) @QueryParam("principal") String principal,
        @Parameter(description = "action as specified in the policy assertion", required = false) @QueryParam("action") String action) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "getResourceAccessList");
            context.authenticate();
            return this.delegate.getResourceAccessList(context, principal, action);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.BAD_REQUEST:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.FORBIDDEN:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.NOT_FOUND:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource getResourceAccessList");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.recordMetrics(context, code);
        }
    }

    @GET
    @Path("/sys/modified_domains")
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "Retrieve the list of modified domains since the specified timestamp. The server will return the list of all modified domains and the latest modification timestamp as the value of the ETag header. The client will need to use this value during its next call to request the changes since the previous request. When metaonly set to true, don't add roles, policies or services, don't sign")
    public Response getSignedDomains(
        @Parameter(description = "filter the domain list only to the specified name", required = false) @QueryParam("domain") String domain,
        @Parameter(description = "valid values are \"true\" or \"false\"", required = false) @QueryParam("metaonly") String metaOnly,
        @Parameter(description = "domain meta attribute to filter/return, valid values \"account\", \"ypmId\", or \"all\"", required = false) @QueryParam("metaattr") String metaAttr,
        @Parameter(description = "for system principals only - request data from master data store and not read replicas if any are configured", required = false) @QueryParam("master") Boolean master,
        @Parameter(description = "for specific purpose only. If this flag is passed, assertion id and assertion conditions will be included in the response assertions if available", required = false) @QueryParam("conditions") Boolean conditions,
        @Parameter(description = "Retrieved from the previous request, this timestamp specifies to the server to return any domains modified since this time", required = true) @HeaderParam("If-None-Match") String matchingTag) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "getSignedDomains");
            context.authenticate();
            return this.delegate.getSignedDomains(context, domain, metaOnly, metaAttr, master, conditions, matchingTag);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.BAD_REQUEST:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.FORBIDDEN:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.NOT_FOUND:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource getSignedDomains");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.recordMetrics(context, code);
        }
    }

    @GET
    @Path("/domain/{name}/signed")
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "")
    public Response getJWSDomain(
        @Parameter(description = "name of the domain to be retrieved", required = true) @PathParam("name") String name,
        @Parameter(description = "true if signature must be in P1363 format instead of ASN.1 DER", required = false) @QueryParam("signaturep1363format") Boolean signatureP1363Format,
        @Parameter(description = "Retrieved from the previous request, this timestamp specifies to the server to return if the domain was modified since this time", required = true) @HeaderParam("If-None-Match") String matchingTag) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "getJWSDomain");
            context.authenticate();
            return this.delegate.getJWSDomain(context, name, signatureP1363Format, matchingTag);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.BAD_REQUEST:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.NOT_FOUND:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource getJWSDomain");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.recordMetrics(context, code);
        }
    }

    @GET
    @Path("/user/{userName}/token")
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "Return a user/principal token for the specified authenticated user. Typical authenticated users with their native credentials are not allowed to update their domain data. They must first obtain a UserToken and then use that token for authentication and authorization of their update requests.")
    public UserToken getUserToken(
        @Parameter(description = "name of the user", required = true) @PathParam("userName") String userName,
        @Parameter(description = "comma separated list of on-behalf-of service names", required = false) @QueryParam("services") String serviceNames,
        @Parameter(description = "include Authorization header name in response", required = false) @QueryParam("header") @DefaultValue("false") Boolean header) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "getUserToken");
            context.authenticate();
            return this.delegate.getUserToken(context, userName, serviceNames, header);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.FORBIDDEN:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource getUserToken");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.recordMetrics(context, code);
        }
    }

    @OPTIONS
    @Path("/user/{userName}/token")
    @Operation(description = "CORS (Cross-Origin Resource Sharing) support to allow Provider Services to obtain AuthorizedService Tokens on behalf of Tenant administrators")
    public UserToken optionsUserToken(
        @Parameter(description = "name of the user", required = true) @PathParam("userName") String userName,
        @Parameter(description = "comma separated list of on-behalf-of service names", required = false) @QueryParam("services") String serviceNames) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "optionsUserToken");
            return this.delegate.optionsUserToken(context, userName, serviceNames);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.BAD_REQUEST:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource optionsUserToken");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.recordMetrics(context, code);
        }
    }

    @GET
    @Path("/principal")
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "Return a ServicePrincipal object if the serviceToken is valid. This request provides a simple operation that an external application can execute to validate a service token.")
    public ServicePrincipal getServicePrincipal(
        ) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "getServicePrincipal");
            context.authenticate();
            return this.delegate.getServicePrincipal(context);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.BAD_REQUEST:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.FORBIDDEN:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource getServicePrincipal");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.recordMetrics(context, code);
        }
    }

    @GET
    @Path("/template")
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "Get the list of solution templates defined in the server")
    public ServerTemplateList getServerTemplateList(
        ) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "getServerTemplateList");
            context.authenticate();
            return this.delegate.getServerTemplateList(context);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource getServerTemplateList");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.recordMetrics(context, code);
        }
    }

    @GET
    @Path("/template/{template}")
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "Get solution template details. Includes the roles and policies that will be automatically provisioned when the template is applied to a domain")
    public Template getTemplate(
        @Parameter(description = "name of the solution template", required = true) @PathParam("template") String template) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "getTemplate");
            context.authenticate();
            return this.delegate.getTemplate(context, template);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.BAD_REQUEST:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.NOT_FOUND:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource getTemplate");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.recordMetrics(context, code);
        }
    }

    @GET
    @Path("/domain/{name}/templatedetails")
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "Get a list of Solution templates with meta data details given a domain name")
    public DomainTemplateDetailsList getDomainTemplateDetailsList(
        @Parameter(description = "List of templates given a domain name", required = true) @PathParam("name") String name) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "getDomainTemplateDetailsList");
            context.authenticate();
            return this.delegate.getDomainTemplateDetailsList(context, name);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.BAD_REQUEST:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.NOT_FOUND:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource getDomainTemplateDetailsList");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.recordMetrics(context, code);
        }
    }

    @GET
    @Path("/templatedetails")
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "Get a list of Solution templates with meta data details defined in the server")
    public DomainTemplateDetailsList getServerTemplateDetailsList(
        ) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "getServerTemplateDetailsList");
            context.authenticate();
            return this.delegate.getServerTemplateDetailsList(context);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource getServerTemplateDetailsList");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.recordMetrics(context, code);
        }
    }

    @GET
    @Path("/user")
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "Enumerate users that are registered as principals in the system This will return only the principals with \"<user-domain>.\" prefix")
    public UserList getUserList(
        @Parameter(description = "name of the allowed user-domains and/or aliases", required = false) @QueryParam("domain") String domainName) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "getUserList");
            context.authenticate();
            return this.delegate.getUserList(context, domainName);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.BAD_REQUEST:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.NOT_FOUND:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource getUserList");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.recordMetrics(context, code);
        }
    }

    @DELETE
    @Path("/user/{name}")
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "Delete the specified user. This command will delete the home.<name> domain and all of its sub-domains (if they exist) and remove the user.<name> from all the roles in the system that it's member of. Upon successful completion of this delete request, the server will return NO_CONTENT status code without any data (no object will be returned).")
    public void deleteUser(
        @Parameter(description = "name of the user", required = true) @PathParam("name") String name,
        @Parameter(description = "Audit reference", required = true) @HeaderParam("Y-Audit-Ref") String auditRef) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "deleteUser");
            context.authorize("delete", "sys.auth:user", null);
            this.delegate.deleteUser(context, name, auditRef);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.BAD_REQUEST:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.CONFLICT:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.FORBIDDEN:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.NOT_FOUND:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource deleteUser");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.publishChangeMessage(context, code);
            this.delegate.recordMetrics(context, code);
        }
    }

    @DELETE
    @Path("/domain/{domainName}/member/{memberName}")
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "Delete the specified role member from the given domain. This command will remove the member from all the roles in the domain that it's member of. Upon successful completion of this delete request, the server will return NO_CONTENT status code without any data (no object will be returned).")
    public void deleteDomainRoleMember(
        @Parameter(description = "name of the domain", required = true) @PathParam("domainName") String domainName,
        @Parameter(description = "name of the role member/principal", required = true) @PathParam("memberName") String memberName,
        @Parameter(description = "Audit reference", required = true) @HeaderParam("Y-Audit-Ref") String auditRef) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "deleteDomainRoleMember");
            context.authorize("update", "" + domainName + ":", null);
            this.delegate.deleteDomainRoleMember(context, domainName, memberName, auditRef);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.BAD_REQUEST:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.CONFLICT:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.FORBIDDEN:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.NOT_FOUND:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource deleteDomainRoleMember");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.publishChangeMessage(context, code);
            this.delegate.recordMetrics(context, code);
        }
    }

    @GET
    @Path("/domain/{name}/quota")
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "Retrieve the quota object defined for the domain")
    public Quota getQuota(
        @Parameter(description = "name of the domain", required = true) @PathParam("name") String name) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "getQuota");
            context.authenticate();
            return this.delegate.getQuota(context, name);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.BAD_REQUEST:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.NOT_FOUND:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource getQuota");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.recordMetrics(context, code);
        }
    }

    @PUT
    @Path("/domain/{name}/quota")
    @Consumes(MediaType.APPLICATION_JSON)
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "Update the specified domain's quota object")
    public void putQuota(
        @Parameter(description = "name of the domain", required = true) @PathParam("name") String name,
        @Parameter(description = "Audit reference", required = true) @HeaderParam("Y-Audit-Ref") String auditRef,
        @Parameter(description = "Quota object with limits for the domain", required = true) Quota quota) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "putQuota");
            context.authorize("update", "sys.auth:quota", null);
            this.delegate.putQuota(context, name, auditRef, quota);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.BAD_REQUEST:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.CONFLICT:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.FORBIDDEN:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.NOT_FOUND:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource putQuota");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.publishChangeMessage(context, code);
            this.delegate.recordMetrics(context, code);
        }
    }

    @DELETE
    @Path("/domain/{name}/quota")
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "Delete the specified domain's quota")
    public void deleteQuota(
        @Parameter(description = "name of the domain", required = true) @PathParam("name") String name,
        @Parameter(description = "Audit reference", required = true) @HeaderParam("Y-Audit-Ref") String auditRef) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "deleteQuota");
            context.authorize("update", "sys.auth:quota", null);
            this.delegate.deleteQuota(context, name, auditRef);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.BAD_REQUEST:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.CONFLICT:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.FORBIDDEN:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.NOT_FOUND:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource deleteQuota");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.publishChangeMessage(context, code);
            this.delegate.recordMetrics(context, code);
        }
    }

    @GET
    @Path("/status")
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "Retrieve the server status")
    public Status getStatus(
        ) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "getStatus");
            context.authenticate();
            return this.delegate.getStatus(context);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.BAD_REQUEST:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.NOT_FOUND:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource getStatus");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.recordMetrics(context, code);
        }
    }

    @GET
    @Path("/pending_members")
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "List of domains containing roles and corresponding members to be approved by either calling or specified principal")
    public DomainRoleMembership getPendingDomainRoleMembersList(
        @Parameter(description = "If present, return pending list for this principal", required = false) @QueryParam("principal") String principal,
        @Parameter(description = "If present, return pending list for this domain", required = false) @QueryParam("domain") String domainName) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "getPendingDomainRoleMembersList");
            context.authenticate();
            return this.delegate.getPendingDomainRoleMembersList(context, principal, domainName);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.BAD_REQUEST:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.FORBIDDEN:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.NOT_FOUND:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource getPendingDomainRoleMembersList");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.recordMetrics(context, code);
        }
    }

    @GET
    @Path("/authority/user/attribute")
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "Map of type to attribute values for the user authority")
    public UserAuthorityAttributeMap getUserAuthorityAttributeMap(
        ) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "getUserAuthorityAttributeMap");
            context.authenticate();
            return this.delegate.getUserAuthorityAttributeMap(context);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.BAD_REQUEST:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.NOT_FOUND:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource getUserAuthorityAttributeMap");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.recordMetrics(context, code);
        }
    }

    @GET
    @Path("/domain/{name}/stats")
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "Retrieve the stats object defined for the domain")
    public Stats getStats(
        @Parameter(description = "name of the domain", required = true) @PathParam("name") String name) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "getStats");
            context.authenticate();
            return this.delegate.getStats(context, name);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.BAD_REQUEST:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.NOT_FOUND:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource getStats");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.recordMetrics(context, code);
        }
    }

    @GET
    @Path("/sys/stats")
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "Retrieve the stats object defined for the system")
    public Stats getSystemStats(
        ) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "getSystemStats");
            context.authorize("get", "sys.auth:stats", null);
            return this.delegate.getSystemStats(context);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.BAD_REQUEST:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.FORBIDDEN:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource getSystemStats");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.recordMetrics(context, code);
        }
    }

    @PUT
    @Path("/dependency/domain/{domainName}")
    @Consumes(MediaType.APPLICATION_JSON)
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "Register domain as a dependency to service There are two possible authorization checks for this endpoint: 1) System Administrator 2) Authorized Service Provider")
    public void putDomainDependency(
        @Parameter(description = "name of the domain", required = true) @PathParam("domainName") String domainName,
        @Parameter(description = "Audit param required(not empty) if domain auditEnabled is true.", required = true) @HeaderParam("Y-Audit-Ref") String auditRef,
        @Parameter(description = "Dependent service provider details", required = true) DependentService service) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "putDomainDependency");
            context.authenticate();
            this.delegate.putDomainDependency(context, domainName, auditRef, service);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.BAD_REQUEST:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.CONFLICT:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.FORBIDDEN:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.NOT_FOUND:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource putDomainDependency");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.publishChangeMessage(context, code);
            this.delegate.recordMetrics(context, code);
        }
    }

    @DELETE
    @Path("/dependency/domain/{domainName}/service/{service}")
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "De-register domain as a dependency to service There are two possible authorization checks for this endpoint: 1) System Administrator 2) Authorized Service Provider")
    public void deleteDomainDependency(
        @Parameter(description = "name of the domain", required = true) @PathParam("domainName") String domainName,
        @Parameter(description = "name of the service", required = true) @PathParam("service") String service,
        @Parameter(description = "Audit param required(not empty) if domain auditEnabled is true.", required = true) @HeaderParam("Y-Audit-Ref") String auditRef) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "deleteDomainDependency");
            context.authenticate();
            this.delegate.deleteDomainDependency(context, domainName, service, auditRef);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.BAD_REQUEST:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.CONFLICT:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.FORBIDDEN:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.NOT_FOUND:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource deleteDomainDependency");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.publishChangeMessage(context, code);
            this.delegate.recordMetrics(context, code);
        }
    }

    @GET
    @Path("/dependency/domain/{domainName}")
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "List registered services for domain")
    public ServiceIdentityList getDependentServiceList(
        @Parameter(description = "name of the domain", required = true) @PathParam("domainName") String domainName) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "getDependentServiceList");
            context.authenticate();
            return this.delegate.getDependentServiceList(context, domainName);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.BAD_REQUEST:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.NOT_FOUND:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource getDependentServiceList");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.recordMetrics(context, code);
        }
    }

    @GET
    @Path("/dependency/domain/{domainName}/resourceGroup")
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "List registered services and resource groups for domain")
    public DependentServiceResourceGroupList getDependentServiceResourceGroupList(
        @Parameter(description = "name of the domain", required = true) @PathParam("domainName") String domainName) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "getDependentServiceResourceGroupList");
            context.authenticate();
            return this.delegate.getDependentServiceResourceGroupList(context, domainName);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.BAD_REQUEST:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.NOT_FOUND:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource getDependentServiceResourceGroupList");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.recordMetrics(context, code);
        }
    }

    @GET
    @Path("/dependency/service/{service}")
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "List dependent domains for service")
    public DomainList getDependentDomainList(
        @Parameter(description = "name of the service", required = true) @PathParam("service") String service) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "getDependentDomainList");
            context.authenticate();
            return this.delegate.getDependentDomainList(context, service);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.BAD_REQUEST:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.NOT_FOUND:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource getDependentDomainList");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.recordMetrics(context, code);
        }
    }

    @GET
    @Path("/review/role")
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "Fetch all the roles across domains for either the caller or specified principal that require a review based on the last reviewed date and configured attributes. The method requires the caller to be either the principal or authorized in system to carry out the operation for any principal (typically this would be system administrators) 1. authenticated principal is the same as the check principal 2. system authorized (\"access\", \"sys.auth:meta.review.lookup\")")
    public ReviewObjects getRolesForReview(
        @Parameter(description = "If not present, will return roles for the user making the call", required = false) @QueryParam("principal") String principal) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "getRolesForReview");
            context.authenticate();
            return this.delegate.getRolesForReview(context, principal);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.BAD_REQUEST:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.FORBIDDEN:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.NOT_FOUND:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource getRolesForReview");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.recordMetrics(context, code);
        }
    }

    @GET
    @Path("/review/group")
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "Fetch all the groups across domains for either the caller or specified principal that require a review based on the last reviewed date and configured attributes. The method requires the caller to be either the principal or authorized in system to carry out the operation for any principal (typically this would be system administrators) 1. authenticated principal is the same as the check principal 2. system authorized (\"access\", \"sys.auth:meta.review.lookup\")")
    public ReviewObjects getGroupsForReview(
        @Parameter(description = "If not present, will return groups for the user making the call", required = false) @QueryParam("principal") String principal) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "getGroupsForReview");
            context.authenticate();
            return this.delegate.getGroupsForReview(context, principal);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.BAD_REQUEST:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.FORBIDDEN:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.NOT_FOUND:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource getGroupsForReview");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.recordMetrics(context, code);
        }
    }

    @GET
    @Path("/sys/info")
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "Retrieve the server info. Since we're exposing server version details, the request will require authorization")
    public Info getInfo(
        ) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "getInfo");
            context.authorize("get", "sys.auth:info", null);
            return this.delegate.getInfo(context);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            case ResourceException.BAD_REQUEST:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.FORBIDDEN:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.NOT_FOUND:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.TOO_MANY_REQUESTS:
                throw typedException(code, e, ResourceError.class);
            case ResourceException.UNAUTHORIZED:
                throw typedException(code, e, ResourceError.class);
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource getInfo");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.recordMetrics(context, code);
        }
    }

    @GET
    @Path("/schema")
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(description = "Get RDL Schema")
    public Schema getRdlSchema(
        ) {
        int code = ResourceException.OK;
        ResourceContext context = null;
        try {
            context = this.delegate.newResourceContext(this.servletContext, this.request, this.response, "getRdlSchema");
            context.authenticate();
            return this.delegate.getRdlSchema(context);
        } catch (ResourceException e) {
            code = e.getCode();
            switch (code) {
            default:
                System.err.println("*** Warning: undeclared exception (" + code + ") for resource getRdlSchema");
                throw typedException(code, e, ResourceError.class);
            }
        } finally {
            this.delegate.recordMetrics(context, code);
        }
    }


    WebApplicationException typedException(int code, ResourceException e, Class<?> eClass) {
        Object data = e.getData();
        Object entity = eClass.isInstance(data) ? data : null;
        if (entity != null) {
            return new WebApplicationException(Response.status(code).entity(entity).build());
        } else {
            return new WebApplicationException(code);
        }
    }

    @Inject private ZMSHandler delegate;
    @Context private ServletContext servletContext;
    @Context private HttpServletRequest request;
    @Context private HttpServletResponse response;
}
